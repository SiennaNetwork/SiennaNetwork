<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","sienna","sienna","api","schema.rs"],"content":"use std::{env::current_dir,fs::create_dir_all};\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse amm_shared::msg::exchange as exchange;\nuse amm_shared::msg::factory as factory;\nuse amm_shared::msg::ido as ido;\nuse amm_shared::msg::snip20;\nuse sienna_mgmt::msg as mgmt;\nuse sienna_rewards::msg as rewards;\nuse sienna_rpt::msg as rpt;\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"api\");\n    out_dir.push(\"mgmt\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n    export_schema(\u0026schema_for!(mgmt::Init), \u0026out_dir);\n    export_schema(\u0026schema_for!(mgmt::Handle), \u0026out_dir);\n    export_schema(\u0026schema_for!(mgmt::Query), \u0026out_dir);\n    export_schema(\u0026schema_for!(mgmt::Response), \u0026out_dir);\n\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"api\");\n    out_dir.push(\"rpt\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n    export_schema(\u0026schema_for!(rpt::Init), \u0026out_dir);\n    export_schema(\u0026schema_for!(rpt::Handle), \u0026out_dir);\n    export_schema(\u0026schema_for!(rpt::Query), \u0026out_dir);\n    export_schema(\u0026schema_for!(rpt::Response), \u0026out_dir);\n\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"api\");\n    out_dir.push(\"rewards\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n    export_schema(\u0026schema_for!(rewards::InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(rewards::HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(rewards::QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(rewards::QueryMsgResponse), \u0026out_dir);\n\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"api\");\n    out_dir.push(\"amm\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n    export_schema(\u0026schema_for!(exchange::InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(exchange::HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(exchange::QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(exchange::QueryMsgResponse), \u0026out_dir);\n\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"api\");\n    out_dir.push(\"factory\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n    export_schema(\u0026schema_for!(factory::InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(factory::HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(factory::QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(factory::QueryResponse), \u0026out_dir);\n\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"api\");\n    out_dir.push(\"ido\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n    export_schema(\u0026schema_for!(ido::InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ido::HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ido::QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ido::QueryResponse), \u0026out_dir);\n\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"api\");\n    out_dir.push(\"snip20\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n    export_schema(\u0026schema_for!(snip20::InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(snip20::HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(snip20::HandleAnswer), \u0026out_dir);\n    export_schema(\u0026schema_for!(snip20::QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(snip20::QueryAnswer), \u0026out_dir);\n}\n//fn main() {\n    ////let mut out_dir = current_dir().unwrap();\n    ////out_dir.push(\"schema\");\n    ////create_dir_all(\u0026out_dir).unwrap();\n    ////remove_schemas(\u0026out_dir).unwrap();\n\n    ////export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    ////export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    ////export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    ////export_schema(\u0026schema_for!(State), \u0026out_dir);\n    ////export_schema(\u0026schema_for!(CountResponse), \u0026out_dir);\n//}\n\n//fn main() {\n    //let mut out_dir = current_dir().unwrap();\n    //out_dir.push(\"schema\");\n    //create_dir_all(\u0026out_dir).unwrap();\n    //remove_schemas(\u0026out_dir).unwrap();\n\n    //export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    //export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    //export_schema(\u0026schema_for!(HandleAnswer), \u0026out_dir);\n    //export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    //export_schema(\u0026schema_for!(QueryAnswer), \u0026out_dir);\n//}\n\n//fn main() {\n    //// let mut out_dir = current_dir().unwrap();\n    //// out_dir.push(\"schema\");\n    //// create_dir_all(\u0026out_dir).unwrap();\n    //// remove_schemas(\u0026out_dir).unwrap();\n    ////\n    //// export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    //// export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    //// export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    //// export_schema(\u0026schema_for!(State), \u0026out_dir);\n    //// export_schema(\u0026schema_for!(CountResponse), \u0026out_dir);\n//}\n\n//fn main() {\n    //let mut out_dir = current_dir().unwrap();\n    //out_dir.push(\"schema\");\n    //create_dir_all(\u0026out_dir).unwrap();\n    //remove_schemas(\u0026out_dir).unwrap();\n\n    //export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    //export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    //export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    //export_schema(\u0026schema_for!(State), \u0026out_dir);\n    //export_schema(\u0026schema_for!(CountResponse), \u0026out_dir);\n//}\n","traces":[{"line":12,"address":[693920,699698],"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":13,"address":[693933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[693975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[694002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[694037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[694156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[694324,699670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[699654,694408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[694492,699638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[694576,699622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[694652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[694701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[694728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[694763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[694882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[695050,699592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[695134,699576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[695218,699560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[699544,695302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[695378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[695427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[695454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[695489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[695608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[699514,695776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[699498,695860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[695944,699482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[696028,699466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[696104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[696153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[696180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[696215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[696334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[699436,696502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[696586,699420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[699404,696670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[699388,696754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[696830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[696879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[696906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[696941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[697060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[697210,699358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[697294,699342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[699326,697378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[697462,699310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[697538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[697587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[697614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[697649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[697756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[697900,699280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[697984,699264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[699248,698068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[698152,699232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[698228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[698277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[698304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[698339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[698446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[699202,698590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[699186,698674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[698758,699170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[698842,699154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[699138,698926],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":65},{"path":["/","home","runner","work","sienna","sienna","contracts","amm-snip20","src","lib.rs"],"content":"use cosmwasm_std::{\n    Extern, Storage, Api, Querier, StdResult,\n    InitResponse, Env, HandleResponse, Binary\n};\n\nuse amm_shared::snip20_impl as composable_snip20;\nuse composable_snip20::{snip20_init, snip20_handle, snip20_query, DefaultSnip20Impl};\nuse composable_snip20::msg::{InitMsg, HandleMsg, QueryMsg};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    snip20_init(deps, env, msg, DefaultSnip20Impl)\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    snip20_handle(deps, env, msg, DefaultSnip20Impl)\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg\n) -\u003e StdResult\u003cBinary\u003e {\n    snip20_query(deps, msg, DefaultSnip20Impl)\n}\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026super::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026super::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026super::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","exchange","src","contract.rs"],"content":"use cosmwasm_std::{\n    to_binary, Api, Env, Extern, HandleResponse, InitResponse, Querier,\n    StdError, Binary, StdResult, Storage, QueryResult, CosmosMsg, WasmMsg,\n    Uint128, log, HumanAddr, Decimal, QueryRequest, WasmQuery, BankMsg, Coin\n};\nuse secret_toolkit::snip20;\nuse amm_shared::{\n    ExchangeSettings, Fee, TokenPairAmount, TokenType, TokenTypeAmount,\n    create_send_msg,\n    msg::{\n        exchange::{InitMsg, HandleMsg, QueryMsg, QueryMsgResponse, SwapSimulationResponse},\n        factory::{QueryMsg as FactoryQueryMsg, QueryResponse as FactoryResponse},\n        snip20::{InitConfig as Snip20InitConfig, InitMsg as Snip20InitMsg}\n    }\n};\nuse amm_shared::fadroma::utils::{u256_math, u256_math::U256, viewing_key::ViewingKey, crypto::Prng};\nuse amm_shared::fadroma::callback::{Callback, ContractInstance};\nuse amm_shared::fadroma::migrate as fadroma_scrt_migrate;\nuse fadroma_scrt_migrate::{get_status, with_status};\n\nuse crate::{state::{Config, store_config, load_config}, decimal_math};\n\n// This should be incremented every time there is a change to the interface of the contract.\nconst CONTRACT_VERSION: u32 = 1;\n\nstruct SwapInfo {\n    total_commission: Uint128,\n    sienna_commission: PercentageDecreaseResult,\n    swap_commission: PercentageDecreaseResult,\n    result: SwapResult\n}\n\nstruct SwapResult {\n    return_amount: Uint128,\n    spread_amount: Uint128\n}\n\nstruct PercentageDecreaseResult {\n    new_amount: Uint128,\n    decrease_amount: Uint128\n}\n\n/// Pad handle responses and log attributes to blocks\n/// of 256 bytes to prevent leaking info based on response size\nconst BLOCK_SIZE: usize = 256;\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n\n    if msg.pair.0 == msg.pair.1 {\n        return Err(StdError::generic_err(\"Trying to create an exchange with the same token.\"));\n    }\n\n    let mut messages = vec![];\n\n    let mut rng = Prng::new(\u0026env.message.sender.0.as_bytes(), \u0026env.block.time.to_be_bytes());\n\n    let viewing_key = ViewingKey::new(\u0026env, \u0026rng.rand_bytes(), \u0026rng.rand_bytes());\n\n    register_custom_token(\u0026env, \u0026mut messages, \u0026msg.pair.0, \u0026viewing_key)?;\n    register_custom_token(\u0026env, \u0026mut messages, \u0026msg.pair.1, \u0026viewing_key)?;\n\n    // Create LP token\n    messages.push(CosmosMsg::Wasm(WasmMsg::Instantiate {\n        code_id: msg.lp_token_contract.id,\n        msg: to_binary(\u0026Snip20InitMsg {\n            name: format!(\n                \"SiennaSwap Liquidity Provider (LP) token for {}-{}\",\n                \u0026msg.pair.0, \u0026msg.pair.1\n            ),\n            admin: Some(env.contract.address.clone()),\n            symbol: \"SWAP-LP\".to_string(),\n            decimals: 6,\n            callback: Some(Callback {\n                msg: to_binary(\u0026HandleMsg::OnLpTokenInit)?,\n                contract: ContractInstance {\n                    address: env.contract.address.clone(),\n                    code_hash: env.contract_code_hash\n                }\n            }),\n            initial_balances: None,\n            prng_seed: Binary::from(rng.rand_bytes()),\n            config: Some(Snip20InitConfig::builder()\n                .public_total_supply()\n                .enable_mint()\n                .build()\n            )\n        })?,\n        send: vec![],\n        label: format!(\n            \"{}-{}-SiennaSwap-LP-Token-{}\",\n            \u0026msg.pair.0,\n            \u0026msg.pair.1,\n            \u0026env.contract.address\n        ),\n        callback_code_hash: msg.lp_token_contract.code_hash.clone(),\n    }));\n\n    // Execute the HandleMsg::RegisterExchange method of\n    // the factory contract in order to register this address\n    messages.push(\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: msg.callback.contract.address,\n            callback_code_hash: msg.callback.contract.code_hash,\n            msg: msg.callback.msg,\n            send: vec![],\n        })\n    );\n\n    let config = Config {\n        factory_info: msg.factory_info,\n        lp_token_info: ContractInstance {\n            code_hash: msg.lp_token_contract.code_hash,\n            // We get the address when the instantiated LP token calls OnLpTokenInit\n            address: HumanAddr::default()\n        },\n        pair: msg.pair,\n        contract_addr: env.contract.address.clone(),\n        viewing_key\n    };\n\n    store_config(deps, \u0026config)?;\n\n    Ok(InitResponse {\n        messages,\n        log: vec![\n            log(\"created_exchange_address\", env.contract.address.as_str())\n        ]\n    })\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    with_status!(deps, env, match msg {\n        HandleMsg::AddLiquidity { deposit, slippage_tolerance } =\u003e add_liquidity(deps, env, deposit, slippage_tolerance),\n        HandleMsg::RemoveLiquidity { amount, recipient } =\u003e remove_liquidity(deps, env, amount, recipient),\n        HandleMsg::OnLpTokenInit =\u003e register_lp_token(deps, env),\n        HandleMsg::Swap { offer, expected_return } =\u003e swap(deps, env, offer, expected_return)\n    })\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e QueryResult {\n    match msg {\n        QueryMsg::Version =\u003e to_binary(\u0026QueryMsgResponse::Version { version: CONTRACT_VERSION }),\n        QueryMsg::Status =\u003e to_binary(\u0026get_status(deps)?),\n        QueryMsg::PairInfo =\u003e {\n            let config = load_config(deps)?;\n\n            let balances = config.pair.query_balances(\u0026deps.querier, config.contract_addr, config.viewing_key.0)?;\n            let total_liquidity = query_liquidity(\u0026deps.querier, \u0026config.lp_token_info)?;\n\n            to_binary(\u0026QueryMsgResponse::PairInfo {\n                liquidity_token: config.lp_token_info,\n                factory: config.factory_info,\n                pair: config.pair,\n                amount_0: balances[0],\n                amount_1: balances[1],\n                total_liquidity\n            })\n        },\n        QueryMsg::SwapSimulation { offer } =\u003e {\n            let config = load_config(deps)?;\n            to_binary(\u0026swap_simulation(deps, config, offer)?)\n        }\n    }\n}\n\nfn add_liquidity\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    deposit: TokenPairAmount\u003cHumanAddr\u003e,\n    slippage: Option\u003cDecimal\u003e\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    deposit.assert_sent_native_token_balance(\u0026env)?;\n\n    let config = load_config(\u0026deps)?;\n\n    let Config {\n        pair,\n        contract_addr,\n        viewing_key,\n        lp_token_info,\n        ..\n    } = config;\n\n    if pair != deposit.pair {\n        return Err(StdError::generic_err(\"The provided tokens dont match those managed by the contract.\"));\n    }\n\n    // Because we asserted that the provided pair and the one that is managed by the contract\n    // are identical, from here on, we must only work with the one provided (deposit.pair).\n    // This is because even though pairs with orders (A,B) and (B,A) are identical, the `amount_0` and `amount_1`\n    // variables correspond directly to the pair provided and not necessarily to the one stored. So in this case, order is important.\n\n    let mut messages: Vec\u003cCosmosMsg\u003e = vec![];\n\n    let mut pool_balances = deposit.pair.query_balances(\u0026deps.querier, contract_addr, viewing_key.0)?;\n\n    for (i, (amount, token)) in deposit.into_iter().enumerate() {\n        match \u0026token {\n            TokenType::CustomToken { contract_addr, token_code_hash } =\u003e {\n                messages.push(snip20::transfer_from_msg(\n                    env.message.sender.clone(),\n                    env.contract.address.clone(),\n                    amount,\n                    None,\n                    BLOCK_SIZE,\n                    token_code_hash.clone(),\n                    contract_addr.clone())?\n                );\n            },\n            TokenType::NativeToken { .. } =\u003e {\n                // If the asset is native token, balance is already increased.\n                // To calculate properly we should subtract user deposit from the pool.\n                pool_balances[i] = (pool_balances[i] - amount)?;\n            }\n        }\n    }\n\n    assert_slippage_tolerance(\n        slippage,\n        \u0026[ deposit.amount_0, deposit.amount_1 ],\n        \u0026pool_balances\n    )?;\n\n    let liquidity_supply = query_liquidity(\u0026deps.querier, \u0026lp_token_info)?;\n\n    let lp_tokens = if liquidity_supply == Uint128::zero() {\n        // If the provider is minting a new pool, the number of liquidity tokens they will\n        // receive will equal sqrt(x * y), where x and y represent the amount of each token provided.\n\n        let amount_0 = U256::from(deposit.amount_0.u128());\n        let amount_1 = U256::from(deposit.amount_1.u128());\n\n        let initial_liquidity = u256_math::mul(Some(amount_0), Some(amount_1))\n            .and_then(u256_math::sqrt)\n            .ok_or(StdError::generic_err(format!(\n                \"Cannot calculate sqrt(deposit_0 {} * deposit_1 {})\",\n                amount_0, amount_1\n            )))?;\n\n        clamp(initial_liquidity)?\n    } else {\n        // When adding to an existing pool, an equal amount of each token, proportional to the\n        // current price, must be deposited. So, determine how many LP tokens are minted.\n\n        let total_share = Some(U256::from(liquidity_supply.u128()));\n\n        let amount_0 = Some(U256::from(deposit.amount_0.u128()));\n        let pool_0 = Some(U256::from(pool_balances[0].u128()));\n\n        let share_0 = u256_math::div(u256_math::mul(amount_0, total_share), pool_0)\n            .ok_or(StdError::generic_err(format!(\n                \"Cannot calculate deposits[0] {} * total_share {} / pools[0].amount {}\",\n                amount_0.unwrap(),\n                total_share.unwrap(),\n                pool_0.unwrap()\n            )))?;\n\n        let amount_1 = Some(U256::from(deposit.amount_1.u128()));\n        let pool_1 = Some(U256::from(pool_balances[1].u128()));\n\n        let share_1 = u256_math::div(u256_math::mul(amount_1, total_share), pool_1)\n            .ok_or(StdError::generic_err(format!(\n                \"Cannot calculate deposits[1] {} * total_share {} / pools[1].amount {}\",\n                amount_1.unwrap(),\n                total_share.unwrap(),\n                pool_1.unwrap()\n            )))?;\n\n        clamp(std::cmp::min(share_0, share_1))?\n    };\n\n    messages.push(snip20::mint_msg(\n        env.message.sender,\n        lp_tokens,\n        None,\n        BLOCK_SIZE,\n        lp_token_info.code_hash,\n        lp_token_info.address,\n    )?);\n\n    Ok(HandleResponse {\n        messages,\n        log: vec![\n            log(\"action\", \"provide_liquidity\"),\n            log(\"assets\", format!(\"{}, {}\", deposit.pair.0, deposit.pair.1)),\n            log(\"share\", lp_tokens),\n        ],\n        data: None,\n    })\n}\n\nfn remove_liquidity\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n    recipient: HumanAddr\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = load_config(\u0026deps)?;\n\n    let Config {\n        pair,\n        lp_token_info,\n        contract_addr,\n        viewing_key,\n        ..\n    } = config;\n\n    let liquidity_supply = query_liquidity(\u0026deps.querier, \u0026lp_token_info)?;\n    let pool_balances = pair.query_balances(\u0026deps.querier, contract_addr, viewing_key.0)?;\n\n    // Calculate the withdrawn amount for each token in the pair - for each token X\n    // amount of X withdrawn = amount in pool for X * amount of LP tokens being burned / total liquidity pool amount\n\n    let withdraw_amount = Some(U256::from(amount.u128()));\n    let total_liquidity = Some(U256::from(liquidity_supply.u128()));\n\n    let mut pool_withdrawn: [Uint128; 2] = [ Uint128::zero(), Uint128::zero() ];\n\n    for (i, pool_amount) in pool_balances.iter().enumerate() {\n        let pool_amount = Some(U256::from(pool_amount.u128()));\n\n        let withdrawn_token_amount = u256_math::div(\n            u256_math::mul(pool_amount, withdraw_amount),\n            total_liquidity,\n        ).ok_or(StdError::generic_err(format!(\n            \"Cannot calculate current_pool_amount {} * withdrawn_share_amount {} / total_share {}\",\n            pool_amount.unwrap(),\n            withdraw_amount.unwrap(),\n            total_liquidity.unwrap()\n        )))?;\n\n        pool_withdrawn[i] = clamp(withdrawn_token_amount)?;\n    }\n\n    let mut messages: Vec\u003cCosmosMsg\u003e = Vec::with_capacity(2);\n\n    for (i, token) in pair.into_iter().enumerate() {\n        messages.push(\n            create_send_msg(\u0026token, env.contract.address.clone(), recipient.clone(), pool_withdrawn[i])?\n        );\n    }\n\n    messages.push(snip20::burn_from_msg(\n        env.message.sender,\n        amount,\n        None,\n        BLOCK_SIZE,\n        lp_token_info.code_hash,\n        lp_token_info.address\n    )?);\n\n    Ok(HandleResponse {\n        messages,\n        log: vec![\n            log(\"action\", \"remove_liquidity\"),\n            log(\"withdrawn_share\", amount),\n            log(\"refund_assets\", format!(\"{}, {}\", \u0026pair.0, \u0026pair.1)),\n        ],\n        data: None\n    })\n}\n\nfn swap\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    offer: TokenTypeAmount\u003cHumanAddr\u003e,\n    expected_return: Option\u003cUint128\u003e\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = load_config(deps)?;\n    let settings = query_exchange_settings(\u0026deps.querier, config.factory_info.clone())?;\n\n    let swap = do_swap(deps, \u0026config, \u0026settings, \u0026offer, false)?;\n\n    if let Some(expected_return) = expected_return {\n        if swap.result.return_amount.lt(\u0026expected_return) {\n            return Err(StdError::generic_err(\n                \"Operation fell short of expected_return\",\n            ));\n        }\n    }\n\n    let mut messages = vec![];\n\n    // Transfer a small fee to the burner address\n    if let Some(burner_address) = settings.sienna_burner {\n        match \u0026offer.token {\n            TokenType::CustomToken { contract_addr, token_code_hash } =\u003e {\n                // Transfer the fee directly to burner\n                messages.push(snip20::transfer_from_msg(\n                    env.message.sender.clone(),\n                    burner_address,\n                    swap.sienna_commission.decrease_amount,\n                    None,\n                    BLOCK_SIZE,\n                    token_code_hash.clone(),\n                    contract_addr.clone()\n                )?);\n\n                // and the rest to the contract\n                messages.push(snip20::transfer_from_msg(\n                    env.message.sender.clone(),\n                    env.contract.address.clone(),\n                    swap.sienna_commission.new_amount,\n                    None,\n                    BLOCK_SIZE,\n                    token_code_hash.clone(),\n                    contract_addr.clone()\n                )?);\n            },\n            TokenType::NativeToken { denom } =\u003e {\n                offer.assert_sent_native_token_balance(\u0026env)?;\n\n                messages.push(CosmosMsg::Bank(BankMsg::Send {\n                    from_address: env.contract.address.clone(),\n                    to_address: burner_address,\n                    amount: vec![Coin {\n                        denom: denom.clone(),\n                        amount: swap.sienna_commission.decrease_amount\n                    }]\n                }));\n            }\n        }\n    } else {\n        match \u0026offer.token {\n            TokenType::NativeToken { .. } =\u003e {\n                offer.assert_sent_native_token_balance(\u0026env)?;\n            },\n            TokenType::CustomToken { contract_addr, token_code_hash } =\u003e {\n                messages.push(snip20::transfer_from_msg(\n                    env.message.sender.clone(),\n                    env.contract.address.clone(),\n                    offer.amount,\n                    None,\n                    BLOCK_SIZE,\n                    token_code_hash.clone(),\n                    contract_addr.clone()\n                )?);\n            }\n        }\n    }\n\n    // Send the resulting amount of the output token\n    let index = config.pair.get_token_index(\u0026offer.token).unwrap(); // Safe, checked in do_swap\n    let token = config.pair.get_token(index ^ 1).unwrap();\n\n    messages.push(create_send_msg(\u0026token, env.contract.address, env.message.sender, swap.result.return_amount)?);\n\n    Ok(HandleResponse{\n        messages,\n        log: vec![\n            log(\"action\", \"swap\"),\n            log(\"offer_token\", offer.token),\n            log(\"offer_amount\", offer.amount),\n            log(\"return_amount\", swap.result.return_amount),\n            log(\"spread_amount\", swap.result.spread_amount),\n            log(\"sienna_commission\", swap.sienna_commission.decrease_amount),\n            log(\"swap_commission\", swap.swap_commission.decrease_amount),\n            log(\"commission_amount\", swap.total_commission)\n        ],\n        data: None\n    })\n}\n\nfn query_liquidity(\n    querier: \u0026impl Querier,\n    lp_token_info: \u0026ContractInstance\u003cHumanAddr\u003e\n) -\u003e StdResult\u003cUint128\u003e {\n    let result = snip20::token_info_query(\n        querier,\n        BLOCK_SIZE,\n        lp_token_info.code_hash.clone(),\n        lp_token_info.address.clone()\n    )?;\n\n    //If this happens, the LP token has been incorrectly configured\n    if result.total_supply.is_none() {\n        unreachable!(\"LP token has no available supply.\");\n    }\n\n    Ok(result.total_supply.unwrap())\n}\n\nfn swap_simulation\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    config: Config\u003cHumanAddr\u003e,\n    offer: TokenTypeAmount\u003cHumanAddr\u003e\n) -\u003e StdResult\u003cSwapSimulationResponse\u003e {\n    let settings = query_exchange_settings(\u0026deps.querier, config.factory_info.clone())?;\n\n    let swap = do_swap(deps, \u0026config, \u0026settings, \u0026offer, true)?;\n\n    Ok(SwapSimulationResponse {\n        return_amount: swap.result.return_amount,\n        spread_amount: swap.result.spread_amount,\n        commission_amount: swap.total_commission\n    })\n}\n\nfn register_lp_token\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = load_config(\u0026deps)?;\n\n    //This should only be set once when the LP token is instantiated.\n    if config.lp_token_info.address != HumanAddr::default() {\n        return Err(StdError::unauthorized());\n    }\n\n    config.lp_token_info.address = env.message.sender.clone();\n\n    store_config(deps, \u0026config)?;\n\n    Ok(HandleResponse {\n        messages: vec![snip20::register_receive_msg(\n            env.contract_code_hash,\n            None,\n            BLOCK_SIZE,\n            config.lp_token_info.code_hash,\n            env.message.sender.clone(),\n        )?],\n        log: vec![log(\"liquidity_token_addr\", env.message.sender)],\n        data: None,\n    })\n}\n\nfn register_custom_token(\n    env: \u0026Env,\n    messages: \u0026mut Vec\u003cCosmosMsg\u003e,\n    token: \u0026TokenType\u003cHumanAddr\u003e,\n    viewing_key: \u0026ViewingKey\n) -\u003e StdResult\u003c()\u003e {\n    if let TokenType::CustomToken {\n        contract_addr, token_code_hash, ..\n    } = token {\n        messages.push(snip20::set_viewing_key_msg(\n            viewing_key.0.clone(),\n            None,\n            BLOCK_SIZE,\n            token_code_hash.clone(),\n            contract_addr.clone(),\n        )?);\n        messages.push(snip20::register_receive_msg(\n            env.contract_code_hash.clone(),\n            None,\n            BLOCK_SIZE,\n            token_code_hash.clone(),\n            contract_addr.clone(),\n        )?);\n    }\n\n    Ok(())\n}\n\nfn do_swap\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    config: \u0026Config\u003cHumanAddr\u003e,\n    settings: \u0026ExchangeSettings\u003cHumanAddr\u003e,\n    offer: \u0026TokenTypeAmount\u003cHumanAddr\u003e,\n    is_simulation: bool\n) -\u003e StdResult\u003cSwapInfo\u003e {\n    if !config.pair.contains(\u0026offer.token) {\n        return Err(StdError::generic_err(format!(\"The supplied token {}, is not managed by this contract.\", offer.token)));\n    }\n\n    let offer_amount = U256::from(offer.amount.u128());\n    let swap_commission = percentage_decrease(offer_amount, settings.swap_fee)?;\n\n    let sienna_commission = if settings.sienna_burner.is_some() {\n        percentage_decrease(offer_amount, settings.sienna_fee)?\n    } else {\n        PercentageDecreaseResult {\n            new_amount: Uint128::zero(),\n            decrease_amount: Uint128::zero()\n        }\n    };\n\n    let balances = config.pair.query_balances(\u0026deps.querier, config.contract_addr.clone(), config.viewing_key.0.clone())?;\n    let token_index = config.pair.get_token_index(\u0026offer.token).unwrap(); //Safe because we checked above for existence\n\n    let mut offer_pool = balances[token_index];\n\n    if !is_simulation {\n        // If offer.token is not native, the balance hasn't been increased yet\n        if let TokenType::NativeToken { .. } = offer.token {\n            let result = U256::from(offer_pool.u128()).checked_sub(U256::from(offer.amount.u128()))\n                .ok_or_else(|| StdError::generic_err(\"This can't really happen.\"))?;\n\n            offer_pool = clamp(result)?\n        }\n    }\n\n    let total_commission = swap_commission.decrease_amount + sienna_commission.decrease_amount;\n    let offer_amount = (offer.amount - total_commission)?;\n\n    Ok(SwapInfo {\n        total_commission,\n        swap_commission,\n        sienna_commission,\n        result: compute_swap(\n            offer_pool,\n            balances[token_index ^ 1],\n            offer_amount\n        )?\n    })\n}\n\n// Copied from https://github.com/enigmampc/SecretSwap/blob/ffd72d1c94096ac3a78aaf8e576f22584f49fe7a/contracts/secretswap_pair/src/contract.rs#L768\nfn compute_swap(\n    offer_pool: Uint128,\n    ask_pool: Uint128,\n    offer_amount: Uint128\n) -\u003e StdResult\u003cSwapResult\u003e {\n    // offer =\u003e ask\n    let offer_pool = Some(U256::from(offer_pool.u128()));\n    let ask_pool = Some(U256::from(ask_pool.u128()));\n    let offer_amount = Some(U256::from(offer_amount.u128()));\n\n    // total_pool = offer_pool * ask_pool\n    let total_pool = u256_math::mul(offer_pool, ask_pool).ok_or(StdError::generic_err(format!(\n        \"Cannot calculate total_pool = offer_pool {} * ask_pool {}\",\n        offer_pool.unwrap(),\n        ask_pool.unwrap()\n    )))?;\n\n    // return_amount = (ask_pool - total_pool / (offer_pool + offer_amount))\n    let return_amount = u256_math::sub(ask_pool, u256_math::div(Some(total_pool), u256_math::add(offer_pool, offer_amount)))\n        .ok_or(StdError::generic_err(format!(\n            \"Cannot calculate return_amount = (ask_pool {} - total_pool {} / (offer_pool {} + offer_amount {}))\",\n            ask_pool.unwrap(),\n            total_pool,\n            offer_pool.unwrap(),\n            offer_amount.unwrap(),\n        )))?;\n\n    // calculate spread\n    // spread = offer_amount * ask_pool / offer_pool - return_amount\n    let spread_amount = u256_math::div(u256_math::mul(offer_amount, ask_pool), offer_pool)\n        .ok_or(StdError::generic_err(format!(\n            \"Cannot calculate offer_amount {} * ask_pool {} / offer_pool {}\",\n            offer_amount.unwrap(),\n            ask_pool.unwrap(),\n            offer_pool.unwrap()\n        )))?\n        .saturating_sub(return_amount);\n\n    Ok(SwapResult {\n        return_amount: clamp(return_amount)?,\n        spread_amount: clamp(spread_amount)?\n    })\n}\n\nfn percentage_decrease(amount: U256, fee: Fee) -\u003e StdResult\u003cPercentageDecreaseResult\u003e {\n    let amount = Some(amount);\n    let nom = Some(U256::from(fee.nom));\n    let denom = Some(U256::from(fee.denom));\n\n    let decrease_amount = u256_math::div(u256_math::mul(amount, nom), denom,)\n        .ok_or(StdError::generic_err(format!(\n            \"Cannot calculate amount {} * fee.nom {} / fee.denom {}\",\n            amount.unwrap(),\n            nom.unwrap(),\n            denom.unwrap()\n        )))?;\n\n    let result = u256_math::sub(amount, Some(decrease_amount))\n        .ok_or(StdError::generic_err(format!(\n            \"Cannot calculate amount {} - decrease_amount {}\",\n            amount.unwrap(),\n            decrease_amount\n        )))?;\n\n    Ok(PercentageDecreaseResult {\n        new_amount: clamp(result)?,\n        decrease_amount: clamp(decrease_amount)?\n    })\n}\n\n/// The amount the price moves in a trading pair between when a transaction is submitted and when it is executed.\n/// Returns an `StdError` if the range of the expected tokens to be received is exceeded.\nfn assert_slippage_tolerance(\n    slippage: Option\u003cDecimal\u003e,\n    deposits: \u0026[Uint128; 2],\n    pools: \u0026[Uint128; 2]\n) -\u003e StdResult\u003c()\u003e {\n    if slippage.is_none() {\n        return Ok(());\n    }\n\n    let one_minus_slippage_tolerance = decimal_math::decimal_subtraction(Decimal::one(), slippage.unwrap())?;\n\n    // Ensure each prices are not dropped as much as slippage tolerance rate\n    if decimal_math::decimal_multiplication(\n        Decimal::from_ratio(deposits[0], deposits[1]),\n        one_minus_slippage_tolerance,\n    ) \u003e Decimal::from_ratio(pools[0], pools[1]) ||\n    decimal_math::decimal_multiplication(\n        Decimal::from_ratio(deposits[1], deposits[0]),\n        one_minus_slippage_tolerance,\n    ) \u003e Decimal::from_ratio(pools[1], pools[0])\n    {\n        return Err(StdError::generic_err(\n            \"Operation exceeds max slippage tolerance\",\n        ));\n    }\n\n    Ok(())\n}\n\nfn query_exchange_settings (\n    querier: \u0026impl Querier,\n    factory: ContractInstance\u003cHumanAddr\u003e\n) -\u003e StdResult\u003cExchangeSettings\u003cHumanAddr\u003e\u003e {\n    let result: FactoryResponse = querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        callback_code_hash: factory.code_hash,\n        contract_addr: factory.address,\n        msg: to_binary(\u0026FactoryQueryMsg::GetExchangeSettings)?\n    }))?;\n\n    match result {\n        FactoryResponse::GetExchangeSettings { settings } =\u003e Ok(settings),\n        _ =\u003e Err(StdError::generic_err(\"An error occurred while trying to retrieve exchange settings.\"))\n    }\n}\n\nfn clamp(val: U256) -\u003e StdResult\u003cUint128\u003e {\n    if val \u003e u128::MAX.into() {\n        Err(StdError::generic_err(format!(\"cannot represent {} in 128 bits\", \u0026val)))\n    } else {\n        Ok(Uint128(val.low_u128()))\n    }\n}\n","traces":[{"line":538,"address":[684548,683488],"length":1,"stats":{"Line":0},"fn_name":"register_custom_token"},{"line":544,"address":[683557,684495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[683626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[683860,683898,683755,684053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[683662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[683689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[683709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[683748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[684281,684319,684480,684176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[684076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[684110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[684130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[684169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[684502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[684816],"length":1,"stats":{"Line":0},"fn_name":"compute_swap"},{"line":626,"address":[684901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[685040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[685179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[686374,685508,686286,685318,685908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[685400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[685454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[687414,687502,686392,687131,686036,687202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[686614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[686452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[686506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[686560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[688198,688127,688390,688510,687330,687520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[687738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[687576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[687630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[687684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[688326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[688980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[688528,688783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[688696,688889,689069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[689200],"length":1,"stats":{"Line":0},"fn_name":"percentage_decrease"},{"line":665,"address":[689251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[689374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[689475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[690257,690742,690328,690654,689568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[689868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[689706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[689760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[689814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[690456,691184,691487,691399,691113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[690814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[690760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[691872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[691675,691505,691312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[691781,691961,691588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[692096],"length":1,"stats":{"Line":0},"fn_name":"assert_slippage_tolerance"},{"line":697,"address":[692163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[692201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[692213,692444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[692853,692597,692547,692698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[692409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[692662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[692823,692761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[692562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[692787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[692867,692914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[692900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[692960],"length":1,"stats":{"Line":0},"fn_name":"clamp"},{"line":738,"address":[692994,693316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[693136,693037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[693333,693106],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":66},{"path":["/","home","runner","work","sienna","sienna","contracts","exchange","src","decimal_math.rs"],"content":"// Copied from https://github.com/enigmampc/SecretSwap/blob/master/contracts/secretswap_pair/src/math.rs\n\nuse cosmwasm_std::{Decimal, StdResult, Uint128};\n\nconst DECIMAL_FRACTIONAL: Uint128 = Uint128(1_000_000_000u128);\n/*\npub fn reverse_decimal(decimal: Decimal) -\u003e Decimal {\n    if decimal.is_zero() {\n        return Decimal::zero();\n    }\n\n    Decimal::from_ratio(DECIMAL_FRACTIONAL, decimal * DECIMAL_FRACTIONAL)\n}\n*/\npub fn decimal_subtraction(a: Decimal, b: Decimal) -\u003e StdResult\u003cDecimal\u003e {\n    Ok(Decimal::from_ratio(\n        (a * DECIMAL_FRACTIONAL - b * DECIMAL_FRACTIONAL)?,\n        DECIMAL_FRACTIONAL,\n    ))\n}\n\npub fn decimal_multiplication(a: Decimal, b: Decimal) -\u003e Decimal {\n    Decimal::from_ratio(a * DECIMAL_FRACTIONAL * b, DECIMAL_FRACTIONAL)\n}\n","traces":[{"line":15,"address":[641328],"length":1,"stats":{"Line":0},"fn_name":"decimal_subtraction"},{"line":16,"address":[641579,641707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[641595,641413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[641744],"length":1,"stats":{"Line":0},"fn_name":"decimal_multiplication"},{"line":23,"address":[641778],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","runner","work","sienna","sienna","contracts","exchange","src","lib.rs"],"content":"pub mod contract;\npub mod state;\nmod decimal_math;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","exchange","src","state.rs"],"content":"use cosmwasm_std::{\n    Api, CanonicalAddr, Extern, HumanAddr,\n    Querier, StdResult, Storage, StdError\n};\nuse serde::{Serialize,Deserialize};\n\nuse amm_shared::fadroma::address::{Humanize, Canonize};\nuse amm_shared::fadroma::callback::ContractInstance;\nuse amm_shared::fadroma::storage::{load, save};\nuse amm_shared::fadroma::utils::viewing_key::ViewingKey;\nuse amm_shared::TokenPair;\n\nconst CONFIG_KEY: \u0026[u8] = b\"config\";\n\n#[derive(Serialize, Deserialize, PartialEq, Debug)]\npub(crate) struct Config\u003cA: Clone\u003e {\n    pub factory_info:  ContractInstance\u003cA\u003e,\n    pub lp_token_info: ContractInstance\u003cA\u003e,\n    pub pair:          TokenPair\u003cA\u003e,\n    /// The address of the current contract.\n    pub contract_addr: A,\n    /// Viewing key used for custom SNIP20 tokens.\n    pub viewing_key:   ViewingKey,\n}\n\nimpl Canonize\u003cConfig\u003cCanonicalAddr\u003e\u003e for Config\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cConfig\u003cCanonicalAddr\u003e\u003e {\n        Ok(Config {\n            factory_info:  self.factory_info.canonize(api)?,\n            lp_token_info: self.lp_token_info.canonize(api)?,\n            pair:          self.pair.canonize(api)?,\n            contract_addr: self.contract_addr.canonize(api)?,\n            viewing_key:   self.viewing_key.clone()\n        })\n    }\n}\nimpl Humanize\u003cConfig\u003cHumanAddr\u003e\u003e for Config\u003cCanonicalAddr\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cConfig\u003cHumanAddr\u003e\u003e {\n        Ok(Config {\n            factory_info:  self.factory_info.humanize(api)?,\n            lp_token_info: self.lp_token_info.humanize(api)?,\n            pair:          self.pair.humanize(api)?,\n            contract_addr: self.contract_addr.humanize(api)?,\n            viewing_key:   self.viewing_key.clone()\n        })\n    }\n}\n\npub(crate) fn store_config \u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps:   \u0026mut Extern\u003cS, A, Q\u003e,\n    config: \u0026Config\u003cHumanAddr\u003e\n) -\u003e StdResult\u003c()\u003e {\n    save(\u0026mut deps.storage, CONFIG_KEY, \u0026config.canonize(\u0026deps.api)?)\n}\n\npub(crate) fn load_config\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e\n) -\u003e StdResult\u003cConfig\u003cHumanAddr\u003e\u003e {\n    let result: Config\u003cCanonicalAddr\u003e = load(\u0026deps.storage, CONFIG_KEY)?.ok_or(\n        StdError::generic_err(\"Config doesn't exist in storage.\")\n    )?;\n    result.humanize(\u0026deps.api)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::mock_dependencies;\n    use amm_shared::TokenType;\n\n    #[test]\n    fn properly_stores_config() -\u003e StdResult\u003c()\u003e {\n        let mut deps = mock_dependencies(10, \u0026[]);\n\n        let config = Config {\n            factory_info: ContractInstance {\n                code_hash: \"factory_hash\".into(),\n                address: HumanAddr(\"factory\".into())\n            },\n            lp_token_info: ContractInstance {\n                code_hash: \"token_hash\".into(),\n                address: HumanAddr(\"lp_token\".into())\n            },\n            pair: TokenPair(\n                TokenType::CustomToken {\n                    contract_addr: HumanAddr(\"first_addr\".into()),\n                    token_code_hash: \"13123adasd\".into()\n                },\n                TokenType::CustomToken {\n                    contract_addr: HumanAddr(\"scnd_addr\".into()),\n                    token_code_hash: \"4534qwerqqw\".into()\n                }\n            ),\n            contract_addr: HumanAddr(\"this\".into()),\n            viewing_key: ViewingKey(\"vk\".into())\n        };\n\n        store_config(\u0026mut deps, \u0026config)?;\n\n        let result = load_config(\u0026deps)?;\n\n        assert_eq!(config, result);\n\n        Ok(())\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[649744,650092],"length":1,"stats":{"Line":1},"fn_name":"store_config\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":53,"address":[649790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[650783,650144],"length":1,"stats":{"Line":1},"fn_name":"load_config\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":59,"address":[650174,650512,650550,650646,650465,650731,650354],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[650323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[650635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[644304,641952,641904,641913],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":73,"address":[641969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[642090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[642248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[642652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[642780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[642843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[643199,643276,644324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[643266,643725,643538,644319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[643972,643651],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[644042],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":31,"coverable":31},{"path":["/","home","runner","work","sienna","sienna","contracts","exchange","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests.\n//! 1. First copy them over verbatum,\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","factory","src","contract.rs"],"content":"use cosmwasm_std::{\n    Api, Binary, CosmosMsg, Env, Extern, HandleResponse, InitResponse,\n    Querier, StdError, StdResult, Storage, WasmMsg, log, to_binary, HumanAddr\n};\nuse amm_shared::{\n    TokenPair, Pagination, Exchange,\n    msg::{\n        exchange::InitMsg as ExchangeInitMsg,\n        ido::{InitMsg as IdoInitMsg, TokenSaleConfig},\n        factory::{InitMsg, HandleMsg, QueryMsg, QueryResponse}\n    },\n    admin::{\n        require_admin,\n        admin::{\n            DefaultHandleImpl as AdminHandle, DefaultQueryImpl as AdminQuery,\n            save_admin, admin_handle, admin_query, assert_admin\n        }\n    }\n};\nuse amm_shared::fadroma::callback::{ContractInstance, Callback};\nuse amm_shared::fadroma::storage::{load, save, remove};\nuse crate::state::{\n    Config, get_address_for_pair, get_exchanges, get_idos, load_config, pair_exists,\n    save_config, store_exchange, store_exchanges, store_ido_address, store_ido_addresses\n};\nuse amm_shared::fadroma::migrate as fadroma_scrt_migrate;\nuse fadroma_scrt_migrate::{get_status, with_status};\n\npub const EPHEMERAL_STORAGE_KEY: \u0026[u8] = b\"ephemeral_storage\";\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let admin = msg.admin.clone().unwrap_or(env.message.sender);\n    save_admin(deps, \u0026admin)?;\n\n    save_config(deps, \u0026Config::from_init_msg(msg))?;\n\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    with_status!(deps, env, match msg {\n        HandleMsg::SetConfig { .. }          =\u003e set_config(deps, env, msg),\n        HandleMsg::CreateExchange { pair }   =\u003e create_exchange(deps, env, pair),\n        HandleMsg::CreateIdo { info }        =\u003e create_ido(deps, env, info),\n        HandleMsg::RegisterIdo { signature } =\u003e register_ido(deps, env, signature),\n        HandleMsg::RegisterExchange { pair, signature } =\u003e\n            register_exchange(deps, env, pair, signature),\n        HandleMsg::AddExchanges { exchanges } =\u003e add_exchanges(deps, env, exchanges),\n        HandleMsg::AddIdos { idos } =\u003e add_idos(deps, env, idos),\n        HandleMsg::Admin(msg) =\u003e admin_handle(deps, env, msg, AdminHandle)\n    })\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Status                       =\u003e to_binary(\u0026get_status(deps)?),\n        QueryMsg::GetConfig {}                 =\u003e get_config(deps),\n        QueryMsg::GetExchangeAddress { pair }  =\u003e query_exchange_address(deps, pair),\n        QueryMsg::ListExchanges { pagination } =\u003e list_exchanges(deps, pagination),\n        QueryMsg::ListIdos { pagination }      =\u003e list_idos(deps, pagination),\n        QueryMsg::GetExchangeSettings          =\u003e query_exchange_settings(deps),\n\n        QueryMsg::Admin(msg) =\u003e admin_query(deps, msg, AdminQuery),\n    }\n}\n\n#[require_admin]\npub fn set_config\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env:  Env,\n    msg:  HandleMsg\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    if let HandleMsg::SetConfig {\n        snip20_contract, lp_token_contract, pair_contract, ido_contract,\n        exchange_settings\n    } = msg {\n        let mut config = load_config(\u0026deps)?;\n\n        if let Some(new_value) = snip20_contract   { config.snip20_contract   = new_value; }\n        if let Some(new_value) = lp_token_contract { config.lp_token_contract = new_value; }\n        if let Some(new_value) = pair_contract     { config.pair_contract     = new_value; }\n        if let Some(new_value) = ido_contract      { config.ido_contract      = new_value; }\n        if let Some(new_value) = exchange_settings { config.exchange_settings = new_value; }\n\n        save_config(deps, \u0026config)?;\n\n        Ok(HandleResponse {\n            messages: vec![],\n            log: vec![\n                log(\"action\", \"set_config\")\n            ],\n            data: None\n        })\n    } else {\n        unreachable!()\n    }\n}\n\npub fn get_config\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e StdResult\u003cBinary\u003e {\n    let Config {\n        snip20_contract, lp_token_contract, pair_contract, ido_contract,\n        exchange_settings, ..\n    } = load_config(deps)?;\n\n    to_binary(\u0026QueryResponse::Config {\n        snip20_contract, lp_token_contract, pair_contract, ido_contract,\n        exchange_settings\n    })\n}\n\npub fn create_exchange\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    pair: TokenPair\u003cHumanAddr\u003e\n) -\u003e StdResult\u003cHandleResponse\u003e {\n\n    if pair.0 == pair.1 {\n        return Err(StdError::generic_err(\"Cannot create an exchange with the same token.\"));\n    }\n\n    if pair_exists(deps, \u0026pair)? {\n        return Err(StdError::generic_err(\"Pair already exists\"));\n    }\n\n    let config = load_config(deps)?;\n\n    // We take advantage of the serialized execution model to create a signature\n    // and remove it at the end of the transaction. This signature is passed to\n    // the created pair which it then returns to HandleMsg::RegisterExchange so that\n    // it can be compared to the one we stored. This way, we ensure that exchanges \n    // can only be created through this method.\n    let signature = create_signature(\u0026env)?;\n    save(\u0026mut deps.storage, EPHEMERAL_STORAGE_KEY, \u0026signature)?;\n\n    // Actually creating the exchange happens when the instantiated contract calls\n    // us back via the HandleMsg::RegisterExchange so that we can get its address.\n\n    Ok(HandleResponse{\n        messages: vec![\n            CosmosMsg::Wasm(\n                WasmMsg::Instantiate {\n                    code_id: config.pair_contract.id,\n                    callback_code_hash: config.pair_contract.code_hash,\n                    send: vec![],\n                    label: format!(\n                        \"{}-{}-pair-{}-{}\",\n                        pair.0,\n                        pair.1,\n                        env.contract.address,\n                        config.pair_contract.id\n                    ),\n                    msg: to_binary(\n                        \u0026ExchangeInitMsg {\n                            pair: pair.clone(),\n                            lp_token_contract: config.lp_token_contract.clone(),\n                            factory_info: ContractInstance {\n                                code_hash: env.contract_code_hash.clone(),\n                                address:   env.contract.address.clone()\n                            },\n                            callback: Callback {\n                                contract: ContractInstance {\n                                    address:   env.contract.address,\n                                    code_hash: env.contract_code_hash,\n                                },\n                                msg: to_binary(\u0026HandleMsg::RegisterExchange {\n                                    pair: pair.clone(),\n                                    signature\n                                })?,\n                            }\n                        }\n                    )?\n                }\n            )\n        ],\n        log: vec![\n            log(\"action\", \"create_exchange\"),\n            log(\"pair\", pair),\n        ],\n        data: None\n    })\n}\n\nfn register_exchange\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    pair: TokenPair\u003cHumanAddr\u003e,\n    signature: Binary\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    ensure_correct_signature(\u0026mut deps.storage, signature)?;\n\n    let exchange = Exchange {\n        pair: pair.clone(),\n        address: env.message.sender.clone()\n    };\n\n    store_exchange(deps, exchange)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![\n            log(\"action\", \"register_exchange\"),\n            log(\"address\", env.message.sender),\n            log(\"pair\", pair)\n        ],\n        data: None\n    })\n}\n\nfn query_exchange_address\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    pair: TokenPair\u003cHumanAddr\u003e\n) -\u003e StdResult\u003cBinary\u003e {\n    let address = get_address_for_pair(deps, \u0026pair)?;\n    \n    to_binary(\u0026QueryResponse::GetExchangeAddress {\n        address\n    })\n}\n\nfn create_ido\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    info: TokenSaleConfig\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let signature = create_signature(\u0026env)?;\n    save(\u0026mut deps.storage, EPHEMERAL_STORAGE_KEY, \u0026signature)?;\n    \n    // Again, creating the IDO happens when the instantiated contract calls\n    // us back via the HandleMsg::RegisterIdo so that we can get its address.\n    \n    let config = load_config(deps)?;\n\n    Ok(HandleResponse {\n        messages: vec![\n            CosmosMsg::Wasm(WasmMsg::Instantiate {\n                code_id: config.ido_contract.id,\n                callback_code_hash: config.ido_contract.code_hash,\n                send: vec![],\n                label: format!(\n                    \"SIENNA IDO for token {}, created at {}\",\n                    info.sold_token.address,\n                    env.block.time // Make sure the label is unique\n                ),\n                msg: to_binary(\u0026IdoInitMsg {\n                    admin: env.message.sender,\n                    info,\n                    callback: Callback {\n                        contract: ContractInstance {\n                            address:   env.contract.address,\n                            code_hash: env.contract_code_hash,\n                        },\n                        msg: to_binary(\u0026HandleMsg::RegisterIdo {\n                            signature\n                        })?\n                    }\n                })?\n            })\n        ],\n        log: vec![\n            log(\"action\", \"create_ido\")\n        ],\n        data: None\n    })\n}\n\nfn register_ido\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    signature: Binary\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    ensure_correct_signature(\u0026mut deps.storage, signature)?;\n\n    store_ido_address(deps, \u0026env.message.sender)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![\n            log(\"action\", \"register_ido\"),\n            log(\"address\", env.message.sender)\n        ],\n        data: None\n    })\n}\n\n#[require_admin]\nfn add_exchanges\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    exchanges: Vec\u003cExchange\u003cHumanAddr\u003e\u003e\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    store_exchanges(deps, exchanges)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![\n            log(\"action\", \"add_exchanges\")\n        ],\n        data: None\n    })\n}\n\n#[require_admin]\nfn add_idos\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    idos: Vec\u003cHumanAddr\u003e\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    store_ido_addresses(deps, idos)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![\n            log(\"action\", \"add_idos\")\n        ],\n        data: None\n    })\n}\n\nfn list_idos\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    pagination: Pagination\n) -\u003e StdResult\u003cBinary\u003e {\n    let idos = get_idos(deps, pagination)?;\n\n    to_binary(\u0026QueryResponse::ListIdos { idos })\n}\n\nfn list_exchanges\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    pagination: Pagination\n) -\u003e StdResult\u003cBinary\u003e {\n    let exchanges = get_exchanges(deps, pagination)?;\n\n    to_binary(\u0026QueryResponse::ListExchanges { exchanges })\n}\n\nfn query_exchange_settings\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e\n) -\u003e StdResult\u003cBinary\u003e {\n    let config = load_config(deps)?;\n\n    Ok(to_binary(\u0026QueryResponse::GetExchangeSettings {\n        settings: config.exchange_settings\n    })?)\n}\n\npub(crate) fn create_signature(env: \u0026Env) -\u003e StdResult\u003cBinary\u003e {\n    to_binary(\u0026[\n        env.message.sender.0.as_bytes(),\n        \u0026env.block.height.to_be_bytes(),\n        \u0026env.block.time.to_be_bytes()\n    ].concat())\n}\n\nfn ensure_correct_signature(storage: \u0026mut impl Storage, signature: Binary) -\u003e StdResult\u003c()\u003e {\n    let stored_signature: Binary =\n        load(storage, EPHEMERAL_STORAGE_KEY)?.unwrap_or_default();\n\n    if stored_signature != signature {\n        return Err(StdError::unauthorized());\n    }\n\n    remove(storage, EPHEMERAL_STORAGE_KEY);\n\n    Ok(())\n}\n","traces":[{"line":31,"address":[1130192,1131288],"length":1,"stats":{"Line":1},"fn_name":"init\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":36,"address":[1130243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1130373,1130488,1131646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[1130755,1131641,1131243,1130432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[1131091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1132144,1135688],"length":1,"stats":{"Line":1},"fn_name":"handle\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":49,"address":[1135604,1132197,1133390,1133963,1135784,1136407,1133084,1135655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1134006,1136924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1134253,1136929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1136934,1134561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1134749,1136939],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[1134913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1135040,1136944],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[1135292,1136949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[1135456,1136954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[1133803,1136919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1137184,1137810],"length":1,"stats":{"Line":1},"fn_name":"query\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":66,"address":[1137806,1137268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[1137794,1137219,1137275,1137554],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[1137579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[1137594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1137685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1137732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1137774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1137258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[1162640,1162773,1167096,1162844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[1165205,1162608],"length":1,"stats":{"Line":1},"fn_name":"set_config\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":84,"address":[1162826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1163113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[1163273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1163334,1163485,1166909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1163450,1163731,1165220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1163827,1165358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1165496,1163949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1165634,1164071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1164193,1165772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1164300,1166904,1164393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1164806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1164383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[1164662,1164718,1166886],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[1164678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1164794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1137856,1138629],"length":1,"stats":{"Line":2},"fn_name":"get_config\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":113,"address":[1138487,1137881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[1138010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[1138123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[1138300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[1138155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[1138268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[1144669,1138672],"length":1,"stats":{"Line":1},"fn_name":"create_exchange\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":130,"address":[1138747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[1138913,1138843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[1138898,1138971,1146006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1139275,1139337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1139395,1146004,1139541,1139322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1139531,1139944,1145893,1139790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1140209,1140344,1139906,1145888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[1143604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1145700,1142872,1140250,1143849,1145616,1143998,1145519,1145870,1145786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[1142748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[1142600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[1140266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1140282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[1140322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1140645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[1140626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[1140633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[1140637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[1142481,1143011,1142205,1143248,1142536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[1141917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[1141183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[1141202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[1141302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[1141233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[1141267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[1141837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1141436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[1141366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[1141398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[1142215,1141773,1142452,1141551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[1141500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[1141519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[1144096,1143477,1143287,1145501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[1143303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[1143351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[1143592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[1147424,1149114],"length":1,"stats":{"Line":1},"fn_name":"register_exchange\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":202,"address":[1147464,1149307,1147611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1147589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1147850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1148046,1148138,1149305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1148826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1148128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1149043,1149287,1148653,1148394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[1148410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[1148455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[1148527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[1148814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[1150333,1149792],"length":1,"stats":{"Line":1},"fn_name":"query_exchange_address\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":226,"address":[1150019,1149830,1150348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[1149957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[1149931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[1154900,1150416],"length":1,"stats":{"Line":0},"fn_name":"create_ido\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":238,"address":[1156297,1150717,1150479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[1151036,1150679,1150982,1156292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[1156287,1151026,1151301,1151507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[1153956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[1155919,1156089,1154198,1156003,1155822,1156173,1151416,1154328,1153395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[1153123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[1151432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[1151445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[1151485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[1151782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[1151774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[1151778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[1153533,1153059,1152604,1153007,1153770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1152084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[1152116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[1152491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[1152221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[1152151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1152183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1152741,1152317,1152978,1152427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[1152285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[1153809,1153865,1155804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1153825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[1153944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[1157520,1158724],"length":1,"stats":{"Line":1},"fn_name":"register_ido\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":284,"address":[1158909,1157554,1157682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[1157975,1157660,1158907,1157926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[1158486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[1157965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[1158889,1158231,1158358,1158686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[1158247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[1158291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[1158474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[1168019,1167880,1169017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[1168957,1167840],"length":1,"stats":{"Line":1},"fn_name":"add_exchanges\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":304,"address":[1168266,1167962,1169015,1168315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[1168715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[1168305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[1168627,1169000,1168571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":309,"address":[1168587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1168703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[1169379,1170379,1169240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[1169200,1170319],"length":1,"stats":{"Line":1},"fn_name":"add_idos\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":321,"address":[1169675,1169626,1170377,1169322],"length":1,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[1170077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[1169665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[1169989,1170362,1169935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[1169955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[1170065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[1159651,1159280],"length":1,"stats":{"Line":1},"fn_name":"list_idos\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":336,"address":[1159321,1159513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[1159428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[1159696,1160067],"length":1,"stats":{"Line":1},"fn_name":"list_exchanges\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":345,"address":[1159737,1159929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[1159844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[1160112,1160919],"length":1,"stats":{"Line":0},"fn_name":"query_exchange_settings\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":353,"address":[1160355,1160137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[1160288,1160459,1160508,1160622,1160848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[1160256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[1161814,1161536],"length":1,"stats":{"Line":1},"fn_name":"create_signature"},{"line":361,"address":[1161704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[1161574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[1161598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[1161648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[1161856,1162519],"length":1,"stats":{"Line":1},"fn_name":"ensure_correct_signature\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":369,"address":[1161891,1162534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[1162274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[1162345,1162297],"length":1,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[1162321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[1162437],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":104,"coverable":173},{"path":["/","home","runner","work","sienna","sienna","contracts","factory","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n\n#[cfg(test)] mod test;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","factory","src","state.rs"],"content":"use cosmwasm_std::{Api, CanonicalAddr, Extern, HumanAddr, Querier, StdError, StdResult, Storage};\nuse amm_shared::fadroma::address::{Humanize, Canonize};\nuse amm_shared::fadroma::callback::ContractInstantiationInfo;\nuse amm_shared::fadroma::storage::{save, load};\nuse serde::{Deserialize, Serialize};\nuse amm_shared::{\n    Exchange, ExchangeSettings, TokenPair, TokenType, Pagination,\n    msg::factory::InitMsg\n};\nuse std::usize;\n\nconst CONFIG_KEY: \u0026[u8] = b\"config\";\nconst IDO_PREFIX: \u0026[u8; 1] = b\"I\";\nconst IDO_COUNT_KEY: \u0026[u8] = b\"ido_count\";\nconst EXCHANGES_KEY: \u0026[u8] = b\"exchanges\";\n\npub const PAGINATION_LIMIT: u8 = 30;\n\n#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\npub(crate) struct Config\u003cA\u003e {\n    pub snip20_contract:   ContractInstantiationInfo,\n    pub lp_token_contract: ContractInstantiationInfo,\n    pub pair_contract:     ContractInstantiationInfo,\n    pub ido_contract:      ContractInstantiationInfo,\n    pub exchange_settings: ExchangeSettings\u003cA\u003e\n}\nimpl Config\u003cHumanAddr\u003e {\n    pub fn from_init_msg(msg: InitMsg) -\u003e Self {\n        Self {\n            snip20_contract:   msg.snip20_contract,\n            lp_token_contract: msg.lp_token_contract,\n            pair_contract:     msg.pair_contract,\n            ido_contract:      msg.ido_contract,\n            exchange_settings: msg.exchange_settings\n        }\n    }\n}\nimpl Canonize\u003cConfig\u003cCanonicalAddr\u003e\u003e for Config\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cConfig\u003cCanonicalAddr\u003e\u003e {\n        Ok(Config {\n            snip20_contract:   self.snip20_contract.clone(),\n            lp_token_contract: self.lp_token_contract.clone(),\n            pair_contract:     self.pair_contract.clone(),\n            ido_contract:      self.ido_contract.clone(),\n            exchange_settings: self.exchange_settings.canonize(api)?\n        })\n    }\n}\nimpl Humanize\u003cConfig\u003cHumanAddr\u003e\u003e for Config\u003cCanonicalAddr\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cConfig\u003cHumanAddr\u003e\u003e {\n        Ok(Config {\n            snip20_contract:   self.snip20_contract.clone(),\n            lp_token_contract: self.lp_token_contract.clone(),\n            pair_contract:     self.pair_contract.clone(),\n            ido_contract:      self.ido_contract.clone(),\n            exchange_settings: self.exchange_settings.clone().humanize(api)?\n        })\n    }\n}\n\n/// Returns StdResult\u003c()\u003e resulting from saving the config to storage\npub(crate) fn save_config\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps:   \u0026mut Extern\u003cS, A, Q\u003e,\n    config: \u0026Config\u003cHumanAddr\u003e\n) -\u003e StdResult\u003c()\u003e {\n    save(\u0026mut deps.storage, CONFIG_KEY, \u0026config.canonize(\u0026deps.api)?)\n}\n\n/// Returns StdResult\u003cConfig\u003e resulting from retrieving the config from storage\npub(crate) fn load_config \u003cS: Storage, A: Api, Q: Querier\u003e (\n    deps: \u0026Extern\u003cS, A, Q\u003e\n) -\u003e StdResult\u003cConfig\u003cHumanAddr\u003e\u003e {\n    let config: Option\u003cConfig\u003cCanonicalAddr\u003e\u003e = load(\u0026deps.storage, CONFIG_KEY)?;\n    config.ok_or(StdError::generic_err(\"Config doesn't exist in storage.\"))?.humanize(\u0026deps.api)\n}\n\n/// Returns StdResult\u003cbool\u003e indicating whether a pair has been created before or not.\n/// Note that TokenPair(A, B) and TokenPair(B, A) is considered to be same.\npub(crate) fn pair_exists\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    pair: \u0026TokenPair\u003cHumanAddr\u003e\n) -\u003e StdResult\u003cbool\u003e {\n    let key = generate_pair_key(\u0026pair.canonize(\u0026deps.api)?);\n    Ok(deps.storage.get(\u0026key).is_some())\n}\n\n/// Stores information about an exchange contract. Returns an `StdError` if the exchange\n/// already exists or if something else goes wrong.\npub(crate) fn store_exchange\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps:    \u0026mut Extern\u003cS, A, Q\u003e,\n    exchange: Exchange\u003cHumanAddr\u003e\n) -\u003e StdResult\u003c()\u003e {\n    let mut exchanges = load_exchanges(\u0026deps.storage)?;\n\n    store_exchange_impl(deps, exchange, \u0026mut exchanges)?;\n    save_exchanges(\u0026mut deps.storage, \u0026exchanges)\n}\n\npub(crate) fn store_exchanges\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps:    \u0026mut Extern\u003cS, A, Q\u003e,\n    exchanges: Vec\u003cExchange\u003cHumanAddr\u003e\u003e\n) -\u003e StdResult\u003c()\u003e {\n    let mut list = load_exchanges(\u0026deps.storage)?;\n\n    for exchange in exchanges {\n        store_exchange_impl(deps, exchange, \u0026mut list)?;\n    }\n\n    save_exchanges(\u0026mut deps.storage, \u0026list)\n}\n\n/// Get the address of an exchange contract which manages the given pair.\npub(crate) fn get_address_for_pair\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    pair: \u0026TokenPair\u003cHumanAddr\u003e\n) -\u003e StdResult\u003cHumanAddr\u003e {\n    let key = generate_pair_key(\u0026pair.canonize(\u0026deps.api)?);\n\n    let canonical = load(\u0026deps.storage, \u0026key)?.ok_or_else(||\n        StdError::generic_err(\"Address doesn't exist in storage.\")\n    )?;\n\n    deps.api.human_address(\u0026canonical)\n}\n\npub(crate) fn store_ido_address\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps:    \u0026mut Extern\u003cS, A, Q\u003e,\n    address: \u0026HumanAddr\n) -\u003e StdResult\u003c()\u003e {\n    let mut count = load_ido_count(\u0026deps.storage)?;\n\n    store_ido_address_impl(deps, address, \u0026mut count)?;\n    save_ido_count(\u0026mut deps.storage, count)\n}\n\npub(crate) fn store_ido_addresses\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps:    \u0026mut Extern\u003cS, A, Q\u003e,\n    addresses: Vec\u003cHumanAddr\u003e\n) -\u003e StdResult\u003c()\u003e {\n    let mut count = load_ido_count(\u0026deps.storage)?;\n\n    for addr in addresses {\n        store_ido_address_impl(deps, \u0026addr, \u0026mut count)?;\n    }\n\n    save_ido_count(\u0026mut deps.storage, count)\n}\n\npub(crate) fn get_idos\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps:       \u0026Extern\u003cS, A, Q\u003e,\n    pagination: Pagination\n) -\u003e StdResult\u003cVec\u003cHumanAddr\u003e\u003e {\n    let ido_count = load_ido_count(\u0026deps.storage)?;\n\n    if pagination.start \u003e= ido_count {\n        return Ok(vec![]);\n    }\n\n    let limit = pagination.limit.min(PAGINATION_LIMIT);\n    let end = (pagination.start + limit as u64).min(ido_count);\n\n    let mut result = Vec::with_capacity((end - pagination.start) as usize);\n\n    for i in pagination.start..end {\n        let index = generate_ido_index(i);\n        let addr: CanonicalAddr = load(\u0026deps.storage, index.as_slice())?.ok_or_else(||\n            StdError::generic_err(\"IDO address doesn't exist in storage.\")\n        )?;\n\n        let human_addr = deps.api.human_address(\u0026addr)?;\n        result.push(human_addr);\n    }\n\n    Ok(result)\n}\n\npub(crate) fn get_exchanges\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    pagination: Pagination\n) -\u003e StdResult\u003cVec\u003cExchange\u003cHumanAddr\u003e\u003e\u003e {\n    let mut exchanges = load_exchanges(\u0026deps.storage)?;\n\n    if pagination.start as usize \u003e= exchanges.len() {\n        return Ok(vec![]);\n    }\n\n    let limit = pagination.limit.min(PAGINATION_LIMIT);\n    let end = (pagination.start + limit as u64).min(exchanges.len() as u64);\n\n    let mut result = Vec::with_capacity((end - pagination.start) as usize);\n\n    let exchanges = exchanges\n        .drain((pagination.start as usize)..(end as usize))\n        .collect::\u003cVec\u003cExchange\u003cCanonicalAddr\u003e\u003e\u003e();\n    \n    for exchange in exchanges {\n        result.push(exchange.humanize(\u0026deps.api)?)\n    }\n\n    Ok(result)\n}\n\n#[inline]\npub(crate) fn load_exchanges(storage: \u0026impl Storage) -\u003e StdResult\u003cVec\u003cExchange\u003cCanonicalAddr\u003e\u003e\u003e {\n    Ok(load(storage, EXCHANGES_KEY)?.unwrap_or(vec![]))\n}\n\npub(crate) fn generate_pair_key(\n    pair: \u0026TokenPair\u003cCanonicalAddr\u003e\n) -\u003e Vec\u003cu8\u003e {\n    let mut bytes: Vec\u003c\u0026[u8]\u003e = Vec::new();\n\n    match \u0026pair.0 {\n        TokenType::NativeToken { denom } =\u003e bytes.push(denom.as_bytes()),\n        TokenType::CustomToken { contract_addr, .. } =\u003e bytes.push(contract_addr.as_slice())\n    }\n\n    match \u0026pair.1 {\n        TokenType::NativeToken { denom } =\u003e bytes.push(denom.as_bytes()),\n        TokenType::CustomToken { contract_addr, .. } =\u003e bytes.push(contract_addr.as_slice())\n    }\n\n    bytes.sort();\n\n    bytes.concat()\n}\n\nfn store_exchange_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps:    \u0026mut Extern\u003cS, A, Q\u003e,\n    exchange: Exchange\u003cHumanAddr\u003e,\n    exchanges: \u0026mut Vec\u003cExchange\u003cCanonicalAddr\u003e\u003e\n) -\u003e StdResult\u003c()\u003e {\n    let exchange = exchange.canonize(\u0026deps.api)?;\n    let key = generate_pair_key(\u0026exchange.pair);\n\n    if deps.storage.get(\u0026key).is_some() {\n        return Err(StdError::generic_err(format!(\"Exchange ({}) already exists\", exchange.pair)));\n    }\n\n    save(\u0026mut deps.storage, \u0026key, \u0026exchange.address)?;\n\n    if exchanges.iter().any(|e| e.address == exchange.address) {\n        return Err(StdError::generic_err(format!(\"Exchange address ({}) already exists\", exchange.address)));\n    }\n\n    exchanges.push(exchange);\n\n    Ok(())\n}\n\nfn store_ido_address_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps:    \u0026mut Extern\u003cS, A, Q\u003e,\n    address: \u0026HumanAddr,\n    count: \u0026mut u64\n) -\u003e StdResult\u003c()\u003e {\n    let address = deps.api.canonical_address(\u0026address)?;\n    let index = generate_ido_index(*count);\n\n    *count += 1;\n\n    save(\u0026mut deps.storage, index.as_slice(), \u0026address)\n}\n\n#[inline]\nfn save_exchanges(\n    storage: \u0026mut impl Storage,\n    exchanges: \u0026Vec\u003cExchange\u003cCanonicalAddr\u003e\u003e\n) -\u003e StdResult\u003c()\u003e {\n    save(storage, EXCHANGES_KEY, exchanges)\n}\n\n#[inline]\nfn load_ido_count(storage: \u0026impl Storage) -\u003e StdResult\u003cu64\u003e {\n    Ok(load(storage,IDO_COUNT_KEY)?.unwrap_or(0))\n}\n\n#[inline]\nfn save_ido_count(storage: \u0026mut impl Storage, count: u64) -\u003e StdResult\u003c()\u003e {\n    save(storage, IDO_COUNT_KEY, \u0026count)\n}\n\n#[inline]\nfn generate_ido_index(index: u64) -\u003e Vec\u003cu8\u003e {\n    [ IDO_PREFIX, index.to_string().as_bytes() ].concat()\n}\n","traces":[{"line":28,"address":[982032],"length":1,"stats":{"Line":1},"fn_name":"from_init_msg"},{"line":30,"address":[982063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[982098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[982134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[982170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[982215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[983620,982528],"length":1,"stats":{"Line":1},"fn_name":"canonize\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":40,"address":[982859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[982570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[983179,982664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[983840,984955],"length":1,"stats":{"Line":2},"fn_name":"humanize\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":51,"address":[984194],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[983882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[983900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[983948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[985516,985168],"length":1,"stats":{"Line":1},"fn_name":"save_config\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":66,"address":[985214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[985568,986288],"length":1,"stats":{"Line":2},"fn_name":"load_config\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":73,"address":[985832,985598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[985943,985775,986303],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[986432,987096],"length":1,"stats":{"Line":1},"fn_name":"pair_exists\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":83,"address":[986483,986881,987159,987086],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[986901,987116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[987280,988117],"length":1,"stats":{"Line":1},"fn_name":"store_exchange\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":93,"address":[987318,988147,987508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[987761,987440,987817,988145],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[987807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[988272,989523],"length":1,"stats":{"Line":1},"fn_name":"store_exchanges\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":103,"address":[989581,988310,988509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[988452,988755,988892,989160],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[989165,989073,989551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[989444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[989728,991111],"length":1,"stats":{"Line":1},"fn_name":"get_address_for_pair\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":117,"address":[991101,990178,989779,991178],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[990997,991328,991131,990681,990198,990771,991180],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":120,"address":[991340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[990745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[991376],"length":1,"stats":{"Line":1},"fn_name":"store_ido_address\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":130,"address":[991418,991510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[991610,991490,991677],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[991665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[991792,992973],"length":1,"stats":{"Line":1},"fn_name":"store_ido_addresses\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":140,"address":[991983,991830,993031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[991926,992866,992214,992350],"length":1,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[992522,992598,993001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[992881,993058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[993184,995410],"length":1,"stats":{"Line":1},"fn_name":"get_idos\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":153,"address":[993246,993346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[993339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[993502,993449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[993471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[993559,995464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[993619,995494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[993930,993666,995312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[993972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[994473,994571,994805,995459,995712,993989],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":167,"address":[995724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[995453,994537,994998,994833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[994932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[993834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[995760,997491],"length":1,"stats":{"Line":1},"fn_name":"get_exchanges\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":181,"address":[995831,995980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[995962,996102],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[996115,996158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[996218,996129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[996225,997557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[996316,997589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[996384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[996368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[997246,996446,996638],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[996804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[997259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[998160,998693],"length":1,"stats":{"Line":2},"fn_name":"generate_pair_key"},{"line":211,"address":[998193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[998212,998276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[998708,998220,998283],"length":1,"stats":{"Line":4},"fn_name":null},{"line":215,"address":[998237,998364,998713],"length":1,"stats":{"Line":6},"fn_name":null},{"line":218,"address":[998448,998379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[998391,998455,998718],"length":1,"stats":{"Line":4},"fn_name":null},{"line":220,"address":[998723,998409,998536],"length":1,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[998554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[998594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[1000682,998752],"length":1,"stats":{"Line":1},"fn_name":"store_exchange_impl\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":233,"address":[998826,1000726,999026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[999016],"length":1,"stats":{"Line":2},"fn_name":null},{"line":236,"address":[999288,1000638],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[999428,999543],"length":1,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[999495,999732,999836,1000697],"length":1,"stats":{"Line":4},"fn_name":null},{"line":242,"address":[1000095,999810,1000880,1000907],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":243,"address":[1000199,1000337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[1000261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[1000516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[1000944,1001411],"length":1,"stats":{"Line":1},"fn_name":"store_ido_address_impl\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":256,"address":[1000992,1001125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[1001107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[1001448,1001230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[1001276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1001504],"length":1,"stats":{"Line":2},"fn_name":"save_exchanges\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":269,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":109,"coverable":112},{"path":["/","home","runner","work","sienna","sienna","contracts","factory","src","test.rs"],"content":"pub use cosmwasm_std::{\n    StdResult, StdError, Extern, Storage, Api, Querier, Env, Binary, to_binary,\n    HandleResponse, from_binary, HumanAddr,\n    testing::{mock_dependencies, mock_env, MockApi, MockQuerier, MockStorage}\n};\npub use amm_shared::{\n    Exchange, ExchangeSettings, Fee,\n    TokenPair, TokenType,\n    Pagination,\n    msg::factory::{InitMsg, HandleMsg, QueryMsg, QueryResponse},\n};\nuse amm_shared::fadroma::address::Canonize;\nuse amm_shared::fadroma::callback::ContractInstantiationInfo;\nuse amm_shared::fadroma::storage::{load, save};\npub use crate::{contract::*, state::*};\n\nimpl Into\u003cInitMsg\u003e for \u0026Config\u003cHumanAddr\u003e {\n    fn into (self) -\u003e InitMsg {\n        InitMsg {\n            snip20_contract:   self.snip20_contract.clone(),\n            lp_token_contract: self.lp_token_contract.clone(),\n            pair_contract:     self.pair_contract.clone(),\n            ido_contract:      self.ido_contract.clone(),\n            exchange_settings: self.exchange_settings.clone(),\n            admin: None\n        }\n    }\n}\nimpl Into\u003cHandleMsg\u003e for \u0026Config\u003cHumanAddr\u003e {\n    fn into (self) -\u003e HandleMsg {\n        HandleMsg::SetConfig {\n            snip20_contract:   Some(self.snip20_contract.clone()),\n            lp_token_contract: Some(self.lp_token_contract.clone()),\n            pair_contract:     Some(self.pair_contract.clone()),\n            ido_contract:      Some(self.ido_contract.clone()),\n            exchange_settings: Some(self.exchange_settings.clone())\n        }\n    }\n}\nimpl Into\u003cQueryResponse\u003e for \u0026Config\u003cHumanAddr\u003e {\n    fn into (self) -\u003e QueryResponse {\n        QueryResponse::Config {\n            snip20_contract:   self.snip20_contract.clone(),\n            lp_token_contract: self.lp_token_contract.clone(),\n            pair_contract:     self.pair_contract.clone(),\n            ido_contract:      self.ido_contract.clone(),\n            exchange_settings: self.exchange_settings.clone()\n        }\n    }\n}\n\nfn mkenv (sender: impl Into\u003cHumanAddr\u003e) -\u003e Env {\n    mock_env(sender, \u0026[])\n}\n\nfn mkdeps () -\u003e Extern\u003cimpl Storage, impl Api, impl Querier\u003e {\n    mock_dependencies(30, \u0026[])\n}\n\nfn mkconfig (id: u64) -\u003e Config\u003cHumanAddr\u003e {\n    Config::from_init_msg(InitMsg {\n        snip20_contract:   ContractInstantiationInfo { id, code_hash: \"snip20\".into() },\n        lp_token_contract: ContractInstantiationInfo { id, code_hash: \"lptoken\".into(), },\n        pair_contract:     ContractInstantiationInfo { id, code_hash: \"2341586789\".into(), },\n        ido_contract:      ContractInstantiationInfo { id,  code_hash: \"348534835\".into(), },\n        exchange_settings: ExchangeSettings {\n            swap_fee: Fee::new(28, 10000),\n            sienna_fee: Fee::new(2, 10000),\n            sienna_burner: None\n        },\n        admin: None\n    })\n}\n\nfn assert_unauthorized(response: StdResult\u003cHandleResponse\u003e) {\n    let err = response.unwrap_err();\n    assert_eq!(err, StdError::unauthorized())\n}\n\nfn pagination(start: u64, limit: u8) -\u003e Pagination {\n    Pagination { start, limit }\n}\n\nmod test_contract {\n    use super::*;\n\n    #[test] fn ok_init () -\u003e StdResult\u003c()\u003e {\n        let ref mut deps = mkdeps();\n        let env = mkenv(\"admin\");\n        let config = mkconfig(0);\n        assert!(init(deps, env, (\u0026config).into()).is_ok());\n        assert_eq!(config, load_config(deps)?);\n        Ok(())\n    }\n\n    #[test] fn ok_get_set_config () -\u003e StdResult\u003c()\u003e {\n        let ref mut deps = mkdeps();\n        let config1 = mkconfig(1);\n        let env = mkenv(\"admin\");\n        // init with some config\n        assert!(init(deps, env.clone(), (\u0026config1).into()).is_ok());\n        // get current config\n        let response: QueryResponse = from_binary(\u0026query(deps, QueryMsg::GetConfig {})?)?;\n        assert_eq!(response, (\u0026config1).into());\n        // set config to something else\n        let config2 = mkconfig(2);\n        assert!(handle(deps, env, (\u0026config2).into()).is_ok());\n        // updated config is returned\n        let response: QueryResponse = from_binary(\u0026query(deps, QueryMsg::GetConfig {})?)?;\n        assert_eq!(response, (\u0026config2).into());\n        Ok(())\n    }\n\n    #[test] fn no_unauthorized_set_config () -\u003e StdResult\u003c()\u003e {\n        let ref mut deps = mkdeps();\n        let config1 = mkconfig(1);\n        let env = mkenv(\"admin\");\n        // init with some config\n        assert!(init(deps, env.clone(), (\u0026config1).into()).is_ok());\n        // someone else tries to set config\n        let config2 = mkconfig(2);\n        let env = mkenv(\"badman\");\n        assert!(handle(deps, env, (\u0026config2).into()).is_err());\n        // config remains unchanged\n        let response: QueryResponse = from_binary(\u0026query(deps, QueryMsg::GetConfig {})?)?;\n        assert_eq!(response, (\u0026config1).into());\n        Ok(())\n    }\n\n    #[test] fn create_exchange_for_the_same_tokens_returns_error() -\u003e StdResult\u003c()\u003e {\n        let ref mut deps = mkdeps();\n\n        let pair = TokenPair (\n            TokenType::CustomToken {\n                contract_addr: HumanAddr(\"token_addr\".into()),\n                token_code_hash: \"13123adasd\".into()\n            },\n            TokenType::CustomToken {\n                contract_addr: HumanAddr(\"token_addr\".into()),\n                token_code_hash: \"13123adasd\".into()\n            },\n        );\n\n        let result = create_exchange(deps, mkenv(\"sender\"), pair);\n\n        let error: StdError = result.unwrap_err();\n\n        let result = match error {\n            StdError::GenericErr { msg, .. } =\u003e {\n                if msg.as_str() == \"Cannot create an exchange with the same token.\" {\n                    true\n                } else {\n                    false\n                }\n            }\n            _ =\u003e false\n        };\n\n        assert!(result);\n\n        let pair = TokenPair (\n            TokenType::NativeToken {\n                denom: \"test1\".into()\n            },\n            TokenType::NativeToken {\n                denom: \"test1\".into()\n            },\n        );\n\n        let result = create_exchange(deps, mkenv(\"sender\"), pair);\n\n        let error: StdError = result.unwrap_err();\n\n        let result = match error {\n            StdError::GenericErr { msg, .. } =\u003e {\n                if msg.as_str() == \"Cannot create an exchange with the same token.\" {\n                    true\n                } else {\n                    false\n                }\n            }\n            _ =\u003e false\n        };\n\n        assert!(result);\n\n        Ok(())\n    }\n\n    #[test] fn test_register_exchange() -\u003e StdResult\u003c()\u003e {\n        let ref mut deps = mkdeps();\n\n        let pair = TokenPair (\n            TokenType::CustomToken {\n                contract_addr: HumanAddr(\"token_addr\".into()),\n                token_code_hash: \"13123adasd\".into()\n            },\n            TokenType::NativeToken {\n                denom: \"test1\".into()\n            },\n        );\n\n        let sender_addr = HumanAddr(\"sender1111\".into());\n\n        let result = handle(\n            deps,\n            mkenv(sender_addr.clone()),\n            HandleMsg::RegisterExchange {\n                pair: pair.clone(),\n                signature: to_binary(\"whatever\")?\n            }\n        );\n\n        assert_unauthorized(result);\n\n        let config = mkconfig(0);\n        save_config(deps, \u0026config)?;\n\n        let env = mkenv(sender_addr.clone());\n\n        let signature = create_signature(\u0026env)?;\n        save(\u0026mut deps.storage, EPHEMERAL_STORAGE_KEY, \u0026signature)?;\n\n        handle(\n            deps,\n            env,\n            HandleMsg::RegisterExchange {\n                pair: pair.clone(),\n                signature\n            }\n        )?;\n\n        //Ensure that the ephemeral storage is empty after the message\n        let result: Option\u003cBinary\u003e = load(\u0026deps.storage, EPHEMERAL_STORAGE_KEY)?;\n        \n        match result {\n            None =\u003e { },\n            _ =\u003e panic!(\"Ephemeral storage should be empty!\")\n        }\n\n        Ok(())\n    }\n\n    #[test] fn test_register_ido() -\u003e StdResult\u003c()\u003e {\n        let ref mut deps = mkdeps();\n\n        let sender_addr = HumanAddr(\"sender1111\".into());\n\n        let result = handle(\n            deps,\n            mkenv(sender_addr.clone()),\n            HandleMsg::RegisterIdo {\n                signature: to_binary(\"whatever\")?\n            }\n        );\n\n        assert_unauthorized(result);\n\n        let config = mkconfig(0);\n        save_config(deps, \u0026config)?;\n\n        let env = mkenv(sender_addr.clone());\n\n        let signature = create_signature(\u0026env)?;\n        save(\u0026mut deps.storage, EPHEMERAL_STORAGE_KEY, \u0026signature)?;\n\n        handle(\n            deps,\n            env,\n            HandleMsg::RegisterIdo {\n                signature\n            }\n        )?;\n        //Ensure that the ephemeral storage is empty after the message\n        let result: Option\u003cBinary\u003e = load(\u0026deps.storage, EPHEMERAL_STORAGE_KEY)?;\n        \n        match result {\n            None =\u003e { },\n            _ =\u003e panic!(\"Ephemeral storage should be empty!\")\n        }\n\n        Ok(())\n    }\n\n    #[test] fn query_exchange() -\u003e StdResult\u003c()\u003e {\n        let ref mut deps = mkdeps();\n\n        let pair = TokenPair (\n            TokenType::CustomToken {\n                contract_addr: HumanAddr(\"token_addr\".into()),\n                token_code_hash: \"13123adasd\".into()\n            },\n            TokenType::NativeToken {\n                denom: \"test1\".into()\n            },\n        );\n\n        let config = mkconfig(0);\n        save_config(deps, \u0026config)?;\n\n        let sender_addr = HumanAddr(\"sender1111\".into());\n        let env = mkenv(sender_addr.clone());\n\n        let signature = create_signature(\u0026env)?;\n        save(\u0026mut deps.storage, EPHEMERAL_STORAGE_KEY, \u0026signature)?;\n\n        handle(\n            deps,\n            env,\n            HandleMsg::RegisterExchange {\n                pair: pair.clone(),\n                signature\n            }\n        ).unwrap();\n        \n        let result = query(\n            deps,\n            QueryMsg::GetExchangeAddress {\n                pair: pair.clone()\n            }\n        )?;\n\n        let response: QueryResponse = from_binary(\u0026result)?;\n\n        match response {\n            QueryResponse::GetExchangeAddress { address } =\u003e assert_eq!(sender_addr, address),\n            _ =\u003e return Err(StdError::generic_err(\"Wrong response. Expected: QueryResponse::GetExchangeAddress.\"))\n        };\n        \n        Ok(())\n    }\n\n    #[test]\n    fn test_add_exchanges()  {\n        let ref mut deps = mkdeps();\n        let env = mkenv(\"admin\");\n        let config = mkconfig(0);\n\n        init(deps, env.clone(), (\u0026config).into()).unwrap();\n\n        let mut exchanges = vec![];\n\n        for i in 0..5 {\n            exchanges.push(Exchange {\n                pair: TokenPair::\u003cHumanAddr\u003e(\n                    TokenType::CustomToken{\n                        contract_addr: format!(\"token_0_addr_{}\", i).into(),\n                        token_code_hash: format!(\"token_0_hash_{}\", i)\n                    },\n                    TokenType::CustomToken{\n                        contract_addr: format!(\"token_1_addr_{}\", i).into(),\n                        token_code_hash: format!(\"token_1_hash_{}\", i)\n                    }\n                ),\n                address: format!(\"pair_addr_{}\", i).into()\n            });\n        }\n\n        store_exchange(deps, exchanges[0].clone()).unwrap();\n\n        let result = handle(deps, mkenv(\"unauthorized\"), HandleMsg::AddExchanges {\n            exchanges: exchanges.clone()[1..].into()\n        });\n        assert_unauthorized(result);\n\n        handle(deps, env, HandleMsg::AddExchanges {\n            exchanges: exchanges.clone()[1..].into()\n        }).unwrap();\n\n        let result = query(deps, QueryMsg::ListExchanges {\n            pagination: pagination(0, PAGINATION_LIMIT)\n        }).unwrap();\n\n        let response: QueryResponse = from_binary(\u0026result).unwrap();\n\n        match response {\n            QueryResponse::ListExchanges { exchanges: stored } =\u003e {\n                assert_eq!(exchanges, stored)\n            },\n            _ =\u003e panic!(\"QueryResponse::ListExchanges\")\n        }\n    }\n\n    #[test]\n    fn test_add_idos() {\n        let ref mut deps = mkdeps();\n        let env = mkenv(\"admin\");\n        let config = mkconfig(0);\n\n        init(deps, env.clone(), (\u0026config).into()).unwrap();\n\n        let mut idos: Vec\u003cHumanAddr\u003e = vec![];\n\n        for i in 0..5 {\n            idos.push(format!(\"ido_addr_{}\", i).into());\n        }\n\n        store_ido_address(deps, \u0026idos[0]).unwrap();\n\n        let result = handle(deps, mkenv(\"unauthorized\"), HandleMsg::AddIdos {\n            idos: idos.clone()[1..].into()\n        });\n        assert_unauthorized(result);\n\n        handle(deps, env, HandleMsg::AddIdos {\n            idos: idos.clone()[1..].into()\n        }).unwrap();\n\n        let result = query(deps, QueryMsg::ListIdos {\n            pagination: pagination(0, PAGINATION_LIMIT)\n        }).unwrap();\n\n        let response: QueryResponse = from_binary(\u0026result).unwrap();\n\n        match response {\n            QueryResponse::ListIdos { idos: stored } =\u003e {\n                assert_eq!(idos, stored)\n            },\n            _ =\u003e panic!(\"QueryResponse::ListIdos\")\n        }\n    }\n}\n\nmod test_state {\n    use super::*;\n\n    fn swap_pair\u003cA: Clone\u003e (pair: \u0026TokenPair\u003cA\u003e) -\u003e TokenPair\u003cA\u003e {\n        TokenPair(pair.1.clone(), pair.0.clone())\n    }\n\n    /*\n    fn mock_config() -\u003e Config\u003cHumanAddr\u003e {\n        Config::from_init_msg(InitMsg {\n            snip20_contract: ContractInstantiationInfo {\n                id: 1,\n                code_hash: \"snip20_contract\".into()\n            },\n            lp_token_contract: ContractInstantiationInfo {\n                id: 2,\n                code_hash: \"lp_token_contract\".into()\n            },\n            ido_contract: ContractInstantiationInfo {\n                id: 3,\n                code_hash: \"ido_contract\".into()\n            },\n            pair_contract: ContractInstantiationInfo {\n                id: 4,\n                code_hash: \"pair_contract\".into()\n            },\n            exchange_settings: ExchangeSettings {\n                swap_fee: Fee::new(28, 10000),\n                sienna_fee: Fee::new(2, 10000),\n                sienna_burner: None\n            },\n            admin: None\n        })\n    }\n    */\n\n    #[test]\n    fn generates_the_same_key_for_swapped_pairs() -\u003e StdResult\u003c()\u003e {\n        fn cmp_pair\u003cS: Storage, A: Api, Q: Querier\u003e(\n            deps: \u0026Extern\u003cS, A, Q\u003e,\n            pair: TokenPair\u003cHumanAddr\u003e\n        ) -\u003e StdResult\u003c()\u003e {\n            let stored_pair = pair.canonize(\u0026deps.api)?;\n            let key = generate_pair_key(\u0026stored_pair);\n\n            let pair = swap_pair(\u0026pair);\n\n            let stored_pair = pair.canonize(\u0026deps.api)?;\n            let swapped_key = generate_pair_key(\u0026stored_pair);\n\n            assert_eq!(key, swapped_key);\n\n            Ok(())\n        }\n\n        let ref deps = mkdeps();\n\n        cmp_pair(\n            deps,\n            TokenPair(\n                TokenType::CustomToken {\n                    contract_addr: HumanAddr(\"first_addr\".into()),\n                    token_code_hash: \"13123adasd\".into()\n                },\n                TokenType::CustomToken {\n                    contract_addr: HumanAddr(\"scnd_addr\".into()),\n                    token_code_hash: \"4534qwerqqw\".into()\n                }\n            )\n        )?;\n\n        cmp_pair(\n            deps,\n            TokenPair(\n                TokenType::NativeToken {\n                    denom: \"test1\".into()\n                },\n                TokenType::NativeToken {\n                    denom: \"test2\".into()\n                },\n            )\n        )?;\n\n        cmp_pair(\n            deps,\n            TokenPair(\n                TokenType::NativeToken {\n                    denom: \"test3\".into()\n                },\n                TokenType::CustomToken {\n                    contract_addr: HumanAddr(\"third_addr\".into()),\n                    token_code_hash: \"asd21312asd\".into()\n                }\n            )\n        )?;\n\n        Ok(())\n    }\n\n    #[test]\n    fn query_correct_exchange_info() -\u003e StdResult\u003c()\u003e {\n        let mut deps = mkdeps();\n\n        let pair = TokenPair (\n            TokenType::CustomToken {\n                contract_addr: HumanAddr(\"first_addr\".into()),\n                token_code_hash: \"13123adasd\".into()\n            },\n            TokenType::CustomToken {\n                contract_addr: HumanAddr(\"scnd_addr\".into()),\n                token_code_hash: \"4534qwerqqw\".into()\n            }\n        );\n\n        let address = HumanAddr(\"ctrct_addr\".into());\n\n        store_exchange(\u0026mut deps, Exchange {\n            pair: pair.clone(),\n            address: address.clone()\n        })?;\n\n        let retrieved_address = get_address_for_pair(\u0026deps, \u0026pair)?;\n\n        assert!(pair_exists(\u0026mut deps, \u0026pair)?);\n        assert_eq!(address, retrieved_address);\n\n        Ok(())\n    }\n\n    #[test]\n    fn only_one_exchange_per_factory() -\u003e StdResult\u003c()\u003e {\n        let ref mut deps = mkdeps();\n        let pair = TokenPair (\n            TokenType::CustomToken {\n                contract_addr: HumanAddr(\"first_addr\".into()),\n                token_code_hash: \"13123adasd\".into()\n            },\n            TokenType::CustomToken {\n                contract_addr: HumanAddr(\"scnd_addr\".into()),\n                token_code_hash: \"4534qwerqqw\".into()\n            }\n        );\n\n        store_exchange(deps, Exchange {\n            pair: pair.clone(),\n            address: \"first_addr\".into()\n        })?;\n\n        let swapped = swap_pair(\u0026pair);\n\n        match store_exchange(deps, Exchange{\n            pair: swapped,\n            address: \"other_addr\".into()\n        }) {\n            Ok(_) =\u003e Err(StdError::generic_err(\"Exchange already exists\")),\n            Err(_) =\u003e Ok(())\n        }\n    }\n\n    #[test]\n    fn test_get_idos() -\u003e StdResult\u003c()\u003e {\n        let ref mut deps = mkdeps();\n        let mut addresses = vec![];\n\n        for i in 0..33 {\n            let addr = HumanAddr::from(format!(\"addr_{}\", i));\n\n            store_ido_address(deps, \u0026addr)?;\n            addresses.push(addr);\n        }\n\n        let result = get_idos(deps, pagination(addresses.len() as u64, 20))?;\n        assert_eq!(result.len(), 0);\n\n        let result = get_idos(deps, pagination((addresses.len() - 1) as u64, 20))?;\n        assert_eq!(result.len(), 1);\n\n        let result = get_idos(deps, pagination(0, 1))?;\n        assert_eq!(result.len(), 1);\n\n        let result = get_idos(deps, pagination(0, PAGINATION_LIMIT + 10))?;\n        assert_eq!(result.len(), PAGINATION_LIMIT as usize);\n\n        let result = get_idos(deps, pagination(3, PAGINATION_LIMIT))?;\n        assert_eq!(result, addresses[3..]);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_get_exchanges() -\u003e StdResult\u003c()\u003e {\n        let ref mut deps = mkdeps();\n\n        let mut exchanges = vec![];\n\n        for i in 0..33 {\n            let pair = TokenPair (\n                TokenType::CustomToken {\n                    contract_addr: HumanAddr(format!(\"addr_{}\", i)),\n                    token_code_hash: format!(\"code_hash_{}\", i)\n                },\n                TokenType::NativeToken {\n                    denom: format!(\"denom_{}\", i)\n                },\n            );\n            let address = HumanAddr(format!(\"address_{}\", i));\n\n            let exchange = Exchange {\n                pair,\n                address\n            };\n\n            store_exchange(deps, exchange.clone())?;\n            exchanges.push(exchange);\n        }\n\n        let result = get_exchanges(deps, pagination(exchanges.len() as u64, 20))?;\n        assert_eq!(result.len(), 0);\n\n        let result = get_exchanges(deps, pagination((exchanges.len() - 1) as u64, 20))?;\n        assert_eq!(result.len(), 1);\n\n        let result = get_exchanges(deps, pagination(0, 1))?;\n        assert_eq!(result.len(), 1);\n\n        let result = get_exchanges(deps, pagination(0, PAGINATION_LIMIT + 10))?;\n        assert_eq!(result.len(), PAGINATION_LIMIT as usize);\n\n        let result = get_exchanges(deps, pagination(3, PAGINATION_LIMIT))?;\n        assert_eq!(result, exchanges[3..]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1002123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1002143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1002163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1002183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[968448,968528],"length":1,"stats":{"Line":2},"fn_name":"mkenv\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":53,"address":[968460,968549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[968576],"length":1,"stats":{"Line":1},"fn_name":"mkdeps"},{"line":57,"address":[968584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[969584,968624],"length":1,"stats":{"Line":1},"fn_name":"mkconfig"},{"line":61,"address":[969170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[968654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[968725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[968801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[968877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[969080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[968953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[969008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[969068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[969158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[969995,969696],"length":1,"stats":{"Line":1},"fn_name":"assert_unauthorized"},{"line":76,"address":[969706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[969743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[970080],"length":1,"stats":{"Line":1},"fn_name":"pagination"},{"line":87,"address":[1072921,1072912,1072960,1073950],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":88,"address":[1072977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[1073016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1073043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1073912,1073997,1073070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1073995,1073766,1073897,1073294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[1073970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1074272,1074224,1077182,1074233],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":97,"address":[1074298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1074364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1074371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[1077138,1077387,1074398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1077375,1077449,1074605,1077119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1077086,1077205,1075421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1075609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1075616,1077058,1077341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1077039,1077326,1077454,1075830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1077009,1076646,1077247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[1076826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[1077977,1077968,1079827,1078016],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":115,"address":[1078033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[1078085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[1078092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1079951,1078135,1079777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1078328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[1078335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[1078362,1079749,1079917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1079985,1078565,1079730,1079902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1079378,1079700,1079850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[1079556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[1082504,1080345,1080384,1080336],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":131,"address":[1080401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1080550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1080456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[1080519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1080720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[1080626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[1080689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1080932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1081115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1081268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1081273,1081249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[1081420,1081321],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[1081412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[1081422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1081260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[1081449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[1081528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[1081497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1081603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[1081572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[1081783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[1081966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[1082119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[1082124,1082100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[1082271,1082172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[1082263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[1082273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[1082111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[1082300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[1082353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1087522,1083376,1083328,1083337],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":191,"address":[1083399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[1083556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[1083462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1083525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1083663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1083632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[1083835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[1083914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1084117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1083952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1084316,1083979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1084595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[1084726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1084754,1087694,1084834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1085096,1084824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[1085293,1085127,1087658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[1087628,1085555,1085662,1085250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[1085586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[1085948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[1085632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[1085908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1087596,1086619,1086825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1086790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1087071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[1087109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[1088313,1088352,1091681,1088304],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":245,"address":[1088375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1088430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1088509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[1088685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[1088547,1088772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[1089051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[1089182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[1089290,1089210,1091825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[1089280,1089552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[1091789,1089583,1089749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1090202,1091759,1090011,1089706],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[1090045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[1090131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1090091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[1090915,1091121,1091755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[1091086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[1091367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[1091405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[1092320,1092281,1092272,1095958],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":286,"address":[1092343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[1092492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[1092398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[1092461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[1092599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[1092568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[1092783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[1096251,1092899,1092811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[1093145,1092865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[1093193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1093413,1093247,1096215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[1093370,1093675,1093782,1096185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":309,"address":[1093706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[1094068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1093752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[1094028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[1094344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[1094317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[1096150,1094620,1094892,1095000],"length":1,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[1094980,1095280,1095837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[1095246,1095530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[1095498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[1100264,1096720,1096693,1096688],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":335,"address":[1096733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[1096810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[1096837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[1100498,1096880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[1097026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[1097033,1097247,1098735],"length":1,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[1098568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[1098231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[1097684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[1097285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[1097506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[1098155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[1097768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[1097977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[1098367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[1097207,1098756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[1098816,1098957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[1098867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[1099079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[1099350,1099198,1099445],"length":1,"stats":{"Line":3},"fn_name":null},{"line":367,"address":[1099260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[1100089,1099437,1100397,1099483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":370,"address":[1099550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[1099518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[1099654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[1099699,1099743],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[1099791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[1099710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[1101029,1101056,1101024,1103236],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":386,"address":[1101063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[1101134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":388,"address":[1101161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[1103470,1101204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[1101347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[1101541,1101354,1101803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[1101579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[1101826,1101504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[1102000,1101855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[1101890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[1102119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[1102486,1102394,1102238],"length":1,"stats":{"Line":3},"fn_name":null},{"line":406,"address":[1102284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[1102478,1103126,1102524,1103369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[1102591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[1102559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[1102692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[1102781,1102737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":417,"address":[1102829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[1102748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[784358,784224],"length":1,"stats":{"Line":1},"fn_name":"swap_pair\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":428,"address":[784347,784254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[784448,786723,784400,784409],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":462,"address":[788586,786992],"length":1,"stats":{"Line":1},"fn_name":"cmp_pair\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":466,"address":[787332,787035,788603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[787322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[787591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[787923,787603,788601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[787913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[788194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[788351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[784465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[784828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[784582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[784488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[784551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[784752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[784658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[784721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[785430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[785311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[785031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[785386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[785355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[786127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[785913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[785633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[786051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[785957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[786020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[786335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[791112,788800,788848,788809],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":525,"address":[788865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[788969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[788875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[788938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[789139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[789045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[789108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[789343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[789940,789706,789456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[789406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[789449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":545,"address":[789968,790087,789696,791132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":547,"address":[790669,790349,791127,790077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":548,"address":[790710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[790861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[791408,791456,791417,793137],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":555,"address":[791473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[791590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[791496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[791559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[791760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[791666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[791729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[792018,792263,792497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[791964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[791991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":572,"address":[792253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[792665,792871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":575,"address":[792526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[792638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":578,"address":[792837,792875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[792864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":584,"address":[798058,793433,793424,793472],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":585,"address":[793501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[793546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":588,"address":[793756,793553,794437],"length":1,"stats":{"Line":2},"fn_name":null},{"line":589,"address":[793794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":591,"address":[794043,798083,794163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":592,"address":[794097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[798081,794658,793735,794455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":596,"address":[794637,794915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":598,"address":[798079,795358,798253,795093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":599,"address":[795337,795615],"length":1,"stats":{"Line":2},"fn_name":null},{"line":601,"address":[798077,795994,795794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":602,"address":[795976,796248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":604,"address":[796415,796603,798075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[796585,796857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":607,"address":[797025,798073,797248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[797187,797532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[797712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":614,"address":[804398,798544,798496,798505],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":615,"address":[798573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":617,"address":[798626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[798836,800737,798633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[799294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":622,"address":[798874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":623,"address":[799104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":625,"address":[799568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[799378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[799756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":636,"address":[800455,800298,804426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[800383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[800958,800755,804424,798815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":641,"address":[801215,800937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":643,"address":[801393,804708,801658,804422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[801637,801915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":646,"address":[802094,802294,804420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":647,"address":[802276,802548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":649,"address":[802715,802903,804418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[803157,802885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":652,"address":[803325,804413,803548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":653,"address":[803487,803832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":655,"address":[804012],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":310,"coverable":321},{"path":["/","home","runner","work","sienna","sienna","contracts","factory","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests.\n//! 1. First copy them over verbatum,\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","ido","src","contract.rs"],"content":"use cosmwasm_std::{\n    Api, CosmosMsg, Env, Extern, HandleResponse, HumanAddr,\n    InitResponse, Querier, QueryResult, StdError, StdResult,\n    Storage, Uint128, WasmMsg, log, to_binary\n};\nuse secret_toolkit::snip20;\nuse amm_shared::TokenType;\nuse amm_shared::fadroma::callback::{ContractInstance};\nuse amm_shared::msg::ido::{InitMsg, HandleMsg, QueryMsg, QueryResponse};\nuse amm_shared::fadroma::utils::convert::convert_token;\nuse amm_shared::admin::admin::{\n    DefaultHandleImpl, DefaultQueryImpl, save_admin, admin_handle,\n    admin_query\n};\n\nuse crate::data::*;\n\n/// Pad handle responses and log attributes to blocks\n/// of 256 bytes to prevent leaking info based on response size\nconst BLOCK_SIZE: usize = 256;\n\nconst OVERFLOW_MSG: \u0026str = \"Upper bound overflow detected.\";\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    msg: InitMsg\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let input_token_decimals = match \u0026msg.info.input_token {\n        TokenType::NativeToken { .. } =\u003e 6,\n        TokenType::CustomToken { contract_addr, token_code_hash } =\u003e {\n            get_token_decimals(\u0026deps.querier, ContractInstance {\n                address: contract_addr.clone(),\n                code_hash: token_code_hash.clone()\n            })?\n        }\n    };\n\n    save_admin(deps, \u0026msg.admin)?;\n\n    let config = Config {\n        input_token: msg.info.input_token,\n        sold_token: msg.info.sold_token.clone(),\n        swap_constants: SwapConstants {\n            sold_token_decimals: get_token_decimals(\u0026deps.querier, msg.info.sold_token)?,\n            rate: msg.info.rate,\n            input_token_decimals\n        },\n        max_seats: msg.info.max_seats,\n        max_allocation: msg.info.max_allocation,\n        min_allocation: msg.info.min_allocation\n    };\n    config.save(deps)?;\n\n    Ok(InitResponse{\n        messages: vec![\n            // Execute the HandleMsg::RegisterIdo method of\n            // the factory contract in order to register this address\n            CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: msg.callback.contract.address,\n                callback_code_hash: msg.callback.contract.code_hash,\n                msg: msg.callback.msg,\n                send: vec![]\n            })\n        ],\n        log: vec![]\n    })\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Swap { amount } =\u003e swap(deps, env, amount),\n        HandleMsg::Admin(admin_msg) =\u003e admin_handle(deps, env, admin_msg, DefaultHandleImpl)\n    }\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e QueryResult {\n    match msg {\n        QueryMsg::GetRate =\u003e get_rate(deps),\n        QueryMsg::Admin(admin_msg) =\u003e admin_query(deps, admin_msg, DefaultQueryImpl)\n    }\n}\n\nfn swap\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut account = Account::load(deps, \u0026env.message.sender)?\n        .ok_or_else(||\n             StdError::generic_err(\"This address is not whitelisted.\")\n        )?;\n\n    let config = Config::load(deps)?;\n\n    let mint_amount = convert_token(\n        amount.u128(),\n        config.swap_constants.rate.u128(),\n        config.swap_constants.input_token_decimals,\n        config.swap_constants.sold_token_decimals\n    )?;\n\n    if mint_amount \u003c config.min_allocation.u128() {\n        return Err(StdError::generic_err(format!(\n            \"Insufficient amount provided: the resulting amount fell short of the minimum purchase expected: {}\",\n            config.min_allocation\n        )));\n    }\n\n    account.total_bought = account.total_bought.u128().checked_add(mint_amount)\n        .ok_or_else(||\n            StdError::generic_err(OVERFLOW_MSG)\n        )?\n        .into();\n\n    if account.total_bought \u003e config.max_allocation {\n        return Err(StdError::generic_err(format!(\n            \"This purchase exceeds the total maximum allowed amount for a single address: {}\",\n            config.min_allocation\n        )));\n    }\n\n    account.save(deps)?;\n\n    let mut messages = vec![];\n\n    // Retrieve the input amount from the sender's balance\n    match config.input_token {\n        TokenType::CustomToken { contract_addr, token_code_hash } =\u003e {\n            messages.push(snip20::transfer_from_msg(\n                env.message.sender.clone(),     \n                env.contract.address,\n                amount,\n                None,\n                BLOCK_SIZE,\n                token_code_hash,\n                contract_addr\n            )?);\n        },\n        TokenType::NativeToken { .. } =\u003e {\n            config.input_token.assert_sent_native_token_balance(\u0026env, amount)?;\n        }\n    }\n\n    // Transfer the resulting amount to the sender\n    messages.push(\n        snip20::transfer_msg(\n            env.message.sender,\n            Uint128(mint_amount),\n            None,\n            BLOCK_SIZE,\n            config.sold_token.code_hash,\n            config.sold_token.address\n        )?\n    );\n\n    Ok(HandleResponse {\n        messages,\n        log: vec![\n            log(\"action\", \"swap\"),\n            log(\"input_amount\", amount),\n            log(\"purchased_amount\", mint_amount)\n        ],\n        data: None\n    })\n}\n\nfn get_rate\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e QueryResult {\n    let config = Config::load(deps)?;\n\n    Ok(to_binary(\u0026QueryResponse::GetRate {\n        rate: config.swap_constants.rate\n    })?)\n}\n\nfn get_token_decimals(\n    querier: \u0026impl Querier,\n    instance: ContractInstance\u003cHumanAddr\u003e\n) -\u003e StdResult\u003cu8\u003e {\n    let result = snip20::token_info_query(\n        querier,\n        BLOCK_SIZE,\n        instance.code_hash,\n        instance.address\n    )?;\n\n    Ok(result.decimals)\n}\n/*\n#[cfg(test)]\nmod tests {\n    use super::*;\n}\n*/\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","ido","src","data.rs"],"content":"use cosmwasm_std::{HumanAddr, CanonicalAddr, Uint128, Api, StdResult};\nuse amm_shared::fadroma::address::{Canonize, Humanize};\nuse amm_shared::fadroma::callback::ContractInstance;\nuse amm_shared::TokenType;\nuse serde::{Serialize, Deserialize};\nuse schemars::JsonSchema;\n\n#[derive(Serialize, Deserialize, Debug)]\npub(crate) struct Config\u003cA\u003e {\n    /// The token that is used to buy the sold SNIP20.\n    pub input_token: TokenType\u003cA\u003e,\n    /// The token that is being sold.\n    pub sold_token: ContractInstance\u003cA\u003e,\n    pub swap_constants: SwapConstants,\n    /// The maximum number of participants allowed.\n    pub max_seats: u32,\n    /// The total amount that each participant is allowed to buy.\n    pub max_allocation: Uint128,\n    /// The minimum amount that each participant is allowed to buy.\n    pub min_allocation: Uint128\n}\n\n/// Used when calculating the swap. These do not change\n/// throughout the lifetime of the contract.\n#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\npub(crate) struct SwapConstants {\n    pub rate: Uint128,\n    pub input_token_decimals: u8,\n    pub sold_token_decimals: u8\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]\npub struct Account\u003cA\u003e {\n    pub owner: A,\n    pub total_bought: Uint128\n}\n\nimpl Humanize\u003cAccount\u003cHumanAddr\u003e\u003e for Account\u003cCanonicalAddr\u003e {\n    fn humanize(\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cAccount\u003cHumanAddr\u003e\u003e {\n        Ok(Account {\n            owner: self.owner.humanize(api)?,\n            total_bought: self.total_bought\n        })\n    }\n}\n\nimpl Canonize\u003cAccount\u003cCanonicalAddr\u003e\u003e for Account\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cAccount\u003cCanonicalAddr\u003e\u003e {\n        Ok(Account {\n            owner: self.owner.canonize(api)?,\n            total_bought: self.total_bought\n        })\n    }\n}\n\nimpl Canonize\u003cConfig\u003cCanonicalAddr\u003e\u003e for Config\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cConfig\u003cCanonicalAddr\u003e\u003e {\n        Ok(Config{\n            input_token: self.input_token.canonize(api)?,\n            sold_token: self.sold_token.canonize(api)?,\n            swap_constants: self.swap_constants.clone(),\n            max_seats: self.max_seats,\n            max_allocation: self.max_allocation,\n            min_allocation: self.min_allocation\n        })\n    }\n}\n\nimpl Humanize\u003cConfig\u003cHumanAddr\u003e\u003e for Config\u003cCanonicalAddr\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cConfig\u003cHumanAddr\u003e\u003e {\n        Ok(Config{\n            input_token: self.input_token.humanize(api)?,\n            sold_token: self.sold_token.humanize(api)?,\n            swap_constants: self.swap_constants.clone(),\n            max_seats: self.max_seats,\n            max_allocation: self.max_allocation,\n            min_allocation: self.min_allocation\n        })\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","runner","work","sienna","sienna","contracts","ido","src","lib.rs"],"content":"pub mod contract;\npub mod state;\npub mod data;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","ido","src","state.rs"],"content":"use cosmwasm_std::{ \n    StdResult, Extern, Storage, Querier, Api,\n    CanonicalAddr, HumanAddr, StdError\n};\nuse amm_shared::fadroma::address::{Canonize, Humanize};\nuse amm_shared::fadroma::storage::{save, load, ns_save, ns_load};\n\nuse crate::data::{Config, Account};\n\nimpl Config\u003cHumanAddr\u003e {\n    const KEY: \u0026'static [u8] = b\"config\";\n\n    pub fn save\u003cS: Storage, A: Api, Q: Querier\u003e(\n        \u0026self,\n        deps: \u0026mut Extern\u003cS, A, Q\u003e\n    ) -\u003e StdResult\u003c()\u003e {\n        save(\u0026mut deps.storage, Self::KEY, \u0026self.canonize(\u0026deps.api)?)\n    }\n    \n    pub fn load\u003cS: Storage, A: Api, Q: Querier\u003e(\n        deps: \u0026Extern\u003cS, A, Q\u003e\n    ) -\u003e StdResult\u003cSelf\u003e {\n        let result: Option\u003cConfig\u003cCanonicalAddr\u003e\u003e = load(\u0026deps.storage, Self::KEY)?;\n        result.ok_or(StdError::generic_err(\"Config doesn't exist in storage.\"))?.humanize(\u0026deps.api)\n    }\n}\n\nimpl Account\u003cHumanAddr\u003e {\n    const KEY: \u0026'static [u8] = b\"accounts\";\n\n    pub fn save\u003cS: Storage, A: Api, Q: Querier\u003e(\n        \u0026self,\n        deps: \u0026mut Extern\u003cS, A, Q\u003e\n    ) -\u003e StdResult\u003c()\u003e {\n        let account = self.canonize(\u0026deps.api)?;\n    \n        ns_save(\u0026mut deps.storage, Self::KEY, account.owner.as_slice(), \u0026account)\n    }\n\n    pub fn load\u003cS: Storage, A: Api, Q: Querier\u003e(\n        deps: \u0026Extern\u003cS, A, Q\u003e,\n        address: \u0026HumanAddr\n    ) -\u003e StdResult\u003cOption\u003cSelf\u003e\u003e {\n        let address = address.canonize(\u0026deps.api)?;  \n        let result: Option\u003cAccount\u003cCanonicalAddr\u003e\u003e = ns_load(\u0026deps.storage, Self::KEY, address.as_slice())?;\n    \n        if let Some(acc) = result {\n            Ok(Some(acc.humanize(\u0026deps.api)?))\n        } else {\n            Ok(None)\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse atoken::msg::{CountResponse, HandleMsg, InitMsg, QueryMsg};\nuse atoken::state::State;\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(State), \u0026out_dir);\n    export_schema(\u0026schema_for!(CountResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken","src","contract.rs"],"content":"use cosmwasm_std::{\n    debug_print, to_binary, Api, Binary, Env, Extern, HandleResponse, InitResponse, Querier,\n    StdError, StdResult, Storage,\n};\n\nuse crate::msg::{CountResponse, HandleMsg, InitMsg, QueryMsg};\nuse crate::state::{config, config_read, State};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let state = State {\n        count: msg.count,\n        owner: deps.api.canonical_address(\u0026env.message.sender)?,\n    };\n\n    config(\u0026mut deps.storage).save(\u0026state)?;\n\n    debug_print!(\"Contract was initialized by {}\", env.message.sender);\n\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Increment {} =\u003e try_increment(deps, env),\n        HandleMsg::Reset { count } =\u003e try_reset(deps, env, count),\n    }\n}\n\npub fn try_increment\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    config(\u0026mut deps.storage).update(|mut state| {\n        state.count += 1;\n        debug_print!(\"count = {}\", state.count);\n        Ok(state)\n    })?;\n\n    debug_print(\"count incremented successfully\");\n    Ok(HandleResponse::default())\n}\n\npub fn try_reset\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    count: i32,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender_address_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n    config(\u0026mut deps.storage).update(|mut state| {\n        if sender_address_raw != state.owner {\n            return Err(StdError::Unauthorized { backtrace: None });\n        }\n        state.count = count;\n        Ok(state)\n    })?;\n    debug_print(\"count reset successfully\");\n    Ok(HandleResponse::default())\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::GetCount {} =\u003e to_binary(\u0026query_count(deps)?),\n    }\n}\n\nfn query_count\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cCountResponse\u003e {\n    let state = config_read(\u0026deps.storage).load()?;\n    Ok(CountResponse { count: state.count })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env};\n    use cosmwasm_std::{coins, from_binary, StdError};\n\n    #[test]\n    fn proper_initialization() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        let msg = InitMsg { count: 17 };\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n\n        // we can just call .unwrap() to assert this was a success\n        let res = init(\u0026mut deps, env, msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // it worked, let's query the state\n        let res = query(\u0026deps, QueryMsg::GetCount {}).unwrap();\n        let value: CountResponse = from_binary(\u0026res).unwrap();\n        assert_eq!(17, value.count);\n    }\n\n    #[test]\n    fn increment() {\n        let mut deps = mock_dependencies(20, \u0026coins(2, \"token\"));\n\n        let msg = InitMsg { count: 17 };\n        let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n        let _res = init(\u0026mut deps, env, msg).unwrap();\n\n        // anyone can increment\n        let env = mock_env(\"anyone\", \u0026coins(2, \"token\"));\n        let msg = HandleMsg::Increment {};\n        let _res = handle(\u0026mut deps, env, msg).unwrap();\n\n        // should increase counter by 1\n        let res = query(\u0026deps, QueryMsg::GetCount {}).unwrap();\n        let value: CountResponse = from_binary(\u0026res).unwrap();\n        assert_eq!(18, value.count);\n    }\n\n    #[test]\n    fn reset() {\n        let mut deps = mock_dependencies(20, \u0026coins(2, \"token\"));\n\n        let msg = InitMsg { count: 17 };\n        let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n        let _res = init(\u0026mut deps, env, msg).unwrap();\n\n        // not anyone can reset\n        let unauth_env = mock_env(\"anyone\", \u0026coins(2, \"token\"));\n        let msg = HandleMsg::Reset { count: 5 };\n        let res = handle(\u0026mut deps, unauth_env, msg);\n        match res {\n            Err(StdError::Unauthorized { .. }) =\u003e {}\n            _ =\u003e panic!(\"Must return unauthorized error\"),\n        }\n\n        // only the original creator can reset the counter\n        let auth_env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n        let msg = HandleMsg::Reset { count: 5 };\n        let _res = handle(\u0026mut deps, auth_env, msg).unwrap();\n\n        // should now be 5\n        let res = query(\u0026deps, QueryMsg::GetCount {}).unwrap();\n        let value: CountResponse = from_binary(\u0026res).unwrap();\n        assert_eq!(5, value.count);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\npub mod state;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n    pub count: i32,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    Increment {},\n    Reset { count: i32 },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    // GetCount returns the current count as a json-encoded number\n    GetCount {},\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct CountResponse {\n    pub count: i32,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{CanonicalAddr, Storage};\nuse cosmwasm_storage::{singleton, singleton_read, ReadonlySingleton, Singleton};\n\npub static CONFIG_KEY: \u0026[u8] = b\"config\";\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct State {\n    pub count: i32,\n    pub owner: CanonicalAddr,\n}\n\npub fn config\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, State\u003e {\n    singleton(storage, CONFIG_KEY)\n}\n\npub fn config_read\u003cS: Storage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, State\u003e {\n    singleton_read(storage, CONFIG_KEY)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests.\n//! 1. First copy them over verbatum,\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse atoken::msg::{HandleAnswer, HandleMsg, InitMsg, QueryAnswer, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleAnswer), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryAnswer), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","src","batch.rs"],"content":"//! Types used in batch operations\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Binary, HumanAddr, Uint128};\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct TransferAction {\n    pub recipient: HumanAddr,\n    pub amount: Uint128,\n    pub memo: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct SendAction {\n    pub recipient: HumanAddr,\n    pub amount: Uint128,\n    pub msg: Option\u003cBinary\u003e,\n    pub memo: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct TransferFromAction {\n    pub owner: HumanAddr,\n    pub recipient: HumanAddr,\n    pub amount: Uint128,\n    pub memo: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct SendFromAction {\n    pub owner: HumanAddr,\n    pub recipient: HumanAddr,\n    pub amount: Uint128,\n    pub msg: Option\u003cBinary\u003e,\n    pub memo: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct MintAction {\n    pub recipient: HumanAddr,\n    pub amount: Uint128,\n    pub memo: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct BurnFromAction {\n    pub owner: HumanAddr,\n    pub amount: Uint128,\n    pub memo: Option\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","src","contract.rs"],"content":"/// This contract implements SNIP-20 standard:\n/// https://github.com/SecretFoundation/SNIPs/blob/master/SNIP-20.md\nuse cosmwasm_std::{\n    log, to_binary, Api, BankMsg, Binary, CanonicalAddr, Coin, CosmosMsg, Env, Extern,\n    HandleResponse, HumanAddr, InitResponse, Querier, QueryResult, ReadonlyStorage, StdError,\n    StdResult, Storage, Uint128,\n};\n\nuse crate::msg::{\n    space_pad, ContractStatusLevel, HandleAnswer, HandleMsg, InitMsg, QueryAnswer, QueryMsg,\n    ResponseStatus::Success,\n};\nuse crate::rand::sha_256;\nuse crate::receiver::Snip20ReceiveMsg;\nuse crate::state::{\n    get_receiver_hash, read_allowance, read_viewing_key, set_receiver_hash, write_allowance,\n    write_viewing_key, Balances, Config, Constants, ReadonlyBalances, ReadonlyConfig,\n};\nuse crate::transaction_history::{\n    get_transfers, get_txs, store_burn, store_deposit, store_mint, store_redeem, store_transfer,\n};\nuse crate::viewing_key::{ViewingKey, VIEWING_KEY_SIZE};\nuse crate::{batch, state};\n\n/// We make sure that responses from `handle` are padded to a multiple of this size.\npub const RESPONSE_BLOCK_SIZE: usize = 256;\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    // Check name, symbol, decimals\n    if !is_valid_name(\u0026msg.name) {\n        return Err(StdError::generic_err(\n            \"Name is not in the expected format (3-30 UTF-8 bytes)\",\n        ));\n    }\n    if !is_valid_symbol(\u0026msg.symbol) {\n        return Err(StdError::generic_err(\n            \"Ticker symbol is not in expected format [A-Z]{3,6}\",\n        ));\n    }\n    if msg.decimals \u003e 18 {\n        return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n    }\n\n    let init_config = msg.config();\n    let admin = msg.admin.unwrap_or(env.message.sender);\n    let canon_admin = deps.api.canonical_address(\u0026admin)?;\n\n    let mut total_supply: u128 = 0;\n    {\n        let initial_balances = msg.initial_balances.unwrap_or_default();\n        for balance in initial_balances {\n            let balance_address = deps.api.canonical_address(\u0026balance.address)?;\n            let amount = balance.amount.u128();\n            let mut balances = Balances::from_storage(\u0026mut deps.storage);\n            balances.set_account_balance(\u0026balance_address, amount);\n            if let Some(new_total_supply) = total_supply.checked_add(amount) {\n                total_supply = new_total_supply;\n            } else {\n                return Err(StdError::generic_err(\n                    \"The sum of all initial balances exceeds the maximum possible total supply\",\n                ));\n            }\n            store_mint(\n                \u0026mut deps.storage,\n                \u0026canon_admin,\n                \u0026balance_address,\n                balance.amount,\n                msg.symbol.clone(),\n                Some(\"Initial Balance\".to_string()),\n                \u0026env.block,\n            )?;\n        }\n    }\n\n    let prng_seed_hashed = sha_256(\u0026msg.prng_seed.0);\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    config.set_constants(\u0026Constants {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n        admin: admin.clone(),\n        prng_seed: prng_seed_hashed.to_vec(),\n        total_supply_is_public: init_config.public_total_supply(),\n        deposit_is_enabled: init_config.deposit_enabled(),\n        redeem_is_enabled: init_config.redeem_enabled(),\n        mint_is_enabled: init_config.mint_enabled(),\n        burn_is_enabled: init_config.burn_enabled(),\n    })?;\n    config.set_total_supply(total_supply);\n    config.set_contract_status(ContractStatusLevel::NormalRun);\n    let minters = if init_config.mint_enabled() {\n        Vec::from([admin])\n    } else {\n        Vec::new()\n    };\n    config.set_minters(minters)?;\n\n    Ok(InitResponse::default())\n}\n\nfn pad_response(response: StdResult\u003cHandleResponse\u003e) -\u003e StdResult\u003cHandleResponse\u003e {\n    response.map(|mut response| {\n        response.data = response.data.map(|mut data| {\n            space_pad(RESPONSE_BLOCK_SIZE, \u0026mut data.0);\n            data\n        });\n        response\n    })\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let contract_status = ReadonlyConfig::from_storage(\u0026deps.storage).contract_status();\n\n    match contract_status {\n        ContractStatusLevel::StopAll | ContractStatusLevel::StopAllButRedeems =\u003e {\n            let response = match msg {\n                HandleMsg::SetContractStatus { level, .. } =\u003e set_contract_status(deps, env, level),\n                HandleMsg::Redeem { amount, .. }\n                    if contract_status == ContractStatusLevel::StopAllButRedeems =\u003e\n                {\n                    try_redeem(deps, env, amount)\n                }\n                _ =\u003e Err(StdError::generic_err(\n                    \"This contract is stopped and this action is not allowed\",\n                )),\n            };\n            return pad_response(response);\n        }\n        ContractStatusLevel::NormalRun =\u003e {} // If it's a normal run just continue\n    }\n\n    let response = match msg {\n        // Native\n        HandleMsg::Deposit { .. } =\u003e try_deposit(deps, env),\n        HandleMsg::Redeem { amount, .. } =\u003e try_redeem(deps, env, amount),\n\n        // Base\n        HandleMsg::Transfer {\n            recipient,\n            amount,\n            memo,\n            ..\n        } =\u003e try_transfer(deps, env, recipient, amount, memo),\n        HandleMsg::Send {\n            recipient,\n            amount,\n            msg,\n            memo,\n            ..\n        } =\u003e try_send(deps, env, recipient, amount, memo, msg),\n        HandleMsg::BatchTransfer { actions, .. } =\u003e try_batch_transfer(deps, env, actions),\n        HandleMsg::BatchSend { actions, .. } =\u003e try_batch_send(deps, env, actions),\n        HandleMsg::Burn { amount, memo, .. } =\u003e try_burn(deps, env, amount, memo),\n        HandleMsg::RegisterReceive { code_hash, .. } =\u003e try_register_receive(deps, env, code_hash),\n        HandleMsg::CreateViewingKey { entropy, .. } =\u003e try_create_key(deps, env, entropy),\n        HandleMsg::SetViewingKey { key, .. } =\u003e try_set_key(deps, env, key),\n\n        // Allowance\n        HandleMsg::IncreaseAllowance {\n            spender,\n            amount,\n            expiration,\n            ..\n        } =\u003e try_increase_allowance(deps, env, spender, amount, expiration),\n        HandleMsg::DecreaseAllowance {\n            spender,\n            amount,\n            expiration,\n            ..\n        } =\u003e try_decrease_allowance(deps, env, spender, amount, expiration),\n        HandleMsg::TransferFrom {\n            owner,\n            recipient,\n            amount,\n            memo,\n            ..\n        } =\u003e try_transfer_from(deps, \u0026env, \u0026owner, \u0026recipient, amount, memo),\n        HandleMsg::SendFrom {\n            owner,\n            recipient,\n            amount,\n            msg,\n            memo,\n            ..\n        } =\u003e try_send_from(deps, env, owner, recipient, amount, memo, msg),\n        HandleMsg::BatchTransferFrom { actions, .. } =\u003e {\n            try_batch_transfer_from(deps, \u0026env, actions)\n        }\n        HandleMsg::BatchSendFrom { actions, .. } =\u003e try_batch_send_from(deps, env, actions),\n        HandleMsg::BurnFrom {\n            owner,\n            amount,\n            memo,\n            ..\n        } =\u003e try_burn_from(deps, \u0026env, \u0026owner, amount, memo),\n        HandleMsg::BatchBurnFrom { actions, .. } =\u003e try_batch_burn_from(deps, \u0026env, actions),\n\n        // Mint\n        HandleMsg::Mint {\n            recipient,\n            amount,\n            memo,\n            ..\n        } =\u003e try_mint(deps, env, recipient, amount, memo),\n        HandleMsg::BatchMint { actions, .. } =\u003e try_batch_mint(deps, env, actions),\n\n        // Other\n        HandleMsg::ChangeAdmin { address, .. } =\u003e change_admin(deps, env, address),\n        HandleMsg::SetContractStatus { level, .. } =\u003e set_contract_status(deps, env, level),\n        HandleMsg::AddMinters { minters, .. } =\u003e add_minters(deps, env, minters),\n        HandleMsg::RemoveMinters { minters, .. } =\u003e remove_minters(deps, env, minters),\n        HandleMsg::SetMinters { minters, .. } =\u003e set_minters(deps, env, minters),\n    };\n\n    pad_response(response)\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e, msg: QueryMsg) -\u003e QueryResult {\n    match msg {\n        QueryMsg::TokenInfo {} =\u003e query_token_info(\u0026deps.storage),\n        QueryMsg::TokenConfig {} =\u003e query_token_config(\u0026deps.storage),\n        QueryMsg::ContractStatus {} =\u003e query_contract_status(\u0026deps.storage),\n        QueryMsg::ExchangeRate {} =\u003e query_exchange_rate(\u0026deps.storage),\n        QueryMsg::Minters { .. } =\u003e query_minters(deps),\n        QueryMsg::LastUserIndex { account } =\u003e query_get_user_index(\u0026account, \u0026deps),\n        QueryMsg::InterestedRedirectionAddress { account } =\u003e {\n            query_get_interested_redirection_address(\u0026account, \u0026deps)\n        }\n        QueryMsg::RedirectedBalance { account } =\u003e query_get_redirected_balance(\u0026account, \u0026deps),\n        _ =\u003e authenticated_queries(deps, msg),\n    }\n}\n\npub fn authenticated_queries\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e QueryResult {\n    let (addresses, key) = msg.get_validation_params();\n\n    for address in addresses {\n        let canonical_addr = deps.api.canonical_address(address)?;\n\n        let expected_key = read_viewing_key(\u0026deps.storage, \u0026canonical_addr);\n\n        if expected_key.is_none() {\n            // Checking the key will take significant time. We don't want to exit immediately if it isn't set\n            // in a way which will allow to time the command and determine if a viewing key doesn't exist\n            key.check_viewing_key(\u0026[0u8; VIEWING_KEY_SIZE]);\n        } else if key.check_viewing_key(expected_key.unwrap().as_slice()) {\n            return match msg {\n                // Base\n                QueryMsg::Balance { address, .. } =\u003e query_balance(\u0026deps, \u0026address),\n                QueryMsg::PrincpleBalanceOf { address } =\u003e {\n                    query_principal_balance_of(\u0026deps, \u0026address)\n                }\n\n                QueryMsg::TransferHistory {\n                    address,\n                    page,\n                    page_size,\n                    ..\n                } =\u003e query_transfers(\u0026deps, \u0026address, page.unwrap_or(0), page_size),\n                QueryMsg::TransactionHistory {\n                    address,\n                    page,\n                    page_size,\n                    ..\n                } =\u003e query_transactions(\u0026deps, \u0026address, page.unwrap_or(0), page_size),\n                QueryMsg::Allowance { owner, spender, .. } =\u003e query_allowance(deps, owner, spender),\n                _ =\u003e panic!(\"This query type does not require authentication\"),\n            };\n        }\n    }\n\n    Ok(to_binary(\u0026QueryAnswer::ViewingKeyError {\n        msg: \"Wrong viewing key for this address or viewing key not set\".to_string(),\n    })?)\n}\n\npub fn query_get_user_index\u003cS: Storage, A: Api, Q: Querier\u003e(\n    account: \u0026HumanAddr,\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e QueryResult {\n    match state::get_user_index(\u0026deps.storage, account) {\n        Some(result) =\u003e Ok(result),\n        None =\u003e {\n            return Err(StdError::generic_err(\n                \"Сouldn't find last index of the user\",\n            ));\n        }\n    }\n}\n\npub fn query_get_interested_redirection_address\u003cS: Storage, A: Api, Q: Querier\u003e(\n    account: \u0026HumanAddr,\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e QueryResult {\n    match state::get_interested_redirection_address(\u0026deps.storage, account) {\n        Some(result) =\u003e Ok(result),\n        None =\u003e {\n            let zero_bin = [0_u8];\n            Ok(Binary::from(zero_bin))\n        }\n    }\n}\n\npub fn query_get_redirected_balance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    account: \u0026HumanAddr,\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e QueryResult {\n    match state::get_redirection_balance(\u0026deps.storage, account) {\n        Some(result) =\u003e Ok(result),\n        None =\u003e {\n            return Err(StdError::generic_err(\n                \"Couldn't find the total redirected balance\",\n            ));\n        }\n    }\n}\npub fn query_principal_balance_of\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n) -\u003e QueryResult {\n    query_balance(deps, account)\n}\n\nfn query_exchange_rate\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n    let constants = config.constants()?;\n\n    if constants.deposit_is_enabled || constants.redeem_is_enabled {\n        let rate: Uint128;\n        let denom: String;\n        // if token has more decimals than SCRT, you get magnitudes of SCRT per token\n        if constants.decimals \u003e= 6 {\n            rate = Uint128(10u128.pow(constants.decimals as u32 - 6));\n            denom = \"SCRT\".to_string();\n        // if token has less decimals, you get magnitudes token for SCRT\n        } else {\n            rate = Uint128(10u128.pow(6 - constants.decimals as u32));\n            denom = constants.symbol;\n        }\n        return to_binary(\u0026QueryAnswer::ExchangeRate { rate, denom });\n    }\n    to_binary(\u0026QueryAnswer::ExchangeRate {\n        rate: Uint128(0),\n        denom: String::new(),\n    })\n}\n\nfn query_token_info\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n    let constants = config.constants()?;\n\n    let total_supply = if constants.total_supply_is_public {\n        Some(Uint128(config.total_supply()))\n    } else {\n        None\n    };\n\n    to_binary(\u0026QueryAnswer::TokenInfo {\n        name: constants.name,\n        symbol: constants.symbol,\n        decimals: constants.decimals,\n        total_supply,\n    })\n}\n\nfn query_token_config\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n    let constants = config.constants()?;\n\n    to_binary(\u0026QueryAnswer::TokenConfig {\n        public_total_supply: constants.total_supply_is_public,\n        deposit_enabled: constants.deposit_is_enabled,\n        redeem_enabled: constants.redeem_is_enabled,\n        mint_enabled: constants.mint_is_enabled,\n        burn_enabled: constants.burn_is_enabled,\n    })\n}\n\nfn query_contract_status\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n\n    to_binary(\u0026QueryAnswer::ContractStatus {\n        status: config.contract_status(),\n    })\n}\n\npub fn query_transfers\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n    page: u32,\n    page_size: u32,\n) -\u003e StdResult\u003cBinary\u003e {\n    let address = deps.api.canonical_address(account)?;\n    let (txs, total) = get_transfers(\u0026deps.api, \u0026deps.storage, \u0026address, page, page_size)?;\n\n    let result = QueryAnswer::TransferHistory {\n        txs,\n        total: Some(total),\n    };\n    to_binary(\u0026result)\n}\n\npub fn query_transactions\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n    page: u32,\n    page_size: u32,\n) -\u003e StdResult\u003cBinary\u003e {\n    let address = deps.api.canonical_address(account)?;\n    let (txs, total) = get_txs(\u0026deps.api, \u0026deps.storage, \u0026address, page, page_size)?;\n\n    let result = QueryAnswer::TransactionHistory {\n        txs,\n        total: Some(total),\n    };\n    to_binary(\u0026result)\n}\n\npub fn query_balance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n) -\u003e StdResult\u003cBinary\u003e {\n    let address = deps.api.canonical_address(account)?;\n\n    let amount = Uint128(ReadonlyBalances::from_storage(\u0026deps.storage).account_amount(\u0026address));\n    let response = QueryAnswer::Balance { amount };\n    to_binary(\u0026response)\n}\n\nfn query_minters\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cBinary\u003e {\n    let minters = ReadonlyConfig::from_storage(\u0026deps.storage).minters();\n\n    let response = QueryAnswer::Minters { minters };\n    to_binary(\u0026response)\n}\n\nfn change_admin\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    address: HumanAddr,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    let mut consts = config.constants()?;\n    consts.admin = address;\n    config.set_constants(\u0026consts)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::ChangeAdmin { status: Success })?),\n    })\n}\n\nfn try_mint_impl\u003cS: Storage\u003e(\n    storage: \u0026mut S,\n    minter: \u0026CanonicalAddr,\n    recipient: \u0026CanonicalAddr,\n    amount: Uint128,\n    denom: String,\n    memo: Option\u003cString\u003e,\n    block: \u0026cosmwasm_std::BlockInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let raw_amount = amount.u128();\n\n    let mut balances = Balances::from_storage(storage);\n\n    let mut account_balance = balances.balance(recipient);\n\n    if let Some(new_balance) = account_balance.checked_add(raw_amount) {\n        account_balance = new_balance;\n    } else {\n        // This error literally can not happen, since the account's funds are a subset\n        // of the total supply, both are stored as u128, and we check for overflow of\n        // the total supply just a couple lines before.\n        // Still, writing this to cover all overflows.\n        return Err(StdError::generic_err(\n            \"This mint attempt would increase the account's balance above the supported maximum\",\n        ));\n    }\n\n    balances.set_account_balance(recipient, account_balance);\n\n    store_mint(storage, minter, recipient, amount, denom, memo, block)?;\n\n    Ok(())\n}\n\nfn try_mint\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: HumanAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    let minters = config.minters();\n    if !minters.contains(\u0026env.message.sender) {\n        return Err(StdError::generic_err(\n            \"Minting is allowed to minter accounts only\",\n        ));\n    }\n\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_add(amount.u128()) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"This mint attempt would increase the total supply above the supported maximum\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    let minter = \u0026deps.api.canonical_address(\u0026env.message.sender)?;\n    let recipient = \u0026deps.api.canonical_address(\u0026recipient)?;\n    try_mint_impl(\n        \u0026mut deps.storage,\n        \u0026minter,\n        \u0026recipient,\n        amount,\n        constants.symbol,\n        memo,\n        \u0026env.block,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Mint { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_batch_mint\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    actions: Vec\u003cbatch::MintAction\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    let minters = config.minters();\n    if !minters.contains(\u0026env.message.sender) {\n        return Err(StdError::generic_err(\n            \"Minting is allowed to minter accounts only\",\n        ));\n    }\n\n    let mut total_supply = config.total_supply();\n\n    // Quick loop to check that the total of amounts is valid\n    for action in \u0026actions {\n        if let Some(new_total_supply) = total_supply.checked_add(action.amount.u128()) {\n            total_supply = new_total_supply;\n        } else {\n            return Err(StdError::generic_err(\n                format!(\"This mint attempt would increase the total supply above the supported maximum: {:?}\", action),\n            ));\n        }\n    }\n    config.set_total_supply(total_supply);\n\n    let minter = \u0026deps.api.canonical_address(\u0026env.message.sender)?;\n    for action in actions {\n        let recipient = \u0026deps.api.canonical_address(\u0026action.recipient)?;\n        try_mint_impl(\n            \u0026mut deps.storage,\n            \u0026minter,\n            \u0026recipient,\n            action.amount,\n            constants.symbol.clone(),\n            action.memo,\n            \u0026env.block,\n        )?;\n    }\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::BatchMint { status: Success })?),\n    };\n\n    Ok(res)\n}\n\npub fn try_set_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    key: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let vk = ViewingKey(key);\n\n    let message_sender = deps.api.canonical_address(\u0026env.message.sender)?;\n    write_viewing_key(\u0026mut deps.storage, \u0026message_sender, \u0026vk);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetViewingKey { status: Success })?),\n    })\n}\n\npub fn try_create_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    entropy: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let constants = ReadonlyConfig::from_storage(\u0026deps.storage).constants()?;\n    let prng_seed = constants.prng_seed;\n\n    let key = ViewingKey::new(\u0026env, \u0026prng_seed, (\u0026entropy).as_ref());\n\n    let message_sender = deps.api.canonical_address(\u0026env.message.sender)?;\n    write_viewing_key(\u0026mut deps.storage, \u0026message_sender, \u0026key);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::CreateViewingKey { key })?),\n    })\n}\n\nfn set_contract_status\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    status_level: ContractStatusLevel,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.set_contract_status(status_level);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetContractStatus {\n            status: Success,\n        })?),\n    })\n}\n\npub fn query_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    owner: HumanAddr,\n    spender: HumanAddr,\n) -\u003e StdResult\u003cBinary\u003e {\n    let owner_address = deps.api.canonical_address(\u0026owner)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n\n    let response = QueryAnswer::Allowance {\n        owner,\n        spender,\n        allowance: Uint128(allowance.amount),\n        expiration: allowance.expiration,\n    };\n    to_binary(\u0026response)\n}\n\nfn try_deposit\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut amount = Uint128::zero();\n\n    for coin in \u0026env.message.sent_funds {\n        if coin.denom == \"uscrt\" {\n            amount = coin.amount\n        } else {\n            return Err(StdError::generic_err(\n                \"Tried to deposit an unsupported token\",\n            ));\n        }\n    }\n\n    if amount.is_zero() {\n        return Err(StdError::generic_err(\"No funds were sent to be deposited\"));\n    }\n\n    let raw_amount = amount.u128();\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.deposit_is_enabled {\n        return Err(StdError::generic_err(\n            \"Deposit functionality is not enabled for this token.\",\n        ));\n    }\n    let total_supply = config.total_supply();\n    if let Some(total_supply) = total_supply.checked_add(raw_amount) {\n        config.set_total_supply(total_supply);\n    } else {\n        return Err(StdError::generic_err(\n            \"This deposit would overflow the currency's total supply\",\n        ));\n    }\n\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let account_balance = balances.balance(\u0026sender_address);\n    if let Some(account_balance) = account_balance.checked_add(raw_amount) {\n        balances.set_account_balance(\u0026sender_address, account_balance);\n    } else {\n        return Err(StdError::generic_err(\n            \"This deposit would overflow your balance\",\n        ));\n    }\n\n    store_deposit(\n        \u0026mut deps.storage,\n        \u0026sender_address,\n        amount,\n        \"uscrt\".to_string(),\n        \u0026env.block,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Deposit { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_redeem\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n    let constants = config.constants()?;\n    if !constants.redeem_is_enabled {\n        return Err(StdError::generic_err(\n            \"Redeem functionality is not enabled for this token.\",\n        ));\n    }\n\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let amount_raw = amount.u128();\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let account_balance = balances.balance(\u0026sender_address);\n\n    if let Some(account_balance) = account_balance.checked_sub(amount_raw) {\n        balances.set_account_balance(\u0026sender_address, account_balance);\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to redeem: balance={}, required={}\",\n            account_balance, amount_raw\n        )));\n    }\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let total_supply = config.total_supply();\n    if let Some(total_supply) = total_supply.checked_sub(amount_raw) {\n        config.set_total_supply(total_supply);\n    } else {\n        return Err(StdError::generic_err(\n            \"You are trying to redeem more tokens than what is available in the total supply\",\n        ));\n    }\n\n    let token_reserve = deps\n        .querier\n        .query_balance(\u0026env.contract.address, \"uscrt\")?\n        .amount;\n    if amount \u003e token_reserve {\n        return Err(StdError::generic_err(\n            \"You are trying to redeem for more SCRT than the token has in its deposit reserve.\",\n        ));\n    }\n\n    let withdrawal_coins: Vec\u003cCoin\u003e = vec![Coin {\n        denom: \"uscrt\".to_string(),\n        amount,\n    }];\n\n    store_redeem(\n        \u0026mut deps.storage,\n        \u0026sender_address,\n        amount,\n        constants.symbol,\n        \u0026env.block,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![CosmosMsg::Bank(BankMsg::Send {\n            from_address: env.contract.address,\n            to_address: env.message.sender,\n            amount: withdrawal_coins,\n        })],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Redeem { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_transfer_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    sender: \u0026CanonicalAddr,\n    recipient: \u0026CanonicalAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n    block: \u0026cosmwasm_std::BlockInfo,\n) -\u003e StdResult\u003c()\u003e {\n    perform_transfer(\u0026mut deps.storage, \u0026sender, \u0026recipient, amount.u128())?;\n\n    let symbol = Config::from_storage(\u0026mut deps.storage).constants()?.symbol;\n\n    store_transfer(\n        \u0026mut deps.storage,\n        \u0026sender,\n        \u0026sender,\n        \u0026recipient,\n        amount,\n        symbol,\n        memo,\n        block,\n    )?;\n\n    Ok(())\n}\n\nfn try_transfer\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: HumanAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender = deps.api.canonical_address(\u0026env.message.sender)?;\n    let recipient = deps.api.canonical_address(\u0026recipient)?;\n    try_transfer_impl(deps, \u0026sender, \u0026recipient, amount, memo, \u0026env.block)?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Transfer { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_batch_transfer\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    actions: Vec\u003cbatch::TransferAction\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender = deps.api.canonical_address(\u0026env.message.sender)?;\n    for action in actions {\n        let recipient = deps.api.canonical_address(\u0026action.recipient)?;\n        try_transfer_impl(\n            deps,\n            \u0026sender,\n            \u0026recipient,\n            action.amount,\n            action.memo,\n            \u0026env.block,\n        )?;\n    }\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::BatchTransfer { status: Success })?),\n    };\n    Ok(res)\n}\n\n#[allow(clippy::too_many_arguments)]\nfn try_add_receiver_api_callback\u003cS: ReadonlyStorage\u003e(\n    storage: \u0026S,\n    messages: \u0026mut Vec\u003cCosmosMsg\u003e,\n    recipient: HumanAddr,\n    msg: Option\u003cBinary\u003e,\n    sender: HumanAddr,\n    from: HumanAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n) -\u003e StdResult\u003c()\u003e {\n    let receiver_hash = get_receiver_hash(storage, \u0026recipient);\n    if let Some(receiver_hash) = receiver_hash {\n        let receiver_hash = receiver_hash?;\n        let receiver_msg = Snip20ReceiveMsg::new(sender, from, amount, memo, msg);\n        let callback_msg = receiver_msg.into_cosmos_msg(receiver_hash, recipient)?;\n\n        messages.push(callback_msg);\n    }\n    Ok(())\n}\n\n#[allow(clippy::too_many_arguments)]\nfn try_send_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    messages: \u0026mut Vec\u003cCosmosMsg\u003e,\n    sender: HumanAddr,\n    sender_canon: \u0026CanonicalAddr, // redundant but more efficient\n    recipient: HumanAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n    msg: Option\u003cBinary\u003e,\n    block: \u0026cosmwasm_std::BlockInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let recipient_canon = deps.api.canonical_address(\u0026recipient)?;\n    try_transfer_impl(\n        deps,\n        \u0026sender_canon,\n        \u0026recipient_canon,\n        amount,\n        memo.clone(),\n        block,\n    )?;\n\n    try_add_receiver_api_callback(\n        \u0026deps.storage,\n        messages,\n        recipient,\n        msg,\n        sender.clone(),\n        sender,\n        amount,\n        memo,\n    )?;\n\n    Ok(())\n}\n\nfn try_send\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: HumanAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n    msg: Option\u003cBinary\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut messages = vec![];\n    let sender = env.message.sender;\n    let sender_canon = deps.api.canonical_address(\u0026sender)?;\n    try_send_impl(\n        deps,\n        \u0026mut messages,\n        sender,\n        \u0026sender_canon,\n        recipient,\n        amount,\n        memo,\n        msg,\n        \u0026env.block,\n    )?;\n\n    let res = HandleResponse {\n        messages,\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Send { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_batch_send\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    actions: Vec\u003cbatch::SendAction\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut messages = vec![];\n    let sender = env.message.sender;\n    let sender_canon = deps.api.canonical_address(\u0026sender)?;\n    for action in actions {\n        try_send_impl(\n            deps,\n            \u0026mut messages,\n            sender.clone(),\n            \u0026sender_canon,\n            action.recipient,\n            action.amount,\n            action.memo,\n            action.msg,\n            \u0026env.block,\n        )?;\n    }\n\n    let res = HandleResponse {\n        messages,\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::BatchSend { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_register_receive\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    code_hash: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    set_receiver_hash(\u0026mut deps.storage, \u0026env.message.sender, code_hash);\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![log(\"register_status\", \"success\")],\n        data: Some(to_binary(\u0026HandleAnswer::RegisterReceive {\n            status: Success,\n        })?),\n    };\n    Ok(res)\n}\n\nfn insufficient_allowance(allowance: u128, required: u128) -\u003e StdError {\n    StdError::generic_err(format!(\n        \"insufficient allowance: allowance={}, required={}\",\n        allowance, required\n    ))\n}\n\nfn use_allowance\u003cS: Storage\u003e(\n    storage: \u0026mut S,\n    env: \u0026Env,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n    amount: u128,\n) -\u003e StdResult\u003c()\u003e {\n    let mut allowance = read_allowance(storage, owner, spender)?;\n\n    if allowance.expiration.map(|ex| ex \u003c env.block.time) == Some(true) \u0026\u0026 allowance.amount != 0 {\n        allowance.amount = 0;\n        write_allowance(storage, owner, spender, allowance)?;\n        return Err(insufficient_allowance(0, amount));\n    }\n    if let Some(new_allowance) = allowance.amount.checked_sub(amount) {\n        allowance.amount = new_allowance;\n    } else {\n        return Err(insufficient_allowance(allowance.amount, amount));\n    }\n\n    write_allowance(storage, owner, spender, allowance)?;\n\n    Ok(())\n}\n\nfn try_transfer_from_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: \u0026Env,\n    spender: \u0026CanonicalAddr,\n    owner: \u0026CanonicalAddr,\n    recipient: \u0026CanonicalAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n) -\u003e StdResult\u003c()\u003e {\n    let raw_amount = amount.u128();\n\n    use_allowance(\u0026mut deps.storage, env, owner, spender, raw_amount)?;\n\n    perform_transfer(\u0026mut deps.storage, owner, recipient, raw_amount)?;\n\n    let symbol = Config::from_storage(\u0026mut deps.storage).constants()?.symbol;\n\n    store_transfer(\n        \u0026mut deps.storage,\n        owner,\n        spender,\n        recipient,\n        amount,\n        symbol,\n        memo,\n        \u0026env.block,\n    )?;\n\n    Ok(())\n}\n\nfn try_transfer_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: \u0026Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let spender = deps.api.canonical_address(\u0026env.message.sender)?;\n    let owner = deps.api.canonical_address(owner)?;\n    let recipient = deps.api.canonical_address(recipient)?;\n    try_transfer_from_impl(deps, env, \u0026spender, \u0026owner, \u0026recipient, amount, memo)?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::TransferFrom { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_batch_transfer_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: \u0026Env,\n    actions: Vec\u003cbatch::TransferFromAction\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let spender = deps.api.canonical_address(\u0026env.message.sender)?;\n    for action in actions {\n        let owner = deps.api.canonical_address(\u0026action.owner)?;\n        let recipient = deps.api.canonical_address(\u0026action.recipient)?;\n        try_transfer_from_impl(\n            deps,\n            env,\n            \u0026spender,\n            \u0026owner,\n            \u0026recipient,\n            action.amount,\n            action.memo,\n        )?;\n    }\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::BatchTransferFrom {\n            status: Success,\n        })?),\n    };\n    Ok(res)\n}\n\n#[allow(clippy::too_many_arguments)]\nfn try_send_from_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    messages: \u0026mut Vec\u003cCosmosMsg\u003e,\n    spender_canon: \u0026CanonicalAddr, // redundant but more efficient\n    owner: HumanAddr,\n    recipient: HumanAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n    msg: Option\u003cBinary\u003e,\n) -\u003e StdResult\u003c()\u003e {\n    let owner_canon = deps.api.canonical_address(\u0026owner)?;\n    let recipient_canon = deps.api.canonical_address(\u0026recipient)?;\n    try_transfer_from_impl(\n        deps,\n        \u0026env,\n        \u0026spender_canon,\n        \u0026owner_canon,\n        \u0026recipient_canon,\n        amount,\n        memo.clone(),\n    )?;\n\n    try_add_receiver_api_callback(\n        \u0026deps.storage,\n        messages,\n        recipient,\n        msg,\n        env.message.sender,\n        owner,\n        amount,\n        memo,\n    )?;\n\n    Ok(())\n}\n\nfn try_send_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: HumanAddr,\n    recipient: HumanAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n    msg: Option\u003cBinary\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let spender = \u0026env.message.sender;\n    let spender_canon = deps.api.canonical_address(spender)?;\n\n    let mut messages = vec![];\n    try_send_from_impl(\n        deps,\n        env,\n        \u0026mut messages,\n        \u0026spender_canon,\n        owner,\n        recipient,\n        amount,\n        memo,\n        msg,\n    )?;\n\n    let res = HandleResponse {\n        messages,\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SendFrom { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_batch_send_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    actions: Vec\u003cbatch::SendFromAction\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let spender = \u0026env.message.sender;\n    let spender_canon = deps.api.canonical_address(spender)?;\n    let mut messages = vec![];\n\n    for action in actions {\n        try_send_from_impl(\n            deps,\n            env.clone(),\n            \u0026mut messages,\n            \u0026spender_canon,\n            action.owner,\n            action.recipient,\n            action.amount,\n            action.memo,\n            action.msg,\n        )?;\n    }\n\n    let res = HandleResponse {\n        messages,\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::BatchSendFrom { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_burn_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: \u0026Env,\n    owner: \u0026HumanAddr,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n    let constants = config.constants()?;\n    if !constants.burn_is_enabled {\n        return Err(StdError::generic_err(\n            \"Burn functionality is not enabled for this token.\",\n        ));\n    }\n\n    let spender = deps.api.canonical_address(\u0026env.message.sender)?;\n    let owner = deps.api.canonical_address(owner)?;\n    let raw_amount = amount.u128();\n    use_allowance(\u0026mut deps.storage, env, \u0026owner, \u0026spender, raw_amount)?;\n\n    // subtract from owner account\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let mut account_balance = balances.balance(\u0026owner);\n\n    if let Some(new_balance) = account_balance.checked_sub(raw_amount) {\n        account_balance = new_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to burn: balance={}, required={}\",\n            account_balance, raw_amount\n        )));\n    }\n    balances.set_account_balance(\u0026owner, account_balance);\n\n    // remove from supply\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_sub(raw_amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"You're trying to burn more than is available in the total supply\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    store_burn(\n        \u0026mut deps.storage,\n        \u0026owner,\n        \u0026spender,\n        amount,\n        constants.symbol,\n        memo,\n        \u0026env.block,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::BurnFrom { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_batch_burn_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: \u0026Env,\n    actions: Vec\u003cbatch::BurnFromAction\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n    let constants = config.constants()?;\n    if !constants.burn_is_enabled {\n        return Err(StdError::generic_err(\n            \"Burn functionality is not enabled for this token.\",\n        ));\n    }\n\n    let spender = deps.api.canonical_address(\u0026env.message.sender)?;\n\n    let mut total_supply = config.total_supply();\n\n    for action in actions {\n        let owner = deps.api.canonical_address(\u0026action.owner)?;\n        let amount = action.amount.u128();\n        use_allowance(\u0026mut deps.storage, env, \u0026owner, \u0026spender, amount)?;\n\n        // subtract from owner account\n        let mut balances = Balances::from_storage(\u0026mut deps.storage);\n        let mut account_balance = balances.balance(\u0026owner);\n\n        if let Some(new_balance) = account_balance.checked_sub(amount) {\n            account_balance = new_balance;\n        } else {\n            return Err(StdError::generic_err(format!(\n                \"insufficient funds to burn: balance={}, required={}\",\n                account_balance, amount\n            )));\n        }\n        balances.set_account_balance(\u0026owner, account_balance);\n\n        // remove from supply\n        if let Some(new_total_supply) = total_supply.checked_sub(amount) {\n            total_supply = new_total_supply;\n        } else {\n            return Err(StdError::generic_err(format!(\n                \"You're trying to burn more than is available in the total supply: {:?}\",\n                action\n            )));\n        }\n\n        store_burn(\n            \u0026mut deps.storage,\n            \u0026owner,\n            \u0026spender,\n            action.amount,\n            constants.symbol.clone(),\n            action.memo,\n            \u0026env.block,\n        )?;\n    }\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    config.set_total_supply(total_supply);\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::BatchBurnFrom { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_increase_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    spender: HumanAddr,\n    amount: Uint128,\n    expiration: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let owner_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n    allowance.amount = allowance.amount.saturating_add(amount.u128());\n    if expiration.is_some() {\n        allowance.expiration = expiration;\n    }\n    let new_amount = allowance.amount;\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::IncreaseAllowance {\n            owner: env.message.sender,\n            spender,\n            allowance: Uint128(new_amount),\n        })?),\n    };\n    Ok(res)\n}\n\nfn try_decrease_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    spender: HumanAddr,\n    amount: Uint128,\n    expiration: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let owner_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n    allowance.amount = allowance.amount.saturating_sub(amount.u128());\n    if expiration.is_some() {\n        allowance.expiration = expiration;\n    }\n    let new_amount = allowance.amount;\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::DecreaseAllowance {\n            owner: env.message.sender,\n            spender,\n            allowance: Uint128(new_amount),\n        })?),\n    };\n    Ok(res)\n}\n\nfn add_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_add: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.add_minters(minters_to_add)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::AddMinters { status: Success })?),\n    })\n}\n\nfn remove_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_remove: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.remove_minters(minters_to_remove)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::RemoveMinters { status: Success })?),\n    })\n}\n\nfn set_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_set: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.set_minters(minters_to_set)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetMinters { status: Success })?),\n    })\n}\n\n/// Burn tokens\n///\n/// Remove `amount` tokens from the system irreversibly, from signer account\n///\n/// @param amount the amount of money to burn\nfn try_burn\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n    memo: Option\u003cString\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n    let constants = config.constants()?;\n    if !constants.burn_is_enabled {\n        return Err(StdError::generic_err(\n            \"Burn functionality is not enabled for this token.\",\n        ));\n    }\n\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let raw_amount = amount.u128();\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let mut account_balance = balances.balance(\u0026sender_address);\n\n    if let Some(new_account_balance) = account_balance.checked_sub(raw_amount) {\n        account_balance = new_account_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to burn: balance={}, required={}\",\n            account_balance, raw_amount\n        )));\n    }\n\n    balances.set_account_balance(\u0026sender_address, account_balance);\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_sub(raw_amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"You're trying to burn more than is available in the total supply\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    store_burn(\n        \u0026mut deps.storage,\n        \u0026sender_address,\n        \u0026sender_address,\n        amount,\n        constants.symbol,\n        memo,\n        \u0026env.block,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Burn { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn perform_transfer\u003cT: Storage\u003e(\n    store: \u0026mut T,\n    from: \u0026CanonicalAddr,\n    to: \u0026CanonicalAddr,\n    amount: u128,\n) -\u003e StdResult\u003c()\u003e {\n    let mut balances = Balances::from_storage(store);\n\n    let mut from_balance = balances.balance(from);\n    if let Some(new_from_balance) = from_balance.checked_sub(amount) {\n        from_balance = new_from_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds: balance={}, required={}\",\n            from_balance, amount\n        )));\n    }\n    balances.set_account_balance(from, from_balance);\n\n    let mut to_balance = balances.balance(to);\n    to_balance = to_balance.checked_add(amount).ok_or_else(|| {\n        StdError::generic_err(\"This tx will literally make them too rich. Try transferring less\")\n    })?;\n    balances.set_account_balance(to, to_balance);\n\n    Ok(())\n}\n\nfn is_admin\u003cS: Storage\u003e(config: \u0026Config\u003cS\u003e, account: \u0026HumanAddr) -\u003e StdResult\u003cbool\u003e {\n    let consts = config.constants()?;\n    if \u0026consts.admin != account {\n        return Ok(false);\n    }\n\n    Ok(true)\n}\n\nfn check_if_admin\u003cS: Storage\u003e(config: \u0026Config\u003cS\u003e, account: \u0026HumanAddr) -\u003e StdResult\u003c()\u003e {\n    if !is_admin(config, account)? {\n        return Err(StdError::generic_err(\n            \"This is an admin command. Admin commands can only be run from admin address\",\n        ));\n    }\n\n    Ok(())\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let len = name.len();\n    (3..=30).contains(\u0026len)\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let len = symbol.len();\n    let len_is_valid = (3..=6).contains(\u0026len);\n\n    len_is_valid \u0026\u0026 symbol.bytes().all(|byte| (b'A'..=b'Z').contains(\u0026byte))\n}\n\n// pub fn migrate\u003cS: Storage, A: Api, Q: Querier\u003e(\n//     _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n//     _env: Env,\n//     _msg: MigrateMsg,\n// ) -\u003e StdResult\u003cMigrateResponse\u003e {\n//     Ok(MigrateResponse::default())\n// }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::msg::ResponseStatus;\n    use crate::msg::{InitConfig, InitialBalance};\n    use cosmwasm_std::testing::*;\n    use cosmwasm_std::{from_binary, BlockInfo, ContractInfo, MessageInfo, QueryResponse, WasmMsg};\n    use std::any::Any;\n\n    // Helper functions\n\n    fn init_helper(\n        initial_balances: Vec\u003cInitialBalance\u003e,\n    ) -\u003e (\n        StdResult\u003cInitResponse\u003e,\n        Extern\u003cMockStorage, MockApi, MockQuerier\u003e,\n    ) {\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n\n        let init_msg = InitMsg {\n            name: \"sec-sec\".to_string(),\n            admin: Some(HumanAddr(\"admin\".to_string())),\n            symbol: \"SECSEC\".to_string(),\n            decimals: 8,\n            initial_balances: Some(initial_balances),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: None,\n        };\n\n        (init(\u0026mut deps, env, init_msg), deps)\n    }\n\n    fn init_helper_with_config(\n        initial_balances: Vec\u003cInitialBalance\u003e,\n        enable_deposit: bool,\n        enable_redeem: bool,\n        enable_mint: bool,\n        enable_burn: bool,\n        contract_bal: u128,\n    ) -\u003e (\n        StdResult\u003cInitResponse\u003e,\n        Extern\u003cMockStorage, MockApi, MockQuerier\u003e,\n    ) {\n        let mut deps = mock_dependencies(\n            20,\n            \u0026[Coin {\n                denom: \"uscrt\".to_string(),\n                amount: Uint128(contract_bal),\n            }],\n        );\n\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":false,\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                enable_deposit, enable_redeem, enable_mint, enable_burn\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: \"sec-sec\".to_string(),\n            admin: Some(HumanAddr(\"admin\".to_string())),\n            symbol: \"SECSEC\".to_string(),\n            decimals: 8,\n            initial_balances: Some(initial_balances),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n\n        (init(\u0026mut deps, env, init_msg), deps)\n    }\n\n    /// Will return a ViewingKey only for the first account in `initial_balances`\n    fn _auth_query_helper(\n        initial_balances: Vec\u003cInitialBalance\u003e,\n    ) -\u003e (ViewingKey, Extern\u003cMockStorage, MockApi, MockQuerier\u003e) {\n        let (init_result, mut deps) = init_helper(initial_balances.clone());\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let account = initial_balances[0].address.clone();\n        let create_vk_msg = HandleMsg::CreateViewingKey {\n            entropy: \"42\".to_string(),\n            padding: None,\n        };\n        let handle_response = handle(\u0026mut deps, mock_env(account.0, \u0026[]), create_vk_msg).unwrap();\n        let vk = match from_binary(\u0026handle_response.data.unwrap()).unwrap() {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"Unexpected result from handle\"),\n        };\n\n        (vk, deps)\n    }\n\n    fn extract_error_msg\u003cT: Any\u003e(error: StdResult\u003cT\u003e) -\u003e String {\n        match error {\n            Ok(response) =\u003e {\n                let bin_err = (\u0026response as \u0026dyn Any)\n                    .downcast_ref::\u003cQueryResponse\u003e()\n                    .expect(\"An error was expected, but no error could be extracted\");\n                match from_binary(bin_err).unwrap() {\n                    QueryAnswer::ViewingKeyError { msg } =\u003e msg,\n                    _ =\u003e panic!(\"Unexpected query answer\"),\n                }\n            }\n            Err(err) =\u003e match err {\n                StdError::GenericErr { msg, .. } =\u003e msg,\n                _ =\u003e panic!(\"Unexpected result from init\"),\n            },\n        }\n    }\n\n    fn ensure_success(handle_result: HandleResponse) -\u003e bool {\n        let handle_result: HandleAnswer = from_binary(\u0026handle_result.data.unwrap()).unwrap();\n\n        match handle_result {\n            HandleAnswer::Deposit { status }\n            | HandleAnswer::Redeem { status }\n            | HandleAnswer::Transfer { status }\n            | HandleAnswer::Send { status }\n            | HandleAnswer::Burn { status }\n            | HandleAnswer::RegisterReceive { status }\n            | HandleAnswer::SetViewingKey { status }\n            | HandleAnswer::TransferFrom { status }\n            | HandleAnswer::SendFrom { status }\n            | HandleAnswer::BurnFrom { status }\n            | HandleAnswer::Mint { status }\n            | HandleAnswer::ChangeAdmin { status }\n            | HandleAnswer::SetContractStatus { status }\n            | HandleAnswer::SetMinters { status }\n            | HandleAnswer::AddMinters { status }\n            | HandleAnswer::RemoveMinters { status } =\u003e {\n                matches!(status, ResponseStatus::Success { .. })\n            }\n            _ =\u003e panic!(\n                \"HandleAnswer not supported for success extraction: {:?}\",\n                handle_result\n            ),\n        }\n    }\n\n    // Init tests\n\n    #[test]\n    fn test_init_sanity() {\n        let (init_result, deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert_eq!(init_result.unwrap(), InitResponse::default());\n\n        let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n        let constants = config.constants().unwrap();\n        assert_eq!(config.total_supply(), 5000);\n        assert_eq!(config.contract_status(), ContractStatusLevel::NormalRun);\n        assert_eq!(constants.name, \"sec-sec\".to_string());\n        assert_eq!(constants.admin, HumanAddr(\"admin\".to_string()));\n        assert_eq!(constants.symbol, \"SECSEC\".to_string());\n        assert_eq!(constants.decimals, 8);\n        assert_eq!(\n            constants.prng_seed,\n            sha_256(\"lolz fun yay\".to_owned().as_bytes())\n        );\n        assert_eq!(constants.total_supply_is_public, false);\n    }\n\n    #[test]\n    fn test_init_with_config_sanity() {\n        let (init_result, deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            true,\n            true,\n            true,\n            true,\n            0,\n        );\n        assert_eq!(init_result.unwrap(), InitResponse::default());\n\n        let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n        let constants = config.constants().unwrap();\n        assert_eq!(config.total_supply(), 5000);\n        assert_eq!(config.contract_status(), ContractStatusLevel::NormalRun);\n        assert_eq!(constants.name, \"sec-sec\".to_string());\n        assert_eq!(constants.admin, HumanAddr(\"admin\".to_string()));\n        assert_eq!(constants.symbol, \"SECSEC\".to_string());\n        assert_eq!(constants.decimals, 8);\n        assert_eq!(\n            constants.prng_seed,\n            sha_256(\"lolz fun yay\".to_owned().as_bytes())\n        );\n        assert_eq!(constants.total_supply_is_public, false);\n        assert_eq!(constants.deposit_is_enabled, true);\n        assert_eq!(constants.redeem_is_enabled, true);\n        assert_eq!(constants.mint_is_enabled, true);\n        assert_eq!(constants.burn_is_enabled, true);\n    }\n\n    #[test]\n    fn test_total_supply_overflow() {\n        let (init_result, _deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(u128::max_value()),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result, _deps) = init_helper(vec![\n            InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(u128::max_value()),\n            },\n            InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: Uint128(1),\n            },\n        ]);\n        let error = extract_error_msg(init_result);\n        assert_eq!(\n            error,\n            \"The sum of all initial balances exceeds the maximum possible total supply\"\n        );\n    }\n\n    // Handle tests\n\n    #[test]\n    fn test_handle_transfer() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1000),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n        let balances = ReadonlyBalances::from_storage(\u0026deps.storage);\n        assert_eq!(5000 - 1000, balances.account_amount(\u0026bob_canonical));\n        assert_eq!(1000, balances.account_amount(\u0026alice_canonical));\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(10000),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient funds\"));\n    }\n\n    #[test]\n    fn test_handle_send() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let handle_msg = HandleMsg::Send {\n            recipient: HumanAddr(\"contract\".to_string()),\n            amount: Uint128(100),\n            memo: Some(\"my memo\".to_string()),\n            padding: None,\n            msg: Some(to_binary(\"hey hey you you\").unwrap()),\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result.clone()));\n        assert!(result.messages.contains(\u0026CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: HumanAddr(\"contract\".to_string()),\n            callback_code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            msg: Snip20ReceiveMsg::new(\n                HumanAddr(\"bob\".to_string()),\n                HumanAddr(\"bob\".to_string()),\n                Uint128(100),\n                Some(\"my memo\".to_string()),\n                Some(to_binary(\"hey hey you you\").unwrap())\n            )\n            .into_binary()\n            .unwrap(),\n            send: vec![]\n        })));\n    }\n\n    #[test]\n    fn test_handle_register_receive() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let hash = get_receiver_hash(\u0026deps.storage, \u0026HumanAddr(\"contract\".to_string()))\n            .unwrap()\n            .unwrap();\n        assert_eq!(hash, \"this_is_a_hash_of_a_code\".to_string());\n    }\n\n    #[test]\n    fn test_handle_create_viewing_key() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::CreateViewingKey {\n            entropy: \"\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let answer: HandleAnswer = from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n\n        let key = match answer {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"NOPE\"),\n        };\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let saved_vk = read_viewing_key(\u0026deps.storage, \u0026bob_canonical).unwrap();\n        assert!(key.check_viewing_key(saved_vk.as_slice()));\n    }\n\n    #[test]\n    fn test_handle_set_viewing_key() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Set VK\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"hi lol\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        // Set valid VK\n        let actual_vk = ViewingKey(\"x\".to_string().repeat(VIEWING_KEY_SIZE));\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: actual_vk.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey { status: Success }).unwrap(),\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let saved_vk = read_viewing_key(\u0026deps.storage, \u0026bob_canonical).unwrap();\n        assert!(actual_vk.check_viewing_key(\u0026saved_vk));\n    }\n\n    #[test]\n    fn test_handle_transfer_from() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Transfer before allowance\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Transfer more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: Some(1_571_797_420),\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Transfer after allowance expired\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\n            \u0026mut deps,\n            Env {\n                block: BlockInfo {\n                    height: 12_345,\n                    time: 1_571_797_420,\n                    chain_id: \"cosmos-testnet-14002\".to_string(),\n                },\n                message: MessageInfo {\n                    sender: HumanAddr(\"bob\".to_string()),\n                    sent_funds: vec![],\n                },\n                contract: ContractInfo {\n                    address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n                },\n                contract_key: Some(\"\".to_string()),\n                contract_code_hash: \"\".to_string(),\n            },\n            handle_msg,\n        );\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        let alice_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026alice_canonical);\n        assert_eq!(bob_balance, 5000 - 2000);\n        assert_eq!(alice_balance, 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 5000);\n\n        // Second send more than allowance\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_send_from() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Send before allowance\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            memo: None,\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Send more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            memo: None,\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"lolz\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let send_msg = Binary::from(r#\"{ \"some_msg\": { \"some_key\": \"some_val\" } }\"#.as_bytes());\n        let snip20_msg = Snip20ReceiveMsg::new(\n            HumanAddr(\"alice\".to_string()),\n            HumanAddr(\"bob\".to_string()),\n            Uint128(2000),\n            Some(\"my memo\".to_string()),\n            Some(send_msg.clone()),\n        );\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"contract\".to_string()),\n            amount: Uint128(2000),\n            memo: Some(\"my memo\".to_string()),\n            msg: Some(send_msg),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        assert!(handle_result.unwrap().messages.contains(\n            \u0026snip20_msg\n                .into_cosmos_msg(\"lolz\".to_string(), HumanAddr(\"contract\".to_string()))\n                .unwrap()\n        ));\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let contract_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"contract\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        let contract_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026contract_canonical);\n        assert_eq!(bob_balance, 5000 - 2000);\n        assert_eq!(contract_balance, 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 5000);\n\n        // Second send more than allowance\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1),\n            memo: None,\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_burn_from() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(10000),\n            }],\n            false,\n            false,\n            false,\n            true,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(10000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when burn disabled\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Burn functionality is not enabled for this token.\"));\n\n        // Burn before allowance\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Burn more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2000),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        assert_eq!(bob_balance, 10000 - 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 10000 - 2000);\n\n        // Second burn more than allowance\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(1),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_batch_burn_from() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![\n                InitialBalance {\n                    address: HumanAddr(\"bob\".to_string()),\n                    amount: Uint128(10000),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"jerry\".to_string()),\n                    amount: Uint128(10000),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"mike\".to_string()),\n                    amount: Uint128(10000),\n                },\n            ],\n            false,\n            false,\n            false,\n            true,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(10000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when burn disabled\n        let actions: Vec\u003c_\u003e = [\"bob\", \"jerry\", \"mike\"]\n            .iter()\n            .map(|name| batch::BurnFromAction {\n                owner: HumanAddr(name.to_string()),\n                amount: Uint128(2500),\n                memo: None,\n            })\n            .collect();\n        let handle_msg = HandleMsg::BatchBurnFrom {\n            actions,\n            padding: None,\n        };\n        let handle_result = handle(\n            \u0026mut deps_for_failure,\n            mock_env(\"alice\", \u0026[]),\n            handle_msg.clone(),\n        );\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Burn functionality is not enabled for this token.\"));\n\n        // Burn before allowance\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Burn more than allowance\n        let allowance_size = 2000;\n        for name in \u0026[\"bob\", \"jerry\", \"mike\"] {\n            let handle_msg = HandleMsg::IncreaseAllowance {\n                spender: HumanAddr(\"alice\".to_string()),\n                amount: Uint128(allowance_size),\n                padding: None,\n                expiration: None,\n            };\n            let handle_result = handle(\u0026mut deps, mock_env(*name, \u0026[]), handle_msg);\n            assert!(\n                handle_result.is_ok(),\n                \"handle() failed: {}\",\n                handle_result.err().unwrap()\n            );\n            let handle_msg = HandleMsg::BurnFrom {\n                owner: HumanAddr(name.to_string()),\n                amount: Uint128(2500),\n                memo: None,\n                padding: None,\n            };\n            let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n            let error = extract_error_msg(handle_result);\n            assert!(error.contains(\"insufficient allowance\"));\n        }\n\n        // Burn some of the allowance\n        let actions: Vec\u003c_\u003e = [(\"bob\", 200_u128), (\"jerry\", 300), (\"mike\", 400)]\n            .iter()\n            .map(|(name, amount)| batch::BurnFromAction {\n                owner: HumanAddr(name.to_string()),\n                amount: Uint128(*amount),\n                memo: None,\n            })\n            .collect();\n\n        let handle_msg = HandleMsg::BatchBurnFrom {\n            actions,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        for (name, amount) in \u0026[(\"bob\", 200_u128), (\"jerry\", 300), (\"mike\", 400)] {\n            let name_canon = deps\n                .api\n                .canonical_address(\u0026HumanAddr(name.to_string()))\n                .unwrap();\n            let balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n                .account_amount(\u0026name_canon);\n            assert_eq!(balance, 10000 - amount);\n        }\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 10000 * 3 - (200 + 300 + 400));\n\n        // Burn the rest of the allowance\n        let actions: Vec\u003c_\u003e = [(\"bob\", 200_u128), (\"jerry\", 300), (\"mike\", 400)]\n            .iter()\n            .map(|(name, amount)| batch::BurnFromAction {\n                owner: HumanAddr(name.to_string()),\n                amount: Uint128(allowance_size - *amount),\n                memo: None,\n            })\n            .collect();\n\n        let handle_msg = HandleMsg::BatchBurnFrom {\n            actions,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        for name in \u0026[\"bob\", \"jerry\", \"mike\"] {\n            let name_canon = deps\n                .api\n                .canonical_address(\u0026HumanAddr(name.to_string()))\n                .unwrap();\n            let balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n                .account_amount(\u0026name_canon);\n            assert_eq!(balance, 10000 - allowance_size);\n        }\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 3 * (10000 - allowance_size));\n\n        // Second burn more than allowance\n        let actions: Vec\u003c_\u003e = [\"bob\", \"jerry\", \"mike\"]\n            .iter()\n            .map(|name| batch::BurnFromAction {\n                owner: HumanAddr(name.to_string()),\n                amount: Uint128(1),\n                memo: None,\n            })\n            .collect();\n        let handle_msg = HandleMsg::BatchBurnFrom {\n            actions,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_decrease_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::DecreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 0,\n                expiration: None\n            }\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::DecreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(50),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 1950,\n                expiration: None\n            }\n        );\n    }\n\n    #[test]\n    fn test_handle_increase_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 2000,\n                expiration: None\n            }\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 4000,\n                expiration: None\n            }\n        );\n    }\n\n    #[test]\n    fn test_handle_change_admin() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::ChangeAdmin {\n            address: HumanAddr(\"bob\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let admin = ReadonlyConfig::from_storage(\u0026deps.storage)\n            .constants()\n            .unwrap()\n            .admin;\n        assert_eq!(admin, HumanAddr(\"bob\".to_string()));\n    }\n\n    #[test]\n    fn test_handle_set_contract_status() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"admin\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAll,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let contract_status = ReadonlyConfig::from_storage(\u0026deps.storage).contract_status();\n        assert!(matches!(\n            contract_status,\n            ContractStatusLevel::StopAll { .. }\n        ));\n    }\n\n    #[test]\n    fn test_handle_redeem() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"butler\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            true,\n            false,\n            false,\n            1000,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_no_reserve, mut deps_no_reserve) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"butler\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            true,\n            false,\n            false,\n            0,\n        );\n        assert!(\n            init_result_no_reserve.is_ok(),\n            \"Init failed: {}\",\n            init_result_no_reserve.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"butler\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when redeem disabled\n        let handle_msg = HandleMsg::Redeem {\n            amount: Uint128(1000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"butler\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Redeem functionality is not enabled for this token.\"));\n\n        // try to redeem when contract has 0 balance\n        let handle_msg = HandleMsg::Redeem {\n            amount: Uint128(1000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_no_reserve, mock_env(\"butler\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\n            \"You are trying to redeem for more SCRT than the token has in its deposit reserve.\"\n        ));\n\n        let handle_msg = HandleMsg::Redeem {\n            amount: Uint128(1000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"butler\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let balances = ReadonlyBalances::from_storage(\u0026deps.storage);\n        let canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"butler\".to_string()))\n            .unwrap();\n        assert_eq!(balances.account_amount(\u0026canonical), 4000)\n    }\n\n    #[test]\n    fn test_handle_deposit() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            true,\n            false,\n            false,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when deposit disabled\n        let handle_msg = HandleMsg::Deposit { padding: None };\n        let handle_result = handle(\n            \u0026mut deps_for_failure,\n            mock_env(\n                \"lebron\",\n                \u0026[Coin {\n                    denom: \"uscrt\".to_string(),\n                    amount: Uint128(1000),\n                }],\n            ),\n            handle_msg,\n        );\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Deposit functionality is not enabled for this token.\"));\n\n        let handle_msg = HandleMsg::Deposit { padding: None };\n        let handle_result = handle(\n            \u0026mut deps,\n            mock_env(\n                \"lebron\",\n                \u0026[Coin {\n                    denom: \"uscrt\".to_string(),\n                    amount: Uint128(1000),\n                }],\n            ),\n            handle_msg,\n        );\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let balances = ReadonlyBalances::from_storage(\u0026deps.storage);\n        let canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"lebron\".to_string()))\n            .unwrap();\n        assert_eq!(balances.account_amount(\u0026canonical), 6000)\n    }\n\n    #[test]\n    fn test_handle_burn() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            false,\n            true,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when burn disabled\n        let handle_msg = HandleMsg::Burn {\n            amount: Uint128(100),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"lebron\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Burn functionality is not enabled for this token.\"));\n\n        let supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        let burn_amount: u128 = 100;\n        let handle_msg = HandleMsg::Burn {\n            amount: Uint128(burn_amount),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let new_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(new_supply, supply - burn_amount);\n    }\n\n    #[test]\n    fn test_handle_mint() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try to mint when mint is disabled\n        let mint_amount: u128 = 100;\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(mint_amount),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        let mint_amount: u128 = 100;\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(mint_amount),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let new_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(new_supply, supply + mint_amount);\n    }\n\n    #[test]\n    fn test_handle_admin_commands() {\n        let admin_err = \"Admin commands can only be run from admin address\".to_string();\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAllButRedeems,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), pause_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"not_admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"not_admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let change_admin_msg = HandleMsg::ChangeAdmin {\n            address: HumanAddr(\"not_admin\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), change_admin_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n    }\n\n    #[test]\n    fn test_handle_pause_with_withdrawals() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            true,\n            false,\n            false,\n            5000,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAllButRedeems,\n            padding: None,\n        };\n\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), pause_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let send_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"account\".to_string()),\n            amount: Uint128(123),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), send_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n\n        let withdraw_msg = HandleMsg::Redeem {\n            amount: Uint128(5000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), withdraw_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Withdraw failed: {}\",\n            handle_result.err().unwrap()\n        );\n    }\n\n    #[test]\n    fn test_handle_pause_all() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAll,\n            padding: None,\n        };\n\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), pause_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let send_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"account\".to_string()),\n            amount: Uint128(123),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), send_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n\n        let withdraw_msg = HandleMsg::Redeem {\n            amount: Uint128(5000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), withdraw_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_handle_set_minters() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try when mint disabled\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n    }\n\n    #[test]\n    fn test_handle_add_minters() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try when mint disabled\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n    }\n\n    #[test]\n    fn test_handle_remove_minters() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try when mint disabled\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        // Removing another extra time to ensure nothing funky happens\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n    }\n\n    // Query tests\n\n    #[test]\n    fn test_authenticated_queries() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"giannis\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let no_vk_yet_query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: \"no_vk_yet\".to_string(),\n        };\n        let query_result = query(\u0026deps, no_vk_yet_query_msg);\n        let error = extract_error_msg(query_result);\n        assert_eq!(\n            error,\n            \"Wrong viewing key for this address or viewing key not set\".to_string()\n        );\n\n        let create_vk_msg = HandleMsg::CreateViewingKey {\n            entropy: \"34\".to_string(),\n            padding: None,\n        };\n        let handle_response = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), create_vk_msg).unwrap();\n        let vk = match from_binary(\u0026handle_response.data.unwrap()).unwrap() {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"Unexpected result from handle\"),\n        };\n\n        let query_balance_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: vk.0,\n        };\n\n        let query_response = query(\u0026deps, query_balance_msg).unwrap();\n        let balance = match from_binary(\u0026query_response).unwrap() {\n            QueryAnswer::Balance { amount } =\u003e amount,\n            _ =\u003e panic!(\"Unexpected result from query\"),\n        };\n        assert_eq!(balance, Uint128(5000));\n\n        let wrong_vk_query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: \"wrong_vk\".to_string(),\n        };\n        let query_result = query(\u0026deps, wrong_vk_query_msg);\n        let error = extract_error_msg(query_result);\n        assert_eq!(\n            error,\n            \"Wrong viewing key for this address or viewing key not set\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_query_token_info() {\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 8;\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            r#\"{ \"public_total_supply\": true }\"#.as_bytes(),\n        ))\n        .unwrap();\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::TokenInfo {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::TokenInfo {\n                name,\n                symbol,\n                decimals,\n                total_supply,\n            } =\u003e {\n                assert_eq!(name, init_name);\n                assert_eq!(symbol, init_symbol);\n                assert_eq!(decimals, init_decimals);\n                assert_eq!(total_supply, Some(Uint128(5000)));\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n    }\n\n    #[test]\n    fn test_query_token_config() {\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 8;\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, false, false, true, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::TokenConfig {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::TokenConfig {\n                public_total_supply,\n                deposit_enabled,\n                redeem_enabled,\n                mint_enabled,\n                burn_enabled,\n            } =\u003e {\n                assert_eq!(public_total_supply, true);\n                assert_eq!(deposit_enabled, false);\n                assert_eq!(redeem_enabled, false);\n                assert_eq!(mint_enabled, true);\n                assert_eq!(burn_enabled, false);\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n    }\n\n    #[test]\n    fn test_query_exchange_rate() {\n        // test more dec than SCRT\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 8;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, true, false, false, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(100));\n                assert_eq!(denom, \"SCRT\");\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n\n        // test same number of decimals as SCRT\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 6;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, true, false, false, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(1));\n                assert_eq!(denom, \"SCRT\");\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n\n        // test less decimal places than SCRT\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 3;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, true, false, false, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(1000));\n                assert_eq!(denom, \"SECSEC\");\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n\n        // test depost/redeem not enabled\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 3;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: None,\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(0));\n                assert_eq!(denom, String::new());\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n    }\n\n    #[test]\n    fn test_query_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"giannis\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let vk1 = ViewingKey(\"key1\".to_string());\n        let vk2 = ViewingKey(\"key2\".to_string());\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk1.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Query failed: {}\",\n            query_result.err().unwrap()\n        );\n        let error = extract_error_msg(query_result);\n        assert!(error.contains(\"Wrong viewing key\"));\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: vk1.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: vk2.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk1.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(2000));\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk2.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(2000));\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"lebron\".to_string()),\n            spender: HumanAddr(\"giannis\".to_string()),\n            key: vk2.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(0));\n    }\n\n    #[test]\n    fn test_query_balance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"key\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"wrong_key\".to_string(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let error = extract_error_msg(query_result);\n        assert!(error.contains(\"Wrong viewing key\"));\n\n        let query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let balance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Balance { amount } =\u003e amount,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(balance, Uint128(5000));\n    }\n\n    #[test]\n    fn test_query_transfer_history() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"key\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1000),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"banana\".to_string()),\n            amount: Uint128(500),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"mango\".to_string()),\n            amount: Uint128(2500),\n            memo: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 0,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        // let a: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        // println!(\"{:?}\", a);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, .. } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert!(transfers.is_empty());\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 10,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, .. } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(transfers.len(), 3);\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 2,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, .. } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(transfers.len(), 2);\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: Some(1),\n            page_size: 2,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, .. } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(transfers.len(), 1);\n    }\n\n    #[test]\n    fn test_query_transaction_history() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(10000),\n            }],\n            true,\n            true,\n            true,\n            true,\n            1000,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"key\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Burn {\n            amount: Uint128(1),\n            memo: Some(\"my burn message\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::Redeem {\n            amount: Uint128(1000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            memo: Some(\"my mint message\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Deposit { padding: None };\n        let handle_result = handle(\n            \u0026mut deps,\n            mock_env(\n                \"bob\",\n                \u0026[Coin {\n                    denom: \"uscrt\".to_string(),\n                    amount: Uint128(1000),\n                }],\n            ),\n            handle_msg,\n        );\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1000),\n            memo: Some(\"my transfer message #1\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"banana\".to_string()),\n            amount: Uint128(500),\n            memo: Some(\"my transfer message #2\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"mango\".to_string()),\n            amount: Uint128(2500),\n            memo: Some(\"my transfer message #3\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 10,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, .. } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(transfers.len(), 3);\n\n        let query_msg = QueryMsg::TransactionHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 10,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransactionHistory { txs, .. } =\u003e txs,\n            other =\u003e panic!(\"Unexpected: {:?}\", other),\n        };\n\n        use crate::transaction_history::{RichTx, TxAction};\n        let expected_transfers = [\n            RichTx {\n                id: 8,\n                action: TxAction::Transfer {\n                    from: HumanAddr(\"bob\".to_string()),\n                    sender: HumanAddr(\"bob\".to_string()),\n                    recipient: HumanAddr(\"mango\".to_string()),\n                },\n                coins: Coin {\n                    denom: \"SECSEC\".to_string(),\n                    amount: Uint128(2500),\n                },\n                memo: Some(\"my transfer message #3\".to_string()),\n                block_time: 1571797419,\n                block_height: 12345,\n            },\n            RichTx {\n                id: 7,\n                action: TxAction::Transfer {\n                    from: HumanAddr(\"bob\".to_string()),\n                    sender: HumanAddr(\"bob\".to_string()),\n                    recipient: HumanAddr(\"banana\".to_string()),\n                },\n                coins: Coin {\n                    denom: \"SECSEC\".to_string(),\n                    amount: Uint128(500),\n                },\n                memo: Some(\"my transfer message #2\".to_string()),\n                block_time: 1571797419,\n                block_height: 12345,\n            },\n            RichTx {\n                id: 6,\n                action: TxAction::Transfer {\n                    from: HumanAddr(\"bob\".to_string()),\n                    sender: HumanAddr(\"bob\".to_string()),\n                    recipient: HumanAddr(\"alice\".to_string()),\n                },\n                coins: Coin {\n                    denom: \"SECSEC\".to_string(),\n                    amount: Uint128(1000),\n                },\n                memo: Some(\"my transfer message #1\".to_string()),\n                block_time: 1571797419,\n                block_height: 12345,\n            },\n            RichTx {\n                id: 5,\n                action: TxAction::Deposit {},\n                coins: Coin {\n                    denom: \"uscrt\".to_string(),\n                    amount: Uint128(1000),\n                },\n                memo: None,\n                block_time: 1571797419,\n                block_height: 12345,\n            },\n            RichTx {\n                id: 4,\n                action: TxAction::Mint {\n                    minter: HumanAddr(\"admin\".to_string()),\n                    recipient: HumanAddr(\"bob\".to_string()),\n                },\n                coins: Coin {\n                    denom: \"SECSEC\".to_string(),\n                    amount: Uint128(100),\n                },\n                memo: Some(\"my mint message\".to_string()),\n                block_time: 1571797419,\n                block_height: 12345,\n            },\n            RichTx {\n                id: 3,\n                action: TxAction::Redeem {},\n                coins: Coin {\n                    denom: \"SECSEC\".to_string(),\n                    amount: Uint128(1000),\n                },\n                memo: None,\n                block_time: 1571797419,\n                block_height: 12345,\n            },\n            RichTx {\n                id: 2,\n                action: TxAction::Burn {\n                    burner: HumanAddr(\"bob\".to_string()),\n                    owner: HumanAddr(\"bob\".to_string()),\n                },\n                coins: Coin {\n                    denom: \"SECSEC\".to_string(),\n                    amount: Uint128(1),\n                },\n                memo: Some(\"my burn message\".to_string()),\n                block_time: 1571797419,\n                block_height: 12345,\n            },\n            RichTx {\n                id: 1,\n                action: TxAction::Mint {\n                    minter: HumanAddr(\"admin\".to_string()),\n                    recipient: HumanAddr(\"bob\".to_string()),\n                },\n                coins: Coin {\n                    denom: \"SECSEC\".to_string(),\n                    amount: Uint128(10000),\n                },\n\n                memo: Some(\"Initial Balance\".to_string()),\n                block_time: 1571797419,\n                block_height: 12345,\n            },\n        ];\n\n        assert_eq!(transfers, expected_transfers);\n    }\n}\n","traces":[{"line":28,"address":[3676400,3681392],"length":1,"stats":{"Line":1},"fn_name":"init\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":34,"address":[3676472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[3676652,3676732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[3676790,3676691],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[3676821,3676876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[3676860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[3676980,3676918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[3676957,3677043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[3677094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[3682305,3677205,3677433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[3677351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[3677375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[3677682,3677873,3679434],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[3682267,3678091,3678264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[3678531,3678226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[3678555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[3678588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[3678605,3678759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[3678791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[3678869,3678712],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[3678812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[3678911,3678838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[3678919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[3679447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[3679519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[3680080,3680317,3679792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[3679534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[3679565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[3679597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[3679620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[3679627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[3679667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[3679688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[3679709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[3679730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[3679751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[3680342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[3680373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[3680412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[3680435,3682601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[3682606,3680541],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[3680551,3682218,3680679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[3680669,3680936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[3683424],"length":1,"stats":{"Line":1},"fn_name":"pad_response"},{"line":107,"address":[3683438,3683600,3683709],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":108,"address":[3683572,3683618,3683488],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":109,"address":[3683512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[3683534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[3683689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[3683776,3690304],"length":1,"stats":{"Line":1},"fn_name":"handle\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":121,"address":[3690272,3683840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[3684496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3684436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[3684594,3684506,3695017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[3684699,3684774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[3684711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[3695022,3684814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[3684544,3684902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[3684952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[3685280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[3684461,3685290,3695032],"length":1,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[3695037,3685378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[3685554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[3685816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[3686186,3695052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[3686346,3695057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3686506,3695062],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3695067,3686722],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[3695072,3686882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[3695077,3687042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[3695082,3687314],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[3687556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[3687862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[3688096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[3688480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[3688512,3695097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[3688586,3695102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[3688836,3690220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[3688951,3695107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[3689089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[3689333,3695117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[3695122,3689487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[3695127,3689641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[3689742,3695132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[3695137,3689896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[3685136,3695027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[3690042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[3696096,3696607],"length":1,"stats":{"Line":1},"fn_name":"query\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":229,"address":[3696278,3696731,3696123],"length":1,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[3696298,3696733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[3696735,3696318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[3696338,3696737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[3696739,3696358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[3696594,3696383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[3696447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[3696465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[3696511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[3696729,3696183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[3696848,3699617],"length":1,"stats":{"Line":1},"fn_name":"authenticated_queries\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":247,"address":[3696892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[3697295,3698762,3697091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[3697329,3700119,3697498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[3697748,3697464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[3697764,3698027,3697884],"length":1,"stats":{"Line":3},"fn_name":null},{"line":257,"address":[3697787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[3697889,3699553,3697814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[3697989,3699534,3698075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[3698162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[3698194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[3698244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[3698276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[3698296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[3699496,3698310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[3698399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[3698431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[3698451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[3699477,3698465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[3700464,3698559],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[3698032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3698794,3699019,3699245,3698906],"length":1,"stats":{"Line":2},"fn_name":null},{"line":285,"address":[3698767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[3700976],"length":1,"stats":{"Line":0},"fn_name":"query_get_user_index\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":293,"address":[3701075,3701020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[3701030,3701082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[3701183,3701050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[3701232],"length":1,"stats":{"Line":0},"fn_name":"query_get_interested_redirection_address\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":307,"address":[3701343,3701444,3701276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[3701350,3701286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[3701306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3701451,3701311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[3701504],"length":1,"stats":{"Line":0},"fn_name":"query_get_redirected_balance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":320,"address":[3701548,3701603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[3701558,3701610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[3701711,3701578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[3701760],"length":1,"stats":{"Line":0},"fn_name":"query_principal_balance_of\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":333,"address":[3701781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[3701808,3703158],"length":1,"stats":{"Line":1},"fn_name":"query_exchange_rate\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":337,"address":[3701833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[3703378,3701991,3701864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[3702241,3701972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[3702277,3702563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[3702331,3703430,3702407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[3702488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[3702359,3702581,3703484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[3702660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[3702769,3703130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[3702911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[3702289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[3702321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[3704553,3703696],"length":1,"stats":{"Line":1},"fn_name":"query_token_info\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":361,"address":[3703721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[3704633,3703863,3703744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[3704163,3703844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[3704175,3704128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[3704151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[3704327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[3704240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[3704266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[3704295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[3704303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[3705581,3704816],"length":1,"stats":{"Line":1},"fn_name":"query_token_config\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":379,"address":[3704840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[3704863,3705230,3705596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[3705165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[3705126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[3705134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":385,"address":[3705142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[3705150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[3705158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[3705728,3705878],"length":1,"stats":{"Line":0},"fn_name":"query_contract_status\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":392,"address":[3705753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[3705790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[3705768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[3706930,3705968],"length":1,"stats":{"Line":1},"fn_name":"query_transfers\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":405,"address":[3706180,3706029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[3706297,3706972,3706599,3706153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":410,"address":[3706489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[3706589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[3708034,3707072],"length":1,"stats":{"Line":1},"fn_name":"query_transactions\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":421,"address":[3707133,3707284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[3707401,3708076,3707703,3707257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[3707593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[3707693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[3708176,3708652],"length":1,"stats":{"Line":1},"fn_name":"query_balance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":435,"address":[3708214,3708336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[3708450,3708628,3708329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[3708519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[3708567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[3708951,3708736],"length":1,"stats":{"Line":0},"fn_name":"query_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":443,"address":[3708941,3708760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[3708819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[3708889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[3709072,3711251],"length":1,"stats":{"Line":1},"fn_name":"change_admin\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":454,"address":[3709109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[3709142,3711424,3709230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[3709480,3709788,3709220,3711419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[3711266,3709735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[3711369,3710099,3711414,3710050],"length":1,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[3710543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[3710089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[3710366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[3710373,3710724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[3712965,3711840],"length":1,"stats":{"Line":1},"fn_name":"try_mint_impl\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":478,"address":[3711958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[3712076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[3712096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[3712161,3712304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[3712336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[3712268,3712388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[3712352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[3713015,3712447,3712648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[3712623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[3716810,3713168],"length":1,"stats":{"Line":1},"fn_name":"try_mint\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":510,"address":[3713258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[3713313,3713446,3717222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[3713424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[3713757,3713695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[3713742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[3713799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[3713887,3713957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":525,"address":[3713926,3714009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[3714228,3714025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[3714260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[3714197,3714315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[3714276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[3714562,3717128,3714373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[3715109,3714536,3717123,3714827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":539,"address":[3714958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[3714966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[3714974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[3714990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[3715030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[3715413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[3715680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[3716125,3715687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[3715956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[3722373,3717808],"length":1,"stats":{"Line":0},"fn_name":"try_batch_mint\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":561,"address":[3717872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[3718060,3722620,3717935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[3718038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[3718309,3718371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[3718356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[3718413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[3718513,3718589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[3718655,3718552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[3718831,3718671,3719163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[3719115,3718865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[3719147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[3719292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[3719061,3719178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[3718797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[3719600,3722615,3719385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[3722404,3719849,3719543,3719985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[3720275,3722534,3720524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[3720442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[3720455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[3720468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[3720494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[3720806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[3721256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[3721271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[3721716,3721278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[3721547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[3724485,3723136],"length":1,"stats":{"Line":1},"fn_name":"try_set_key\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":618,"address":[3723170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[3724502,3723357,3723207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":[3723347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":623,"address":[3723813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[3723621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":625,"address":[3723636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[3723995,3723643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":630,"address":[3724784,3727186],"length":1,"stats":{"Line":1},"fn_name":"try_create_key\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":635,"address":[3727658,3727151,3724827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":636,"address":[3725419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[3725459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[3725754,3725592,3727572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[3725744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":643,"address":[3726286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[3726021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[3726036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[3726043,3726471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[3728240,3729437],"length":1,"stats":{"Line":1},"fn_name":"set_contract_status\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":655,"address":[3728288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":657,"address":[3728386,3729454,3728299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":659,"address":[3728368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":661,"address":[3728830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":662,"address":[3728638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":663,"address":[3728653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":664,"address":[3728734,3729008,3728660,3729242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":670,"address":[3731308,3729680],"length":1,"stats":{"Line":1},"fn_name":"query_allowance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":675,"address":[3731327,3729897,3729720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[3729871,3730154,3731325,3730278],"length":1,"stats":{"Line":2},"fn_name":null},{"line":678,"address":[3730544,3730268,3731323,3730898],"length":1,"stats":{"Line":2},"fn_name":null},{"line":683,"address":[3730712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[3730744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[3730888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[3735218,3731584],"length":1,"stats":{"Line":1},"fn_name":"try_deposit\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":693,"address":[3731631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[3731983,3731704,3731873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":696,"address":[3731915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[3731959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":699,"address":[3731988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[3731842,3732076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":706,"address":[3732082,3732162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[3732113,3732228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":711,"address":[3732252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[3735239,3732275,3732400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":713,"address":[3732378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":714,"address":[3732649,3732722],"length":1,"stats":{"Line":2},"fn_name":null},{"line":718,"address":[3732793,3732688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":719,"address":[3732931,3732809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":720,"address":[3732971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":722,"address":[3733029,3732900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[3732994,3733087,3733201,3735237],"length":1,"stats":{"Line":2},"fn_name":null},{"line":729,"address":[3733191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[3733466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[3733653,3733531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":732,"address":[3733701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":734,"address":[3733622,3733782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[3733721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":743,"address":[3733747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[3733939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[3734206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[3734647,3734213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":753,"address":[3734482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":756,"address":[3740414,3735568],"length":1,"stats":{"Line":1},"fn_name":"try_redeem\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":761,"address":[3735640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[3741326,3735852,3735719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":763,"address":[3735830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[3736101,3736183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":769,"address":[3736373,3736148,3736241,3741235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":770,"address":[3736646,3736329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":772,"address":[3736670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":773,"address":[3736693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":775,"address":[3737007,3736754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":776,"address":[3737055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[3737116,3736909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[3737078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[3737385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[3737572,3737434],"length":1,"stats":{"Line":2},"fn_name":null},{"line":787,"address":[3737612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":789,"address":[3737679,3737541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[3737764,3737635,3737914,3738151,3737737,3737643],"length":1,"stats":{"Line":4},"fn_name":null},{"line":796,"address":[3737916,3737639,3737744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":797,"address":[3741230,3737892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":798,"address":[3738163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":799,"address":[3738298,3738206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":804,"address":[3738247,3738356,3741211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":805,"address":[3738263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":806,"address":[3738340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":812,"address":[3738503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":813,"address":[3738519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[3738781,3738656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":823,"address":[3739344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[3739351,3739793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":827,"address":[3739620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[3742224,3743898],"length":1,"stats":{"Line":1},"fn_name":"try_transfer_impl\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":838,"address":[3742306,3742500,3744075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":840,"address":[3742762,3742490,3744070,3743921,3743862],"length":1,"stats":{"Line":3},"fn_name":null},{"line":844,"address":[3743372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":846,"address":[3743377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":847,"address":[3743382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":848,"address":[3743398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[3743438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":853,"address":[3743573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":856,"address":[3744336,3746570],"length":1,"stats":{"Line":1},"fn_name":"try_transfer\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":863,"address":[3744415,3746610,3744583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":864,"address":[3744557,3745038,3746608,3744842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":865,"address":[3746606,3744958,3745300,3745349],"length":1,"stats":{"Line":2},"fn_name":null},{"line":868,"address":[3745339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":869,"address":[3745603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":870,"address":[3745610,3746045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":872,"address":[3745876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":875,"address":[3749680,3746960],"length":1,"stats":{"Line":0},"fn_name":"try_batch_transfer\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":880,"address":[3747000,3747207,3749919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[3747447,3747150,3747583,3749711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[3748123,3749838,3747870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[3748018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[3748034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[3748731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[3748746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[3748753,3749185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[3749019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[3752586,3750320],"length":1,"stats":{"Line":1},"fn_name":"try_add_receiver_api_callback\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":912,"address":[3750433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":913,"address":[3750557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":914,"address":[3750690,3751116,3752887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":915,"address":[3750935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[3752857,3752055,3751367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":918,"address":[3751901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":920,"address":[3752327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[3753248,3755049],"length":1,"stats":{"Line":1},"fn_name":"try_send_impl\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":935,"address":[3753385,3753635,3755203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":938,"address":[3753600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":941,"address":[3753613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":948,"address":[3754019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[3754058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":950,"address":[3754105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":951,"address":[3754394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":953,"address":[3754426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":956,"address":[3754614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":959,"address":[3757786,3755520],"length":1,"stats":{"Line":1},"fn_name":"try_send\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":967,"address":[3755615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":968,"address":[3755717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":969,"address":[3756158,3755765,3758224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":973,"address":[3755938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":975,"address":[3755978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":977,"address":[3756010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":978,"address":[3756042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":984,"address":[3756496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":985,"address":[3756752,3757187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":987,"address":[3757018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":990,"address":[3761830,3758992],"length":1,"stats":{"Line":0},"fn_name":"try_batch_send\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":995,"address":[3759035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":996,"address":[3759129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[3759166,3759363,3762322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[3759306,3759609,3759745,3760498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1002,"address":[3760184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[3760201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1005,"address":[3760241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":[3760257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[3760297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1014,"address":[3760836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[3760843,3761278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[3761109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1020,"address":[3763040,3764057],"length":1,"stats":{"Line":1},"fn_name":"try_register_receive\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1025,"address":[3763089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1027,"address":[3763130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1028,"address":[3764074,3763147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1029,"address":[3763274,3763343,3763918,3763684],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1033,"address":[3763607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1036,"address":[3764256],"length":1,"stats":{"Line":1},"fn_name":"insufficient_allowance"},{"line":1037,"address":[3764293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1043,"address":[3764576],"length":1,"stats":{"Line":1},"fn_name":"use_allowance\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":1050,"address":[3764700,3764909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1052,"address":[3765009,3764861,3765853,3765840],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":1053,"address":[3765109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1054,"address":[3765333,3765256,3765127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1055,"address":[3765323,3765437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1057,"address":[3765524,3765212,3765460],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1058,"address":[3765556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1060,"address":[3765481,3765646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1063,"address":[3765669,3765566,3765728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1065,"address":[3765719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1068,"address":[3767933,3765888],"length":1,"stats":{"Line":1},"fn_name":"try_transfer_from_impl\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1077,"address":[3766000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1079,"address":[3768097,3766105,3766210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[3766200,3768095,3766469,3766523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1083,"address":[3766513,3767897,3768090,3766785,3767956],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1090,"address":[3767410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1091,"address":[3767426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1092,"address":[3767466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1096,"address":[3767598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[3768384,3771047],"length":1,"stats":{"Line":1},"fn_name":"try_transfer_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1107,"address":[3768508,3768685,3771086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[3768947,3768659,3771084,3769071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1109,"address":[3771082,3769333,3769045,3769541],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1110,"address":[3771080,3769449,3769852,3769803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1113,"address":[3769842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1114,"address":[3770106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1115,"address":[3770113,3770548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[3770379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1120,"address":[3774714,3771440],"length":1,"stats":{"Line":0},"fn_name":"try_batch_transfer_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1125,"address":[3775062,3771695,3771488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[3771638,3774768,3772071,3771935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1127,"address":[3774961,3772660,3772486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1128,"address":[3773140,3772626,3772922,3774956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1135,"address":[3773023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1136,"address":[3773039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1141,"address":[3773767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1142,"address":[3773782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[3773863,3773789,3774221,3774455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1147,"address":[3774055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1151,"address":[3775552,3777813],"length":1,"stats":{"Line":1},"fn_name":"try_send_from_impl\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1162,"address":[3775692,3775938,3778324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1163,"address":[3776200,3775912,3776328,3778319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1167,"address":[3776293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1171,"address":[3776306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1177,"address":[3776750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1178,"address":[3776781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1179,"address":[3776813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1180,"address":[3776846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1182,"address":[3776878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1185,"address":[3777283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1188,"address":[3779024,3781257],"length":1,"stats":{"Line":1},"fn_name":"try_send_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1197,"address":[3779130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1198,"address":[3779375,3779230,3781434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1200,"address":[3779365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1203,"address":[3779634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1206,"address":[3779709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1207,"address":[3779741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1209,"address":[3779773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1210,"address":[3779805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1215,"address":[3780016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1216,"address":[3780272,3780715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1218,"address":[3780538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1221,"address":[3784731,3781888],"length":1,"stats":{"Line":0},"fn_name":"try_batch_send_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1226,"address":[3781928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1227,"address":[3782134,3782004,3784985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1228,"address":[3782124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1230,"address":[3782580,3783456,3782382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1233,"address":[3783091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1236,"address":[3783103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1237,"address":[3783143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1238,"address":[3783183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1239,"address":[3783199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[3783239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1246,"address":[3783808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1247,"address":[3783815,3784255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[3784081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":[3785344,3789874],"length":1,"stats":{"Line":1},"fn_name":"try_burn_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1259,"address":[3785467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1260,"address":[3785655,3790285,3785522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1261,"address":[3785633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1262,"address":[3785986,3785904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1267,"address":[3786044,3786174,3785951,3790194],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1268,"address":[3786439,3786571,3790189,3786148],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1269,"address":[3786852,3786527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1270,"address":[3786994,3786868,3790184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1273,"address":[3786984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1274,"address":[3787259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1276,"address":[3787320,3787573],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1277,"address":[3787605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1279,"address":[3787475,3787691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1284,"address":[3787621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1287,"address":[3787968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1288,"address":[3787983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1289,"address":[3788032,3788186],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1290,"address":[3788218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1292,"address":[3788155,3788273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1296,"address":[3788234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1302,"address":[3788339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1303,"address":[3788355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1304,"address":[3788395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1309,"address":[3788542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1310,"address":[3788809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1311,"address":[3788816,3789250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1314,"address":[3789085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1317,"address":[3796157,3790880],"length":1,"stats":{"Line":1},"fn_name":"try_batch_burn_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1322,"address":[3790952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1323,"address":[3796412,3791140,3791015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1324,"address":[3791118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1325,"address":[3791389,3791471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1330,"address":[3791657,3791529,3796407,3791436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1332,"address":[3791625,3791930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1334,"address":[3792136,3791946,3796188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1335,"address":[3792605,3796326,3792426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1336,"address":[3792886,3792561],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1337,"address":[3796321,3793028,3792902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1340,"address":[3793018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1341,"address":[3793293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1343,"address":[3793613,3793354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1344,"address":[3793645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1346,"address":[3793509,3793737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1351,"address":[3793661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1354,"address":[3794004,3794197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1355,"address":[3794229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1357,"address":[3794135,3794316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1367,"address":[3794250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1368,"address":[3794276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1369,"address":[3794530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1374,"address":[3795002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1375,"address":[3795009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1378,"address":[3795048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1379,"address":[3795063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1380,"address":[3795504,3795070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1383,"address":[3795339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1386,"address":[3796944,3800136],"length":1,"stats":{"Line":1},"fn_name":"try_increase_allowance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1393,"address":[3797026,3797225,3800592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1394,"address":[3797487,3797614,3800587,3797199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1396,"address":[3798025,3797876,3797604,3800582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1397,"address":[3797964,3798396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1398,"address":[3798475,3798420],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1399,"address":[3798443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1401,"address":[3798484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1406,"address":[3798525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1410,"address":[3798651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1411,"address":[3798915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1412,"address":[3799021,3799195,3799639,3799405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1418,"address":[3799669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1421,"address":[3801312,3804499],"length":1,"stats":{"Line":1},"fn_name":"try_decrease_allowance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1428,"address":[3804955,3801394,3801593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1429,"address":[3801567,3801855,3804950,3801982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1431,"address":[3802244,3801972,3804945,3802393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1432,"address":[3802332,3802759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1433,"address":[3802838,3802783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1434,"address":[3802806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1436,"address":[3802847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1441,"address":[3802888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1445,"address":[3803014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1446,"address":[3803278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1447,"address":[3803384,3803768,3803558,3804002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1453,"address":[3804032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1456,"address":[3807786,3805680],"length":1,"stats":{"Line":1},"fn_name":"add_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1461,"address":[3805718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1462,"address":[3805881,3805759,3807841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1463,"address":[3805859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1464,"address":[3806127,3806192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1469,"address":[3806163,3806247,3806345,3807839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1471,"address":[3806656,3806607,3807837,3806283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1473,"address":[3807087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1474,"address":[3806646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1475,"address":[3806910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1476,"address":[3807265,3806917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1480,"address":[3808224,3810330],"length":1,"stats":{"Line":1},"fn_name":"remove_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1485,"address":[3808262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1486,"address":[3808303,3808425,3810385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1487,"address":[3808403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1488,"address":[3808736,3808671],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1493,"address":[3808707,3810383,3808791,3808889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1495,"address":[3808827,3810381,3809151,3809200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1497,"address":[3809631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1498,"address":[3809190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1499,"address":[3809454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1500,"address":[3809809,3809461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1504,"address":[3812874,3810768],"length":1,"stats":{"Line":1},"fn_name":"set_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1509,"address":[3810806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1510,"address":[3812929,3810847,3810969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1511,"address":[3810947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1512,"address":[3811215,3811280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1517,"address":[3812927,3811251,3811433,3811335],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1519,"address":[3811371,3812925,3811744,3811695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1521,"address":[3812175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1522,"address":[3811734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1523,"address":[3811998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1524,"address":[3812353,3812005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1533,"address":[3813312,3817011],"length":1,"stats":{"Line":1},"fn_name":"try_burn\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1539,"address":[3813386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1540,"address":[3813441,3813574,3817415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1541,"address":[3813552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1542,"address":[3813905,3813823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1547,"address":[3813870,3813963,3817324,3814095],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1548,"address":[3814368,3814051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1550,"address":[3814392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1551,"address":[3814415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1553,"address":[3814726,3814476],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1554,"address":[3814758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1556,"address":[3814841,3814631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1562,"address":[3814774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1564,"address":[3815118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1565,"address":[3815133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1566,"address":[3815182,3815336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1567,"address":[3815368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1569,"address":[3815305,3815423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1573,"address":[3815384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1579,"address":[3815489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1580,"address":[3815505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1581,"address":[3815545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1586,"address":[3815687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1587,"address":[3815954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1588,"address":[3816395,3815961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1591,"address":[3816230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1594,"address":[3817952,3819336],"length":1,"stats":{"Line":1},"fn_name":"perform_transfer\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":1600,"address":[3818031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1602,"address":[3818060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1603,"address":[3818367,3818121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1604,"address":[3818399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1606,"address":[3818264,3818474],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1611,"address":[3818415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1613,"address":[3818732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1614,"address":[3819408,3819018,3818936,3819255,3818781],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":1615,"address":[3819420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1617,"address":[3818984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1619,"address":[3819272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1622,"address":[3819964,3819456],"length":1,"stats":{"Line":1},"fn_name":"is_admin\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":1623,"address":[3819486,3819785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1624,"address":[3819746,3819889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1625,"address":[3819900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1631,"address":[3820016],"length":1,"stats":{"Line":1},"fn_name":"check_if_admin\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":1632,"address":[3820048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1633,"address":[3820206,3820251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1638,"address":[3820238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1641,"address":[3820288],"length":1,"stats":{"Line":1},"fn_name":"is_valid_name"},{"line":1642,"address":[3820302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1643,"address":[3820312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1646,"address":[3820352],"length":1,"stats":{"Line":1},"fn_name":"is_valid_symbol"},{"line":1647,"address":[3820376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1648,"address":[3820386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1650,"address":[3820471,3820417,3820528,3820512],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1672,"address":[3114626,3113616],"length":1,"stats":{"Line":1},"fn_name":"init_helper"},{"line":1678,"address":[3113638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1679,"address":[3113693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1682,"address":[3113740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1683,"address":[3113767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1684,"address":[3113858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1686,"address":[3113890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1687,"address":[3114036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1691,"address":[3114259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1694,"address":[3114848,3117106],"length":1,"stats":{"Line":1},"fn_name":"init_helper_with_config"},{"line":1707,"address":[3115092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1708,"address":[3115033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1709,"address":[3115076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1713,"address":[3115257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1714,"address":[3115945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1715,"address":[3115312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1727,"address":[3116108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1728,"address":[3116135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1729,"address":[3116226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1731,"address":[3116261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1732,"address":[3116407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1733,"address":[3116426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1736,"address":[3116678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1740,"address":[3117408,3118906],"length":1,"stats":{"Line":0},"fn_name":"_auth_query_helper"},{"line":1743,"address":[3117430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1744,"address":[3118863,3117658,3117859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1745,"address":[3117641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1747,"address":[3117821,3117666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1750,"address":[3117792,3118020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1752,"address":[3118035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1755,"address":[3118154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1756,"address":[3118335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1757,"address":[3118497,3118450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1758,"address":[3118464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1761,"address":[3118616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1764,"address":[3120069,3119456,3121558,3120896,3120796,3120176],"length":1,"stats":{"Line":3},"fn_name":"extract_error_msg\u003ccosmwasm_std::encoding::Binary\u003e"},{"line":1765,"address":[3120975,3120255,3119535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1766,"address":[3119478,3119542,3120262,3120198,3120982,3120918],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1767,"address":[3120289,3119560,3121027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1770,"address":[3120376,3121114,3119647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1771,"address":[3121203,3119730,3120410,3120459,3121151,3119681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1772,"address":[3120421,3121165,3119692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1775,"address":[3119493,3120933,3120213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1776,"address":[3120235,3120955,3119515,3121347,3119862,3120591],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1777,"address":[3120553,3121309,3119824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1782,"address":[3122455,3121664],"length":1,"stats":{"Line":1},"fn_name":"ensure_success"},{"line":1783,"address":[3121676,3122439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1785,"address":[3122166,3121947,3122040,3122130,3121962,3122058,3122148,3122184,3121992,3122007,3121977,3122022,3122094,3122112,3122076,3121932],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1786,"address":[3122063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1802,"address":[3121892,3122189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1804,"address":[3121835,3122343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1814,"address":[3122672,3122704,3122677,3125409],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1815,"address":[3122804,3125451,3122711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1816,"address":[3122745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1819,"address":[3123067,3125368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1821,"address":[3123436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1822,"address":[3123459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1823,"address":[3123504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1824,"address":[3123749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1825,"address":[3125326,3123968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1826,"address":[3124188,3125310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1827,"address":[3125294,3124444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1828,"address":[3124656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1829,"address":[3124809,3124910,3125278],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1831,"address":[3124822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1833,"address":[3125077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1837,"address":[3125744,3129136,3125776,3125749],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1839,"address":[3125801,3125876,3129178],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1840,"address":[3125817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1849,"address":[3126172,3129095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1851,"address":[3126541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1852,"address":[3126564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1853,"address":[3126609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1854,"address":[3126854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1855,"address":[3129053,3127073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1856,"address":[3127293,3129037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1857,"address":[3129021,3127561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1858,"address":[3127797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1859,"address":[3128075,3129005,3127962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1861,"address":[3127978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1863,"address":[3128242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1864,"address":[3128384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1865,"address":[3128524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1866,"address":[3128664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1867,"address":[3128804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1871,"address":[3129472,3129504,3129477,3131243],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1872,"address":[3129652,3131324,3129511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1873,"address":[3129553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1874,"address":[3129628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1876,"address":[3129930,3130144,3131214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1877,"address":[3129913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1879,"address":[3129938,3130106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1882,"address":[3130543,3131285,3130060,3131199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1883,"address":[3130364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1884,"address":[3130292,3130076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1885,"address":[3130340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1887,"address":[3130487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1888,"address":[3130428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1892,"address":[3130807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1893,"address":[3130942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1902,"address":[3131573,3134626,3131600,3131568],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1903,"address":[3134728,3131716,3131607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1904,"address":[3131657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1907,"address":[3134597,3132010,3132213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1908,"address":[3131987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1910,"address":[3132175,3132018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1914,"address":[3132145,3132373],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1915,"address":[3132405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1919,"address":[3132597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1920,"address":[3132721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1921,"address":[3132847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1922,"address":[3132993,3133070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1924,"address":[3133006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1926,"address":[3133146,3133223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1928,"address":[3133159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1930,"address":[3133315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1931,"address":[3133338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1932,"address":[3133563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1935,"address":[3133772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1936,"address":[3133831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1940,"address":[3134023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1941,"address":[3134141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1942,"address":[3134268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1946,"address":[3135088,3135061,3138352,3135056],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1947,"address":[3135095,3135228,3138529],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1948,"address":[3135169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1951,"address":[3135510,3138320,3135710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1952,"address":[3135493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1954,"address":[3135518,3135672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1958,"address":[3135642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1961,"address":[3135950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1962,"address":[3136068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1963,"address":[3136194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1966,"address":[3136340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1967,"address":[3136399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1968,"address":[3136423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1970,"address":[3136494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1972,"address":[3136759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1973,"address":[3136877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1974,"address":[3137019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1975,"address":[3138168,3137742,3137100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1976,"address":[3137143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1977,"address":[3137202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1978,"address":[3137543,3137676],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1979,"address":[3137229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1980,"address":[3137296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1981,"address":[3137363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1982,"address":[3137387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1983,"address":[3137454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1987,"address":[3137713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1992,"address":[3138960,3138965,3140724,3138992],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1993,"address":[3139100,3140790,3138999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1994,"address":[3139041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1997,"address":[3140695,3139376,3139570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1998,"address":[3139359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2000,"address":[3139384,3139532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2004,"address":[3139502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2007,"address":[3139810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2008,"address":[3139928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2009,"address":[3140054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2011,"address":[3140213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2014,"address":[3140649,3140379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2018,"address":[3141008,3141013,3141040,3143303],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2019,"address":[3141164,3141047,3143668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2020,"address":[3141105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2023,"address":[3143271,3141443,3141639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2024,"address":[3141426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2026,"address":[3141601,3141451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2030,"address":[3141572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2033,"address":[3141879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2034,"address":[3143252,3142346,3142030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2035,"address":[3142013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2037,"address":[3142041,3142308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2039,"address":[3142171,3143363,3143450,3142494,3143544,3143233,3143318],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2042,"address":[3143340,3142672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2043,"address":[3142639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2045,"address":[3142821,3142744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2047,"address":[3142757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2049,"address":[3142921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2050,"address":[3142958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2054,"address":[3147277,3144096,3144101,3144128],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2055,"address":[3144250,3147686,3144141],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2056,"address":[3144191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2059,"address":[3144544,3144747,3147245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2060,"address":[3144521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2062,"address":[3144552,3144709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2067,"address":[3144679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2070,"address":[3144993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2071,"address":[3145111,3147226,3147292,3147337,3147549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2073,"address":[3145464,3147180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2074,"address":[3147327,3145374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2075,"address":[3145404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2082,"address":[3145650,3147164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2084,"address":[3145794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2087,"address":[3145913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2088,"address":[3147130,3147367,3146031,3147415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2090,"address":[3147084,3146384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2091,"address":[3147405,3146294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2092,"address":[3146324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2094,"address":[3146647,3146570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2096,"address":[3146583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2098,"address":[3146747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2099,"address":[3146784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2103,"address":[3148341,3148336,3155910,3148368],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2104,"address":[3148381,3148538,3156204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2105,"address":[3148479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2108,"address":[3149035,3155878,3148832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2109,"address":[3148809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2111,"address":[3148997,3148840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2116,"address":[3149195,3148967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2117,"address":[3149227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2118,"address":[3149286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2122,"address":[3149510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2123,"address":[3149634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2124,"address":[3149761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2128,"address":[3149882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2129,"address":[3149941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2131,"address":[3149977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2133,"address":[3150145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2134,"address":[3155824,3150308,3150511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2135,"address":[3150285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2137,"address":[3150316,3150473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2140,"address":[3150671,3150443],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2141,"address":[3150703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2142,"address":[3150762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2146,"address":[3150986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2147,"address":[3151110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2148,"address":[3151237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2152,"address":[3151358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2153,"address":[3151417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2154,"address":[3151476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2160,"address":[3152072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2161,"address":[3151727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2164,"address":[3151700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2166,"address":[3151861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2167,"address":[3151783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2168,"address":[3151842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2170,"address":[3151956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2171,"address":[3151925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2173,"address":[3151988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2174,"address":[3152046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2176,"address":[3152264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2178,"address":[3152349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2179,"address":[3152476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2183,"address":[3152597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2184,"address":[3152656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2185,"address":[3152715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2189,"address":[3152939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2190,"address":[3155643,3153102,3153321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2191,"address":[3153079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2193,"address":[3153110,3153283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2195,"address":[3153237,3153521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2197,"address":[3153489,3153253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2199,"address":[3153680,3153597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2201,"address":[3153613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2203,"address":[3153772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2204,"address":[3153858,3155562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2205,"address":[3153881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2206,"address":[3155547,3153961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2207,"address":[3153976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2208,"address":[3154140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2209,"address":[3155532,3154312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2210,"address":[3154399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2214,"address":[3154555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2215,"address":[3154614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2216,"address":[3154673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2220,"address":[3154897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2221,"address":[3155015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2222,"address":[3155142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2226,"address":[3157136,3157104,3165589,3157109],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2227,"address":[3157149,3157370,3166089],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2228,"address":[3157311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2231,"address":[3157664,3157867,3165557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2232,"address":[3157641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2234,"address":[3157672,3157829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2239,"address":[3158027,3157799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2240,"address":[3158059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2241,"address":[3158118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2246,"address":[3158386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2247,"address":[3158510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2248,"address":[3158637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2252,"address":[3158758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2253,"address":[3158817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2257,"address":[3159009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2258,"address":[3159375,3165503,3159172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2259,"address":[3159149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2261,"address":[3159180,3159337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2264,"address":[3159535,3159307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2265,"address":[3159567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2266,"address":[3159626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2271,"address":[3159894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2272,"address":[3160018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2273,"address":[3160145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2277,"address":[3160266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2280,"address":[3160385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2281,"address":[3160548,3160805,3165446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2282,"address":[3160525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2284,"address":[3160556,3160767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2286,"address":[3160981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2288,"address":[3161008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2289,"address":[3161075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2290,"address":[3161142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2291,"address":[3161166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2292,"address":[3161249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2295,"address":[3161413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2296,"address":[3161472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2297,"address":[3161531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2298,"address":[3161555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2299,"address":[3161614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2302,"address":[3161906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2303,"address":[3162385,3165361,3162069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2304,"address":[3162046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2306,"address":[3162080,3162347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2308,"address":[3162553,3162961,3162210,3165330],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2309,"address":[3162614,3162836,3162907],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2310,"address":[3162742,3165637,3162891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2313,"address":[3163153,3163070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2315,"address":[3163086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2317,"address":[3163312,3163229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2319,"address":[3163245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2321,"address":[3163404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2322,"address":[3163496,3165249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2323,"address":[3163519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2324,"address":[3163599,3165234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2325,"address":[3163614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2326,"address":[3163778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2327,"address":[3165219,3163950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2328,"address":[3164037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2332,"address":[3164193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2333,"address":[3164252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2334,"address":[3164311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2339,"address":[3164579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2340,"address":[3164697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2341,"address":[3164824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2345,"address":[3167152,3167120,3173893,3167125],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2347,"address":[3174238,3167255,3167330],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2348,"address":[3167271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2357,"address":[3167888,3167659,3173861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2358,"address":[3167636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2360,"address":[3167850,3167667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2363,"address":[3174187,3167804,3168080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2364,"address":[3168048,3167820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2367,"address":[3168395,3168598,3173829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2368,"address":[3168372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2370,"address":[3168403,3168560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2374,"address":[3168530,3168758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2375,"address":[3168790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2379,"address":[3168982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2380,"address":[3169106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2381,"address":[3169233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2385,"address":[3169354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2386,"address":[3169413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2390,"address":[3169605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2391,"address":[3169729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2392,"address":[3169856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2396,"address":[3169977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2397,"address":[3170036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2401,"address":[3170228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2402,"address":[3170391,3173772,3170594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2403,"address":[3170368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2405,"address":[3170399,3170556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2408,"address":[3170526,3170754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2409,"address":[3170786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2413,"address":[3170978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2414,"address":[3171102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2415,"address":[3171229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2419,"address":[3171350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2420,"address":[3171409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2424,"address":[3171601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2425,"address":[3171983,3171764,3173734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2426,"address":[3171741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2428,"address":[3171772,3171945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2430,"address":[3171899,3172177],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2432,"address":[3172145,3171915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2434,"address":[3172269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2435,"address":[3172349,3173683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2436,"address":[3172364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2437,"address":[3172536,3173668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2438,"address":[3172623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2442,"address":[3172779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2443,"address":[3172838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2447,"address":[3173030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2448,"address":[3173148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2449,"address":[3173275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2453,"address":[3174912,3184331,3174944,3174917],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2455,"address":[3175063,3184719,3175488,3184300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2456,"address":[3175162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2457,"address":[3175079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2458,"address":[3175138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2460,"address":[3175309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2461,"address":[3175226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2462,"address":[3175285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2464,"address":[3175432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2465,"address":[3175373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2475,"address":[3184268,3175829,3176058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2476,"address":[3175806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2478,"address":[3176020,3175837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2481,"address":[3184668,3176250,3175974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2482,"address":[3175990,3176218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2485,"address":[3176565,3176786,3184236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2486,"address":[3176542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2488,"address":[3176748,3176573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2491,"address":[3176700,3176962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2493,"address":[3185712,3185799],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2494,"address":[3185749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2496,"address":[3185790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2505,"address":[3177146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2506,"address":[3177209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2508,"address":[3177271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2509,"address":[3177398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2512,"address":[3177519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2513,"address":[3177643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2514,"address":[3177770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2517,"address":[3177891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2518,"address":[3178096,3179580,3177915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2520,"address":[3178138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2521,"address":[3178205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2525,"address":[3178405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2526,"address":[3178563,3178766,3184184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2527,"address":[3178540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2529,"address":[3178728,3178571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2532,"address":[3178706,3178926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2533,"address":[3178958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2537,"address":[3179150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2538,"address":[3179274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2539,"address":[3179401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2543,"address":[3178052,3179601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2545,"address":[3185872,3186002,3185902],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2546,"address":[3185930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2547,"address":[3185976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2548,"address":[3185993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2556,"address":[3179785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2557,"address":[3179948,3180160,3184146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2558,"address":[3179925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2560,"address":[3180122,3179956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2562,"address":[3181036,3180083,3180336,3180443],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2563,"address":[3180500,3180575],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2565,"address":[3180516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2567,"address":[3180667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2568,"address":[3180759,3184095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2569,"address":[3180783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2571,"address":[3184077,3181049,3180433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2572,"address":[3181133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2575,"address":[3181301,3181374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2577,"address":[3186352,3186118,3181366,3186268,3186080],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":2578,"address":[3186146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2579,"address":[3186367,3186187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2580,"address":[3186259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2588,"address":[3181544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2589,"address":[3181919,3181707,3184058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2590,"address":[3181684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2592,"address":[3181715,3181881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2594,"address":[3182095,3182206,3182786,3181842],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2595,"address":[3182240,3182315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2597,"address":[3182256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2599,"address":[3182407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2600,"address":[3182499,3184007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2601,"address":[3185486,3182506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2603,"address":[3182196,3183989,3182799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2604,"address":[3185544,3182875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2607,"address":[3183184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2609,"address":[3186519,3186432],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2610,"address":[3186469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2612,"address":[3186510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2619,"address":[3183405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2620,"address":[3183523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2621,"address":[3183650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2625,"address":[3190702,3186624,3186592,3186597],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2626,"address":[3186778,3186637,3190924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2627,"address":[3186719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2630,"address":[3187072,3187275,3190670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2631,"address":[3187049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2633,"address":[3187080,3187237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2637,"address":[3187435,3187207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2638,"address":[3187467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2642,"address":[3187659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2643,"address":[3188041,3187822,3190651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2644,"address":[3187799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2646,"address":[3187830,3188003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2649,"address":[3188241,3187957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2651,"address":[3187973,3188209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2653,"address":[3188394,3188317],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2655,"address":[3188330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2658,"address":[3188502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2659,"address":[3188547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2668,"address":[3188694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2669,"address":[3188753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2673,"address":[3188945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2674,"address":[3189096,3190564,3189299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2675,"address":[3189079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2677,"address":[3189261,3189104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2681,"address":[3189447,3189231],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2682,"address":[3189479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2686,"address":[3189671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2687,"address":[3190545,3189822,3190037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2688,"address":[3189805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2690,"address":[3189999,3189830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2693,"address":[3189989,3190185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2694,"address":[3190223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2704,"address":[3191381,3194661,3191376,3191408],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2705,"address":[3191415,3194829,3191540],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2706,"address":[3191481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2709,"address":[3191834,3194629,3192037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2710,"address":[3191811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2712,"address":[3191999,3191842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2716,"address":[3192197,3191969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2717,"address":[3192229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2721,"address":[3192421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2722,"address":[3192578,3192794,3194613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2723,"address":[3192561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2725,"address":[3192756,3192586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2728,"address":[3192713,3192979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2730,"address":[3192947,3192726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2732,"address":[3193055,3193132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2734,"address":[3193068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2737,"address":[3193240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2738,"address":[3193285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2747,"address":[3193432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2748,"address":[3193491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2752,"address":[3193683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2753,"address":[3194526,3193834,3194049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2754,"address":[3193817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2756,"address":[3193842,3194011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2759,"address":[3194197,3194001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2760,"address":[3194235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2770,"address":[3195200,3195232,3197135,3195205],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2771,"address":[3197339,3195239,3195348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2772,"address":[3195289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2775,"address":[3197103,3195818,3195624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2776,"address":[3195607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2778,"address":[3195780,3195632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2782,"address":[3195966,3195750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2785,"address":[3196090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2786,"address":[3197084,3196241,3196440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2787,"address":[3196224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2789,"address":[3196249,3196402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2792,"address":[3196392,3196604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2795,"address":[3197034,3196673,3197158,3197066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2796,"address":[3196695,3197018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2800,"address":[3197696,3197728,3197701,3199268],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2801,"address":[3197735,3199361,3197844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2802,"address":[3197785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2805,"address":[3198402,3198117,3199239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2806,"address":[3198100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2808,"address":[3198364,3198125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2815,"address":[3198322,3198550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2816,"address":[3198861,3198662,3199223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2817,"address":[3198645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2819,"address":[3198670,3198823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2822,"address":[3198813,3199208,3199017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2823,"address":[3199070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2825,"address":[3199056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2830,"address":[3199616,3199589,3204458,3199584],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2832,"address":[3204734,3199695,3199770],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2833,"address":[3199711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2842,"address":[3200098,3200327,3204426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2843,"address":[3200075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2845,"address":[3200289,3200106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2849,"address":[3200243,3200519,3204683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2850,"address":[3200259,3200487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2859,"address":[3200866,3204394,3201095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2860,"address":[3200843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2862,"address":[3201057,3200874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2865,"address":[3204632,3201011,3201287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2866,"address":[3201255,3201027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2869,"address":[3201983,3201602,3204362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2870,"address":[3201579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2872,"address":[3201945,3201613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2876,"address":[3201743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2880,"address":[3201903,3202143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2881,"address":[3202228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2882,"address":[3202355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2886,"address":[3202470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2890,"address":[3202630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2891,"address":[3202748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2892,"address":[3202875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2897,"address":[3202978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2901,"address":[3203138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2902,"address":[3203289,3204305,3203488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2903,"address":[3203272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2905,"address":[3203297,3203450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2908,"address":[3203440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2909,"address":[3203636,3203713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2911,"address":[3203649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2913,"address":[3203805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2917,"address":[3205344,3205312,3205317,3208918],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2919,"address":[3205415,3209137,3205490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2920,"address":[3205431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2929,"address":[3205818,3206047,3208886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2930,"address":[3205795],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2932,"address":[3205826,3206009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2935,"address":[3206239,3209086,3205963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2936,"address":[3206207,3205979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2939,"address":[3208854,3206817,3206554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2940,"address":[3206531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2942,"address":[3206779,3206562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2945,"address":[3206689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2948,"address":[3207081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2950,"address":[3206977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2951,"address":[3206749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2955,"address":[3207122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2957,"address":[3207224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2958,"address":[3207359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2960,"address":[3207462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2963,"address":[3207653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2965,"address":[3207549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2966,"address":[3207522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2970,"address":[3207694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2972,"address":[3207821,3208020,3208780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2973,"address":[3207804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2975,"address":[3207829,3207982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2978,"address":[3207972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2979,"address":[3208245,3208168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2981,"address":[3208181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2983,"address":[3208337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2987,"address":[3209664,3213074,3209632,3209637],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2989,"address":[3209802,3213266,3209727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2990,"address":[3209743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2999,"address":[3213042,3210131,3210360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3000,"address":[3210108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3002,"address":[3210139,3210322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3005,"address":[3210276,3213215,3210552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3006,"address":[3210292,3210520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3009,"address":[3213010,3210867,3211248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3010,"address":[3210844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3012,"address":[3210878,3211210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3016,"address":[3211008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3020,"address":[3211168,3211408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3021,"address":[3211493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3022,"address":[3211620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3024,"address":[3212978,3211745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3025,"address":[3211824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3027,"address":[3211848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3031,"address":[3212008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3032,"address":[3212358,3212159,3212962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3033,"address":[3212142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3035,"address":[3212167,3212320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3038,"address":[3212514,3212944,3212310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3039,"address":[3213608,3212588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3043,"address":[3213728,3213696,3213701,3217338],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3045,"address":[3213866,3217530,3213791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3046,"address":[3213807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3055,"address":[3217306,3214195,3214424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3056,"address":[3214172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3058,"address":[3214203,3214386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3060,"address":[3214616,3217479,3214340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3061,"address":[3214584,3214356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3064,"address":[3217274,3214931,3215158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3065,"address":[3214908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3067,"address":[3214939,3215120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3070,"address":[3215066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3072,"address":[3215090,3215318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3073,"address":[3215350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3077,"address":[3215542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3078,"address":[3215666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3079,"address":[3215793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3081,"address":[3215918,3217242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3082,"address":[3215997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3084,"address":[3216021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3085,"address":[3216080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3089,"address":[3216272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3090,"address":[3217226,3216423,3216622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3091,"address":[3216406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3093,"address":[3216584,3216431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3096,"address":[3217208,3216574,3216778],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3097,"address":[3217872,3216852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3101,"address":[3218000,3217968,3222405,3217973],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3102,"address":[3218013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3104,"address":[3218171,3222672,3218096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3105,"address":[3218112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3114,"address":[3218816,3222359,3218519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3115,"address":[3218496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3117,"address":[3218527,3218778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3124,"address":[3218736,3218976],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3125,"address":[3219061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3126,"address":[3219188,3222326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3129,"address":[3219408,3222588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3132,"address":[3219634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3133,"address":[3219758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3134,"address":[3219885,3222293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3137,"address":[3222537,3220105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3140,"address":[3220331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3141,"address":[3220455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3142,"address":[3220582,3222260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3145,"address":[3220784,3222486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3148,"address":[3221010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3149,"address":[3221128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3150,"address":[3222227,3221255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3153,"address":[3221429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3156,"address":[3221580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3157,"address":[3221698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3158,"address":[3221825,3222194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3162,"address":[3223264,3223296,3226209,3223269],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3164,"address":[3223361,3223436,3226401],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3165,"address":[3223377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3174,"address":[3223764,3226177,3224061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3175,"address":[3223741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3177,"address":[3223772,3224023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3185,"address":[3223981,3224215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3186,"address":[3224530,3226158,3224327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3187,"address":[3224310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3189,"address":[3224335,3224492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3193,"address":[3224678,3224462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3194,"address":[3224710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3198,"address":[3224902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3199,"address":[3225020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3200,"address":[3225174,3226125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3202,"address":[3225139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3206,"address":[3225341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3210,"address":[3225501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3211,"address":[3226109,3225843,3225652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3212,"address":[3225635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3214,"address":[3225805,3225660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3219,"address":[3229611,3226752,3226784,3226757],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3220,"address":[3226791,3226916,3229773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3221,"address":[3226857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3224,"address":[3229579,3227501,3227204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3225,"address":[3227187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3227,"address":[3227212,3227463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3235,"address":[3227649,3227421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3236,"address":[3227964,3227761,3229563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3237,"address":[3227744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3239,"address":[3227769,3227926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3243,"address":[3227896,3228112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3244,"address":[3228144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3248,"address":[3228336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3249,"address":[3228454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3250,"address":[3229533,3228608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3252,"address":[3228573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3256,"address":[3228775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3260,"address":[3228935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3261,"address":[3229053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3262,"address":[3229207,3229503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3264,"address":[3229172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3269,"address":[3230133,3234901,3230160,3230128],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3271,"address":[3235207,3230314,3230239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3272,"address":[3230255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3281,"address":[3234869,3230643,3230872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3282,"address":[3230620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3284,"address":[3230651,3230834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3286,"address":[3235156,3230788,3231064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3287,"address":[3230804,3231032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3290,"address":[3231608,3234837,3231379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3291,"address":[3231356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3293,"address":[3231387,3231570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3297,"address":[3231768,3235105,3231524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3300,"address":[3231951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3301,"address":[3232075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3302,"address":[3232202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3305,"address":[3232321,3235054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3308,"address":[3232547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3309,"address":[3232665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3310,"address":[3232792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3313,"address":[3232905,3235003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3316,"address":[3233131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3317,"address":[3233249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3320,"address":[3233441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3321,"address":[3233500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3325,"address":[3233692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3326,"address":[3233810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3329,"address":[3234002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3330,"address":[3234061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3334,"address":[3234253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3335,"address":[3234371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3336,"address":[3234498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3340,"address":[3235744,3235712,3240397,3235717],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3342,"address":[3240703,3235898,3235823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3343,"address":[3235839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3352,"address":[3236456,3236227,3240365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3353,"address":[3236204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3355,"address":[3236235,3236418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3357,"address":[3236648,3240652,3236372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3358,"address":[3236616,3236388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3361,"address":[3240333,3236963,3237192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3362,"address":[3236940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3364,"address":[3236971,3237154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3368,"address":[3240601,3237352,3237108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3371,"address":[3237535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3372,"address":[3237653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3373,"address":[3237780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3376,"address":[3237893,3240550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3379,"address":[3238119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3380,"address":[3238237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3381,"address":[3238364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3384,"address":[3238477,3240499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3387,"address":[3238703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3388,"address":[3238821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3391,"address":[3239013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3392,"address":[3239072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3396,"address":[3239264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3397,"address":[3239382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3400,"address":[3239574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3401,"address":[3239633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3405,"address":[3239825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3406,"address":[3239943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3410,"address":[3241189,3241216,3247973,3241184],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3412,"address":[3248396,3241394,3241319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3413,"address":[3241335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3422,"address":[3241952,3241723,3247941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3423,"address":[3241700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3425,"address":[3241731,3241914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3427,"address":[3241868,3248345,3242144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3428,"address":[3241884,3242112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3431,"address":[3242688,3242459,3247909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3432,"address":[3242436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3434,"address":[3242467,3242650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3438,"address":[3248294,3242604,3242848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3441,"address":[3243031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3442,"address":[3243155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3443,"address":[3243282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3446,"address":[3243413,3248243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3449,"address":[3243639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3450,"address":[3243763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3451,"address":[3243890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3454,"address":[3248192,3244021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3457,"address":[3244247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3458,"address":[3244371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3461,"address":[3244569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3462,"address":[3244628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3466,"address":[3244820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3467,"address":[3244944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3468,"address":[3245071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3471,"address":[3245192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3472,"address":[3245251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3476,"address":[3245443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3477,"address":[3245561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3478,"address":[3245688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3482,"address":[3245801,3248081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3485,"address":[3246027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3486,"address":[3246145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3489,"address":[3246337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3490,"address":[3246396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3494,"address":[3246588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3495,"address":[3246706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3496,"address":[3246833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3499,"address":[3246936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3500,"address":[3246995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3504,"address":[3247187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3505,"address":[3247305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3506,"address":[3247432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3512,"address":[3249077,3252510,3249104,3249072],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3513,"address":[3252751,3249111,3249220],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3514,"address":[3249161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3517,"address":[3249502,3252478,3249702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3518,"address":[3249485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3520,"address":[3249664,3249510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3524,"address":[3249850,3249634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3525,"address":[3249882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3527,"address":[3249984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3528,"address":[3250095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3529,"address":[3250249,3252432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3531,"address":[3250214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3535,"address":[3250416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3538,"address":[3250535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3539,"address":[3250683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3540,"address":[3250845,3250798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3541,"address":[3250812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3545,"address":[3250972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3546,"address":[3251031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3549,"address":[3251146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3550,"address":[3251303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3551,"address":[3251387,3251340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3552,"address":[3251354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3554,"address":[3251458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3557,"address":[3251605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3558,"address":[3251664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3560,"address":[3251766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3561,"address":[3251877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3562,"address":[3252031,3252303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3564,"address":[3251996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3569,"address":[3253248,3253280,3257026,3253253],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3570,"address":[3253287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3571,"address":[3253352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3572,"address":[3253411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3573,"address":[3253438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3574,"address":[3253541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3578,"address":[3253691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3580,"address":[3253715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3581,"address":[3253749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3583,"address":[3253796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3584,"address":[3253839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3585,"address":[3253878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3586,"address":[3253913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3587,"address":[3253939,3257243,3254030],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3591,"address":[3254276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3592,"address":[3254302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3594,"address":[3254553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3595,"address":[3256876,3254805,3255103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3596,"address":[3254782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3598,"address":[3254813,3255065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3601,"address":[3254940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3602,"address":[3255257,3254951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3603,"address":[3255606,3256857,3255290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3604,"address":[3255273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3606,"address":[3255568,3255301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3608,"address":[3256838,3255431,3255770],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3610,"address":[3255929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3616,"address":[3256039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3617,"address":[3256195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3618,"address":[3256343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3619,"address":[3256502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3621,"address":[3255856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3626,"address":[3257776,3257781,3257808,3262265],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3627,"address":[3257818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3628,"address":[3257867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3629,"address":[3257926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3630,"address":[3257953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3631,"address":[3258800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3632,"address":[3257961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3644,"address":[3258969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3646,"address":[3258993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3647,"address":[3259027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3649,"address":[3259074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3650,"address":[3259117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3651,"address":[3259156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3652,"address":[3259191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3653,"address":[3262334,3259217,3259308],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3657,"address":[3259554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3658,"address":[3259580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3660,"address":[3259831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3661,"address":[3262101,3260077,3260375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3662,"address":[3260060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3664,"address":[3260085,3260337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3667,"address":[3260212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3668,"address":[3260523,3260223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3669,"address":[3262082,3260872,3260556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3670,"address":[3260539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3672,"address":[3260834,3260567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3674,"address":[3260697,3261036,3262063],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3676,"address":[3261139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3683,"address":[3261217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3684,"address":[3261357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3685,"address":[3261499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3686,"address":[3261641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3687,"address":[3261781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3689,"address":[3261106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3694,"address":[3262853,3278365,3262880,3262848],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3696,"address":[3262896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3697,"address":[3263049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3698,"address":[3263108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3699,"address":[3263135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3701,"address":[3263143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3703,"address":[3263167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3704,"address":[3263201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3705,"address":[3264087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3706,"address":[3263248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3718,"address":[3264256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3719,"address":[3264299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3720,"address":[3264338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3721,"address":[3264373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3722,"address":[3264490,3279192,3264399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3726,"address":[3264736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3727,"address":[3264762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3729,"address":[3265013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3730,"address":[3265563,3278198,3265265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3731,"address":[3265242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3733,"address":[3265525,3265273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3736,"address":[3265400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3737,"address":[3265723,3265411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3738,"address":[3266078,3278179,3265762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3739,"address":[3265739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3741,"address":[3265773,3266040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3743,"address":[3266254,3265903,3278160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3745,"address":[3266318,3266365],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3746,"address":[3266445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3747,"address":[3266618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3749,"address":[3266332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3753,"address":[3266802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3754,"address":[3266829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3755,"address":[3266888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3756,"address":[3266915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3758,"address":[3266923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3760,"address":[3266947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3761,"address":[3266981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3762,"address":[3267867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3763,"address":[3267028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3775,"address":[3268036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3776,"address":[3268079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3777,"address":[3268118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3778,"address":[3268153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3779,"address":[3268179,3268270,3279025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3783,"address":[3268516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3784,"address":[3268542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3786,"address":[3268793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3787,"address":[3277969,3269343,3269045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3788,"address":[3269022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3790,"address":[3269053,3269305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3793,"address":[3269180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3794,"address":[3269191,3269503],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3795,"address":[3277950,3269858,3269542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3796,"address":[3269519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3798,"address":[3269820,3269553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3800,"address":[3269683,3277931,3270034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3802,"address":[3270145,3270098],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3803,"address":[3270225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3804,"address":[3270398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3806,"address":[3270112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3810,"address":[3270582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3811,"address":[3270609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3812,"address":[3270668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3813,"address":[3270695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3815,"address":[3270703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3817,"address":[3270727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3818,"address":[3270761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3819,"address":[3271647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3820,"address":[3270808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3832,"address":[3271816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3833,"address":[3271859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3834,"address":[3271898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3835,"address":[3271933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3836,"address":[3278858,3271959,3272050],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3840,"address":[3272296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3841,"address":[3272322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3843,"address":[3272573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3844,"address":[3277740,3272825,3273123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3845,"address":[3272802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3847,"address":[3273085,3272833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3850,"address":[3272960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3851,"address":[3272971,3273283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3852,"address":[3273638,3273322,3277721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3853,"address":[3273299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3855,"address":[3273333,3273600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3857,"address":[3273814,3273463,3277702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3859,"address":[3273878,3273925],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3860,"address":[3274005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3861,"address":[3274178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3863,"address":[3273892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3867,"address":[3274362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3868,"address":[3274389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3869,"address":[3274448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3870,"address":[3274475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3872,"address":[3274483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3874,"address":[3274507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3875,"address":[3274541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3877,"address":[3274588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3878,"address":[3274631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3879,"address":[3274670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3880,"address":[3274705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3881,"address":[3278691,3274728,3274819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3885,"address":[3275053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3888,"address":[3275279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3889,"address":[3277544,3275519,3275817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3890,"address":[3275502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3892,"address":[3275527,3275779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3895,"address":[3275654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3896,"address":[3275965,3275665],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3897,"address":[3276314,3277525,3275998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3898,"address":[3275981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3900,"address":[3276276,3276009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3902,"address":[3276478,3277506,3276139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3904,"address":[3276542,3276589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3905,"address":[3276669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3906,"address":[3277473,3276824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3908,"address":[3276556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3913,"address":[3281136,3281141,3288485,3281168],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3914,"address":[3281314,3288990,3281181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3915,"address":[3281255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3918,"address":[3288453,3281811,3281608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3919,"address":[3281585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3921,"address":[3281773,3281616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3925,"address":[3281743,3281971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3926,"address":[3282003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3930,"address":[3282195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3931,"address":[3282358,3282561,3288434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3932,"address":[3282335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3934,"address":[3282523,3282366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3937,"address":[3282721,3282493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3938,"address":[3282753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3941,"address":[3282812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3942,"address":[3282871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3943,"address":[3282930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3945,"address":[3283064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3946,"address":[3288356,3283214,3283523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3947,"address":[3283191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3949,"address":[3283485,3283225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3951,"address":[3283355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3952,"address":[3283691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3955,"address":[3283812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3958,"address":[3283931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3959,"address":[3288760,3288500,3284055,3288318,3288548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3961,"address":[3288272,3284408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3962,"address":[3288538,3284318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3963,"address":[3284348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3970,"address":[3284594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3973,"address":[3284713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3974,"address":[3284831,3288253,3288626,3288578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3976,"address":[3288207,3285184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3977,"address":[3285094,3288616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3978,"address":[3285124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3985,"address":[3285370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3986,"address":[3285429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3987,"address":[3285488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3989,"address":[3285622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3990,"address":[3285733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3991,"address":[3285959,3285912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3992,"address":[3285926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3994,"address":[3286049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3997,"address":[3286196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3998,"address":[3286255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3999,"address":[3286314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4001,"address":[3286448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4002,"address":[3286559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4003,"address":[3286738,3286785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4004,"address":[3286752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4006,"address":[3286875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4009,"address":[3287022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4010,"address":[3287081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4011,"address":[3287140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4013,"address":[3287274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4014,"address":[3287385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4015,"address":[3287564,3287611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4016,"address":[3287578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4018,"address":[3287701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4022,"address":[3290064,3290096,3290069,3293067],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":4023,"address":[3293291,3290103,3290204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4024,"address":[3290145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4027,"address":[3290680,3293035,3290483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4028,"address":[3290466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4030,"address":[3290491,3290642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4034,"address":[3290612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4037,"address":[3290920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4038,"address":[3293127,3293016,3293082,3291038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4040,"address":[3291391,3292970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4041,"address":[3293117,3291301],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4042,"address":[3291331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4049,"address":[3291577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4050,"address":[3291636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4052,"address":[3291738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4053,"address":[3291849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4054,"address":[3291976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4057,"address":[3292079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4058,"address":[3292138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4060,"address":[3292240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4061,"address":[3292351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4062,"address":[3292577,3292530],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4063,"address":[3292544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4065,"address":[3292667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4069,"address":[3300676,3293744,3293776,3293749],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":4070,"address":[3300986,3293789,3293914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4071,"address":[3293855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4074,"address":[3300644,3294208,3294411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4075,"address":[3294185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4077,"address":[3294216,3294373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4081,"address":[3294343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4084,"address":[3294663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4085,"address":[3294787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4088,"address":[3294979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4089,"address":[3295038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4093,"address":[3295230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4094,"address":[3295348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4095,"address":[3295474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4097,"address":[3295620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4098,"address":[3295679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4102,"address":[3295871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4103,"address":[3295989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4104,"address":[3296115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4106,"address":[3296261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4107,"address":[3296320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4111,"address":[3296512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4112,"address":[3296630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4113,"address":[3296756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4116,"address":[3296902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4117,"address":[3296961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4121,"address":[3297113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4124,"address":[3297224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4125,"address":[3297450,3297403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4126,"address":[3297417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4128,"address":[3297577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4131,"address":[3297635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4132,"address":[3297694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4136,"address":[3297846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4137,"address":[3297957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4138,"address":[3298136,3298183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4139,"address":[3298150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4141,"address":[3298310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4144,"address":[3298488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4145,"address":[3298547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4149,"address":[3298699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4150,"address":[3298810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4151,"address":[3298989,3299036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4152,"address":[3299003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4154,"address":[3299163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4157,"address":[3299341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4158,"address":[3299400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4159,"address":[3299427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4162,"address":[3299563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4163,"address":[3299674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4164,"address":[3299900,3299853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4165,"address":[3299867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4167,"address":[3300027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4171,"address":[3301712,3315235,3301744,3301717],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":4173,"address":[3315660,3301938,3301863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4174,"address":[3301879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4183,"address":[3302265,3302468,3315203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4184,"address":[3302242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4186,"address":[3302430,3302273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4190,"address":[3302400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4193,"address":[3302720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4194,"address":[3302844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4197,"address":[3303042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4198,"address":[3303066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4201,"address":[3303249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4202,"address":[3315184,3303412,3303793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4203,"address":[3303389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4205,"address":[3303755,3303423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4209,"address":[3303553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4213,"address":[3303713,3303953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4214,"address":[3304280,3315165,3304077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4215,"address":[3304054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4217,"address":[3304085,3304242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4221,"address":[3304212,3304440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4222,"address":[3304472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4223,"address":[3304496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4226,"address":[3304711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4227,"address":[3304835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4229,"address":[3305033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4232,"address":[3305224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4234,"address":[3305120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4235,"address":[3305093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4239,"address":[3305265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4241,"address":[3305404,3305607,3315109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4242,"address":[3305381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4244,"address":[3305412,3305569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4248,"address":[3305539,3305767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4249,"address":[3305799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4250,"address":[3305823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4253,"address":[3306038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4254,"address":[3306162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4255,"address":[3306288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4258,"address":[3306440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4259,"address":[3306499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4260,"address":[3306523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4263,"address":[3306738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4264,"address":[3306862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4265,"address":[3306988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4268,"address":[3307134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4269,"address":[3307193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4270,"address":[3307217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4273,"address":[3307432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4274,"address":[3307550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4275,"address":[3307676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4278,"address":[3307822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4279,"address":[3307881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4283,"address":[3308033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4284,"address":[3308144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4285,"address":[3308370,3308323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4286,"address":[3308337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4288,"address":[3308497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4291,"address":[3308675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4292,"address":[3308734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4296,"address":[3308886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4297,"address":[3308997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4298,"address":[3309352,3309176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4299,"address":[3309194,3314924,3309481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4303,"address":[3313871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4304,"address":[3310024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4306,"address":[3309742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4307,"address":[3309565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4308,"address":[3309624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4309,"address":[3309683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4311,"address":[3309901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4312,"address":[3309850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4313,"address":[3309877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4315,"address":[3309965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4319,"address":[3310679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4321,"address":[3310397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4322,"address":[3310220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4323,"address":[3310279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4324,"address":[3310338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4326,"address":[3310556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4327,"address":[3310505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4328,"address":[3310532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4330,"address":[3310620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4334,"address":[3311334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4336,"address":[3311052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4337,"address":[3310875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4338,"address":[3310934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4339,"address":[3310993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4341,"address":[3311211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4342,"address":[3311160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4343,"address":[3311187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4345,"address":[3311275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4349,"address":[3311637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4351,"address":[3311530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4352,"address":[3311569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4353,"address":[3311542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4356,"address":[3311625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4360,"address":[3312201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4362,"address":[3311951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4363,"address":[3311833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4364,"address":[3311892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4366,"address":[3312078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4367,"address":[3312027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4368,"address":[3312054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4370,"address":[3312142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4374,"address":[3312504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4376,"address":[3312397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4377,"address":[3312436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4378,"address":[3312409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4381,"address":[3312492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4385,"address":[3313068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4387,"address":[3312818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4388,"address":[3312700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4389,"address":[3312759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4391,"address":[3312945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4392,"address":[3312894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4393,"address":[3312921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4395,"address":[3313009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4399,"address":[3313632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4401,"address":[3313382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4402,"address":[3313264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4403,"address":[3313323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4405,"address":[3313509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4406,"address":[3313458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4407,"address":[3313485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4410,"address":[3313573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4416,"address":[3314082],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1740,"coverable":1996},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","src","lib.rs"],"content":"mod batch;\npub mod contract;\npub mod msg;\nmod rand;\npub mod receiver;\npub mod state;\nmod transaction_history;\nmod utils;\nmod viewing_key;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","src","msg.rs"],"content":"#![allow(clippy::field_reassign_with_default)] // This is triggered in `#[derive(JsonSchema)]`\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Binary, HumanAddr, StdError, StdResult, Uint128};\n\nuse crate::batch;\nuse crate::transaction_history::{RichTx, Tx};\nuse crate::viewing_key::ViewingKey;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct InitialBalance {\n    pub address: HumanAddr,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema)]\npub struct InitMsg {\n    pub name: String,\n    pub admin: Option\u003cHumanAddr\u003e,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Option\u003cVec\u003cInitialBalance\u003e\u003e,\n    pub prng_seed: Binary,\n    pub config: Option\u003cInitConfig\u003e,\n}\n\nimpl InitMsg {\n    pub fn config(\u0026self) -\u003e InitConfig {\n        self.config.clone().unwrap_or_default()\n    }\n}\n\n/// This type represents optional configuration values which can be overridden.\n/// All values are optional and have defaults which are more private by default,\n/// but can be overridden if necessary\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Default, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct InitConfig {\n    /// Indicates whether the total supply is public or should be kept secret.\n    /// default: False\n    public_total_supply: Option\u003cbool\u003e,\n    /// Indicates whether deposit functionality should be enabled\n    /// default: False\n    enable_deposit: Option\u003cbool\u003e,\n    /// Indicates whether redeem functionality should be enabled\n    /// default: False\n    enable_redeem: Option\u003cbool\u003e,\n    /// Indicates whether mint functionality should be enabled\n    /// default: False\n    enable_mint: Option\u003cbool\u003e,\n    /// Indicates whether burn functionality should be enabled\n    /// default: False\n    enable_burn: Option\u003cbool\u003e,\n}\n\nimpl InitConfig {\n    pub fn public_total_supply(\u0026self) -\u003e bool {\n        self.public_total_supply.unwrap_or(false)\n    }\n\n    pub fn deposit_enabled(\u0026self) -\u003e bool {\n        self.enable_deposit.unwrap_or(false)\n    }\n\n    pub fn redeem_enabled(\u0026self) -\u003e bool {\n        self.enable_redeem.unwrap_or(false)\n    }\n\n    pub fn mint_enabled(\u0026self) -\u003e bool {\n        self.enable_mint.unwrap_or(false)\n    }\n\n    pub fn burn_enabled(\u0026self) -\u003e bool {\n        self.enable_burn.unwrap_or(false)\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    // Native coin interactions\n    Redeem {\n        amount: Uint128,\n        denom: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    Deposit {\n        padding: Option\u003cString\u003e,\n    },\n\n    // Base ERC-20 stuff\n    Transfer {\n        recipient: HumanAddr,\n        amount: Uint128,\n        memo: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    Send {\n        recipient: HumanAddr,\n        amount: Uint128,\n        msg: Option\u003cBinary\u003e,\n        memo: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    BatchTransfer {\n        actions: Vec\u003cbatch::TransferAction\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    BatchSend {\n        actions: Vec\u003cbatch::SendAction\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    Burn {\n        amount: Uint128,\n        memo: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    RegisterReceive {\n        code_hash: String,\n        padding: Option\u003cString\u003e,\n    },\n    CreateViewingKey {\n        entropy: String,\n        padding: Option\u003cString\u003e,\n    },\n    SetViewingKey {\n        key: String,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Allowance\n    IncreaseAllowance {\n        spender: HumanAddr,\n        amount: Uint128,\n        expiration: Option\u003cu64\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    DecreaseAllowance {\n        spender: HumanAddr,\n        amount: Uint128,\n        expiration: Option\u003cu64\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    TransferFrom {\n        owner: HumanAddr,\n        recipient: HumanAddr,\n        amount: Uint128,\n        memo: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    SendFrom {\n        owner: HumanAddr,\n        recipient: HumanAddr,\n        amount: Uint128,\n        msg: Option\u003cBinary\u003e,\n        memo: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    BatchTransferFrom {\n        actions: Vec\u003cbatch::TransferFromAction\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    BatchSendFrom {\n        actions: Vec\u003cbatch::SendFromAction\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    BurnFrom {\n        owner: HumanAddr,\n        amount: Uint128,\n        memo: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    BatchBurnFrom {\n        actions: Vec\u003cbatch::BurnFromAction\u003e,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Mint\n    Mint {\n        recipient: HumanAddr,\n        amount: Uint128,\n        memo: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    BatchMint {\n        actions: Vec\u003cbatch::MintAction\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    AddMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    RemoveMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    SetMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Admin\n    ChangeAdmin {\n        address: HumanAddr,\n        padding: Option\u003cString\u003e,\n    },\n    SetContractStatus {\n        level: ContractStatusLevel,\n        padding: Option\u003cString\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleAnswer {\n    // Native\n    Deposit {\n        status: ResponseStatus,\n    },\n    Redeem {\n        status: ResponseStatus,\n    },\n\n    // Base\n    Transfer {\n        status: ResponseStatus,\n    },\n    Send {\n        status: ResponseStatus,\n    },\n    BatchTransfer {\n        status: ResponseStatus,\n    },\n    BatchSend {\n        status: ResponseStatus,\n    },\n    Burn {\n        status: ResponseStatus,\n    },\n    RegisterReceive {\n        status: ResponseStatus,\n    },\n    CreateViewingKey {\n        key: ViewingKey,\n    },\n    SetViewingKey {\n        status: ResponseStatus,\n    },\n\n    // Allowance\n    IncreaseAllowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n    },\n    DecreaseAllowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n    },\n    TransferFrom {\n        status: ResponseStatus,\n    },\n    SendFrom {\n        status: ResponseStatus,\n    },\n    BatchTransferFrom {\n        status: ResponseStatus,\n    },\n    BatchSendFrom {\n        status: ResponseStatus,\n    },\n    BurnFrom {\n        status: ResponseStatus,\n    },\n    BatchBurnFrom {\n        status: ResponseStatus,\n    },\n\n    // Mint\n    Mint {\n        status: ResponseStatus,\n    },\n    BatchMint {\n        status: ResponseStatus,\n    },\n    AddMinters {\n        status: ResponseStatus,\n    },\n    RemoveMinters {\n        status: ResponseStatus,\n    },\n    SetMinters {\n        status: ResponseStatus,\n    },\n\n    // Other\n    ChangeAdmin {\n        status: ResponseStatus,\n    },\n    SetContractStatus {\n        status: ResponseStatus,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    TokenInfo {},\n    TokenConfig {},\n    ContractStatus {},\n    ExchangeRate {},\n    Allowance {\n        owner: HumanAddr,\n        spender: HumanAddr,\n        key: String,\n    },\n    Balance {\n        address: HumanAddr,\n        key: String,\n    },\n    TransferHistory {\n        address: HumanAddr,\n        key: String,\n        page: Option\u003cu32\u003e,\n        page_size: u32,\n    },\n    TransactionHistory {\n        address: HumanAddr,\n        key: String,\n        page: Option\u003cu32\u003e,\n        page_size: u32,\n    },\n    Minters {},\n    LastUserIndex {\n        account: HumanAddr,\n    },\n    InterestedRedirectionAddress {\n        account: HumanAddr,\n    },\n    RedirectedBalance {\n        account: HumanAddr,\n    },\n    PrincpleBalanceOf {\n        address: HumanAddr,\n    },\n}\n\nimpl QueryMsg {\n    pub fn get_validation_params(\u0026self) -\u003e (Vec\u003c\u0026HumanAddr\u003e, ViewingKey) {\n        match self {\n            Self::Balance { address, key } =\u003e (vec![address], ViewingKey(key.clone())),\n            Self::TransferHistory { address, key, .. } =\u003e (vec![address], ViewingKey(key.clone())),\n            Self::TransactionHistory { address, key, .. } =\u003e {\n                (vec![address], ViewingKey(key.clone()))\n            }\n            Self::Allowance {\n                owner,\n                spender,\n                key,\n                ..\n            } =\u003e (vec![owner, spender], ViewingKey(key.clone())),\n            _ =\u003e panic!(\"This query type does not require authentication\"),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryAnswer {\n    TokenInfo {\n        name: String,\n        symbol: String,\n        decimals: u8,\n        total_supply: Option\u003cUint128\u003e,\n    },\n    TokenConfig {\n        public_total_supply: bool,\n        deposit_enabled: bool,\n        redeem_enabled: bool,\n        mint_enabled: bool,\n        burn_enabled: bool,\n    },\n    ContractStatus {\n        status: ContractStatusLevel,\n    },\n    ExchangeRate {\n        rate: Uint128,\n        denom: String,\n    },\n    Allowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n        expiration: Option\u003cu64\u003e,\n    },\n    Balance {\n        amount: Uint128,\n    },\n    TransferHistory {\n        txs: Vec\u003cTx\u003e,\n        total: Option\u003cu64\u003e,\n    },\n    TransactionHistory {\n        txs: Vec\u003cRichTx\u003e,\n        total: Option\u003cu64\u003e,\n    },\n    ViewingKeyError {\n        msg: String,\n    },\n    Minters {\n        minters: Vec\u003cHumanAddr\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct CreateViewingKeyResponse {\n    pub key: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ResponseStatus {\n    Success,\n    Failure,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ContractStatusLevel {\n    NormalRun,\n    StopAllButRedeems,\n    StopAll,\n}\n\npub fn status_level_to_u8(status_level: ContractStatusLevel) -\u003e u8 {\n    match status_level {\n        ContractStatusLevel::NormalRun =\u003e 0,\n        ContractStatusLevel::StopAllButRedeems =\u003e 1,\n        ContractStatusLevel::StopAll =\u003e 2,\n    }\n}\n\npub fn u8_to_status_level(status_level: u8) -\u003e StdResult\u003cContractStatusLevel\u003e {\n    match status_level {\n        0 =\u003e Ok(ContractStatusLevel::NormalRun),\n        1 =\u003e Ok(ContractStatusLevel::StopAllButRedeems),\n        2 =\u003e Ok(ContractStatusLevel::StopAll),\n        _ =\u003e Err(StdError::generic_err(\"Invalid state level\")),\n    }\n}\n\n// Take a Vec\u003cu8\u003e and pad it up to a multiple of `block_size`, using spaces at the end.\npub fn space_pad(block_size: usize, message: \u0026mut Vec\u003cu8\u003e) -\u003e \u0026mut Vec\u003cu8\u003e {\n    let len = message.len();\n    let surplus = len % block_size;\n    if surplus == 0 {\n        return message;\n    }\n\n    let missing = block_size - surplus;\n    message.reserve(missing);\n    message.extend(std::iter::repeat(b' ').take(missing));\n    message\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::{from_slice, StdResult};\n\n    #[derive(Serialize, Deserialize, JsonSchema, Debug, PartialEq)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum Something {\n        Var { padding: Option\u003cString\u003e },\n    }\n\n    #[test]\n    fn test_deserialization_of_missing_option_fields() -\u003e StdResult\u003c()\u003e {\n        let input = b\"{ \\\"var\\\": {} }\";\n        let obj: Something = from_slice(input)?;\n        assert_eq!(\n            obj,\n            Something::Var { padding: None },\n            \"unexpected value: {:?}\",\n            obj\n        );\n        Ok(())\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[7941881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[7942000],"length":1,"stats":{"Line":1},"fn_name":"public_total_supply"},{"line":60,"address":[7942009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[7942048],"length":1,"stats":{"Line":1},"fn_name":"deposit_enabled"},{"line":64,"address":[7942057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[7942096],"length":1,"stats":{"Line":1},"fn_name":"redeem_enabled"},{"line":68,"address":[7942105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[7942805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[7943472],"length":1,"stats":{"Line":1},"fn_name":"status_level_to_u8"},{"line":439,"address":[7943525,7943516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[7943520,7943483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":441,"address":[7943527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[7943511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[7943552],"length":1,"stats":{"Line":1},"fn_name":"u8_to_status_level"},{"line":447,"address":[7943638,7943664,7943651],"length":1,"stats":{"Line":3},"fn_name":null},{"line":448,"address":[7943631,7943576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":449,"address":[7943644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[7943657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[7943670,7943602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[7943712],"length":1,"stats":{"Line":1},"fn_name":"space_pad"},{"line":457,"address":[7943749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[7943770,7943963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[7943810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[7943821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[7943993,7943838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[7943872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[7943878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[7943948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[8860192,8860201,8860240,8860843],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":482,"address":[8860257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[8860272,8860467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[8860683,8860389,8860571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":490,"address":[8860651],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":42,"coverable":50},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","src","rand.rs"],"content":"use rand_chacha::ChaChaRng;\nuse rand_core::{RngCore, SeedableRng};\n\nuse sha2::{Digest, Sha256};\n\npub fn sha_256(data: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    let hash = hasher.finalize();\n\n    let mut result = [0u8; 32];\n    result.copy_from_slice(hash.as_slice());\n    result\n}\n\npub struct Prng {\n    rng: ChaChaRng,\n}\n\nimpl Prng {\n    pub fn new(seed: \u0026[u8], entropy: \u0026[u8]) -\u003e Self {\n        let mut hasher = Sha256::new();\n\n        // write input message\n        hasher.update(\u0026seed);\n        hasher.update(\u0026entropy);\n        let hash = hasher.finalize();\n\n        let mut hash_bytes = [0u8; 32];\n        hash_bytes.copy_from_slice(hash.as_slice());\n\n        let rng: ChaChaRng = ChaChaRng::from_seed(hash_bytes);\n\n        Self { rng }\n    }\n\n    pub fn rand_bytes(\u0026mut self) -\u003e [u8; 32] {\n        let mut bytes = [0u8; 32];\n        self.rng.fill_bytes(\u0026mut bytes);\n\n        bytes\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// This test checks that the rng is stateful and generates\n    /// different random bytes every time it is called.\n    #[test]\n    fn test_rng() {\n        let mut rng = Prng::new(b\"foo\", b\"bar!\");\n        let r1: [u8; 32] = [\n            155, 11, 21, 97, 252, 65, 160, 190, 100, 126, 85, 251, 47, 73, 160, 49, 216, 182, 93,\n            30, 185, 67, 166, 22, 34, 10, 213, 112, 21, 136, 49, 214,\n        ];\n        let r2: [u8; 32] = [\n            46, 135, 19, 242, 111, 125, 59, 215, 114, 130, 122, 155, 202, 23, 36, 118, 83, 11, 6,\n            180, 97, 165, 218, 136, 134, 243, 191, 191, 149, 178, 7, 149,\n        ];\n        let r3: [u8; 32] = [\n            9, 2, 131, 50, 199, 170, 6, 68, 168, 28, 242, 182, 35, 114, 15, 163, 65, 139, 101, 221,\n            207, 147, 119, 110, 81, 195, 6, 134, 14, 253, 245, 244,\n        ];\n        let r4: [u8; 32] = [\n            68, 196, 114, 205, 225, 64, 201, 179, 18, 77, 216, 197, 211, 13, 21, 196, 11, 102, 106,\n            195, 138, 250, 29, 185, 51, 38, 183, 0, 5, 169, 65, 190,\n        ];\n        assert_eq!(r1, rng.rand_bytes());\n        assert_eq!(r2, rng.rand_bytes());\n        assert_eq!(r3, rng.rand_bytes());\n        assert_eq!(r4, rng.rand_bytes());\n    }\n}\n","traces":[{"line":6,"address":[3820576],"length":1,"stats":{"Line":1},"fn_name":"sha_256"},{"line":7,"address":[3820619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[3820640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[3820651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[3820701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[3820722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2737792,2737760,2737765],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":53,"address":[2737799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2737834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[2738090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[2738346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[2738602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[2738858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[2739025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[2739192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[2739359],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":28},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","src","receiver.rs"],"content":"#![allow(clippy::field_reassign_with_default)] // This is triggered in `#[derive(JsonSchema)]`\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{to_binary, Binary, CosmosMsg, HumanAddr, StdResult, Uint128, WasmMsg};\n\nuse crate::{contract::RESPONSE_BLOCK_SIZE, msg::space_pad};\n\n/// Snip20ReceiveMsg should be de/serialized under `Receive()` variant in a HandleMsg\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct Snip20ReceiveMsg {\n    pub sender: HumanAddr,\n    pub from: HumanAddr,\n    pub amount: Uint128,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub memo: Option\u003cString\u003e,\n    pub msg: Option\u003cBinary\u003e,\n}\n\nimpl Snip20ReceiveMsg {\n    pub fn new(\n        sender: HumanAddr,\n        from: HumanAddr,\n        amount: Uint128,\n        memo: Option\u003cString\u003e,\n        msg: Option\u003cBinary\u003e,\n    ) -\u003e Self {\n        Self {\n            sender,\n            from,\n            amount,\n            memo,\n            msg,\n        }\n    }\n\n    /// serializes the message, and pads it to 256 bytes\n    pub fn into_binary(self) -\u003e StdResult\u003cBinary\u003e {\n        let msg = ReceiverHandleMsg::Receive(self);\n        let mut data = to_binary(\u0026msg)?;\n        space_pad(RESPONSE_BLOCK_SIZE, \u0026mut data.0);\n        Ok(data)\n    }\n\n    /// creates a cosmos_msg sending this struct to the named contract\n    pub fn into_cosmos_msg(\n        self,\n        callback_code_hash: String,\n        contract_addr: HumanAddr,\n    ) -\u003e StdResult\u003cCosmosMsg\u003e {\n        let msg = self.into_binary()?;\n        let execute = WasmMsg::Execute {\n            msg,\n            callback_code_hash,\n            contract_addr,\n            send: vec![],\n        };\n        Ok(execute.into())\n    }\n}\n\n// This is just a helper to properly serialize the above message\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\nenum ReceiverHandleMsg {\n    Receive(Snip20ReceiveMsg),\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","src","state.rs"],"content":"use std::any::type_name;\nuse std::convert::TryFrom;\n\nuse cosmwasm_std::Binary;\nuse cosmwasm_std::{CanonicalAddr, HumanAddr, ReadonlyStorage, StdError, StdResult, Storage};\nuse cosmwasm_storage::{PrefixedStorage, ReadonlyPrefixedStorage};\n\nuse secret_toolkit::storage::{TypedStore, TypedStoreMut};\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::msg::{status_level_to_u8, u8_to_status_level, ContractStatusLevel};\nuse crate::viewing_key::ViewingKey;\nuse serde::de::DeserializeOwned;\n\npub static CONFIG_KEY: \u0026[u8] = b\"config\";\npub const PREFIX_TXS: \u0026[u8] = b\"transfers\";\n\npub const KEY_CONSTANTS: \u0026[u8] = b\"constants\";\npub const KEY_TOTAL_SUPPLY: \u0026[u8] = b\"total_supply\";\npub const KEY_CONTRACT_STATUS: \u0026[u8] = b\"contract_status\";\npub const KEY_MINTERS: \u0026[u8] = b\"minters\";\npub const KEY_TX_COUNT: \u0026[u8] = b\"tx-count\";\n\npub const PREFIX_CONFIG: \u0026[u8] = b\"config\";\npub const PREFIX_BALANCES: \u0026[u8] = b\"balances\";\npub const PREFIX_ALLOWANCES: \u0026[u8] = b\"allowances\";\npub const PREFIX_VIEW_KEY: \u0026[u8] = b\"viewingkey\";\npub const PREFIX_RECEIVERS: \u0026[u8] = b\"receivers\";\npub const PREFIX_USER_INDEXIS: \u0026[u8] = b\"user_indexes\";\npub const INTERESTED_REDIRECTION_ADDRESS: \u0026[u8] = b\"interestRedirectionAddresses\";\npub const REDIRECTED_BALANCES: \u0026[u8] = b\"redirectedBalances\";\n\n// Config\n\n#[derive(Serialize, Debug, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct Constants {\n    pub name: String,\n    pub admin: HumanAddr,\n    pub symbol: String,\n    pub decimals: u8,\n    pub prng_seed: Vec\u003cu8\u003e,\n    // privacy configuration\n    pub total_supply_is_public: bool,\n    // is deposit enabled\n    pub deposit_is_enabled: bool,\n    // is redeem enabled\n    pub redeem_is_enabled: bool,\n    // is mint enabled\n    pub mint_is_enabled: bool,\n    // is burn enabled\n    pub burn_is_enabled: bool,\n}\n\npub struct ReadonlyConfig\u003c'a, S: ReadonlyStorage\u003e {\n    storage: ReadonlyPrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyConfig\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a S) -\u003e Self {\n        Self {\n            storage: ReadonlyPrefixedStorage::new(PREFIX_CONFIG, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyConfigImpl\u003cReadonlyPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyConfigImpl(\u0026self.storage)\n    }\n\n    pub fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        self.as_readonly().constants()\n    }\n\n    pub fn total_supply(\u0026self) -\u003e u128 {\n        self.as_readonly().total_supply()\n    }\n\n    pub fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        self.as_readonly().contract_status()\n    }\n\n    pub fn minters(\u0026self) -\u003e Vec\u003cHumanAddr\u003e {\n        self.as_readonly().minters()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        self.as_readonly().tx_count()\n    }\n}\n\nfn ser_bin_data\u003cT: Serialize\u003e(obj: \u0026T) -\u003e StdResult\u003cVec\u003cu8\u003e\u003e {\n    bincode2::serialize(\u0026obj).map_err(|e| StdError::serialize_err(type_name::\u003cT\u003e(), e))\n}\n\nfn deser_bin_data\u003cT: DeserializeOwned\u003e(data: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n    bincode2::deserialize::\u003cT\u003e(\u0026data).map_err(|e| StdError::serialize_err(type_name::\u003cT\u003e(), e))\n}\n\nfn set_bin_data\u003cT: Serialize, S: Storage\u003e(storage: \u0026mut S, key: \u0026[u8], data: \u0026T) -\u003e StdResult\u003c()\u003e {\n    let bin_data = ser_bin_data(data)?;\n\n    storage.set(key, \u0026bin_data);\n    Ok(())\n}\n\nfn get_bin_data\u003cT: DeserializeOwned, S: ReadonlyStorage\u003e(storage: \u0026S, key: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n    let bin_data = storage.get(key);\n\n    match bin_data {\n        None =\u003e Err(StdError::not_found(\"Key not found in storage\")),\n        Some(bin_data) =\u003e Ok(deser_bin_data(\u0026bin_data)?),\n    }\n}\n\npub struct Config\u003c'a, S: Storage\u003e {\n    storage: PrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: Storage\u003e Config\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a mut S) -\u003e Self {\n        Self {\n            storage: PrefixedStorage::new(PREFIX_CONFIG, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyConfigImpl\u003cPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyConfigImpl(\u0026self.storage)\n    }\n\n    pub fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        self.as_readonly().constants()\n    }\n\n    pub fn set_constants(\u0026mut self, constants: \u0026Constants) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_CONSTANTS, constants)\n    }\n\n    pub fn total_supply(\u0026self) -\u003e u128 {\n        self.as_readonly().total_supply()\n    }\n\n    pub fn set_total_supply(\u0026mut self, supply: u128) {\n        self.storage.set(KEY_TOTAL_SUPPLY, \u0026supply.to_be_bytes());\n    }\n\n    pub fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        self.as_readonly().contract_status()\n    }\n\n    pub fn set_contract_status(\u0026mut self, status: ContractStatusLevel) {\n        let status_u8 = status_level_to_u8(status);\n        self.storage\n            .set(KEY_CONTRACT_STATUS, \u0026status_u8.to_be_bytes());\n    }\n\n    pub fn set_minters(\u0026mut self, minters_to_set: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_MINTERS, \u0026minters_to_set)\n    }\n\n    pub fn add_minters(\u0026mut self, minters_to_add: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        let mut minters = self.minters();\n        minters.extend(minters_to_add);\n\n        self.set_minters(minters)\n    }\n\n    pub fn remove_minters(\u0026mut self, minters_to_remove: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        let mut minters = self.minters();\n\n        for minter in minters_to_remove {\n            minters.retain(|x| x != \u0026minter);\n        }\n\n        self.set_minters(minters)\n    }\n\n    pub fn minters(\u0026mut self) -\u003e Vec\u003cHumanAddr\u003e {\n        self.as_readonly().minters()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        self.as_readonly().tx_count()\n    }\n\n    pub fn set_tx_count(\u0026mut self, count: u64) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_TX_COUNT, \u0026count)\n    }\n}\n\n/// This struct refactors out the readonly methods that we need for `Config` and `ReadonlyConfig`\n/// in a way that is generic over their mutability.\n///\n/// This was the only way to prevent code duplication of these methods because of the way\n/// that `ReadonlyPrefixedStorage` and `PrefixedStorage` are implemented in `cosmwasm-std`\nstruct ReadonlyConfigImpl\u003c'a, S: ReadonlyStorage\u003e(\u0026'a S);\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyConfigImpl\u003c'a, S\u003e {\n    fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        let consts_bytes = self\n            .0\n            .get(KEY_CONSTANTS)\n            .ok_or_else(|| StdError::generic_err(\"no constants stored in configuration\"))?;\n        bincode2::deserialize::\u003cConstants\u003e(\u0026consts_bytes)\n            .map_err(|e| StdError::serialize_err(type_name::\u003cConstants\u003e(), e))\n    }\n\n    fn total_supply(\u0026self) -\u003e u128 {\n        let supply_bytes = self\n            .0\n            .get(KEY_TOTAL_SUPPLY)\n            .expect(\"no total supply stored in config\");\n        // This unwrap is ok because we know we stored things correctly\n        slice_to_u128(\u0026supply_bytes).unwrap()\n    }\n\n    fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        let supply_bytes = self\n            .0\n            .get(KEY_CONTRACT_STATUS)\n            .expect(\"no contract status stored in config\");\n\n        // These unwraps are ok because we know we stored things correctly\n        let status = slice_to_u8(\u0026supply_bytes).unwrap();\n        u8_to_status_level(status).unwrap()\n    }\n\n    fn minters(\u0026self) -\u003e Vec\u003cHumanAddr\u003e {\n        get_bin_data(self.0, KEY_MINTERS).unwrap()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        get_bin_data(self.0, KEY_TX_COUNT).unwrap_or_default()\n    }\n}\n\n// Balances\n\npub struct ReadonlyBalances\u003c'a, S: ReadonlyStorage\u003e {\n    storage: ReadonlyPrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyBalances\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a S) -\u003e Self {\n        Self {\n            storage: ReadonlyPrefixedStorage::new(PREFIX_BALANCES, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyBalancesImpl\u003cReadonlyPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyBalancesImpl(\u0026self.storage)\n    }\n\n    pub fn account_amount(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        self.as_readonly().account_amount(account)\n    }\n}\n\npub struct Balances\u003c'a, S: Storage\u003e {\n    storage: PrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: Storage\u003e Balances\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a mut S) -\u003e Self {\n        Self {\n            storage: PrefixedStorage::new(PREFIX_BALANCES, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyBalancesImpl\u003cPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyBalancesImpl(\u0026self.storage)\n    }\n\n    pub fn balance(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        self.as_readonly().account_amount(account)\n    }\n\n    pub fn set_account_balance(\u0026mut self, account: \u0026CanonicalAddr, amount: u128) {\n        self.storage.set(account.as_slice(), \u0026amount.to_be_bytes())\n    }\n}\n\n/// This struct refactors out the readonly methods that we need for `Balances` and `ReadonlyBalances`\n/// in a way that is generic over their mutability.\n///\n/// This was the only way to prevent code duplication of these methods because of the way\n/// that `ReadonlyPrefixedStorage` and `PrefixedStorage` are implemented in `cosmwasm-std`\nstruct ReadonlyBalancesImpl\u003c'a, S: ReadonlyStorage\u003e(\u0026'a S);\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyBalancesImpl\u003c'a, S\u003e {\n    pub fn account_amount(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        let account_bytes = account.as_slice();\n        let result = self.0.get(account_bytes);\n        match result {\n            // This unwrap is ok because we know we stored things correctly\n            Some(balance_bytes) =\u003e slice_to_u128(\u0026balance_bytes).unwrap(),\n            None =\u003e 0,\n        }\n    }\n}\n\n// Allowances\n\n#[derive(Serialize, Debug, Deserialize, Clone, PartialEq, Default, JsonSchema)]\npub struct Allowance {\n    pub amount: u128,\n    pub expiration: Option\u003cu64\u003e,\n}\n\npub fn read_allowance\u003cS: Storage\u003e(\n    store: \u0026S,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n) -\u003e StdResult\u003cAllowance\u003e {\n    let owner_store =\n        ReadonlyPrefixedStorage::multilevel(\u0026[PREFIX_ALLOWANCES, owner.as_slice()], store);\n    let owner_store = TypedStore::attach(\u0026owner_store);\n    let allowance = owner_store.may_load(spender.as_slice());\n    allowance.map(Option::unwrap_or_default)\n}\n\npub fn write_allowance\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n    allowance: Allowance,\n) -\u003e StdResult\u003c()\u003e {\n    let mut owner_store =\n        PrefixedStorage::multilevel(\u0026[PREFIX_ALLOWANCES, owner.as_slice()], store);\n    let mut owner_store = TypedStoreMut::attach(\u0026mut owner_store);\n\n    owner_store.store(spender.as_slice(), \u0026allowance)\n}\n\n// Viewing Keys\n\npub fn write_viewing_key\u003cS: Storage\u003e(store: \u0026mut S, owner: \u0026CanonicalAddr, key: \u0026ViewingKey) {\n    let mut balance_store = PrefixedStorage::new(PREFIX_VIEW_KEY, store);\n    balance_store.set(owner.as_slice(), \u0026key.to_hashed());\n}\n\npub fn read_viewing_key\u003cS: Storage\u003e(store: \u0026S, owner: \u0026CanonicalAddr) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n    let balance_store = ReadonlyPrefixedStorage::new(PREFIX_VIEW_KEY, store);\n    balance_store.get(owner.as_slice())\n}\n\n// Receiver Interface\n\npub fn get_receiver_hash\u003cS: ReadonlyStorage\u003e(\n    store: \u0026S,\n    account: \u0026HumanAddr,\n) -\u003e Option\u003cStdResult\u003cString\u003e\u003e {\n    let store = ReadonlyPrefixedStorage::new(PREFIX_RECEIVERS, store);\n    store.get(account.as_str().as_bytes()).map(|data| {\n        String::from_utf8(data)\n            .map_err(|_err| StdError::invalid_utf8(\"stored code hash was not a valid String\"))\n    })\n}\n\npub fn set_receiver_hash\u003cS: Storage\u003e(store: \u0026mut S, account: \u0026HumanAddr, code_hash: String) {\n    let mut store = PrefixedStorage::new(PREFIX_RECEIVERS, store);\n    store.set(account.as_str().as_bytes(), code_hash.as_bytes());\n}\n\n// Helpers\n\n/// Converts 16 bytes value into u128\n/// Errors if data found that is not 16 bytes\nfn slice_to_u128(data: \u0026[u8]) -\u003e StdResult\u003cu128\u003e {\n    match \u003c[u8; 16]\u003e::try_from(data) {\n        Ok(bytes) =\u003e Ok(u128::from_be_bytes(bytes)),\n        Err(_) =\u003e Err(StdError::generic_err(\n            \"Corrupted data found. 16 byte expected.\",\n        )),\n    }\n}\n\n/// Converts 1 byte value into u8\n/// Errors if data found that is not 1 byte\nfn slice_to_u8(data: \u0026[u8]) -\u003e StdResult\u003cu8\u003e {\n    if data.len() == 1 {\n        Ok(data[0])\n    } else {\n        Err(StdError::generic_err(\n            \"Corrupted data found. 1 byte expected.\",\n        ))\n    }\n}\n// Get user index inteface\npub fn get_user_index\u003cS: ReadonlyStorage\u003e(storage: \u0026S, account: \u0026HumanAddr) -\u003e Option\u003cBinary\u003e {\n    let store = ReadonlyPrefixedStorage::new(PREFIX_USER_INDEXIS, storage);\n    let result = store.get(account.as_str().as_bytes())?;\n    Some(Binary::from(result.as_slice()))\n}\n\n// Get interested redirection address\npub fn get_interested_redirection_address\u003cS: ReadonlyStorage\u003e(\n    storage: \u0026S,\n    account: \u0026HumanAddr,\n) -\u003e Option\u003cBinary\u003e {\n    let store = ReadonlyPrefixedStorage::new(INTERESTED_REDIRECTION_ADDRESS, storage);\n    let result = store.get(account.as_str().as_bytes())?;\n    Some(Binary::from(result.as_slice()))\n}\n\n// Get the total redirected balance\npub fn get_redirection_balance\u003cS: ReadonlyStorage\u003e(\n    storage: \u0026S,\n    account: \u0026HumanAddr,\n) -\u003e Option\u003cBinary\u003e {\n    let store = ReadonlyPrefixedStorage::new(REDIRECTED_BALANCES, storage);\n    let result = store.get(account.as_str().as_bytes())?;\n    Some(Binary::from(result.as_slice()))\n}\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1787152,1787216,1787280],"length":1,"stats":{"Line":3},"fn_name":"ser_bin_data\u003cu64\u003e"},{"line":93,"address":[1787488,1787170,1787298,1787362,1787234,1787344,1787632,1787650,1787506],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003catoken::state::Constants\u003e"},{"line":96,"address":[1787776,1787856],"length":1,"stats":{"Line":2},"fn_name":"deser_bin_data\u003calloc::vec::Vec\u003ccosmwasm_std::addresses::HumanAddr, alloc::alloc::Global\u003e\u003e"},{"line":97,"address":[1787986,1787968,1788130,1787800,1788112,1787880],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003calloc::vec::Vec\u003ccosmwasm_std::addresses::HumanAddr, alloc::alloc::Global\u003e\u003e"},{"line":100,"address":[1788688,1789069,1789120,1789501,1788256,1788637],"length":1,"stats":{"Line":3},"fn_name":"set_bin_data\u003cu64,cosmwasm_storage::prefixed_storage::PrefixedStorage\u003ccosmwasm_std::storage::MemoryStorage\u003e\u003e"},{"line":101,"address":[1788462,1788333,1788894,1789197,1788765,1789326],"length":1,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[1788431,1789295,1789015,1788863,1788583,1789447],"length":1,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[1789027,1788595,1789459],"length":1,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[1791722,1790151,1790224,1789552,1790938,1791008],"length":1,"stats":{"Line":2},"fn_name":"get_bin_data\u003cu64,cosmwasm_storage::prefixed_storage::PrefixedStorage\u003ccosmwasm_std::storage::MemoryStorage\u003e\u003e"},{"line":108,"address":[1791049,1790265,1789593],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[1791137,1791197,1789741,1790413,1789681,1790353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1789603,1789683,1790275,1790355,1791059,1791139],"length":1,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[1790149,1790293,1790435,1790131,1790936,1790918,1791077,1791702,1789621,1791219,1791720,1789763],"length":1,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[1797730,1797328],"length":1,"stats":{"Line":1},"fn_name":"read_allowance\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":315,"address":[1797392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[1797488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[1797521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[1797586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[1797776,1798067],"length":1,"stats":{"Line":1},"fn_name":"write_allowance\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":328,"address":[1797845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[1797941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[1797974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[1798300,1798112],"length":1,"stats":{"Line":1},"fn_name":"write_viewing_key\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":338,"address":[1798150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[1798177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[1798352,1798493],"length":1,"stats":{"Line":1},"fn_name":"read_viewing_key\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":343,"address":[1798384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[1798411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[1798765,1798528],"length":1,"stats":{"Line":1},"fn_name":"get_receiver_hash\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":353,"address":[1798566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[1798708,1798912,1798593],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":355,"address":[1798926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[1798832,1798816],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":360,"address":[1798992,1799281],"length":1,"stats":{"Line":1},"fn_name":"set_receiver_hash\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":361,"address":[1799025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[1799054,1799174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":369,"address":[1799344],"length":1,"stats":{"Line":1},"fn_name":"slice_to_u128"},{"line":370,"address":[1799377,1799501,1799424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[1799388,1799426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":372,"address":[1799399,1799508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[1799552],"length":1,"stats":{"Line":1},"fn_name":"slice_to_u8"},{"line":381,"address":[1799611,1799695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[1799638,1799687,1799747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":384,"address":[1799652,1799702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[1800262,1799776],"length":1,"stats":{"Line":0},"fn_name":"get_user_index\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":391,"address":[1799817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[1799962,1800108,1799844,1800277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[1800076,1800155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[1800352,1800838],"length":1,"stats":{"Line":0},"fn_name":"get_interested_redirection_address\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":401,"address":[1800393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[1800684,1800853,1800420,1800538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[1800731,1800652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[1801414,1800928],"length":1,"stats":{"Line":0},"fn_name":"get_redirection_balance\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":411,"address":[1800969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[1801114,1801429,1801260,1800996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[1801307,1801228],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":119,"coverable":147},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","src","transaction_history.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{\n    Api, CanonicalAddr, Coin, HumanAddr, ReadonlyStorage, StdError, StdResult, Storage, Uint128,\n};\nuse cosmwasm_storage::{PrefixedStorage, ReadonlyPrefixedStorage};\n\nuse secret_toolkit::storage::{AppendStore, AppendStoreMut};\n\nuse crate::state::Config;\n\nconst PREFIX_TXS: \u0026[u8] = b\"transactions\";\nconst PREFIX_TRANSFERS: \u0026[u8] = b\"transfers\";\n\n// Note that id is a globally incrementing counter.\n// Since it's 64 bits long, even at 50 tx/s it would take\n// over 11 billion years for it to rollback. I'm pretty sure\n// we'll have bigger issues by then.\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\npub struct Tx {\n    pub id: u64,\n    pub from: HumanAddr,\n    pub sender: HumanAddr,\n    pub receiver: HumanAddr,\n    pub coins: Coin,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub memo: Option\u003cString\u003e,\n    // The block time and block height are optional so that the JSON schema\n    // reflects that some SNIP-20 contracts may not include this info.\n    pub block_time: Option\u003cu64\u003e,\n    pub block_height: Option\u003cu64\u003e,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum TxAction {\n    Transfer {\n        from: HumanAddr,\n        sender: HumanAddr,\n        recipient: HumanAddr,\n    },\n    Mint {\n        minter: HumanAddr,\n        recipient: HumanAddr,\n    },\n    Burn {\n        burner: HumanAddr,\n        owner: HumanAddr,\n    },\n    Deposit {},\n    Redeem {},\n}\n\n// Note that id is a globally incrementing counter.\n// Since it's 64 bits long, even at 50 tx/s it would take\n// over 11 billion years for it to rollback. I'm pretty sure\n// we'll have bigger issues by then.\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub struct RichTx {\n    pub id: u64,\n    pub action: TxAction,\n    pub coins: Coin,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub memo: Option\u003cString\u003e,\n    pub block_time: u64,\n    pub block_height: u64,\n}\n\n// Stored types:\n\n/// This type is the stored version of the legacy transfers\n#[derive(Serialize, Deserialize, Clone, Debug)]\n#[serde(rename_all = \"snake_case\")]\nstruct StoredLegacyTransfer {\n    id: u64,\n    from: CanonicalAddr,\n    sender: CanonicalAddr,\n    receiver: CanonicalAddr,\n    coins: Coin,\n    memo: Option\u003cString\u003e,\n    block_time: u64,\n    block_height: u64,\n}\n\nimpl StoredLegacyTransfer {\n    pub fn into_humanized\u003cA: Api\u003e(self, api: \u0026A) -\u003e StdResult\u003cTx\u003e {\n        let tx = Tx {\n            id: self.id,\n            from: api.human_address(\u0026self.from)?,\n            sender: api.human_address(\u0026self.sender)?,\n            receiver: api.human_address(\u0026self.receiver)?,\n            coins: self.coins,\n            memo: self.memo,\n            block_time: Some(self.block_time),\n            block_height: Some(self.block_height),\n        };\n        Ok(tx)\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\n#[repr(u8)]\nenum TxCode {\n    Transfer = 0,\n    Mint = 1,\n    Burn = 2,\n    Deposit = 3,\n    Redeem = 4,\n}\n\nimpl TxCode {\n    fn to_u8(self) -\u003e u8 {\n        self as u8\n    }\n\n    fn from_u8(n: u8) -\u003e StdResult\u003cSelf\u003e {\n        use TxCode::*;\n        match n {\n            0 =\u003e Ok(Transfer),\n            1 =\u003e Ok(Mint),\n            2 =\u003e Ok(Burn),\n            3 =\u003e Ok(Deposit),\n            4 =\u003e Ok(Redeem),\n            other =\u003e Err(StdError::generic_err(format!(\n                \"Unexpected Tx code in transaction history: {} Storage is corrupted.\",\n                other\n            ))),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\n#[serde(rename_all = \"snake_case\")]\nstruct StoredTxAction {\n    tx_type: u8,\n    address1: Option\u003cCanonicalAddr\u003e,\n    address2: Option\u003cCanonicalAddr\u003e,\n    address3: Option\u003cCanonicalAddr\u003e,\n}\n\nimpl StoredTxAction {\n    fn transfer(from: CanonicalAddr, sender: CanonicalAddr, recipient: CanonicalAddr) -\u003e Self {\n        Self {\n            tx_type: TxCode::Transfer.to_u8(),\n            address1: Some(from),\n            address2: Some(sender),\n            address3: Some(recipient),\n        }\n    }\n    fn mint(minter: CanonicalAddr, recipient: CanonicalAddr) -\u003e Self {\n        Self {\n            tx_type: TxCode::Mint.to_u8(),\n            address1: Some(minter),\n            address2: Some(recipient),\n            address3: None,\n        }\n    }\n    fn burn(owner: CanonicalAddr, burner: CanonicalAddr) -\u003e Self {\n        Self {\n            tx_type: TxCode::Burn.to_u8(),\n            address1: Some(owner),\n            address2: Some(burner),\n            address3: None,\n        }\n    }\n    fn deposit() -\u003e Self {\n        Self {\n            tx_type: TxCode::Deposit.to_u8(),\n            address1: None,\n            address2: None,\n            address3: None,\n        }\n    }\n    fn redeem() -\u003e Self {\n        Self {\n            tx_type: TxCode::Redeem.to_u8(),\n            address1: None,\n            address2: None,\n            address3: None,\n        }\n    }\n\n    fn into_humanized\u003cA: Api\u003e(self, api: \u0026A) -\u003e StdResult\u003cTxAction\u003e {\n        let transfer_addr_err = || {\n            StdError::generic_err(\n                \"Missing address in stored Transfer transaction. Storage is corrupt\",\n            )\n        };\n        let mint_addr_err = || {\n            StdError::generic_err(\"Missing address in stored Mint transaction. Storage is corrupt\")\n        };\n        let burn_addr_err = || {\n            StdError::generic_err(\"Missing address in stored Burn transaction. Storage is corrupt\")\n        };\n\n        // In all of these, we ignore fields that we don't expect to find populated\n        let action = match TxCode::from_u8(self.tx_type)? {\n            TxCode::Transfer =\u003e {\n                let from = self.address1.ok_or_else(transfer_addr_err)?;\n                let sender = self.address2.ok_or_else(transfer_addr_err)?;\n                let recipient = self.address3.ok_or_else(transfer_addr_err)?;\n                let from = api.human_address(\u0026from)?;\n                let sender = api.human_address(\u0026sender)?;\n                let recipient = api.human_address(\u0026recipient)?;\n                TxAction::Transfer {\n                    from,\n                    sender,\n                    recipient,\n                }\n            }\n            TxCode::Mint =\u003e {\n                let minter = self.address1.ok_or_else(mint_addr_err)?;\n                let recipient = self.address2.ok_or_else(mint_addr_err)?;\n                let minter = api.human_address(\u0026minter)?;\n                let recipient = api.human_address(\u0026recipient)?;\n                TxAction::Mint { minter, recipient }\n            }\n            TxCode::Burn =\u003e {\n                let burner = self.address1.ok_or_else(burn_addr_err)?;\n                let owner = self.address2.ok_or_else(burn_addr_err)?;\n                let burner = api.human_address(\u0026burner)?;\n                let owner = api.human_address(\u0026owner)?;\n                TxAction::Burn { burner, owner }\n            }\n            TxCode::Deposit =\u003e TxAction::Deposit {},\n            TxCode::Redeem =\u003e TxAction::Redeem {},\n        };\n\n        Ok(action)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\n#[serde(rename_all = \"snake_case\")]\nstruct StoredRichTx {\n    id: u64,\n    action: StoredTxAction,\n    coins: Coin,\n    memo: Option\u003cString\u003e,\n    block_time: u64,\n    block_height: u64,\n}\n\nimpl StoredRichTx {\n    fn new(\n        id: u64,\n        action: StoredTxAction,\n        coins: Coin,\n        memo: Option\u003cString\u003e,\n        block: \u0026cosmwasm_std::BlockInfo,\n    ) -\u003e Self {\n        Self {\n            id,\n            action,\n            coins,\n            memo,\n            block_time: block.time,\n            block_height: block.height,\n        }\n    }\n\n    fn into_humanized\u003cA: Api\u003e(self, api: \u0026A) -\u003e StdResult\u003cRichTx\u003e {\n        Ok(RichTx {\n            id: self.id,\n            action: self.action.into_humanized(api)?,\n            coins: self.coins,\n            memo: self.memo,\n            block_time: self.block_time,\n            block_height: self.block_height,\n        })\n    }\n\n    fn from_stored_legacy_transfer(transfer: StoredLegacyTransfer) -\u003e Self {\n        let action = StoredTxAction::transfer(transfer.from, transfer.sender, transfer.receiver);\n        Self {\n            id: transfer.id,\n            action,\n            coins: transfer.coins,\n            memo: transfer.memo,\n            block_time: transfer.block_time,\n            block_height: transfer.block_height,\n        }\n    }\n}\n\n// Storage functions:\n\nfn increment_tx_count\u003cS: Storage\u003e(store: \u0026mut S) -\u003e StdResult\u003cu64\u003e {\n    let mut config = Config::from_storage(store);\n    let id = config.tx_count() + 1;\n    config.set_tx_count(id)?;\n    Ok(id)\n}\n\n#[allow(clippy::too_many_arguments)] // We just need them\npub fn store_transfer\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    owner: \u0026CanonicalAddr,\n    sender: \u0026CanonicalAddr,\n    receiver: \u0026CanonicalAddr,\n    amount: Uint128,\n    denom: String,\n    memo: Option\u003cString\u003e,\n    block: \u0026cosmwasm_std::BlockInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let id = increment_tx_count(store)?;\n    let coins = Coin { denom, amount };\n    let transfer = StoredLegacyTransfer {\n        id,\n        from: owner.clone(),\n        sender: sender.clone(),\n        receiver: receiver.clone(),\n        coins,\n        memo,\n        block_time: block.time,\n        block_height: block.height,\n    };\n    let tx = StoredRichTx::from_stored_legacy_transfer(transfer.clone());\n\n    if owner != sender {\n        cosmwasm_std::debug_print(\"saving transaction history for owner\");\n        append_tx(store, \u0026tx, owner)?;\n        append_transfer(store, \u0026transfer, owner)?;\n    }\n    cosmwasm_std::debug_print(\"saving transaction history for sender\");\n    append_tx(store, \u0026tx, sender)?;\n    append_transfer(store, \u0026transfer, sender)?;\n    cosmwasm_std::debug_print(\"saving transaction history for receiver\");\n    append_tx(store, \u0026tx, receiver)?;\n    append_transfer(store, \u0026transfer, receiver)?;\n\n    Ok(())\n}\n\npub fn store_mint\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    minter: \u0026CanonicalAddr,\n    recipient: \u0026CanonicalAddr,\n    amount: Uint128,\n    denom: String,\n    memo: Option\u003cString\u003e,\n    block: \u0026cosmwasm_std::BlockInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let id = increment_tx_count(store)?;\n    let coins = Coin { denom, amount };\n    let action = StoredTxAction::mint(minter.clone(), recipient.clone());\n    let tx = StoredRichTx::new(id, action, coins, memo, block);\n\n    if minter != recipient {\n        append_tx(store, \u0026tx, recipient)?;\n    }\n    append_tx(store, \u0026tx, minter)?;\n\n    Ok(())\n}\n\npub fn store_burn\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    owner: \u0026CanonicalAddr,\n    burner: \u0026CanonicalAddr,\n    amount: Uint128,\n    denom: String,\n    memo: Option\u003cString\u003e,\n    block: \u0026cosmwasm_std::BlockInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let id = increment_tx_count(store)?;\n    let coins = Coin { denom, amount };\n    let action = StoredTxAction::burn(owner.clone(), burner.clone());\n    let tx = StoredRichTx::new(id, action, coins, memo, block);\n\n    if burner != owner {\n        append_tx(store, \u0026tx, owner)?;\n    }\n    append_tx(store, \u0026tx, burner)?;\n\n    Ok(())\n}\n\npub fn store_deposit\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    recipient: \u0026CanonicalAddr,\n    amount: Uint128,\n    denom: String,\n    block: \u0026cosmwasm_std::BlockInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let id = increment_tx_count(store)?;\n    let coins = Coin { denom, amount };\n    let action = StoredTxAction::deposit();\n    let tx = StoredRichTx::new(id, action, coins, None, block);\n\n    append_tx(store, \u0026tx, recipient)?;\n\n    Ok(())\n}\n\npub fn store_redeem\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    redeemer: \u0026CanonicalAddr,\n    amount: Uint128,\n    denom: String,\n    block: \u0026cosmwasm_std::BlockInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let id = increment_tx_count(store)?;\n    let coins = Coin { denom, amount };\n    let action = StoredTxAction::redeem();\n    let tx = StoredRichTx::new(id, action, coins, None, block);\n\n    append_tx(store, \u0026tx, redeemer)?;\n\n    Ok(())\n}\n\nfn append_tx\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    tx: \u0026StoredRichTx,\n    for_address: \u0026CanonicalAddr,\n) -\u003e StdResult\u003c()\u003e {\n    let mut store = PrefixedStorage::multilevel(\u0026[PREFIX_TXS, for_address.as_slice()], store);\n    let mut store = AppendStoreMut::attach_or_create(\u0026mut store)?;\n    store.push(tx)\n}\n\nfn append_transfer\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    tx: \u0026StoredLegacyTransfer,\n    for_address: \u0026CanonicalAddr,\n) -\u003e StdResult\u003c()\u003e {\n    let mut store = PrefixedStorage::multilevel(\u0026[PREFIX_TRANSFERS, for_address.as_slice()], store);\n    let mut store = AppendStoreMut::attach_or_create(\u0026mut store)?;\n    store.push(tx)\n}\n\npub fn get_txs\u003cA: Api, S: ReadonlyStorage\u003e(\n    api: \u0026A,\n    storage: \u0026S,\n    for_address: \u0026CanonicalAddr,\n    page: u32,\n    page_size: u32,\n) -\u003e StdResult\u003c(Vec\u003cRichTx\u003e, u64)\u003e {\n    let store = ReadonlyPrefixedStorage::multilevel(\u0026[PREFIX_TXS, for_address.as_slice()], storage);\n\n    // Try to access the storage of txs for the account.\n    // If it doesn't exist yet, return an empty list of transfers.\n    let store = AppendStore::\u003cStoredRichTx, _, _\u003e::attach(\u0026store);\n    let store = if let Some(result) = store {\n        result?\n    } else {\n        return Ok((vec![], 0));\n    };\n\n    // Take `page_size` txs starting from the latest tx, potentially skipping `page * page_size`\n    // txs from the start.\n    let tx_iter = store\n        .iter()\n        .rev()\n        .skip((page * page_size) as _)\n        .take(page_size as _);\n\n    // The `and_then` here flattens the `StdResult\u003cStdResult\u003cRichTx\u003e\u003e` to an `StdResult\u003cRichTx\u003e`\n    let txs: StdResult\u003cVec\u003cRichTx\u003e\u003e = tx_iter\n        .map(|tx| tx.map(|tx| tx.into_humanized(api)).and_then(|x| x))\n        .collect();\n    txs.map(|txs| (txs, store.len() as u64))\n}\n\npub fn get_transfers\u003cA: Api, S: ReadonlyStorage\u003e(\n    api: \u0026A,\n    storage: \u0026S,\n    for_address: \u0026CanonicalAddr,\n    page: u32,\n    page_size: u32,\n) -\u003e StdResult\u003c(Vec\u003cTx\u003e, u64)\u003e {\n    let store =\n        ReadonlyPrefixedStorage::multilevel(\u0026[PREFIX_TRANSFERS, for_address.as_slice()], storage);\n\n    // Try to access the storage of transfers for the account.\n    // If it doesn't exist yet, return an empty list of transfers.\n    let store = AppendStore::\u003cStoredLegacyTransfer, _, _\u003e::attach(\u0026store);\n    let store = if let Some(result) = store {\n        result?\n    } else {\n        return Ok((vec![], 0));\n    };\n\n    // Take `page_size` txs starting from the latest tx, potentially skipping `page * page_size`\n    // txs from the start.\n    let transfer_iter = store\n        .iter()\n        .rev()\n        .skip((page * page_size) as _)\n        .take(page_size as _);\n\n    // The `and_then` here flattens the `StdResult\u003cStdResult\u003cRichTx\u003e\u003e` to an `StdResult\u003cRichTx\u003e`\n    let transfers: StdResult\u003cVec\u003cTx\u003e\u003e = transfer_iter\n        .map(|tx| tx.map(|tx| tx.into_humanized(api)).and_then(|x| x))\n        .collect();\n    transfers.map(|txs| (txs, store.len() as u64))\n}\n","traces":[{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[621329,620880],"length":1,"stats":{"Line":1},"fn_name":"increment_tx_count\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":291,"address":[620905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[621368,620920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[621344,620984,621067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[621041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[624740,621424],"length":1,"stats":{"Line":1},"fn_name":"store_transfer\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":308,"address":[621572,621815,624824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[621705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[621792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[622058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[622091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[622203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[622200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[622423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[622515,622929,622463],"length":1,"stats":{"Line":3},"fn_name":null},{"line":324,"address":[624794,622525,622636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[624792,622605,622934,622898],"length":1,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[624790,623212,623323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[623648,623585,624788,623292],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[624010,624786,623920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[624272,624333,624784,624000],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[624308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[625216,626944],"length":1,"stats":{"Line":1},"fn_name":"store_mint\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":346,"address":[627048,625588,625337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[625478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[625831,625565,626992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[625921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[626193,626137,626245],"length":1,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[626250,626214,626165,626990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[626606,626988,626501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[626581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[629024,627296],"length":1,"stats":{"Line":1},"fn_name":"store_burn\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":368,"address":[627668,627417,629128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[627558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[629072,627911,627645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[628001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[628273,628217,628325],"length":1,"stats":{"Line":3},"fn_name":null},{"line":374,"address":[629070,628330,628294,628245],"length":1,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[629068,628581,628686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[628661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[630552,629376],"length":1,"stats":{"Line":1},"fn_name":"store_deposit\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":388,"address":[629474,629696,630610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[629591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[629686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[629943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[630580,630156,630240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[630215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[630768,631944],"length":1,"stats":{"Line":1},"fn_name":"store_redeem\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":405,"address":[630866,631088,632002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[630983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[631078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[631335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[631972,631632,631548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[631607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[632160,632725],"length":1,"stats":{"Line":1},"fn_name":"append_tx\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":420,"address":[632224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[632740,632319,632439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[632429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[633365,632800],"length":1,"stats":{"Line":1},"fn_name":"append_transfer\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":430,"address":[632864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[632959,633079,633380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[633069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[633440,634822],"length":1,"stats":{"Line":1},"fn_name":"get_txs\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":442,"address":[633522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[633631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[633697,633646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[634008,633801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[634259,633687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[633998,634451,634395,634482],"length":1,"stats":{"Line":4},"fn_name":null},{"line":458,"address":[635019,634410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[634462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[634550,634489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[635056,635184,635225,635152,635164,635099,634542],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":465,"address":[634609,635361,635328],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":468,"address":[635488,636870],"length":1,"stats":{"Line":1},"fn_name":"get_transfers\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":475,"address":[635570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[635679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[635694,635745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":482,"address":[636056,635849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[636307,635735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[636443,636530,636046,636499],"length":1,"stats":{"Line":4},"fn_name":null},{"line":492,"address":[636458,637067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[636510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[636598,636537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":497,"address":[637145,637212,637104,637232,637200,636590,637273],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":499,"address":[637409,637376,636657],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"}],"covered":156,"coverable":166},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","src","utils.rs"],"content":"use crate::viewing_key::VIEWING_KEY_SIZE;\nuse sha2::{Digest, Sha256};\nuse std::convert::TryInto;\nuse subtle::ConstantTimeEq;\n\npub fn ct_slice_compare(s1: \u0026[u8], s2: \u0026[u8]) -\u003e bool {\n    bool::from(s1.ct_eq(s2))\n}\n\npub fn create_hashed_password(s1: \u0026str) -\u003e [u8; VIEWING_KEY_SIZE] {\n    Sha256::digest(s1.as_bytes())\n        .as_slice()\n        .try_into()\n        .expect(\"Wrong password length\")\n}\n","traces":[{"line":6,"address":[2951536],"length":1,"stats":{"Line":1},"fn_name":"ct_slice_compare"},{"line":7,"address":[2951560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[2951600],"length":1,"stats":{"Line":1},"fn_name":"create_hashed_password"},{"line":11,"address":[2951698],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","src","viewing_key.rs"],"content":"use std::fmt;\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::Env;\n\nuse crate::rand::{sha_256, Prng};\nuse crate::utils::{create_hashed_password, ct_slice_compare};\n\npub const VIEWING_KEY_SIZE: usize = 32;\npub const VIEWING_KEY_PREFIX: \u0026str = \"api_key_\";\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\npub struct ViewingKey(pub String);\n\nimpl ViewingKey {\n    pub fn check_viewing_key(\u0026self, hashed_pw: \u0026[u8]) -\u003e bool {\n        let mine_hashed = create_hashed_password(\u0026self.0);\n\n        ct_slice_compare(\u0026mine_hashed, hashed_pw)\n    }\n\n    pub fn new(env: \u0026Env, seed: \u0026[u8], entropy: \u0026[u8]) -\u003e Self {\n        // 16 here represents the lengths in bytes of the block height and time.\n        let entropy_len = 16 + env.message.sender.len() + entropy.len();\n        let mut rng_entropy = Vec::with_capacity(entropy_len);\n        rng_entropy.extend_from_slice(\u0026env.block.height.to_be_bytes());\n        rng_entropy.extend_from_slice(\u0026env.block.time.to_be_bytes());\n        rng_entropy.extend_from_slice(\u0026env.message.sender.0.as_bytes());\n        rng_entropy.extend_from_slice(entropy);\n\n        let mut rng = Prng::new(seed, \u0026rng_entropy);\n\n        let rand_slice = rng.rand_bytes();\n\n        let key = sha_256(\u0026rand_slice);\n\n        Self(VIEWING_KEY_PREFIX.to_string() + \u0026base64::encode(key))\n    }\n\n    pub fn to_hashed(\u0026self) -\u003e [u8; VIEWING_KEY_SIZE] {\n        create_hashed_password(\u0026self.0)\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        self.0.as_bytes()\n    }\n}\n\nimpl fmt::Display for ViewingKey {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[2736237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[2736282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2736320,2737265],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":26,"address":[2736416,2737308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2736533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":20},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-atoken-experimental","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests.\n//! 1. First copy them over verbatum,\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-configuration","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse configuration::msg::{HandleMsg, InitMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-configuration","src","contract.rs"],"content":"use cosmwasm_std::{\n    debug_print, to_binary, Api, Binary, Env, Extern, HandleResponse, InitResponse, Querier,\n    QueryResult, StdError, StdResult, Storage,\n};\n\nuse crate::{\n    msg::{HandleMsg, InitMsg, QueryMsg},\n    state,\n};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    Ok(HandleResponse::default())\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::GetAddress { key } =\u003e query_get_address(\u0026deps, \u0026key),\n        QueryMsg::GetUint { key } =\u003e query_get_unit(\u0026deps, \u0026key),\n    }\n}\n\npub fn query_get_address\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    key: \u0026[u8],\n) -\u003e QueryResult {\n    match state::get_address(\u0026deps.storage, key) {\n        Some(data) =\u003e Ok(data),\n        None =\u003e Err(StdError::generic_err(\n            \"Сouldn't find address in address storage\",\n        )),\n    }\n}\n\npub fn query_get_unit\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    key: \u0026[u8],\n) -\u003e QueryResult {\n    match state::get_uint(\u0026deps.storage, key) {\n        Some(data) =\u003e Ok(data),\n        None =\u003e Err(StdError::generic_err(\"Сouldn't find in address storage\")),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-configuration","src","lending_pool_addresses_provider.rs"],"content":"use cosmwasm_std::{Binary, HumanAddr, ReadonlyStorage, Storage};\n\nuse crate::state::get_address;\n\npub const LENDING_POOL: \u0026[u8] = b\"LENDING_POOL\";\npub const LENDING_POOL_CORE: \u0026[u8] = b\"LENDING_POOL_CORE\";\npub const LENDING_POOL_CONFIGURATOR: \u0026[u8] = b\"LENDING_POOL_CONFIGURATOR\";\npub const LENDING_POOL_PARAMETETRS_PROVIDER: \u0026[u8] = b\"PARAMETRS_PROVIDER\";\npub const LENDING_POOL_MANAGER: \u0026[u8] = b\"LENDING_POOL_MANAGER\";\npub const LENDING_POOL_LIQUIDATION_MANAGER: \u0026[u8] = b\"LIQUIDATION_MANAGER\";\npub const LENDING_POOL_FLASHLOAN_PROVIDER: \u0026[u8] = b\"FLASHLOAN_PROVIDER\";\npub const DATA_PROVIDER: \u0026[u8] = b\"DATA_PROVIDER\";\npub const ETHEREUM_ADDRESS: \u0026[u8] = b\"ETHEREUM_ADDRESS\";\npub const PRICE_ORACLE: \u0026[u8] = b\"PRICE_ORACLE\";\npub const LENDING_RATE_ORACLE: \u0026[u8] = b\"LENDING_RATE_ORACLE\";\npub const FEE_PROVIDER: \u0026[u8] = b\"FEE_PROVIDER\";\npub const WALLET_BALANCE_PROVIDER: \u0026[u8] = b\"WALLET_BALANCE_PROVIDER\";\npub const TOKEN_DISTRIBUTOR: \u0026[u8] = b\"TOKEN_DISTRIBUTOR\";\n\n/**\n * @dev returns the address of the LendingPool proxy\n * @return the lending pool proxy address\n **/\npub fn get_lending_pool\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e Option\u003cBinary\u003e {\n    let res = get_address(storage, LENDING_POOL)?;\n    Some(res)\n}\n\n/**\n * @dev internal function to update the implementation of a specific component of the protocol\n * @param _id the id of the contract to be updated\n * @param _newAddress the address of the new implementation\n **/\npub fn update_impl_internal\u003cS: Storage\u003e(storage: \u0026mut S, _id: \u0026[u8], address: \u0026HumanAddr) {\n    // unimplemented!\n    let proxy_address = get_address(storage, _id);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-configuration","src","lending_pool_core.rs"],"content":"use cosmwasm_std::{Env, HumanAddr, ReadonlyStorage, Storage};\nuse cosmwasm_storage::{Bucket, ReadonlyBucket, bucket, bucket_read};\nuse libraries::core_library::{ReserveData, UserReserveData};\nuse libraries::uint256::Uint256;\npub const RESERVERS_KEY: \u0026[u8] = b\"reserves\";\npub const USERS_RESERVE_DATA_KEY: \u0026[u8] = b\"usersReserveData\";\n\npub fn reservers\u003c'a, S: Storage\u003e(storage: \u0026'a mut S) -\u003e Bucket\u003c'a, S, ReserveData\u003e {\n    bucket(RESERVERS_KEY, storage)\n}\n\npub fn users_reserve_data\u003c'a, S: Storage\u003e(storage: \u0026'a mut S) -\u003e Bucket\u003c'a, S, UserReserveData\u003e {\n    bucket(USERS_RESERVE_DATA_KEY, storage)\n}\n\npub fn read_reservers\u003c'a, S: ReadonlyStorage\u003e(storage: \u0026'a S) -\u003e ReadonlyBucket\u003c'a,S,ReserveData\u003e{\n    bucket_read(RESERVERS_KEY, storage)\n}\n\npub fn read_users_reseve_data\u003c'a,S: ReadonlyStorage\u003e(storage: \u0026'a mut S) -\u003e ReadonlyBucket\u003c'a,S,UserReserveData\u003e {\n    bucket_read(USERS_RESERVE_DATA_KEY, storage)\n\n}\n\npub const CORE_REVISION: u64 = 0x6;\n\n/**\n * @dev returns the revision number of the contract\n **/\npub fn get_revision() -\u003e Uint256 {\n    let res: Uint256 = CORE_REVISION.into();\n    res\n}\n\n/**\n * @dev updates the state of the core as a result of a deposit action\n * @param _reserve the address of the reserve in which the deposit is happening\n * @param _user the address of the the user depositing\n * @param _amount the amount being deposited\n * @param _isFirstDeposit true if the user is depositing for the first time\n **/\n\npub fn update_state_on_deposit\u003cS: ReadonlyStorage\u003e(\n    _storage: \u0026S,\n    _env:Env,\n    _reserver: HumanAddr,\n    _user: HumanAddr,\n    _amount: Uint256,\n    _is_first_deposit: bool,\n) {\n    let reader = read_reservers(_storage);\n    let mut a = reader.load(_reserver.as_str().as_bytes()).unwrap();\n    a.update_cumulative_indexes(\u0026_env);\n    unimplemented!();\n}\n","traces":[{"line":30,"address":[468960],"length":1,"stats":{"Line":0},"fn_name":"get_revision"},{"line":31,"address":[468968],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-configuration","src","lending_pool_parameters_provider.rs"],"content":"pub const MAX_STABLE_RATE_BORROW_SIZE_PERCENT: u128 = 25;\npub const REBALANCE_DOWN_RATE_DELTA: u128 = (1 * 10_u128.pow(27)) / 5;\npub const FLASHLOAN_FEE_TOTAL: u128 = 35;\npub const FLASHLOAN_FEE_PROTOCOL: u128 = 3000;\n\npub const DATA_PROVIDER_REVISION: u128 = 0x1;\n\npub fn get_revision() -\u003e u128 {\n    DATA_PROVIDER_REVISION\n}\n\n/**\n * @dev initializes the LendingPoolParametersProvider after it's added to the proxy\n * @param _addressesProvider the address of the LendingPoolAddressesProvider\n */\npub fn initilize(_address_provider: \u0026str) {}\n\n/**\n * @dev returns the maximum stable rate borrow size, in percentage of the available liquidity.\n **/\npub fn get_max_stable_rate_borrow_size_precent() -\u003e u128 {\n    MAX_STABLE_RATE_BORROW_SIZE_PERCENT\n}\n\n/**\n * @dev returns the delta between the current stable rate and the user stable rate at\n *      which the borrow position of the user will be rebalanced (scaled down)\n **/\npub fn get_rebalance_down_rate_delta() -\u003e u128 {\n    REBALANCE_DOWN_RATE_DELTA\n}\n\n/**\n * @dev returns the fee applied to a flashloan and the portion to redirect to the protocol, in basis points.\n **/\npub fn get_flash_loan_fees_in_bips() -\u003e (u128, u128) {\n    (FLASHLOAN_FEE_TOTAL, FLASHLOAN_FEE_PROTOCOL)\n}\n","traces":[{"line":8,"address":[468288],"length":1,"stats":{"Line":0},"fn_name":"get_revision"},{"line":16,"address":[468317,468304],"length":1,"stats":{"Line":0},"fn_name":"initilize"},{"line":21,"address":[468336],"length":1,"stats":{"Line":0},"fn_name":"get_max_stable_rate_borrow_size_precent"},{"line":29,"address":[468352],"length":1,"stats":{"Line":0},"fn_name":"get_rebalance_down_rate_delta"},{"line":36,"address":[468368],"length":1,"stats":{"Line":0},"fn_name":"get_flash_loan_fees_in_bips"},{"line":37,"address":[468375],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-configuration","src","lib.rs"],"content":"pub mod contract;\npub mod lending_pool_addresses_provider;\npub mod lending_pool_core;\npub mod lending_pool_parameters_provider;\npub mod msg;\npub mod state;\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-configuration","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n    pub count: i32,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    GetAddress { key: Vec\u003cu8\u003e },\n    GetUint { key: Vec\u003cu8\u003e },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-configuration","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Binary, CanonicalAddr, HumanAddr, ReadonlyStorage, Storage};\nuse cosmwasm_storage::{\n    singleton, singleton_read, PrefixedStorage, ReadonlyPrefixedStorage, ReadonlySingleton,\n    Singleton,\n};\n//pub static CONFIG_KEY: \u0026[u8] = b\"config\";\n\npub const ADDRESSES_KEY: \u0026[u8] = b\"addresses\";\npub const UINTS_KEY: \u0026[u8] = b\"uints\";\n\npub fn get_address\u003cS: ReadonlyStorage\u003e(storage: \u0026S, key: \u0026[u8]) -\u003e Option\u003cBinary\u003e {\n    let store = ReadonlyPrefixedStorage::new(ADDRESSES_KEY, storage);\n    let result = store.get(key)?;\n    Some(Binary::from(result.as_slice()))\n}\n\npub fn set_address\u003cS: Storage\u003e(storage: \u0026mut S, key: \u0026[u8], value: HumanAddr) {\n    let mut store = PrefixedStorage::new(ADDRESSES_KEY, storage);\n    store.set(key, value.as_str().as_bytes());\n}\n\npub fn get_uint\u003cS: ReadonlyStorage\u003e(storage: \u0026S, key: \u0026[u8]) -\u003e Option\u003cBinary\u003e {\n    let store = ReadonlyPrefixedStorage::new(UINTS_KEY, storage);\n    let result = store.get(key)?;\n    Some(Binary::from(result.as_slice()))\n}\n\npub fn set_uint\u003cS: Storage\u003e(storage: \u0026mut S, key: \u0026[u8], value: HumanAddr) {\n    let mut store = PrefixedStorage::new(UINTS_KEY, storage);\n    store.set(key, value.as_str().as_bytes());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lend-configuration","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests.\n//! 1. First copy them over verbatum,\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lp-token","src","lib.rs"],"content":"use cosmwasm_std::{\n    to_binary, Api, Binary, Env, Extern, HandleResponse, HumanAddr, InitResponse, Querier,\n    StdError, StdResult, Storage, Uint128,\n};\nuse std::ops::RangeInclusive;\n\nuse amm_shared::snip20_impl as composable_snip20;\n\nuse composable_snip20::msg::{HandleAnswer, HandleMsg, InitMsg, QueryMsg, ResponseStatus};\nuse composable_snip20::state::{Balances, Config};\nuse composable_snip20::transaction_history::store_burn;\nuse composable_snip20::{\n    check_if_admin, snip20_handle, snip20_init, snip20_query, Snip20, SymbolValidation,\n};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    snip20_init(deps, env, msg, LpTokenImpl)\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    snip20_handle(deps, env, msg, LpTokenImpl)\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    snip20_query(deps, msg, LpTokenImpl)\n}\n\nstruct LpTokenImpl;\n\nimpl Snip20 for LpTokenImpl {\n    fn symbol_validation(\u0026self) -\u003e SymbolValidation {\n        SymbolValidation {\n            length: 3..=12,\n            allow_upper: true,\n            allow_lower: true,\n            allow_numeric: false,\n            allowed_special: Some(vec![b'-']),\n        }\n    }\n\n    fn name_range(\u0026self) -\u003e RangeInclusive\u003cusize\u003e {\n        3..=200\n    }\n\n    fn burn_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n        \u0026self,\n        deps: \u0026mut Extern\u003cS, A, Q\u003e,\n        env: Env,\n        owner: HumanAddr,\n        amount: Uint128,\n        memo: Option\u003cString\u003e,\n    ) -\u003e StdResult\u003cHandleResponse\u003e {\n        let mut config = Config::from_storage(\u0026mut deps.storage);\n\n        check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n        let symbol = config.constants()?.symbol;\n        let raw_amount = amount.u128();\n\n        // remove from supply\n        let mut total_supply = config.total_supply();\n        if let Some(new_total_supply) = total_supply.checked_sub(raw_amount) {\n            total_supply = new_total_supply;\n        } else {\n            return Err(StdError::generic_err(\n                \"You're trying to burn more than is available in the total supply\",\n            ));\n        }\n\n        config.set_total_supply(total_supply);\n        // subtract from owner account\n        let owner = deps.api.canonical_address(\u0026owner)?;\n\n        let mut balances = Balances::from_storage(\u0026mut deps.storage);\n        let mut account_balance = balances.balance(\u0026owner);\n        if let Some(new_balance) = account_balance.checked_sub(raw_amount) {\n            account_balance = new_balance;\n        } else {\n            return Err(StdError::generic_err(format!(\n                \"insufficient funds to burn: balance={}, required={}\",\n                account_balance, raw_amount\n            )));\n        }\n\n        balances.set_account_balance(\u0026owner, account_balance);\n        store_burn(\n            \u0026mut deps.storage,\n            \u0026owner,\n            \u0026deps.api.canonical_address(\u0026env.message.sender)?,\n            amount,\n            symbol,\n            memo,\n            \u0026env.block,\n        )?;\n        let res = HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: Some(to_binary(\u0026HandleAnswer::BurnFrom {\n                status: ResponseStatus::Success,\n            })?),\n        };\n        Ok(res)\n    }\n}\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026super::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026super::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026super::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[{"line":42,"address":[440176],"length":1,"stats":{"Line":0},"fn_name":"symbol_validation"},{"line":44,"address":[440195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[440216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":36},{"path":["/","home","runner","work","sienna","sienna","contracts","lp-token","tests","example-receiver","src","contract.rs"],"content":"use cosmwasm_std::{\n    from_binary, to_binary, Api, BankMsg, Binary, Coin, Context, CosmosMsg, Env, Extern,\n    HandleResponse, HumanAddr, InitResponse, Querier, StdError, StdResult, Storage, Uint128,\n    WasmMsg,\n};\n\nuse crate::msg::{CountResponse, HandleMsg, InitMsg, QueryMsg, Snip20Msg};\nuse crate::state::{config, config_read, State};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let state = State {\n        count: msg.count,\n        owner: deps.api.canonical_address(\u0026env.message.sender)?,\n        known_snip_20: vec![],\n    };\n\n    config(\u0026mut deps.storage).save(\u0026state)?;\n\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Increment {} =\u003e try_increment(deps, env),\n        HandleMsg::Reset { count } =\u003e try_reset(deps, env, count),\n        HandleMsg::Register { reg_addr, reg_hash } =\u003e try_register(deps, env, reg_addr, reg_hash),\n        HandleMsg::Receive {\n            sender,\n            from,\n            amount,\n            msg,\n        } =\u003e try_receive(deps, env, sender, from, amount, msg),\n        HandleMsg::Redeem {\n            addr,\n            hash,\n            to,\n            amount,\n        } =\u003e try_redeem(deps, env, addr, hash, to, amount),\n        HandleMsg::Fail {} =\u003e try_fail(),\n    }\n}\n\npub fn try_increment\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut count = 0;\n    config(\u0026mut deps.storage).update(|mut state| {\n        state.count += 1;\n        count = state.count;\n        Ok(state)\n    })?;\n\n    let mut context = Context::new();\n    context.add_log(\"count\", count.to_string());\n\n    Ok(context.into())\n}\n\npub fn try_reset\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    count: i32,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender_address_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n    config(\u0026mut deps.storage).update(|mut state| {\n        if sender_address_raw != state.owner {\n            return Err(StdError::Unauthorized { backtrace: None });\n        }\n        state.count = count;\n        Ok(state)\n    })?;\n    Ok(HandleResponse::default())\n}\n\npub fn try_register\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    reg_addr: HumanAddr,\n    reg_hash: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut conf = config(\u0026mut deps.storage);\n    let mut state = conf.load()?;\n    if !state.known_snip_20.contains(\u0026reg_addr) {\n        state.known_snip_20.push(reg_addr.clone());\n    }\n    conf.save(\u0026state)?;\n\n    let msg = to_binary(\u0026Snip20Msg::register_receive(env.contract_code_hash))?;\n    let message = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: reg_addr,\n        callback_code_hash: reg_hash,\n        msg,\n        send: vec![],\n    });\n\n    Ok(HandleResponse {\n        messages: vec![message],\n        log: vec![],\n        data: None,\n    })\n}\n\npub fn try_receive\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    _sender: HumanAddr,\n    _from: HumanAddr,\n    _amount: Uint128,\n    msg: Binary,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let msg: HandleMsg = from_binary(\u0026msg)?;\n\n    if matches!(msg, HandleMsg::Receive { .. }) {\n        return Err(StdError::generic_err(\n            \"Recursive call to receive() is not allowed\",\n        ));\n    }\n\n    let state = config_read(\u0026deps.storage).load()?;\n    if !state.known_snip_20.contains(\u0026env.message.sender) {\n        return Err(StdError::generic_err(format!(\n            \"{} is not a known SNIP-20 coin that this contract registered to\",\n            env.message.sender\n        )));\n    }\n\n    /* use sender \u0026 amount */\n    handle(deps, env, msg)\n}\n\nfn try_redeem\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    addr: HumanAddr,\n    hash: String,\n    to: HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let state = config_read(\u0026deps.storage).load()?;\n    if !state.known_snip_20.contains(\u0026addr) {\n        return Err(StdError::generic_err(format!(\n            \"{} is not a known SNIP-20 coin that this contract registered to\",\n            addr\n        )));\n    }\n\n    let msg = to_binary(\u0026Snip20Msg::redeem(amount))?;\n    let secret_redeem = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: addr,\n        callback_code_hash: hash,\n        msg,\n        send: vec![],\n    });\n    let redeem = CosmosMsg::Bank(BankMsg::Send {\n        amount: vec![Coin::new(amount.u128(), \"uscrt\")],\n        from_address: env.contract.address,\n        to_address: to,\n    });\n\n    Ok(HandleResponse {\n        messages: vec![secret_redeem, redeem],\n        log: vec![],\n        data: None,\n    })\n}\n\nfn try_fail() -\u003e StdResult\u003cHandleResponse\u003e {\n    Err(StdError::generic_err(\"intentional failure\"))\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::GetCount {} =\u003e to_binary(\u0026query_count(deps)?),\n    }\n}\n\nfn query_count\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cCountResponse\u003e {\n    let state = config_read(\u0026deps.storage).load()?;\n    Ok(CountResponse { count: state.count })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lp-token","tests","example-receiver","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\npub mod state;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lp-token","tests","example-receiver","src","msg.rs"],"content":"use cosmwasm_std::{Binary, HumanAddr, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n    pub count: i32,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    Increment {},\n    Reset {\n        count: i32,\n    },\n    Register {\n        reg_addr: HumanAddr,\n        reg_hash: String,\n    },\n    Receive {\n        sender: HumanAddr,\n        from: HumanAddr,\n        amount: Uint128,\n        msg: Binary,\n    },\n    Redeem {\n        addr: HumanAddr,\n        hash: String,\n        to: HumanAddr,\n        amount: Uint128,\n    },\n    Fail {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    // GetCount returns the current count as a json-encoded number\n    GetCount {},\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct CountResponse {\n    pub count: i32,\n}\n\n// Messages sent to SNIP-20 contracts\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum Snip20Msg {\n    RegisterReceive {\n        code_hash: String,\n        padding: Option\u003cString\u003e,\n    },\n    Redeem {\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n}\n\nimpl Snip20Msg {\n    pub fn register_receive(code_hash: String) -\u003e Self {\n        Snip20Msg::RegisterReceive {\n            code_hash,\n            padding: None, // TODO add padding calculation\n        }\n    }\n\n    pub fn redeem(amount: Uint128) -\u003e Self {\n        Snip20Msg::Redeem {\n            amount,\n            padding: None, // TODO add padding calculation\n        }\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","sienna","sienna","contracts","lp-token","tests","example-receiver","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{CanonicalAddr, HumanAddr, Storage};\nuse cosmwasm_storage::{singleton, singleton_read, ReadonlySingleton, Singleton};\n\npub static CONFIG_KEY: \u0026[u8] = b\"config\";\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct State {\n    pub count: i32,\n    pub owner: CanonicalAddr,\n    pub known_snip_20: Vec\u003cHumanAddr\u003e,\n}\n\npub fn config\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, State\u003e {\n    singleton(storage, CONFIG_KEY)\n}\n\npub fn config_read\u003cS: Storage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, State\u003e {\n    singleton_read(storage, CONFIG_KEY)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","lp-token","tests","integration.rs"],"content":"#[test]\n#[ignore]\nfn empty_test() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","mgmt","examples","mgmt_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse sienna_mgmt::msg;\nuse sienna_mgmt::State;\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(State),         \u0026out_dir);\n    export_schema(\u0026schema_for!(msg::Init),     \u0026out_dir);\n    export_schema(\u0026schema_for!(msg::Handle),   \u0026out_dir);\n    export_schema(\u0026schema_for!(msg::Query),    \u0026out_dir);\n    export_schema(\u0026schema_for!(msg::Response), \u0026out_dir);\n\n    // TODO schedule, progress, configurable\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","mgmt","src","lib.rs"],"content":"#[macro_use] extern crate fadroma;\n\n// TODO(fadroma): remove need for these to be public\npub use secret_toolkit::snip20::handle::{mint_msg, transfer_msg, set_minters_msg, change_admin_msg};\npub use sienna_migration::{ContractStatus, ContractStatusLevel, is_operational, can_set_status};\npub use sienna_schedule::{\n    Seconds, Schedule, Pool, Account,\n    vesting::Vesting, validate::Validation, canon::{Humanize, Canonize}\n};\npub use linear_map::LinearMap;\n\n/// How much each recipient has claimed so far\npub type History\u003cT\u003e = LinearMap\u003cT, Uint128\u003e;\n\n/// The managed SNIP20 contract's code hash.\npub type CodeHash = String;\n\n/// Pair of address and code hash\npub type ContractLink\u003cT\u003e = (T, CodeHash);\n\n/// Whether the vesting process has begun and when.\npub type Launched = Option\u003cSeconds\u003e;\n\n/// Default value for Secret Network block size\n/// (according to Reuven on Discord; used for padding).\npub const BLOCK_SIZE: usize = 256;\n\n/// Error messages\n#[macro_export] macro_rules! MGMTError {\n    (CORRUPTED)   =\u003e { \"Contract has entered a state that violates core assumptions\".to_string() };\n    (NOTHING)     =\u003e { \"Nothing to claim right now.\".to_string() };\n    (UNDERWAY)    =\u003e { \"The vesting has already begun.\".to_string() };\n    (PRELAUNCH)   =\u003e { \"The vesting has not yet begun.\".to_string() };\n    (NOT_FOUND)   =\u003e { \"Can't find account or pool by name\".to_string() };\n    (ADD_ACCOUNT) =\u003e { \"Can't add account - pool full\".to_string() };\n}\n\ncontract!(\n\n    [State] {\n        /// Starts out as the instantiatior of the contract, can be changed via `SetOwner`\n        admin:    CanonicalAddr,\n        /// The SNIP20 token contract that will be managed by this instance.\n        /// This needs to be provided at init and can't be changed.\n        /// (see `secretcli query compute contract-hash --help` to get the hash).\n        token:    ContractLink\u003cCanonicalAddr\u003e,\n        /// When this contract is launched, this is set to the block time.\n        launched: Launched,\n        /// How much each address has received from the contract.\n        history:  History\u003cCanonicalAddr\u003e,\n        /// Vesting configuration. Can be changed using `Configure`.\n        schedule: Schedule\u003cCanonicalAddr\u003e,\n        /// The paused/migration flag.\n        status:   ContractStatus\n    }\n\n    [Init] (deps, env, msg: {\n        schedule: Schedule\u003cHumanAddr\u003e,\n        history:  Option\u003cHistory\u003cHumanAddr\u003e\u003e,\n        token:    ContractLink\u003cHumanAddr\u003e\n    }) {\n        State {\n            admin:    deps.api.canonical_address(\u0026env.message.sender)?,\n            history:  history.unwrap_or_default().canonize(\u0026deps.api)?,\n            launched: None,\n            schedule: schedule.canonize(\u0026deps.api)?,\n            token:    (deps.api.canonical_address(\u0026token.0)?, token.1),\n            status:   ContractStatus::default()\n        }\n    }\n\n    [Query] (deps, state, msg) -\u003e Response {\n        /// Return error count and launch timestamp.\n        Status () {\n            Ok(Response::Status {\n                status:   state.status,\n                launched: state.launched,\n                token:    (deps.api.human_address(\u0026state.token.0)?, state.token.1.clone()),\n            })\n        }\n\n        /// Return schedule\n        Schedule () {\n            Ok(Response::Schedule { schedule: state.schedule.humanize(\u0026deps.api)? })\n        }\n\n        /// Return claim history\n        History () {\n            Ok(Response::History { history: state.history.humanize(\u0026deps.api)? })\n        }\n\n        /// Return amount that can be claimed by the specified address at the specified time\n        Progress (address: HumanAddr, time: Seconds) {\n            if let Some(launched) = \u0026state.launched {\n                let address_human = address;\n                let address_canon = deps.api.canonical_address(\u0026address_human)?;\n                let elapsed  = get_elapsed(time, *launched);\n                let unlocked = state.schedule.unlocked(elapsed, \u0026address_canon).into();\n                let claimed  = match state.history.get(\u0026address_canon) {\n                    Some(\u0026claimed) =\u003e claimed,\n                    None =\u003e Uint128::zero()\n                };\n                Ok(Response::Progress { time, launched: *launched, elapsed, unlocked, claimed })\n            } else {\n                Ok(Response::Error { msg: MGMTError!(PRELAUNCH).to_string() })\n            }\n        }\n    }\n\n    [Response] {\n        Status   { launched: Launched, token: ContractLink\u003cHumanAddr\u003e, status: ContractStatus }\n        Schedule { schedule: Schedule\u003cHumanAddr\u003e }\n        History  { history: History\u003cHumanAddr\u003e }\n        Progress { time: Seconds, launched: Seconds, elapsed: Seconds, unlocked: Uint128, claimed: Uint128 }\n        Error    { msg: String }\n        NotFound {}\n    }\n\n    [Handle] (deps, env, state, msg) -\u003e Response {\n\n        /// Set the contract status.\n        /// Used to pause the contract operation in case of errors,\n        /// and to initiate a migration to a fixed version of the contract.\n        SetStatus (level: ContractStatusLevel, reason: String, new_address: Option\u003cHumanAddr\u003e) {\n            is_admin(\u0026deps.api, \u0026state, \u0026env)?;\n            can_set_status(\u0026state.status, \u0026level)?; // can't go back from migration\n\n            let messages = match level {\n                // upon entering migration mode,\n                // token admin is changed from \"MGMT\" to \"MGMT's admin\"\n                // so that the token can be administrated manually\n                ContractStatusLevel::Migrating =\u003e vec![{\n                    change_admin_msg(\n                        deps.api.human_address(\u0026state.admin)?,\n                        None, BLOCK_SIZE, state.token.1.clone(), deps.api.human_address(\u0026state.token.0)?\n                    )?\n                }],\n                _ =\u003e vec![]\n            };\n            state.status = ContractStatus { level, reason, new_address };\n\n            save_state!();\n            Ok(HandleResponse { messages, data: None, log: vec![] })\n        }\n\n        /// The current admin can make someone else the admin.\n        SetOwner (new_admin: HumanAddr) {\n            is_admin(\u0026deps.api, \u0026state, \u0026env)?;\n            is_operational(\u0026state.status)?;\n\n            state.admin = deps.api.canonical_address(\u0026new_admin)?;\n\n            save_state!();\n            Ok(HandleResponse::default())\n        }\n\n        /// Load a new schedule (only before launching the contract)\n        Configure (schedule: Schedule\u003cHumanAddr\u003e) {\n            is_admin(\u0026deps.api, \u0026state, \u0026env)?;\n            is_operational(\u0026state.status)?;\n            is_not_launched(\u0026state)?;\n\n            schedule.validate()?;\n            state.schedule = schedule.canonize(\u0026deps.api)?;\n\n            save_state!();\n            Ok(HandleResponse::default())\n        }\n\n        /// Add a new account to a partially filled pool\n        AddAccount (pool_name: String, account: Account\u003cHumanAddr\u003e) {\n            is_admin(\u0026deps.api, \u0026state, \u0026env)?;\n            is_operational(\u0026state.status)?;\n\n            let account = account.canonize(\u0026deps.api)?;\n            state.schedule.add_account(\u0026pool_name, account)?;\n\n            save_state!();\n            Ok(HandleResponse::default())\n        }\n\n        /// An instance can be launched only once.\n        /// Launching the instance mints the total tokens as specified by\n        /// the schedule, and prevents any more tokens from ever being minted\n        /// by the underlying contract.\n        Launch () {\n            is_admin(\u0026deps.api, \u0026state, \u0026env)?;\n            is_not_launched(\u0026state)?;\n            is_operational(\u0026state.status)?;\n\n            state.launched = Some(env.block.time);\n            let messages = mint_and_clear_minters(\u0026deps.api, \u0026state, \u0026env)?;\n\n            save_state!();\n            Ok(HandleResponse { messages, data: None, log: vec![\n                LogAttribute { key: \"launched\".to_string(), value: env.block.time.to_string() }\n            ] })\n        }\n\n        /// After launch, recipients can call the Claim method to\n        /// receive the gains that they have accumulated so far.\n        Claim () {\n            is_operational(\u0026state.status)?;\n\n            let launched = is_launched(\u0026state)?;\n            let elapsed  = get_elapsed(env.block.time, launched);\n            let claimant = deps.api.canonical_address(\u0026env.message.sender)?;\n            let (unlocked, claimable) = portion(\u0026state, \u0026claimant, elapsed);\n            if claimable \u003e 0 {\n                state.history.insert(claimant.clone(), unlocked.into());\n                let messages = vec![transfer(\u0026deps.api, \u0026state, \u0026claimant, claimable.into())?];\n\n                save_state!();\n                Ok(HandleResponse { messages, data: None, log: vec![] })\n            } else {\n                Err(StdError::GenericErr { msg: MGMTError!(NOTHING), backtrace: None })\n            }\n        }\n    }\n\n);\n\nfn is_admin \u003cA:Api\u003e (api: \u0026A, state: \u0026State, env: \u0026Env) -\u003e StdResult\u003c()\u003e {\n    let sender = api.canonical_address(\u0026env.message.sender)?;\n    if state.admin == sender { return Ok(()) }\n    Err(StdError::Unauthorized { backtrace: None })\n}\n\nfn is_not_launched (state: \u0026State) -\u003e StdResult\u003c()\u003e {\n    match state.launched {\n        None =\u003e Ok(()),\n        Some(_) =\u003e Err(StdError::GenericErr {\n            msg: MGMTError!(UNDERWAY).to_string(),\n            backtrace: None\n        })\n    }\n}\n\nfn is_launched (state: \u0026State) -\u003e StdResult\u003cSeconds\u003e {\n    match state.launched {\n        Some(launched) =\u003e Ok(launched),\n        None =\u003e Err(StdError::GenericErr {\n            msg: MGMTError!(PRELAUNCH).to_string(),\n            backtrace: None\n        })\n    }\n}\n\nfn get_elapsed (t1: Seconds, t2: Seconds) -\u003e Seconds {\n    if t1 \u003e t2 {\n        t1 - t2\n    } else {\n        0\n    }\n}\n\nfn portion (state: \u0026State, address: \u0026CanonicalAddr, elapsed: Seconds) -\u003e (u128, u128) {\n    let unlocked = state.schedule.unlocked(elapsed, \u0026address);\n    if unlocked \u003e 0 {\n        let claimed = match state.history.get(\u0026address.clone().into()) {\n            Some(claimed) =\u003e claimed.u128(),\n            None =\u003e 0\n        };\n        if unlocked \u003e claimed {\n            return (unlocked, unlocked - claimed);\n        }\n    }\n    return (unlocked, 0)\n}\n\nfn mint_and_clear_minters \u003cA:Api\u003e (api: \u0026A, state: \u0026State, env: \u0026Env) -\u003e StdResult\u003cVec\u003cCosmosMsg\u003e\u003e {\n    let (addr_canon, hash) = state.token.clone();\n    let addr_human = api.human_address(\u0026addr_canon)?;\n    Ok(vec![\n        mint_msg(\n            env.contract.address.clone(), state.schedule.total,\n            None, BLOCK_SIZE, hash.clone(), addr_human.clone()\n        )?,\n        set_minters_msg(\n            vec![],\n            None, BLOCK_SIZE, hash.clone(), addr_human.clone()\n        )?,\n    ])\n}\n\nfn transfer \u003cA:Api\u003e (\n    api: \u0026A, state: \u0026State, recipient: \u0026CanonicalAddr, amount: Uint128\n) -\u003e StdResult\u003cCosmosMsg\u003e {\n    let (token_addr, token_hash) = state.token.clone();\n    let token_addr = api.human_address(\u0026token_addr)?;\n    let recipient  = api.human_address(\u0026recipient)?;\n    transfer_msg(recipient, amount, None, BLOCK_SIZE, token_hash, token_addr)\n}\n","traces":[{"line":38,"address":[1401032,1404464,1436698,1430673,1436980,1381074,1437826,1380850,1430758,1412748,1388251,1388344,1432462,1425962,1406095,1401210,1413716,1430580,1401125,1437262,1406188,1437544,1425784,1429038,1427496,1380680,1412264,1430843,1425877,1413232,1392797,1430928,1380769,1402833],"length":1,"stats":{"Line":81},"fn_name":null},{"line":62,"address":[1085643],"length":1,"stats":{"Line":7},"fn_name":null},{"line":63,"address":[1087091,1083828,1084019],"length":1,"stats":{"Line":7},"fn_name":null},{"line":64,"address":[1084268,1083959,1084443],"length":1,"stats":{"Line":14},"fn_name":null},{"line":65,"address":[1084404],"length":1,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[1084416,1084722,1084884],"length":1,"stats":{"Line":14},"fn_name":null},{"line":67,"address":[1085163,1085380,1084850],"length":1,"stats":{"Line":14},"fn_name":null},{"line":68,"address":[1085358],"length":1,"stats":{"Line":7},"fn_name":null},{"line":75,"address":[984908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[984313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[984381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[985167,984399,984844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[988971,988649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[986286,986009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[986933,986874],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[986950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[988310,986990,987160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[987135,987433],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[987441],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[987641,987544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[987643,987588],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[987611,988390],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[987720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[986893,987967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[852961,857128,853070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[853332,857126,853032,853386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[856456,856207,854120,856274,856505,856981,853363,853660,854956,855336,857075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[854673,855095,855329,854286,854700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[853871,853681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[854143,854370,853821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[853640,856584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[855362,856597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[855563,856709,856943,856419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[855894,856387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[848254,846349,846450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[846420,846712,846782,848249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[848244,848052,846748,847044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[847965,848135,847418,848239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[847757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[851826,849231,849332],"length":1,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[849594,849652,851821,849302],"length":1,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[849914,849971,851816,849625],"length":1,"stats":{"Line":8},"fn_name":null},{"line":163,"address":[850233,849961,851811,850299],"length":1,"stats":{"Line":8},"fn_name":null},{"line":164,"address":[850269,851806,850561,851604],"length":1,"stats":{"Line":8},"fn_name":null},{"line":166,"address":[851517,850970,851697,851801],"length":1,"stats":{"Line":8},"fn_name":null},{"line":167,"address":[851309],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[834620,837267,834721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[837262,834691,835049,834983],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[835019,835311,835617,837257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[835570,837221,835878,836091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[836081,836358,836959,837216],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[836697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[842866,842964,845398],"length":1,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[845396,843287,843226,842937],"length":1,"stats":{"Line":6},"fn_name":null},{"line":189,"address":[845394,843257,843549,843673],"length":1,"stats":{"Line":6},"fn_name":null},{"line":191,"address":[843590],"length":1,"stats":{"Line":3},"fn_name":null},{"line":192,"address":[843646,845392,844054,843935],"length":1,"stats":{"Line":7},"fn_name":null},{"line":194,"address":[845363,844321,845270,844044],"length":1,"stats":{"Line":8},"fn_name":null},{"line":195,"address":[844652,844854,845348],"length":1,"stats":{"Line":8},"fn_name":null},{"line":196,"address":[844740,845225],"length":1,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[838424,841891,838320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[838774,838689,838394,841886],"length":1,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[838745,839047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[839055,841881,839291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[839563,839197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[839627,841281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[839710,841847,839634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[839816,841811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[841681,840652,841782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[841017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[839670,841294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[1090688,1091153],"length":1,"stats":{"Line":6},"fn_name":"is_admin\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":224,"address":[1090747,1090872],"length":1,"stats":{"Line":6},"fn_name":null},{"line":225,"address":[1090976,1090859],"length":1,"stats":{"Line":12},"fn_name":null},{"line":226,"address":[1091012],"length":1,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[768112,768381],"length":1,"stats":{"Line":4},"fn_name":"is_not_launched"},{"line":230,"address":[768189,768175],"length":1,"stats":{"Line":4},"fn_name":null},{"line":231,"address":[768182,768137],"length":1,"stats":{"Line":8},"fn_name":null},{"line":232,"address":[768231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[768148,768207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[768219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[768432,768748],"length":1,"stats":{"Line":1},"fn_name":"is_launched"},{"line":240,"address":[768502,768537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[768462,768514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[768579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[768475,768555],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[768567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[768800],"length":1,"stats":{"Line":2},"fn_name":"get_elapsed"},{"line":250,"address":[768824,768865],"length":1,"stats":{"Line":4},"fn_name":null},{"line":251,"address":[768839,768872,768887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[768856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[768928,769517],"length":1,"stats":{"Line":1},"fn_name":"portion"},{"line":258,"address":[768995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[769051,769092,769360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[769063,769206,769097],"length":1,"stats":{"Line":3},"fn_name":null},{"line":261,"address":[769210,769159,769542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[769182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[769280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[769381,769316,769585],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[769416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1082985,1080144],"length":1,"stats":{"Line":3},"fn_name":"mint_and_clear_minters\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":272,"address":[1080208],"length":1,"stats":{"Line":3},"fn_name":null},{"line":273,"address":[1080514,1083216,1080333],"length":1,"stats":{"Line":3},"fn_name":null},{"line":274,"address":[1083005,1082069,1083104,1082574,1083198,1082665,1082804,1081564,1082874,1080471],"length":1,"stats":{"Line":6},"fn_name":null},{"line":275,"address":[1080890,1081022,1081049,1081323,1081557],"length":1,"stats":{"Line":9},"fn_name":null},{"line":276,"address":[1080779,1080492],"length":1,"stats":{"Line":6},"fn_name":null},{"line":277,"address":[1080805],"length":1,"stats":{"Line":3},"fn_name":null},{"line":279,"address":[1081786,1082325,1082559,1081665,1081813],"length":1,"stats":{"Line":9},"fn_name":null},{"line":280,"address":[1081313],"length":1,"stats":{"Line":3},"fn_name":null},{"line":281,"address":[1081582],"length":1,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[1091200,1092507],"length":1,"stats":{"Line":1},"fn_name":"transfer\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":289,"address":[1091282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[1091391,1091559,1092580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[1092550,1091532,1092131,1091825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[1091939],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":103,"coverable":115},{"path":["/","home","runner","work","sienna","sienna","contracts","mgmt","tests","helpers.rs"],"content":"#![allow(unused_macros)]\n#![allow(dead_code)]\n\nuse cosmwasm_std::{\n    HumanAddr, Coin,\n    Extern, MemoryStorage,\n    Env, BlockInfo, MessageInfo, ContractInfo,\n};\n\nuse cosmwasm_std::testing::{\n    mock_dependencies_with_balances, /*mock_env,*/\n    MockApi, MockQuerier\n};\n\ntype ExternMock = Extern\u003cMemoryStorage, MockApi, MockQuerier\u003e;\ntype HandleResult = cosmwasm_std::StdResult\u003ccosmwasm_std::HandleResponse\u003e;\n\nmacro_rules! harness {\n    ($deps:ident ; $($AGENT:ident),+) =\u003e {\n        $(let $AGENT: cosmwasm_std::HumanAddr =\n            cosmwasm_std::HumanAddr::from(stringify!($AGENT));)+\n        let mut $deps = harness(\u0026[\n            $((\u0026$AGENT, \u0026[])),+\n        ]);\n    }\n}\n\npub fn harness (balances: \u0026[(\u0026HumanAddr, \u0026[Coin])])-\u003e ExternMock {\n    let mut deps = mock_dependencies_with_balances(45, \u0026balances);\n    let res = sienna_mgmt::init(\n        \u0026mut deps,\n        mock_env(0, 0, balances[0].0), // first address in `balances` is admin\n        sienna_mgmt::msg::Init {\n            history:  None,\n            schedule: sienna_schedule::Schedule::new(\u0026[]),\n            token:    (cosmwasm_std::HumanAddr::from(\"token\"), String::new()),\n        }\n    ).unwrap();\n    assert_eq!(0, res.messages.len());\n    deps\n}\n\npub fn mock_env (\n    height: u64, time: u64, sender: \u0026HumanAddr\n) -\u003e Env { Env {\n    block: BlockInfo { height, time, chain_id: \"secret\".into() },\n    message: MessageInfo { sender: sender.into(), sent_funds: vec![] },\n    contract: ContractInfo { address: \"mgmt\".into() },\n    contract_key: Some(\"\".into()),\n    contract_code_hash: \"0\".into()\n} }\n\nmacro_rules! q {\n    ( $deps:expr;\n        $QueryVariant:ident $( { $($query_field:ident $(: $query_value:expr)?),* } )? ==\n        $ResponseVariant:ident { $($response_field:ident : $expected_value:expr),* }\n    ) =\u003e {\n        let decoded = cosmwasm_std::from_binary(\u0026sienna_mgmt::query(\n            \u0026$deps,\n            sienna_mgmt::msg::Query::$QueryVariant { $( $($query_field $(:$query_value)?),* )? }\n        ).unwrap()).unwrap();\n        if let sienna_mgmt::msg::Response::$ResponseVariant {$($response_field),* ,.. } = decoded {\n            $(assert_eq!($response_field, $expected_value, stringify!($response_field)));*\n        } else {\n            panic!(\"{} query returned {} instead of {}\",\n                stringify!($QueryVariant),\n                format!(\"{:#?}\", \u0026decoded),\n                stringify!($ResponseVariant)\n            )\n        }\n    }\n}\n\nmacro_rules! tx {\n    ( $deps: ident; $SENDER:expr, $block:expr, $time:expr\n    ; $TX:ident { $($arg:ident : $val:expr),* }\n    == $ExpectedResult:expr\n    ) =\u003e {\n\n        macro_rules! ok {\n            () =\u003e {\n                Ok(cosmwasm_std::HandleResponse { data: None, log: vec![], messages: vec![] })\n            };\n            (messages: $msgs:tt) =\u003e {\n                Ok(cosmwasm_std::HandleResponse { data: None, log: vec![], messages: vec! $msgs })\n            };\n            (messages: $msgs:tt, log: $log:expr) =\u003e {\n                Ok(cosmwasm_std::HandleResponse { data: None, log: $log, messages: vec! $msgs })\n            };\n            (launched: $amount:expr) =\u003e {\n                ok!(messages: [\n                    secret_toolkit::snip20::handle::mint_msg(\n                        cosmwasm_std::HumanAddr::from(\"mgmt\"),\n                        cosmwasm_std::Uint128::from($amount),\n                        None, 256, String::new(), cosmwasm_std::HumanAddr::from(\"token\")\n                    ).unwrap(),\n                    secret_toolkit::snip20::handle::set_minters_msg(\n                        vec![],\n                        None, 256, String::new(), cosmwasm_std::HumanAddr::from(\"token\")\n                    ).unwrap()\n                ], log: vec![\n                    cosmwasm_std::LogAttribute { key: \"launched\".to_string(), value: $time.to_string() }\n                ])\n            };\n            (claimed: $addr:expr, $amount:expr) =\u003e {\n                ok!(messages: [\n                    secret_toolkit::snip20::handle::transfer_msg(\n                        $addr.clone(), $amount,\n                        None, 256, String::new(), HumanAddr::from(\"token\")\n                    ).unwrap()\n                ])\n            };\n        }\n        macro_rules! err {\n            (auth) =\u003e { Err(cosmwasm_std::StdError::Unauthorized { backtrace: None }) };\n            ($msg:tt) =\u003e { Err(cosmwasm_std::StdError::GenericErr {\n                backtrace: None, msg: $msg.to_string()\n            }) }\n        }\n\n        let expected_response = $ExpectedResult;\n        let request = sienna_mgmt::msg::Handle::$TX { $($arg : $val),* };\n        let response = sienna_mgmt::handle(\u0026mut $deps, mock_env($block, $time, \u0026$SENDER), request);\n        if response != expected_response {\n            println!(\"!!! Test transaction failed (block {}, time {})\", $block, $time);\n            if let Ok(cosmwasm_std::HandleResponse { messages, log, data }) = expected_response {\n                println!(\"Expected data: {:#?}\", \u0026data);\n                println!(\"Expected logs: {:#?}\", \u0026log);\n                println!(\"Expected messages:\");\n                for message in messages.iter() {\n                    match message {\n                        cosmwasm_std::CosmosMsg::Wasm(cosmwasm_std::WasmMsg::Execute{contract_addr,callback_code_hash,msg,send}) =\u003e {\n                            println!(\"  WASM execute\");\n                            println!(\"    contract_addr:     = {:?}\", contract_addr);\n                            println!(\"    callback_code_hash = {:?}\", callback_code_hash);\n                            println!(\"    send               = {:?}\", send);\n                            println!(\"    msg:\\n{}\", std::str::from_utf8(msg.as_slice()).unwrap())\n                        },\n                        _ =\u003e\n                            println!(\"  {:#?}\", \u0026message)\n                    }\n                }\n            } else {\n                println!(\"Expected response:\\n  {:#?}\", \u0026expected_response);\n            }\n            if let Ok(cosmwasm_std::HandleResponse { messages, log, data }) = response {\n                println!(\"Actual data: {:#?}\", \u0026data);\n                println!(\"Actual logs: {:#?}\", \u0026log);\n                println!(\"Actual messages:\");\n                for message in messages.iter() {\n                    match message {\n                        cosmwasm_std::CosmosMsg::Wasm(cosmwasm_std::WasmMsg::Execute{contract_addr,callback_code_hash,msg,send}) =\u003e {\n                            println!(\"  WASM execute\");\n                            println!(\"    contract_addr:     = {:?}\", contract_addr);\n                            println!(\"    callback_code_hash = {:?}\", callback_code_hash);\n                            println!(\"    send:              = {:?}\", send);\n                            println!(\"    msg:\\n{}\", std::str::from_utf8(msg.as_slice()).unwrap())\n                        },\n                        _ =\u003e\n                            println!(\"  {:#?}\", \u0026message)\n                    }\n                }\n            } else {\n                println!(\"Actual response:\\n  {:#?}\", \u0026response);\n            }\n            panic!(\"transaction test failed\")\n        }\n    }\n}\n\n/// Add 18 zeroes and make serializable\nmacro_rules! SIENNA {\n    ($x:expr) =\u003e { Uint128::from($x as u128 * sienna_schedule::ONE_SIENNA) }\n}\n","traces":[{"line":28,"address":[775136,775903],"length":1,"stats":{"Line":6},"fn_name":"harness"},{"line":29,"address":[775166],"length":1,"stats":{"Line":7},"fn_name":null},{"line":32,"address":[555771,556535],"length":1,"stats":{"Line":7},"fn_name":null},{"line":33,"address":[775427],"length":1,"stats":{"Line":7},"fn_name":null},{"line":34,"address":[555834],"length":1,"stats":{"Line":7},"fn_name":null},{"line":35,"address":[775286],"length":1,"stats":{"Line":7},"fn_name":null},{"line":36,"address":[819008,819555],"length":1,"stats":{"Line":7},"fn_name":null},{"line":39,"address":[775628],"length":1,"stats":{"Line":7},"fn_name":null},{"line":40,"address":[775806],"length":1,"stats":{"Line":7},"fn_name":null},{"line":43,"address":[556704,557321],"length":1,"stats":{"Line":7},"fn_name":"mock_env"},{"line":46,"address":[556760],"length":1,"stats":{"Line":7},"fn_name":null},{"line":47,"address":[776736,776276],"length":1,"stats":{"Line":7},"fn_name":null},{"line":48,"address":[776363],"length":1,"stats":{"Line":7},"fn_name":null},{"line":49,"address":[776422],"length":1,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[776482],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":15,"coverable":15},{"path":["/","home","runner","work","sienna","sienna","contracts","mgmt","tests","test_01_setup.rs"],"content":"#![cfg(test)]\n#![allow(unused_macros)]\n#![allow(non_snake_case)]\n\n#[macro_use] extern crate sienna_mgmt;\nextern crate sienna_schedule; use sienna_schedule::{Schedule, Pool};\n#[macro_use] extern crate kukumba;\n#[macro_use] mod helpers; use helpers::{harness, mock_env};\nuse cosmwasm_std::HumanAddr;\n\nkukumba! {\n\n    #[ok_initialize_become_admin]\n    given \"no instance\" { harness!(deps; ADMIN); }\n    when \"someone deploys the instance\" {\n        use sienna_mgmt::{init, msg::Init};\n        let s = Schedule::new(\u0026[Pool::full(\"\",\u0026[])]);\n        let _ = init(\u0026mut deps, mock_env(0, 0, \u0026ADMIN), Init {\n            history:  None,\n            schedule: s.clone(),\n            token:    (cosmwasm_std::HumanAddr::from(\"token\"), String::new()),\n        }).unwrap(); }\n    then \"they become admin\" { /* admin address is not public */ }\n    and \"the instance is not launched\" { q!(deps; Status   == Status   { launched: None }); }\n    and \"the given schedule is set\"    { q!(deps; Schedule == Schedule { schedule: s    }); }\n\n    #[ok_configure_authorized_only]\n    given \"an instance before launch\" { harness!(deps; ADMIN, RECIPIENT, STRANGER); }\n    when \"the admin sets a minimal valid configuration\" {\n        let original_schedule = sienna_schedule::Schedule::new(\u0026[Pool::full(\"original\",\u0026[])]);\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: original_schedule.clone() } == ok!()); }\n    then \"the configuration is updated\" {\n        q!(deps; Schedule == Schedule { schedule: original_schedule }); }\n    when \"anyone but the admin tries to set a configuration\"\n    then \"that fails\" {\n        for sender in [\u0026RECIPIENT, \u0026STRANGER].iter() {\n            let sender = sender.clone();\n            let bad_schedule = Schedule::new(\u0026[Pool::full(\"malicious\",\u0026[])]);\n            tx!(deps; sender, 0, 0; Configure { schedule: bad_schedule } == err!(auth));\n            q!(deps; Schedule == Schedule { schedule: original_schedule }); } }\n    when \"the admin sets the real configuration\" {\n        let src = include_str!(\"../../../settings/schedule.json\")\n        let s: Schedule\u003cHumanAddr\u003e = serde_json::from_str(src).unwrap();\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: s.clone() } == ok!()); }\n    then \"the configuration is updated\" {\n        q!(deps; Schedule == Schedule { schedule: s.clone() }); }\n\n    #[no_reconfigure_after_launch]\n    given \"a launched instance\" {\n        harness!(deps; ADMIN, RECIPIENT, STRANGER);\n        tx!(deps; ADMIN, 0, 0; Launch {} == ok!(launched: cosmwasm_std::Uint128::zero())); }\n    then \"the total configuration can't be changed anymore by anyone\" {\n        let s = sienna_schedule::Schedule::new(\u0026[Pool::full(\"\",\u0026[])]);\n        let UNDERWAY = MGMTError!(UNDERWAY);\n        tx!(deps; ADMIN,     0, 0; Configure { schedule: s.clone() } == err!(UNDERWAY));\n        tx!(deps; RECIPIENT, 0, 0; Configure { schedule: s.clone() } == err!(auth));\n        tx!(deps; STRANGER,  0, 0; Configure { schedule: s.clone() } == err!(auth)); }\n\n    #[no_unauthorized_launch]\n    given \"the instance is not yet launched\" {\n        harness!(deps; ADMIN, STRANGER); }\n    when \"a stranger tries to start the vesting\"\n    then \"that fails\" {\n        tx!(deps; STRANGER, 2, 2; Launch {} == err!(auth));\n        q!(deps; Status == Status { launched: None }); }\n\n    #[ok_launch]\n    given \"the instance is not yet launched\" {\n        harness!(deps; ADMIN, STRANGER); }\n    when \"the instance is configured\"\n    and  \"the admin starts the vesting\"\n    then \"the instance mints the tokens\"\n    and  \"the current time is remembered as the launch date\" {\n        let s = sienna_schedule::Schedule::new(\u0026[]);\n        tx!(deps; ADMIN, 3, 3; Configure { schedule: s.clone() } == ok!());\n        tx!(deps; ADMIN, 4, 4; Launch {} == ok!(launched: s.total));\n        q!(deps; Status == Status { launched: Some(4) }); }\n\n    #[no_relaunch]\n    given \"the instance was launched\" {\n        harness!(deps; ADMIN);\n        let s = sienna_schedule::Schedule::new(\u0026[]);\n        tx!(deps; ADMIN, 3, 3; Configure { schedule: s.clone() } == ok!());\n        tx!(deps; ADMIN, 4, 4; Launch {} == ok!(launched: s.total)); }\n    when \"the admin tries to start the vesting again\"\n    then \"the instance says it's already launched\"\n    and \"it does not update its launch date\" {\n        let UNDERWAY = MGMTError!(UNDERWAY);\n        tx!(deps; ADMIN, 5, 5; Launch {} == err!(UNDERWAY));\n        q!(deps; Status == Status { launched: Some(4) }); }\n\n}\n","traces":[{"line":17,"address":[547262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[547788,547438,547605],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[547456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[547468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[547495,551366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[547780,547826,551602,551380],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[551350,548573,551320,549138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[550087,551266,550684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[552563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[553260,576486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[576443,554203,553422,576333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[576276,559198,559906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[561405,568302,561084],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[561439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[561473,576258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[561643,576148,562318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[577053,576091,562232,576569,567053,576238],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[568567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[568607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[575935,568644,569425,576045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[574420,575063,575864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[579691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[603923,603813,605199,581786,580018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[603795,586781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[586937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[586964,587842,603638,603748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[592577,603528,587584,593185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[597920,603418,592927,598325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[607155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[614604,608065,608639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[614585,613793,608553,614552,613374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[615915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[617449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[617475,630932,618223,630822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[630627,624551,631312,618104,630737,622958],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[629711,630608,630575,629286,624465],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[633299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[633428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[633454,653366,653476,634202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[653281,634083,653171,654125,638937,640597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[646216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[646243,646872,653138,653028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[652976,652026,646786,651607,653009],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":43,"coverable":43},{"path":["/","home","runner","work","sienna","sienna","contracts","mgmt","tests","test_02_ownership.rs"],"content":"#![allow(unused_macros)]\n#![allow(non_snake_case)]\n#[macro_use] extern crate kukumba;\n#[macro_use] mod helpers; use helpers::{harness, mock_env};\n\nkukumba! {\n\n    #[no_unauthorized_set_admin]\n    given \"a contract instance\" { harness!(deps; ADMIN, ADMIN2, STRANGER); }\n    when \"a stranger tries to set a new admin\"\n    then \"that fails\" {\n        tx!(deps; STRANGER, 1, 1; SetOwner { new_admin: STRANGER.clone() } == err!(auth)); }\n\n    #[ok_set_admin]\n    given \"a contract instance\" { harness!(deps; ADMIN, ADMIN2, STRANGER); }\n    when \"the admin tries to set a new admin\"\n    then \"the admin is updated\" {\n        tx!(deps; ADMIN, 2, 2; SetOwner { new_admin: ADMIN2.clone() } == ok!()); }\n    when \"the former admin tries to set a new admin\"\n    then \"that fails\" {\n        tx!(deps; ADMIN, 3, 3; SetOwner { new_admin: ADMIN.clone() } == err!(auth)); }\n    when \"the new admin tries to set the admin\"\n    then \"the admin is updated\" {\n        tx!(deps; ADMIN2, 4, 4; SetOwner { new_admin: ADMIN.clone() } == ok!()); }\n\n}\n","traces":[{"line":9,"address":[546803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[548413,553210,547812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[554515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[555524,556286,573484,573594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[562289,561593,573374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[568263,573232,573342,567596],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","sienna","sienna","contracts","mgmt","tests","test_03_claim.rs"],"content":"#![cfg(test)]\n#![allow(unused_macros)]\n#![allow(non_snake_case)]\n\n#[macro_use] extern crate sienna_mgmt;\n#[macro_use] extern crate kukumba;\n#[macro_use] mod helpers; use helpers::{harness, mock_env};\nuse cosmwasm_std::{HumanAddr, Uint128};\nuse sienna_schedule::{Schedule};\n\nkukumba! {\n\n    #[no_claim_as_stranger_before_launch]\n    given \"the contract is not yet launched\" {\n        harness!(deps; ADMIN, STRANGER); }\n    when \"a stranger tries to claim funds\"\n    then \"they are denied\" {\n        let PRELAUNCH = MGMTError!(PRELAUNCH);\n        tx!(deps; STRANGER, 1, 1; Claim {} == err!(PRELAUNCH)); }\n\n    #[no_claim_as_stranger_after_launch]\n    given \"the contract is launched\" {\n        harness!(deps; ADMIN, STRANGER);\n        let s = Schedule { total: Uint128::from(0u128), pools: vec![] }\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: s.clone() } == ok!());\n        tx!(deps; ADMIN, 2, 2; Launch {} == ok!(launched: s.total)); }\n    when \"a stranger tries to claim funds\"\n    then \"they are denied\" {\n        let NOTHING = MGMTError!(NOTHING); \n        tx!(deps; STRANGER, 4, 4; Claim {} == err!(NOTHING)); }\n\n    #[ok_claim_as_user_only_after_launch]\n    given \"a contract with the production schedule\" {\n        harness!(deps; ADMIN);\n        let s: Schedule\u003cHumanAddr\u003e = serde_json::from_str(include_str!(\"../../../settings/schedule.json\")).unwrap();\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: s.clone() } == ok!());\n        let founder_1 = HumanAddr::from(\"secret1TODO20xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n        let founder_2 = HumanAddr::from(\"secret1TODO21xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n        let founder_3 = HumanAddr::from(\"secret1TODO22xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n        let PRELAUNCH = MGMTError!(PRELAUNCH); }\n    when \"the contract is not yet launched\"\n    and  \"anyone tries to claim funds\"\n    then \"they are denied\" {\n        for user in [\u0026founder_1, \u0026founder_2, \u0026founder_3].iter() {\n            tx!(deps; *user, 1, 1; Claim {} == err!(PRELAUNCH)); } }\n    when \"the contract is launched\" {\n        let t_launch = 2;\n        tx!(deps; ADMIN, 2, t_launch; Launch {} == ok!(launched: s.total)); }\n    and \"the appropriate amounts will be unlocked at the appropriate times\" {\n        let zero = Uint128::zero();\n        for P in s.pools.iter() {\n            for A in P.accounts.iter() {\n                let address       = A.address.clone();\n                let portion_count = A.portion_count();\n                let portion_size  = A.portion_size();\n                let remainder     = A.remainder();\n                println!(\"\\naccount: {} {} {} {}\",\n                    \u0026A.name, A.start_at, A.interval, A.duration);\n                println!(\"amounts: {} = {} + {} * {} + {}\",\n                    A.amount, A.cliff, portion_count, portion_size, remainder);\n                assert_eq!(\n                    A.cliff.u128() + portion_count as u128 * portion_size + remainder,\n                    A.amount.u128(),\n                    \"(cliff + portions + remainder) should equal account total\");\n                if A.start_at \u003e 0 { //funds are not unlocked before `start_at`\n                    q!(deps;\n                        Progress { address: address.clone(), time: A.start_at - 1 } ==\n                        Progress { unlocked: zero, claimed: zero }); }\n                if A.cliff \u003e zero { // cliff\n                    q!(deps;\n                        Progress { address: address.clone(), time: A.start_at + A.interval } ==\n                        Progress { unlocked: A.cliff, claimed: zero });\n                } else { // first portion\n                    q!(deps;\n                        Progress { address: address.clone(), time: A.start_at + A.interval } ==\n                        Progress { unlocked: Uint128::from(A.portion_size()), claimed: zero });\n                }\n                q!(deps; // entire amount is unlocked by the end\n                    Progress { address: address.clone(), time: A.start_at + A.duration + A.interval } ==\n                    Progress { unlocked: A.amount, claimed: zero }); } } }\n    and \"by the end of the contract everyone will have unlocked exactly their assigned amount\" {\n        for P in s.pools.iter() {\n            for A in P.accounts.iter() {\n                let t = A.end() + A.interval;\n                tx!(deps; A.address, t / 5, t;\n                    Claim {} == ok!(claimed: A.address, A.amount)); } } }\n\n}\n","traces":[{"line":15,"address":[546803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[547713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[547740,548341,553132,553242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[554499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[554727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[554846,555593,573365,573255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[560328,555474,573170,574028,561988,573060],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[567295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[573027,572917,567322,567923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[576262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[576391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[613121,577150,613231,576448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[577076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[581885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[581916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[581947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[583313,588765,582976],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[583355,614173,612936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[589030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[612744,612854,590792,589042,613974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[595791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[595856,596209,596479],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[605207,596243,596484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[596526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[596553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[596595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[596664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[596767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[596733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[597374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[597363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[598517,598699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[598130,615891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[598440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[598797,598674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[599637,612665,598845,612695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[598790,598810,615990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[612679,599599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[600334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[601267,600471,612603,612633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[600436,616123,600395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[612617,601229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[602909,612568,601999,612535,602472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[616256,600418,601964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[602354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[612464,604499,603703,612497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[603614,616389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[605188,604461,612478,612725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[605472,606000,605730],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[612006,606005,605764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[616555,606047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[612303,607274,606835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[613314,607224,611935,612393,606120],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":53,"coverable":53},{"path":["/","home","runner","work","sienna","sienna","contracts","mgmt","tests","test_04_mutate.rs"],"content":"#![cfg(test)]\n#![allow(dead_code)]\n#![allow(unused_macros)]\n#![allow(unused_imports)]\n#![allow(non_snake_case)]\n\nextern crate sienna_mgmt;\n#[macro_use] extern crate kukumba;\n#[macro_use] mod helpers; use helpers::{harness, mock_env};\nuse cosmwasm_std::{HumanAddr, Uint128};\nuse sienna_schedule::{Schedule, Pool, Account};\n\nkukumba! {\n\n    #[no_unauthorized_mutate_before_launch]\n    given \"an instance\" { harness!(deps; ADMIN, STRANGER); }\n    and \"a schedule with a partial pool\" {\n        let original_schedule = Schedule::new(\u0026[Pool::partial(\"pool\", 1000, \u0026[])]);\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: original_schedule.clone() } == ok!()); }\n    when \"a stranger tries to add an account to an existing pool\"\n    then \"that fails\" {\n        let a = Account::immediate(\"account\", \u0026HumanAddr::from(\"account\"), 500);\n        tx!(deps; STRANGER, 1, 1; AddAccount { pool_name: \"pool\".to_string(), account: a }\n            == err!(auth));\n        q!(deps; Schedule == Schedule { schedule: original_schedule }); }\n\n    #[no_add_user_to_missing_pool]\n    given \"an instance\" { harness!(deps; ADMIN); }\n    and \"a schedule with a partial pool\" {\n        let original_schedule = Schedule::new(\u0026[Pool::partial(\"pool\", 1000, \u0026[])]);\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: original_schedule.clone() } == ok!()); }\n    when \"the admin tries to add an account to a missing pool\"\n    then \"that fails\" {\n        let a = Account::immediate(\"account\", \u0026HumanAddr::from(\"account\"), 500);\n        tx!(deps; ADMIN, 1, 1; AddAccount { pool_name: \"missing\".to_string(), account: a }\n            == err!(\"schedule: pool missing not found\"));\n        q!(deps; Schedule == Schedule { schedule: original_schedule }); }\n\n    #[ok_add_user_to_pool_before_launch]\n    given \"an instance\" { harness!(deps; ADMIN); }\n    and \"a schedule with a partial pool\" {\n        let original_schedule = Schedule::new(\u0026[Pool::partial(\"pool\", 1000, \u0026[])]);\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: original_schedule.clone() } == ok!()); }\n    when \"the admin tries to add an account to a pool\"\n    then \"the schedule is updated\" {\n        let a = Account::immediate(\"account\", \u0026HumanAddr::from(\"account\"), 500);\n        let mut updated_schedule = original_schedule.clone();\n        updated_schedule.add_account(\"pool\", a.clone()).unwrap();\n        tx!(deps; ADMIN, 1, 1; AddAccount { pool_name: \"pool\".to_string(), account: a.clone() }\n            == ok!());\n        q!(deps; Schedule == Schedule { schedule: updated_schedule }); }\n\n    #[no_add_user_to_full_pool_before_launch]\n    given \"an instance\" { harness!(deps; ADMIN); }\n    and \"a schedule with a partial pool\" {\n        let s = Schedule::new(\u0026[Pool::partial(\"pool\", 1000, \u0026[])]);\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: s.clone() } == ok!()); }\n    when \"the admin tries to add an account to a pool\"\n    and \"the account's amount is more than what's left in the pool\"\n    then \"that fails\" {\n        let a = Account::immediate(\"account\", \u0026HumanAddr::from(\"account\"), 1001);\n        tx!(deps; ADMIN, 1, 1; AddAccount { pool_name: \"pool\".to_string(), account: a }\n            == err!(\"pool pool: account (1001) \u003e unallocated funds in pool (1000)\")); }\n\n    #[no_unauthorized_mutate_after_launch]\n    given \"a launched instance\"\n    and \"a schedule with a partial pool\" {\n        harness!(deps; ADMIN, STRANGER);\n        let s = Schedule::new(\u0026[Pool::partial(\"pool\", 1000, \u0026[])]);\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: s.clone() } == ok!());\n        tx!(deps; ADMIN, 1, 1; Launch {} == ok!(launched: 1000u128)); }\n    when \"someone tries to add an account to an existing pool\" {}\n    then \"that fails\" {\n        let a = Account::immediate(\"account\", \u0026HumanAddr::from(\"account\"), 500);\n        tx!(deps; STRANGER, 2, 2; AddAccount { pool_name: \"bad\".to_string(), account: a }\n            == err!(auth)); }\n\n    #[ok_add_user_to_pool_after_launch]\n    given \"a launched instance\"\n    and \"a schedule with a partial pool\" {\n        harness!(deps; ADMIN, STRANGER);\n        let original_schedule = Schedule::new(\u0026[Pool::partial(\"pool\", 1000, \u0026[])]);\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: original_schedule.clone() } == ok!());\n        tx!(deps; ADMIN, 1, 1; Launch {} == ok!(launched: 1000u128)); }\n    when \"the admin tries to add an account to a missing pool\" {}\n    then \"the schedule is updated\" {}\n    and \"the correct amounts claimable can be queried for the new account\" {\n        let a = Account::immediate(\"account\", \u0026HumanAddr::from(\"account\"), 500);\n        let mut updated_schedule = original_schedule.clone();\n        updated_schedule.add_account(\"pool\", a.clone()).unwrap();\n        tx!(deps; ADMIN, 1, 1; AddAccount { pool_name: \"pool\".to_string(), account: a.clone() }\n            == ok!());\n        q!(deps; Schedule == Schedule { schedule: updated_schedule });\n        q!(deps; Progress { address: a.address, time: 0 }\n            == Progress { unlocked: cosmwasm_std::Uint128::from(500u128) }); }\n\n    #[no_add_user_to_full_pool_after_launch]\n    given \"a launched instance\"\n    and \"a schedule with a partial pool\" {\n        harness!(deps; ADMIN, STRANGER);\n        let s = Schedule::new(\u0026[Pool::partial(\"pool\", 1000, \u0026[])]);\n        tx!(deps; ADMIN, 0, 0; Configure { schedule: s.clone() } == ok!());\n        tx!(deps; ADMIN, 1, 1; Launch {} == ok!(launched: 1000u128)); }\n    when \"the admin tries to add an account to a pool\"\n    and \"the account's amount is more than what's left in the pool\" {}\n    then \"that fails\" {\n        let a = Account::immediate(\"account\", \u0026HumanAddr::from(\"account\"), 1001);\n        tx!(deps; ADMIN, 1, 1; AddAccount { pool_name: \"pool\".to_string(), account: a }\n            == err!(\"pool pool: account (1001) \u003e unallocated funds in pool (1000)\")); }\n\n}\n","traces":[{"line":16,"address":[546875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[547473,561107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[561064,560954,548431,547650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[560935,553738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[560825,554030,554707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[553842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[559442,560768,554621,560002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[563131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[563630,577317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[564588,577274,563807,577164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[577145,569895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[570923,577016,570246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[569999,577126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[575658,570837,576212,576959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[579315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[579814,593596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[593553,580772,579991,593443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[593424,586079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[586175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[586202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[586548,587132,593255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[593364,586294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[587046,593198,591867,592421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[595667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[608910,596166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[608757,597124,608867,596343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[608738,602743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[603094,603743,608609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[608719,602847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[611062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[611290,630366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[630213,630323,611467,612214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[612095,631019,630018,630128,618606,616949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[623971,629999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[629889,624263,624912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[624075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[633486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[655949,633714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[633891,634638,655796,655906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[655711,656788,639373,641030,634519,655601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[646765,655582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[646869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[646896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[647826,647242,655427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[646988,655536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[655370,647740,652561,653243],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[654337,655351,653097,653841,655318,654155],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[654073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[659526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[659754,679226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[679073,659931,660678,679183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[678988,678878,679879,660559,665413,667070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[672747,678859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[673747,673098,678730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[672851,678840],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":55,"coverable":55},{"path":["/","home","runner","work","sienna","sienna","contracts","rewards","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse sienna_rewards::msg::*;\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsgResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","rewards","src","auth.rs"],"content":"use cosmwasm_std::{\n    Extern, Storage, Api, Querier, Env, HandleResponse, to_binary,\n    StdResult\n};\nuse composable_auth::{\n    AuthHandle, ViewingKey, save_viewing_key, HandleAnswer\n};\n\nuse crate::state::load_config;\n\npub(crate) struct AuthImpl;\n\nimpl AuthHandle for AuthImpl {\n    fn create_viewing_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n        \u0026self,\n        deps: \u0026mut Extern\u003cS, A, Q\u003e,\n        env: Env,\n        entropy: String\n    ) -\u003e StdResult\u003cHandleResponse\u003e {\n        let config = load_config(deps)?;\n\n        let key = ViewingKey::new(\u0026env, config.prng_seed.as_slice(), entropy.as_bytes());\n        \n        let address = deps.api.canonical_address(\u0026env.message.sender)?;\n        save_viewing_key(deps, address.as_slice(), \u0026key)?;\n\n        Ok(HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: Some(to_binary(\u0026HandleAnswer::CreateViewingKey {\n                key\n            })?)\n        })\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","runner","work","sienna","sienna","contracts","rewards","src","contract.rs"],"content":"use cosmwasm_std::{\n    Api, Binary, Env, Extern, HandleResponse, HumanAddr, InitResponse,\n    Querier, StdResult, Storage, Uint128, StdError, log, to_binary\n};\nuse composable_admin::require_admin;\nuse composable_admin::admin::{\n    save_admin, admin_handle, admin_query, DefaultHandleImpl as DefaultAdminHandle,\n    DefaultQueryImpl, assert_admin\n};\nuse composable_auth::{auth_handle, authenticate, AuthHandleMsg};\nuse secret_toolkit::snip20;\nuse fadroma_scrt_callback::ContractInstance;\nuse cosmwasm_utils::viewing_key::ViewingKey;\nuse cosmwasm_utils::convert::{convert_token, get_whole_token_representation};\n\nuse crate::msg::{\n    HandleMsg, InitMsg, QueryMsg, OVERFLOW_MSG, RewardPoolConfig,\n    QueryMsgResponse, ClaimSimulationResult, ClaimResult, ClaimError,\n    GetBalanceError\n};\nuse crate::state::{\n    save_config, Config, replace_active_pools, get_pool, get_account, save_account,\n    get_or_create_account, save_pool, load_config, get_pools, get_inactive_pool\n};\nuse crate::data::{RewardPool, Account, PendingBalance};\nuse crate::auth::AuthImpl;\n\nconst BLOCK_SIZE: usize = 256;\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let viewing_key = ViewingKey::new(\u0026env, msg.prng_seed.as_slice(), msg.entropy.as_slice());\n\n    let admin = msg.admin.unwrap_or(env.message.sender);\n    save_admin(deps, \u0026admin)?;\n\n    let token_info = snip20::token_info_query(\n        \u0026deps.querier,\n        BLOCK_SIZE,\n        msg.reward_token.code_hash.clone(),\n        msg.reward_token.address.clone()\n    )?;\n\n    let config = Config {\n        reward_token: msg.reward_token,\n        this_contract: ContractInstance {\n            address: env.contract.address,\n            code_hash: env.contract_code_hash\n        },\n        token_decimals: token_info.decimals,\n        viewing_key,\n        prng_seed: msg.prng_seed,\n        claim_interval: msg.claim_interval\n    };\n\n    save_config(deps, \u0026config)?;\n\n    if let Some(pools) = msg.reward_pools {\n        let pools = into_pools(pools);\n        replace_active_pools(deps, \u0026pools)?;\n    }\n\n    Ok(InitResponse {\n        messages: vec![\n            snip20::set_viewing_key_msg(\n                config.viewing_key.0,\n                None,\n                BLOCK_SIZE,\n                config.reward_token.code_hash,\n                config.reward_token.address\n            )?\n        ],\n        log: vec![]\n    })\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::LockTokens { amount, lp_token } =\u003e lock_tokens(deps, env, amount, lp_token),\n        HandleMsg::RetrieveTokens { amount, lp_token } =\u003e retrieve_tokens(deps, env, amount, lp_token),\n        HandleMsg::Claim { lp_tokens } =\u003e claim(deps, env, lp_tokens),\n        HandleMsg::ChangePools { pools, total_share } =\u003e change_pools(deps, env, into_pools(pools), total_share),\n        HandleMsg::Admin(admin_msg) =\u003e admin_handle(deps, env, admin_msg, DefaultAdminHandle),\n        HandleMsg::CreateViewingKey { entropy, .. } =\u003e\n            auth_handle(deps, env, AuthHandleMsg::CreateViewingKey { entropy, padding: None }, AuthImpl),\n        HandleMsg::SetViewingKey { key, .. } =\u003e\n            auth_handle(deps, env, AuthHandleMsg::SetViewingKey { key, padding: None }, AuthImpl)\n    }\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ClaimSimulation { lp_tokens, viewing_key, address, current_time } =\u003e \n            claim_simulation(deps, lp_tokens, address, ViewingKey(viewing_key), current_time),\n        QueryMsg::Accounts { address, viewing_key } =\u003e\n            query_accounts(deps, address, ViewingKey(viewing_key)),\n        QueryMsg::Pools =\u003e query_pools(deps),\n\n        QueryMsg::Admin(admin_msg) =\u003e admin_query(deps, admin_msg, DefaultQueryImpl),\n        QueryMsg::TotalRewardsSupply =\u003e query_supply(deps),\n        // Keplr support:\n        QueryMsg::TokenInfo { } =\u003e to_binary(\u0026QueryMsgResponse::TokenInfo {\n            name: \"Sienna Rewards\".into(),\n            symbol: \"SRW\".into(),\n            decimals: 1,\n            total_supply: None\n        }),\n        QueryMsg::Balance { .. } =\u003e to_binary(\u0026QueryMsgResponse::Balance {\n            amount: Uint128::zero()\n        })\n    }\n}\n\n/// Lock the provided `amount` of tokens associated with the given LP token address.\n/// Increases the total locked for the sender as well as the entire pool size by the given `amount`.\n/// Returns an error if the token address is not among the reward pools.\npub(crate) fn lock_tokens\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n    lp_token_addr: HumanAddr\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    if amount == Uint128::zero() {\n        return Err(StdError::generic_err(\"Lock amount is zero.\"));\n    }\n\n    let mut pool = get_pool_or_fail(deps, \u0026lp_token_addr)?;\n    let mut account = get_or_create_account(deps, \u0026env.message.sender, \u0026lp_token_addr)?;\n\n    account.add_pending_balance(PendingBalance { \n        amount,\n        submitted_at: env.block.time \n    })?;\n\n    // Prevent instant claiming for new accounts\n    if account.last_claimed == 0 {\n        account.last_claimed = env.block.time;\n    }\n\n    pool.size = pool.size\n        .u128()\n        .checked_add(amount.u128())\n        .ok_or_else(||\n            StdError::generic_err(\"Pool size overflow detected.\")\n        )?\n        .into();\n\n    save_account(deps, \u0026account)?;\n    save_pool(deps, \u0026pool)?;\n    \n    Ok(HandleResponse{\n        messages: vec![\n            snip20::transfer_from_msg(\n                account.owner.clone(),\n                env.contract.address,\n                amount,\n                None,\n                BLOCK_SIZE,\n                pool.lp_token.code_hash,\n                pool.lp_token.address\n            )?\n        ],\n        log: vec![\n            log(\"action\", \"lock_tokens\"),\n            log(\"amount_locked\", amount),\n            log(\"locked_by\", account.owner),\n            log(\"lp_token\", account.lp_token_addr),\n            log(\"new_pool_size\", pool.size)\n        ],\n        data: None\n    })\n}\n\n/// Transfer back the specified `amount` of LP tokens to the sender.\n/// Also works even if the pool is not eligible for rewards anymore.\npub(crate) fn retrieve_tokens\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n    lp_token_addr: HumanAddr\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut account = get_account_or_fail(deps, \u0026env.message.sender, \u0026lp_token_addr)?;\n    account.subtract_balance(amount.u128())?;\n\n    save_account(deps, \u0026account)?;\n\n    let pool = if let Some(mut p) = get_pool(deps, \u0026lp_token_addr)? {\n        p.size = p.size.u128().saturating_sub(amount.u128()).into();\n        save_pool(deps, \u0026p)?;\n\n        Some(p)\n    } else {\n        get_inactive_pool(deps, \u0026lp_token_addr)?\n    }.ok_or_else(||\n        StdError::generic_err(\n            format!(\"Pool {} doesn't exist.\", lp_token_addr)\n        )\n    )?;\n    \n    Ok(HandleResponse{\n        messages: vec![\n            snip20::transfer_msg(\n                account.owner.clone(),\n                amount,\n                None,\n                BLOCK_SIZE,\n                pool.lp_token.code_hash,\n                pool.lp_token.address\n            )?\n        ],\n        log: vec![\n            log(\"action\", \"retrieve_tokens\"),\n            log(\"amount_retrieved\", amount),\n            log(\"retrieved_by\", account.owner),\n            log(\"lp_token\", account.lp_token_addr),\n            log(\"new_pool_size\", pool.size)\n        ],\n        data: None\n    })\n}\n\n/// Calculate and transfer the reward token amount for the specified LP token addresses.\n/// If the calculated rewards amount exceeds the current rewards balance, the resulting\n/// amount is truncated to fit the available rewards balance.\npub(crate) fn claim\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    lp_tokens: Vec\u003cHumanAddr\u003e\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = load_config(deps)?;\n    let available_balance = get_balance(\u0026deps.querier, \u0026config)?;\n\n    let mut total_rewards_amount = 0u128;\n\n    for addr in lp_tokens {\n        let pool = get_pool_or_fail(deps, \u0026addr)?;\n\n        let mut account = get_account_or_fail(deps, \u0026env.message.sender, \u0026addr)?;\n        account.unlock_pending(env.block.time, config.claim_interval)?;\n\n        let reward_amount = calc_reward_share(\n            account.locked_amount(),\n            \u0026pool,\n            config.token_decimals\n        )?;\n\n        if reward_amount == 0 {\n            return Err(StdError::generic_err(format!(\n                \"Reward amount for {} is zero.\", \u0026addr\n            )));\n        }\n\n        let portions = calc_portions(\n            account.last_claimed,\n            config.claim_interval,\n            env.block.time\n        )?;\n\n        if portions == 0 {\n            return Err(StdError::generic_err(format!(\n                \"Need to wait {} more seconds before claiming.\",\n                config.claim_interval - (env.block.time - account.last_claimed)\n            )));\n        }\n\n        account.last_claimed = env.block.time;\n        save_account(deps, \u0026account)?;\n\n        total_rewards_amount = total_rewards_amount.saturating_add(\n            reward_amount.saturating_mul(portions as u128)\n        );\n    }\n\n    // Claim the remaining rewards amount if the current rewards pool,\n    // is less than what should be claimed.\n    let claim_amount = if total_rewards_amount \u003e available_balance {\n        available_balance\n    } else {\n        total_rewards_amount\n    };\n\n    Ok(HandleResponse {\n        messages: vec![\n            snip20::transfer_msg(\n                env.message.sender.clone(),\n                Uint128(claim_amount),\n                None,\n                BLOCK_SIZE,\n                config.reward_token.code_hash,\n                config.reward_token.address\n            )?\n        ],\n        log: vec![\n            log(\"action\", \"claim\"),\n            log(\"claimed_by\", env.message.sender),\n            log(\"total_rewards_amount\", total_rewards_amount),\n            log(\"claimed_amount\", claim_amount)\n        ],\n        data: None\n    })\n}\n\n/// Dry runs the claim method providing a detailed result for each of\n/// the provided LP token addresses. Records the actual would be\n/// errors, if any, instead of terminating the function early.\nfn claim_simulation\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    lp_tokens: Vec\u003cHumanAddr\u003e,\n    sender: HumanAddr,\n    key: ViewingKey,\n    current_time: u64\n) -\u003e StdResult\u003cBinary\u003e {\n    let canonical = deps.api.canonical_address(\u0026sender)?;\n    authenticate(\u0026deps.storage, \u0026key, canonical.as_slice())?;\n\n    let config = load_config(deps)?;\n\n    let available_balance = match get_balance(\u0026deps.querier, \u0026config) {\n        Ok(balance) =\u003e balance,\n        Err(err) =\u003e {\n            match err {\n                GetBalanceError::StdError(std_err) =\u003e {\n                    return Err(std_err);\n                }\n                GetBalanceError::PoolEmpty =\u003e {\n                    let mut results = Vec::with_capacity(lp_tokens.len());\n\n                    for addr in lp_tokens {\n                        results.push(ClaimResult::error(addr, ClaimError::PoolEmpty))\n                    }\n                    \n                    return Ok(to_binary(\u0026QueryMsgResponse::ClaimSimulation(\n                        ClaimSimulationResult {\n                            total_rewards_amount: Uint128::zero(),\n                            actual_claimed: Uint128::zero(),\n                            results\n                        }\n                    ))?);\n                }\n            }\n        }\n    };\n    \n    let mut total_rewards_amount = 0u128;\n\n    let mut results = Vec::with_capacity(lp_tokens.len());\n\n    for addr in lp_tokens {\n        let pool = get_pool_or_fail(deps, \u0026addr)?;\n\n        let mut account = get_account_or_fail(deps, \u0026sender, \u0026addr)?;\n        account.unlock_pending(current_time, config.claim_interval)?;\n\n        if account.locked_amount() == 0 {\n            results.push(ClaimResult::error(addr, ClaimError::AccountZeroLocked));\n            continue;\n        }\n\n        let reward_per_portion = calc_reward_share(\n            account.locked_amount(),\n            \u0026pool,\n            config.token_decimals\n        )?;\n\n        if reward_per_portion == 0 {\n            results.push(ClaimResult::error(addr, ClaimError::AccountZeroReward));\n            continue;\n        }\n\n        let portions = calc_portions(\n            account.last_claimed,\n            config.claim_interval,\n            current_time\n        )?;\n\n        if portions == 0 {\n            results.push(ClaimResult::error(addr, ClaimError::EarlyClaim {\n                time_to_wait: config.claim_interval - (current_time - account.last_claimed)\n            }));\n            continue;\n        }\n\n        let reward_amount = reward_per_portion.saturating_mul(portions as u128);\n        results.push(ClaimResult::success(addr, Uint128(reward_amount), Uint128(reward_per_portion)));\n\n        total_rewards_amount = total_rewards_amount.saturating_add(reward_amount);\n    }\n\n    let claim_amount = if total_rewards_amount \u003e available_balance {\n        available_balance\n    } else {\n        total_rewards_amount\n    };\n\n    Ok(to_binary(\u0026QueryMsgResponse::ClaimSimulation(\n        ClaimSimulationResult {\n            total_rewards_amount: Uint128(total_rewards_amount),\n            actual_claimed: Uint128(claim_amount),\n            results\n        }\n    ))?)\n}\n\n/// Admin only command. Replaces the current reward pools with the ones provided.\n/// Keeps the existing pool sizes for the ones that should remain. Instead of deleting\n/// any newly redundant pools, they are marked as inactive in order to allow liquidity providers\n/// to withdraw their shares using the `retrieve_tokens` method.\n#[require_admin]\nfn change_pools\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    pools: Vec\u003cRewardPool\u003cHumanAddr\u003e\u003e,\n    total_share: Uint128\n) -\u003e StdResult\u003cHandleResponse\u003e{\n    let mut sum_total = 0u128;\n\n    for pool in pools.iter() {\n        sum_total = sum_total.checked_add(pool.share.u128()).ok_or_else(||\n            StdError::generic_err(OVERFLOW_MSG)\n        )?;\n    }\n\n    if total_share.u128() != sum_total {\n        return Err(StdError::generic_err(\n            format!(\"Total pool share({}) doesn't match the expected total({}).\", sum_total, total_share)\n        ))\n    }\n\n    replace_active_pools(deps, \u0026pools)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![\n            log(\"action\", \"change_pools\"),\n        ],\n        data: None\n    })\n}\n\n/// Returns all the currently active reward pools.\nfn query_pools\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e StdResult\u003cBinary\u003e {\n    let pools = get_pools(deps)?;\n\n    Ok(to_binary(\u0026QueryMsgResponse::Pools(pools))?)\n}\n\n/// Authenticated command. Returns all the accounts that are\n/// associated with the provided `address` given the LP token\n/// addresses, since a single address can have multiple\n/// accounts - one for each reward pool.\nfn query_accounts\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    address: HumanAddr,\n    key: ViewingKey\n) -\u003e StdResult\u003cBinary\u003e {\n    let canonical = deps.api.canonical_address(\u0026address)?;\n    authenticate(\u0026deps.storage, \u0026key, canonical.as_slice())?;\n\n    let pools = get_pools(deps)?;\n    let mut result = vec![];\n\n    for token in pools.iter().map(|x| \u0026x.lp_token) {\n        let account = get_account(deps, \u0026address, \u0026token.address)?;\n\n        if let Some(acc) = account {\n            result.push(acc);\n        }\n    }\n\n    Ok(to_binary(\u0026QueryMsgResponse::Accounts(result))?)\n}\n\n/// Returns the available balance of reward tokens that\n/// this contract currently has to work with.\nfn query_supply\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e\n) -\u003e StdResult\u003cBinary\u003e {\n    let config = load_config(deps)?;\n    \n    let balance = match get_balance(\u0026deps.querier, \u0026config) {\n        Ok(balance) =\u003e balance,\n        Err(err) =\u003e {\n            match err {\n                GetBalanceError::StdError(std_err) =\u003e {\n                    return Err(std_err);\n                }\n                GetBalanceError::PoolEmpty =\u003e {\n                    0\n                }\n            }\n        }\n    };\n\n    Ok(to_binary(\u0026QueryMsgResponse::TotalRewardsSupply {\n        amount: Uint128(balance)\n    })?)\n}\n\n/// Given a `pool`, calculates the amount of rewards for a single portion.\npub(crate) fn calc_reward_share(\n    mut user_locked: u128,\n    pool: \u0026RewardPool\u003cHumanAddr\u003e,\n    reward_token_decimals: u8\n) -\u003e StdResult\u003cu128\u003e {\n    // Multiply by 100 to get a non float percentage\n    user_locked = user_locked.checked_mul(100).ok_or_else(||\n        StdError::generic_err(OVERFLOW_MSG)\n    )?;\n\n    // This error shouldn't really happen since the TX should already have failed.\n    let share_percentage = user_locked.checked_div(pool.size.u128()).ok_or_else(|| \n        StdError::generic_err(format!(\"Pool size for {} is zero.\", pool.lp_token.address))\n    )?;\n\n    // Convert to actual amount of reward token\n    let share = share_percentage.saturating_mul(\n        // -2 to compensate for the multiplication above\n        get_whole_token_representation(reward_token_decimals - 2)\n    );\n\n    // share * pool.share / one reward token\n    convert_token(\n        share,\n        pool.share.u128(),\n        reward_token_decimals,\n        reward_token_decimals\n    )\n}\n\n#[inline]\npub(crate) fn into_pools(mut vec: Vec\u003cRewardPoolConfig\u003e) -\u003e Vec\u003cRewardPool\u003cHumanAddr\u003e\u003e {\n    vec.drain(..).map(|p| p.into()).collect()\n}\n\n/// Calculates how many portions should be transferred. The amount of portions\n/// depends on when the `claim` method was last called. Ex. given a claim interval\n/// of 1 day and user who hasn't claimed their rewards for 3 days, then they should\n/// earn 3x of their reward share. So the resulting portions would be 3.\npub(crate) fn calc_portions(\n    last_claimed: u64,\n    claim_interval: u64,\n    block_time: u64\n) -\u003e StdResult\u003cu32\u003e {\n    // Could do (current_time - last_claimed) / interval\n    // but can't use floats so...\n    let mut result = 0;\n    \n    let gap = block_time.checked_sub(last_claimed).ok_or_else(|| \n        // Will happen if a wrong time has been provided in claim simulation\n        StdError::generic_err(\"Invalid timestamp supplied.\")\n    )?;\n    let mut acc = claim_interval;\n\n    while gap \u003e= acc {\n        acc += claim_interval;\n        result += 1;\n    }\n\n    Ok(result)\n}\n\n#[inline]\nfn get_pool_or_fail\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    address: \u0026HumanAddr\n) -\u003e StdResult\u003cRewardPool\u003cHumanAddr\u003e\u003e { \n    get_pool(deps, address)?.ok_or_else(||\n        StdError::generic_err(format!(\n            \"LP token {} is not eligible for rewards.\", address\n        ))\n    )\n}\n\n#[inline]\nfn get_account_or_fail\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    address: \u0026HumanAddr,\n    lp_token: \u0026HumanAddr\n) -\u003e StdResult\u003cAccount\u003cHumanAddr\u003e\u003e { \n    get_account(deps, address, lp_token)?.ok_or_else(||\n        StdError::generic_err(format!(\n            \"No account for {} exists for address {}.\",\n            address,\n            lp_token\n        ))\n    )\n}\n\n/// Returns the available balance of reward tokens that\n/// this contract currently has to work with. Returns a \n/// special error type to differentiate between a balance of 0\n/// or something else that went wrong.\nfn get_balance(querier: \u0026impl Querier, config: \u0026Config\u003cHumanAddr\u003e) -\u003e Result\u003cu128, GetBalanceError\u003e {\n    let available_balance = snip20::balance_query(\n        querier,\n        config.this_contract.address.clone(),\n        config.viewing_key.0.clone(),\n        BLOCK_SIZE,\n        config.reward_token.code_hash.clone(),\n        config.reward_token.address.clone()\n    )?;\n\n    let available_balance = available_balance.amount.u128();\n\n    if available_balance == 0 {\n        return Err(GetBalanceError::PoolEmpty);\n    }\n\n    Ok(available_balance)\n}\n","traces":[{"line":30,"address":[848192,852218],"length":1,"stats":{"Line":1},"fn_name":"init\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":35,"address":[848240],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[848539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[848654,848753,853316],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[848718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[848727,849004],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[849012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[849306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[849420],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[849484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[849528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[849560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[849779,850118,853145,850051],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[850364,850087],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[850406],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[850482,850554,853140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[851745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[850823,851707,851327,853063,853125],"length":1,"stats":{"Line":4},"fn_name":null},{"line":68,"address":[851071,850971,851700,851466],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[850839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[850879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[850891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[850931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[851733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[855836,854416],"length":1,"stats":{"Line":2},"fn_name":"handle\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":85,"address":[854728,855432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[856019,854740,854465],"length":1,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[854916,856024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[855092,856029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[855224,855901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[856034,855447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[855579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[855628,856039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[854518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[854567,856014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[857035,856096],"length":1,"stats":{"Line":1},"fn_name":"query\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":102,"address":[856190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[856131,856207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[857155,856282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[856450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[857157,856498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[856630,857159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[856650,857161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[856670,857163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[856759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[856680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[856711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[856747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[856935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[856160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[862272,857264],"length":1,"stats":{"Line":2},"fn_name":"lock_tokens\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":133,"address":[857341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[857493,857563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[857870,857621,862935,857548],"length":1,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[862868,857848,858135,858472],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[859054,858398,858817,858721,858765],"length":1,"stats":{"Line":6},"fn_name":null},{"line":141,"address":[858378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[858394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[858797,859086],"length":1,"stats":{"Line":4},"fn_name":null},{"line":147,"address":[859074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[859590,859620,859090,859180,859295],"length":1,"stats":{"Line":8},"fn_name":null},{"line":152,"address":[859125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[863728],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":154,"address":[863740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[862858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[859652,862853,859740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[860005,859730,860088,862848],"length":1,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[861826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[861245,862830,862733,860862,860046],"length":1,"stats":{"Line":4},"fn_name":null},{"line":163,"address":[860485,860606,861238,861001],"length":1,"stats":{"Line":4},"fn_name":null},{"line":164,"address":[860078],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[860345],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[860377],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[860393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[860405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[860445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[862156,861273,862715,861565],"length":1,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[861289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[861329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[861372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[861447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[861522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[861814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[863776,869046],"length":1,"stats":{"Line":1},"fn_name":"retrieve_tokens\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":192,"address":[863874,864222,869503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[864497,864184,869498,864585],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[864912,864850,864575,869493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[864902,865578,866736,866035,867080,866843,866665,865177,869508,866398],"length":1,"stats":{"Line":6},"fn_name":null},{"line":198,"address":[865856,865674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[865929,869432,866040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[865983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[865568,866318,866403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[869430,870096,866657],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":205,"address":[870278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[870120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[868531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[869262,869079,869357,867567,867950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[867943,867706,867311,867200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[869111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[867092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[867108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[867120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[867160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[868891,869244,868270,867978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[867994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[868034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[868077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[868152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[868227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[868519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[877118,870304],"length":1,"stats":{"Line":1},"fn_name":"claim\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":240,"address":[870368,870632,877869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[871077,870897,877750,870610],"length":1,"stats":{"Line":4},"fn_name":null},{"line":243,"address":[870996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[871020,875112,871458,871322],"length":1,"stats":{"Line":5},"fn_name":null},{"line":246,"address":[871884,877711,871628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[871854,872149,872414,877706],"length":1,"stats":{"Line":4},"fn_name":null},{"line":249,"address":[872779,877701,872663,872376],"length":1,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[872747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[873183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[873470,873596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[873454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[873542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[873550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[873558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[873856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[874274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[874127,874234,878375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[874186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[877686,874551,874214,874665],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[874605,875039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[874631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[875133,875191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[875175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[875193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[876629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[875235,877591,877668,875785,876168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[876161,875402,875529,875924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[875259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[875278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[875310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[875322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[875362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[876413,877573,876966,876196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[876212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[876260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[876327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[876370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[876617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[878896,886870],"length":1,"stats":{"Line":0},"fn_name":"claim_simulation\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":323,"address":[878992,887121,879235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[879191,879528,887116,879608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[887111,880038,879877,879598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[880429,880016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[880291,880439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[880306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[880574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[880402,880576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[880602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[880556,880694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[880717,880907,881167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[881053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[887160,881885,881512,881362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[881298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[881172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[881205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[881258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[880503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[880527,881923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[882128,885437,881938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[882558,886978,882306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[886973,882548,882827,883088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[886968,883054,883451,883341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[883714,883425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[883721,887165,883859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[883820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[884012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[884279,884425,887170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[884378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[884386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[884499],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[885050,884959,884774,887175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[884838,884935,887702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[885080,884891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[885096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[885256,885375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[885567,885509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[885551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[885569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[885793,885940,886053,886282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[885697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[885601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[885633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[885665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[897663,897781,900039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[900005,897584],"length":1,"stats":{"Line":1},"fn_name":"change_pools\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":425,"address":[897725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[898046,898535,897749,898261],"length":1,"stats":{"Line":3},"fn_name":null},{"line":428,"address":[898777,900208,898295,898487,898540],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":429,"address":[900220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[898217,898805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":434,"address":[899178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[898842,898996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":439,"address":[899271,900035,899320,898961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":441,"address":[899734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[899310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[899635,900020,899579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[899595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[899722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[888756,887952],"length":1,"stats":{"Line":0},"fn_name":"query_pools\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":454,"address":[888165,887976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[888076,888265,888473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[888832,891805],"length":1,"stats":{"Line":0},"fn_name":"query_accounts\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":468,"address":[891969,888878,889061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[889023,889419,889342,891964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[889794,891959,889409,889688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[889784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[890360,892320,891828,890055,892336],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":475,"address":[890558,890412,891954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[890832,890523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[890941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[890262,891065,891230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[892352,893472],"length":1,"stats":{"Line":0},"fn_name":"query_supply\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":490,"address":[892382,892532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[892771,892821,892513,892850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[892773,892636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[892651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[892855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[892747,892857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[892883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[892826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[893012,893519,893348,893122,892963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[893487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[893696],"length":1,"stats":{"Line":1},"fn_name":"calc_reward_share"},{"line":518,"address":[893760,894656,893890,894000,894088],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":519,"address":[894668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[894704,894133,894328,894416,894251,893938],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":524,"address":[894728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[894477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[894612,894439,894309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":536,"address":[894514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":551,"address":[895136],"length":1,"stats":{"Line":1},"fn_name":"calc_portions"},{"line":558,"address":[895195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[895600,895278,895203,895314,895396],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":562,"address":[895612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[895304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[895416,895510,895312],"length":1,"stats":{"Line":3},"fn_name":null},{"line":567,"address":[895451,895525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[895555,895484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[895431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[895648],"length":1,"stats":{"Line":2},"fn_name":"get_pool_or_fail\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":579,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[896144],"length":1,"stats":{"Line":2},"fn_name":"get_account_or_fail\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":592,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[897413,896784],"length":1,"stats":{"Line":2},"fn_name":"get_balance\u003csienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":608,"address":[896859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":609,"address":[896889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":611,"address":[896925],"length":1,"stats":{"Line":2},"fn_name":null},{"line":612,"address":[896969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":615,"address":[897156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":617,"address":[897310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":618,"address":[897322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":[897385],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":168,"coverable":271},{"path":["/","home","runner","work","sienna","sienna","contracts","rewards","src","data.rs"],"content":"use cosmwasm_std::{Api, CanonicalAddr, HumanAddr, StdResult, Uint128, StdError};\nuse fadroma_scrt_callback::ContractInstance;\nuse fadroma_scrt_addr::{Canonize, Humanize};\nuse serde::{Serialize, Deserialize};\nuse schemars::JsonSchema;\n\nuse crate::msg::{OVERFLOW_MSG, UNDERFLOW_MSG};\n\n#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]\n/// Represents a pair that is eligible for rewards.\npub struct RewardPool\u003cA\u003e {\n    pub lp_token: ContractInstance\u003cA\u003e,\n    /// The reward amount allocated to this pool.\n    pub share: Uint128,\n    /// Total amount locked by all participants.\n    pub size: Uint128\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]\n/// Accounts are based on (user - LP token) pairs. This means that a single\n/// user can have multiple accounts - one for each LP token.\npub struct Account\u003cA\u003e {\n    /// The owner of this account.\n    pub owner: A,\n    /// The address of the LP token that this account is for.\n    pub lp_token_addr: A,\n    /// The last time that the user claimed their rewards.\n    pub last_claimed: u64,\n    /// The amount of LP tokens the owner has locked into this contract.\n    locked_amount: Uint128,\n    /// A history of submitted tokens that aren't included in the rewards calculations yet.\n    pending_balances: Option\u003cVec\u003cPendingBalance\u003e\u003e\n}\n\n#[derive(Serialize, Deserialize, Clone, Copy, Debug, JsonSchema)]\npub struct PendingBalance {\n    pub submitted_at: u64,\n    pub amount: Uint128\n}\n\nimpl PartialEq for Account\u003cHumanAddr\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.owner == other.owner \u0026\u0026 self.lp_token_addr == self.lp_token_addr\n    }\n}\n\nimpl PartialEq for RewardPool\u003cHumanAddr\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.lp_token.address == other.lp_token.address\n    }\n}\n\nimpl Account\u003cHumanAddr\u003e {\n    pub fn new(owner: HumanAddr, lp_token_addr: HumanAddr) -\u003e Self {\n        Account {\n            owner,\n            lp_token_addr,\n            locked_amount: Uint128::zero(),\n            pending_balances: None,\n            last_claimed: 0\n        }\n    }\n\n    pub fn locked_amount(\u0026self) -\u003e u128 {\n        self.locked_amount.u128()\n    }\n\n    pub fn total_pending(\u0026self) -\u003e u128 {\n        if let Some(pending) = \u0026self.pending_balances {\n            pending.iter().map(|x| x.amount.u128()).sum()\n        } else {\n            0    \n        }\n    }\n\n    /// Adds the pending `balance` to the deposit history.\n    /// Also checks if calling `unlock_pending` would cause an overflow.\n    /// Returns the pending balance after the add operation.\n    pub fn add_pending_balance(\u0026mut self, balance: PendingBalance) -\u003e StdResult\u003cu128\u003e {\n        let total = self.total_pending();\n\n        let new_total = total.checked_add(balance.amount.u128());\n\n        if let Some(nt) = new_total {\n            if self.locked_amount.u128().checked_add(nt).is_some() {\n                if let Some(history) = \u0026mut self.pending_balances {\n                    history.push(balance);\n                } else {\n                    self.pending_balances = Some(vec![balance]);\n                }\n\n                return Ok(nt);\n            }\n        }\n\n        return Err(StdError::generic_err(OVERFLOW_MSG));\n    }\n\n    /// Adds any of the pending balance that can be unlocked to the actual locked amount.\n    /// Returns the amount unlocked.\n    pub fn unlock_pending(\u0026mut self, current_time: u64, interval: u64) -\u003e StdResult\u003cu128\u003e {\n        let mut total_unlocked = 0u128;\n\n        if let Some(balances) = \u0026mut self.pending_balances {\n            let mut index = 0;\n\n            for (i, balance) in balances.iter().enumerate() {\n                let gap = current_time.checked_sub(balance.submitted_at).ok_or_else(||\n                    // Will happen if a wrong time has been provided in claim simulation\n                    StdError::generic_err(UNDERFLOW_MSG)\n                )?;\n\n                if gap \u003c interval {\n                    if i == 0 {\n                        return Ok(0);\n                    }\n\n                    break;\n                }\n\n                total_unlocked += balance.amount.u128();\n                self.locked_amount += balance.amount;\n                \n                index = i;\n            }\n\n            for _ in 0..=index {\n                balances.remove(0);\n            }\n\n            if balances.len() == 0 {\n                self.pending_balances = None;\n            }\n        }\n\n        Ok(total_unlocked)\n    }\n\n    /// Subtracts the specified `amount` from the account, starting from\n    /// the pending balance and any remainder - from the actual locked amount.\n    pub fn subtract_balance(\u0026mut self, mut amount: u128) -\u003e StdResult\u003c()\u003e {\n        if amount \u003e self.total_pending() + self.locked_amount.u128() {\n            return Err(StdError::generic_err(\"Insufficient balance.\"));\n        }\n\n        if let Some(balances) = \u0026mut self.pending_balances {\n            let mut to_remove = 0;\n\n            for balance in balances.iter_mut().rev() {\n                if balance.amount.u128() \u003c= amount {\n                    amount -= balance.amount.u128();\n                } else {\n                    balance.amount = Uint128(balance.amount.u128() - amount);\n                    amount = 0;\n\n                    break;\n                }\n\n                to_remove += 1;\n            }\n\n            while to_remove \u003e 0 {\n                balances.pop();\n                to_remove -= 1;\n            }\n\n            if balances.len() == 0 {\n                self.pending_balances = None;\n            }\n\n            if amount \u003e 0 {\n                self.locked_amount = Uint128(self.locked_amount.u128() - amount);\n            }\n        } else {\n            self.locked_amount = Uint128(self.locked_amount.u128() - amount);\n        }\n        \n        Ok(())\n    }\n}\n\nimpl Humanize\u003cAccount\u003cHumanAddr\u003e\u003e for Account\u003cCanonicalAddr\u003e {\n    fn humanize(\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cAccount\u003cHumanAddr\u003e\u003e {\n        Ok(Account {\n            owner: self.owner.humanize(api)?,\n            lp_token_addr: self.lp_token_addr.humanize(api)?,\n            locked_amount: self.locked_amount,\n            pending_balances: self.pending_balances.clone(),\n            last_claimed: self.last_claimed\n        })\n    }\n}\n\nimpl Canonize\u003cAccount\u003cCanonicalAddr\u003e\u003e for Account\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cAccount\u003cCanonicalAddr\u003e\u003e {\n        Ok(Account {\n            owner: self.owner.canonize(api)?,\n            lp_token_addr: self.lp_token_addr.canonize(api)?,\n            locked_amount: self.locked_amount,\n            pending_balances: self.pending_balances.clone(),\n            last_claimed: self.last_claimed\n        })\n    }\n}\n\nimpl Humanize\u003cRewardPool\u003cHumanAddr\u003e\u003e for RewardPool\u003cCanonicalAddr\u003e {\n    fn humanize(\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cRewardPool\u003cHumanAddr\u003e\u003e {\n        Ok(RewardPool {\n            lp_token: self.lp_token.humanize(api)?,\n            share: self.share,\n            size: self.size\n        })\n    }\n}\n\nimpl Canonize\u003cRewardPool\u003cCanonicalAddr\u003e\u003e for RewardPool\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cRewardPool\u003cCanonicalAddr\u003e\u003e {\n        Ok(RewardPool {\n            lp_token: self.lp_token.canonize(api)?,\n            share: self.share,\n            size: self.size\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_account() -\u003e Account\u003cHumanAddr\u003e {\n        Account::new(\"user\".into(), \"lp_token\".into())\n    }\n\n    #[test]\n    fn test_add_pending_balance() {\n        let mut acc = create_account();\n\n        let amount = 100;\n\n        let total = acc.add_pending_balance(PendingBalance {\n            amount: Uint128(amount),\n            submitted_at: 50\n        }).unwrap();\n\n        assert_eq!(total, amount);\n\n        let total = acc.add_pending_balance(PendingBalance {\n            amount: Uint128(amount),\n            submitted_at: 50\n        }).unwrap();\n\n        assert_eq!(total, amount * 2);\n        assert_eq!(acc.total_pending(), amount * 2);\n\n        let result = acc.add_pending_balance(PendingBalance {\n            amount: Uint128(u128::MAX),\n            submitted_at: 50\n        });\n        assert!(result.is_err());\n\n        // Should overflow when trying to add to locked_amount\n        let result = acc.add_pending_balance(PendingBalance {\n            amount: Uint128((u128::MAX - amount * 2) + 1),\n            submitted_at: 50\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_unlock_pending_balance() {\n        let mut acc = create_account();\n        let interval = 100;\n\n        acc.add_pending_balance(PendingBalance {\n            amount: Uint128(100),\n            submitted_at: 100\n        }).unwrap();\n\n        acc.add_pending_balance(PendingBalance {\n            amount: Uint128(50),\n            submitted_at: 200\n        }).unwrap();\n\n        acc.add_pending_balance(PendingBalance {\n            amount: Uint128(20),\n            submitted_at: 300\n        }).unwrap();\n\n        let unlocked = acc.unlock_pending(310, interval).unwrap();\n        assert_eq!(acc.locked_amount(), 150);\n        assert_eq!(unlocked, 150);\n        assert_eq!(acc.total_pending(), 20);\n\n        acc.add_pending_balance(PendingBalance {\n            amount: Uint128(50),\n            submitted_at: 340\n        }).unwrap();\n\n        let unlocked = acc.unlock_pending(350, interval).unwrap();\n        assert_eq!(acc.locked_amount(), 150);\n        assert_eq!(unlocked, 0);\n        assert_eq!(acc.total_pending(), 70);\n\n        let unlocked = acc.unlock_pending(440, interval).unwrap();\n        assert_eq!(acc.locked_amount(), 220);\n        assert_eq!(unlocked, 70);\n        assert_eq!(acc.total_pending(), 0);\n    }\n\n    #[test]\n    fn test_subtract_balance() {\n        let mut acc = create_account();\n\n        acc.add_pending_balance(PendingBalance {\n            amount: Uint128(100),\n            submitted_at: 100\n        }).unwrap();\n\n        acc.add_pending_balance(PendingBalance {\n            amount: Uint128(100),\n            submitted_at: 120\n        }).unwrap();\n\n        acc.subtract_balance(201).unwrap_err();\n        assert_eq!(acc.locked_amount(), 0);\n        assert_eq!(acc.total_pending(), 200);\n\n        acc.subtract_balance(199).unwrap();\n        assert_eq!(acc.locked_amount(), 0);\n        assert_eq!(acc.total_pending(), 1);\n\n        // Should start subtracting from the most recent entry\n        acc.unlock_pending(200, 100).unwrap();\n        assert_eq!(acc.locked_amount(), 1);\n        assert_eq!(acc.total_pending(), 0);\n\n        acc.add_pending_balance(PendingBalance {\n            amount: Uint128(100),\n            submitted_at: 100\n        }).unwrap();\n\n        acc.subtract_balance(101).unwrap();\n        assert_eq!(acc.locked_amount(), 0);\n        assert_eq!(acc.total_pending(), 0);\n\n        acc.add_pending_balance(PendingBalance {\n            amount: Uint128(100),\n            submitted_at: 100\n        }).unwrap();\n\n        acc.add_pending_balance(PendingBalance {\n            amount: Uint128(100),\n            submitted_at: 120\n        }).unwrap();\n\n        acc.subtract_balance(100).unwrap();\n        assert_eq!(acc.locked_amount(), 0);\n        assert_eq!(acc.total_pending(), 100);\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[1177534,1177424],"length":1,"stats":{"Line":2},"fn_name":"create_account"},{"line":231,"address":[1177437,1177546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[1180464,1180432,1180437,1182145],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":236,"address":[1180471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1180484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1180540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1180508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[1180715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1180912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[1180880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[1181079,1182184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[1182214,1181329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[1181608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[1181699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[1181901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[1181757,1182269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[1182000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[1182405,1182400,1182432,1185124],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":271,"address":[1182439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[1182452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[1182464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[1182569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[1182674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[1182805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[1182896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[1183141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[1183317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[1183554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[1183685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[1183776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[1184021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[1184184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1184429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[1184508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[1184729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[1184893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1188348,1185168,1185200,1185173],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":312,"address":[1185207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[1185220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[1185325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[1185453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[1185517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[1185749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[1186009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[1186046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[1186278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[1186541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[1186578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[1186823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[1187047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[1187175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[1187212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[1187426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[1187626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[1187731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[1187859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[1187896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":358,"address":[1188104],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":139,"coverable":144},{"path":["/","home","runner","work","sienna","sienna","contracts","rewards","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\npub mod state;\npub mod data;\npub mod auth;\n\n#[cfg(test)]\nmod test_helpers;\n#[cfg(test)]\nmod tests;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","rewards","src","msg.rs"],"content":"use cosmwasm_std::{Binary, HumanAddr, Uint128, StdError};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse fadroma_scrt_callback::ContractInstance;\nuse composable_admin::admin::{AdminHandleMsg, AdminQueryMsg};\n\nuse crate::data::{RewardPool, Account};\n\npub(crate) const OVERFLOW_MSG: \u0026str = \"Overflow detected.\";\npub(crate) const UNDERFLOW_MSG: \u0026str = \"Underflow detected.\";\n\n/// Represents a pair that is eligible for rewards.\n#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema)]\npub struct RewardPoolConfig {\n    /// The LP token address that the pool will be associated with.\n    pub lp_token: ContractInstance\u003cHumanAddr\u003e,\n    /// The reward amount allocated to this pool.\n    pub share: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n    pub admin: Option\u003cHumanAddr\u003e,\n    pub reward_token: ContractInstance\u003cHumanAddr\u003e,\n    pub reward_pools: Option\u003cVec\u003cRewardPoolConfig\u003e\u003e,\n    pub claim_interval: u64,\n    pub prng_seed: Binary,\n    pub entropy: Binary\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    LockTokens { \n        amount: Uint128,\n        lp_token: HumanAddr\n    },\n    RetrieveTokens {\n        amount: Uint128,\n        lp_token: HumanAddr\n    },\n    Claim {\n        /// The addresses of the LP tokens pools to claim from.\n        lp_tokens: Vec\u003cHumanAddr\u003e\n    },\n    ChangePools {\n        /// The total share of all the pools provided. This is used\n        /// as an additional correctness check.\n        total_share: Uint128, \n        pools: Vec\u003cRewardPoolConfig\u003e\n    },\n    CreateViewingKey {\n        entropy: String,\n        padding: Option\u003cString\u003e,\n    },\n    SetViewingKey {\n        key: String,\n        padding: Option\u003cString\u003e,\n    },\n    Admin(AdminHandleMsg)\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    ClaimSimulation {\n        /// The addresses of the LP tokens pools to claim from.\n        lp_tokens: Vec\u003cHumanAddr\u003e,\n        viewing_key: String,\n        address: HumanAddr,\n        /// Unix time in seconds.\n        current_time: u64\n    },\n    Accounts { \n        address: HumanAddr,\n        viewing_key: String\n    },\n    Pools,\n    TotalRewardsSupply,\n    Admin(AdminQueryMsg),\n    /// Copy of SNIP20 message for Keplr support\n    TokenInfo { },\n    /// This is only here because of Keplr\n    Balance { address: HumanAddr, key: String, },\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsgResponse {\n    ClaimSimulation(ClaimSimulationResult),\n    Accounts(Vec\u003cAccount\u003cHumanAddr\u003e\u003e),\n    Pools(Vec\u003cRewardPool\u003cHumanAddr\u003e\u003e),\n    TotalRewardsSupply {\n        amount: Uint128\n    },\n    /// Copy of SNIP20 message for Keplr support\n    TokenInfo {\n        name: String,\n        symbol: String,\n        decimals: u8,\n        total_supply: Option\u003cUint128\u003e\n    },\n    /// Copy of SNIP20 message for Keplr support\n    Balance {\n        amount: Uint128,\n    },\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, PartialEq, Debug)]\npub struct ClaimSimulationResult {\n    /// Detailed info about the claim for each reward pool.\n    pub results: Vec\u003cClaimResult\u003e,\n    /// The total amount of rewards that should be claimed from all\n    /// the supplied pools.\n    pub total_rewards_amount: Uint128,\n    /// The actual amount of rewards that would be claimed from all\n    /// the supplied pools.\n    pub actual_claimed: Uint128\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, PartialEq, Debug)]\npub struct ClaimResult {\n    /// The address of the LP token that the reward pool\n    /// corresponds to.\n    pub lp_token_addr: HumanAddr,\n    /// The total reward amount that would be claimed from this pool.\n    pub reward_amount: Uint128,\n    /// The reward amount that would be claimed for a single portion.\n    pub reward_per_portion: Uint128,\n    pub success: bool,\n    pub error: Option\u003cClaimError\u003e\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\n#[serde(tag = \"type\")]\npub enum ClaimError {\n    /// Occurs when the rewards pool is currently empty.\n    PoolEmpty,\n    /// Occurs when the user has no tokens locked in this pool.\n    /// In practice, this can occur when a wrong address was provided to the query.\n    AccountZeroLocked,\n    /// It is possible for the user's share to be so little, that\n    /// the actual reward amount of rewards calculated to be zero.\n    /// However, it is highly unlikely in practice.\n    AccountZeroReward,\n    /// Occurs when the user tries to claim earlier than the designated claim interval.\n    EarlyClaim {\n        /// In Unix seconds.\n        time_to_wait: u64\n    }\n}\n\npub(crate) enum GetBalanceError {\n    PoolEmpty,\n    StdError(StdError)\n}\n\nimpl From\u003cStdError\u003e for GetBalanceError {\n    fn from(err: StdError) -\u003e Self {\n        GetBalanceError::StdError(err)\n    }\n}\n\nimpl From\u003cGetBalanceError\u003e for StdError {\n    fn from(err: GetBalanceError) -\u003e Self {\n        match err {\n            GetBalanceError::PoolEmpty =\u003e {\n                StdError::generic_err(\n                    \"The reward token pool is currently empty.\"\n                )\n            },\n            GetBalanceError::StdError(std_err) =\u003e std_err\n        }\n    }\n}\n\nimpl ClaimResult {\n    pub fn success(lp_token_addr: HumanAddr, reward_amount: Uint128, reward_per_portion: Uint128) -\u003e Self {\n        Self {\n            lp_token_addr,\n            reward_amount,\n            reward_per_portion,\n            success: true,\n            error: None\n        }\n    }\n\n    pub fn error(lp_token_addr: HumanAddr, error: ClaimError) -\u003e Self {\n        Self {\n            lp_token_addr,\n            reward_amount: Uint128::zero(),\n            reward_per_portion: Uint128::zero(),\n            success: false,\n            error: Some(error)\n        }\n    }\n}\n\nimpl Into\u003cRewardPool\u003cHumanAddr\u003e\u003e for RewardPoolConfig {\n    fn into(self) -\u003e RewardPool\u003cHumanAddr\u003e {\n        RewardPool {\n            lp_token: self.lp_token,\n            share: self.share,\n            size: Uint128::zero()\n        }\n    }\n}\n","traces":[{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[1172240],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[1172259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[605408],"length":1,"stats":{"Line":0},"fn_name":"success"},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[1054081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[1054146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":6,"coverable":15},{"path":["/","home","runner","work","sienna","sienna","contracts","rewards","src","state.rs"],"content":"use cosmwasm_std::{\n    Api, CanonicalAddr, Extern, HumanAddr, Querier, StdResult,\n    Storage, StdError, Uint128, Binary\n};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse fadroma_scrt_callback::ContractInstance;\nuse fadroma_scrt_addr::{Canonize, Humanize};\nuse fadroma_scrt_storage::{load, save, ns_load, ns_save, ns_remove};\nuse cosmwasm_utils::viewing_key::ViewingKey;\n\nuse crate::data::*;\n\nconst CONFIG_KEY: \u0026[u8] = b\"config\";\nconst POOLS_KEY: \u0026[u8] = b\"pools\";\nconst POOL_INDEX: \u0026[u8] = b\"pools_index\";\nconst INACTIVE_POOLS_KEY: \u0026[u8] = b\"inactive_pools\";\nconst ACCOUNTS_KEY: \u0026[u8] = b\"accounts\";\n\n#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]\npub struct Config\u003cA\u003e {\n    pub reward_token: ContractInstance\u003cA\u003e,\n    pub this_contract: ContractInstance\u003cA\u003e,\n    pub token_decimals: u8,\n    pub viewing_key: ViewingKey,\n    pub prng_seed: Binary,\n    pub claim_interval: u64\n}\n\npub(crate) fn save_config\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    config: \u0026Config\u003cHumanAddr\u003e\n) -\u003e StdResult\u003c()\u003e {\n    save(\u0026mut deps.storage, CONFIG_KEY, \u0026config.canonize(\u0026deps.api)?)\n}\n\npub(crate) fn load_config\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e\n) -\u003e StdResult\u003cConfig\u003cHumanAddr\u003e\u003e {\n    let config: Config\u003cCanonicalAddr\u003e = load(\u0026deps.storage, CONFIG_KEY)?.unwrap();\n\n    Ok(config.humanize(\u0026deps.api)?)\n}\n\npub(crate) fn replace_active_pools\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    pools: \u0026Vec\u003cRewardPool\u003cHumanAddr\u003e\u003e\n) -\u003e StdResult\u003c()\u003e {\n    let mut index = Vec::with_capacity(pools.len());\n    let mut pools_stored = Vec::with_capacity(pools.len());\n\n    // Keep sizes for pools that stay\n    for pool in pools.iter() {\n        let mut pool = pool.canonize(\u0026deps.api)?;\n        index.push(pool.lp_token.address.clone());\n\n        let stored_pool: Option\u003cRewardPool\u003cCanonicalAddr\u003e\u003e = \n            ns_load(\u0026deps.storage, POOLS_KEY, pool.lp_token.address.as_slice())?;\n\n        if let Some(p) = stored_pool {\n            pool.size = p.size;\n        }\n\n        pools_stored.push(pool);\n    }\n\n    // Delete all the current pools. The reason why they are not actually deleted\n    // is to allow users that still have locked their LP tokens into them to be\n    // able to withdraw them.\n    set_current_pools_inactive(deps)?;\n\n    // Finally, save/update the new ones and ensure they are not inactive\n    for pool in pools_stored {\n        ns_save(\n            \u0026mut deps.storage,\n            POOLS_KEY,\n            pool.lp_token.address.as_slice(),\n            \u0026pool\n        )?;\n\n        ns_remove(\u0026mut deps.storage, INACTIVE_POOLS_KEY, \u0026pool.lp_token.address.as_slice());\n    }\n\n    save(\u0026mut deps.storage, POOL_INDEX, \u0026index)\n}\n\npub(crate) fn get_pools\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e StdResult\u003cVec\u003cRewardPool\u003cHumanAddr\u003e\u003e\u003e {\n    let index: Vec\u003cCanonicalAddr\u003e = \n        load(\u0026deps.storage, POOL_INDEX)?.unwrap_or(vec![]);\n\n    let mut result = Vec::with_capacity(index.len());\n\n    for addr in index {\n        let pool: Option\u003cRewardPool\u003cCanonicalAddr\u003e\u003e = \n            ns_load(\u0026deps.storage, POOLS_KEY, addr.as_slice())?;\n\n        if let Some(p) = pool {\n            result.push(p.humanize(\u0026deps.api)?)\n        }\n    }\n\n    Ok(result)\n}\n\npub(crate) fn get_pool\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    address: \u0026HumanAddr\n) -\u003e StdResult\u003cOption\u003cRewardPool\u003cHumanAddr\u003e\u003e\u003e {\n    let address = deps.api.canonical_address(address)?;\n\n    let result: Option\u003cRewardPool\u003cCanonicalAddr\u003e\u003e = \n        ns_load(\u0026deps.storage, POOLS_KEY, address.as_slice())?;\n    \n    if let Some(pool) = result {\n        Ok(Some(pool.humanize(\u0026deps.api)?))\n    } else {\n        Ok(None)\n    }\n}\n\npub(crate) fn get_inactive_pool\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    address: \u0026HumanAddr\n) -\u003e StdResult\u003cOption\u003cRewardPool\u003cHumanAddr\u003e\u003e\u003e {\n    let address = deps.api.canonical_address(address)?;\n\n    let result: Option\u003cRewardPool\u003cCanonicalAddr\u003e\u003e = \n        ns_load(\u0026deps.storage, INACTIVE_POOLS_KEY, address.as_slice())?;\n    \n    if let Some(pool) = result {\n        Ok(Some(pool.humanize(\u0026deps.api)?))\n    } else {\n        Ok(None)\n    }\n}\n\npub(crate) fn save_pool\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    pool: \u0026RewardPool\u003cHumanAddr\u003e\n) -\u003e StdResult\u003c()\u003e {\n    let pool = pool.canonize(\u0026deps.api)?;\n\n    ns_save(\n        \u0026mut deps.storage,\n        POOLS_KEY,\n        pool.lp_token.address.as_slice(),\n        \u0026pool\n    )\n}\n\npub(crate) fn save_account\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    account: \u0026Account\u003cHumanAddr\u003e\n) -\u003e StdResult\u003c()\u003e {\n    let account = account.canonize(\u0026deps.api)?;\n    let key = generate_account_key(\u0026account.owner, \u0026account.lp_token_addr);\n\n    ns_save(\n        \u0026mut deps.storage,\n        ACCOUNTS_KEY,\n        \u0026key,\n        \u0026account\n    )\n}\n\npub(crate) fn get_or_create_account\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    address: \u0026HumanAddr,\n    lp_token_addr: \u0026HumanAddr\n) -\u003e StdResult\u003cAccount\u003cHumanAddr\u003e\u003e {\n    let result: Option\u003cAccount\u003cHumanAddr\u003e\u003e = get_account(deps, address, lp_token_addr)?;\n\n    if let Some(acc) = result {\n        Ok(acc)\n    } else {\n        Ok(Account::new(address.clone(), lp_token_addr.clone()))\n    }\n}\n\npub(crate) fn get_account\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    address: \u0026HumanAddr,\n    lp_token_addr: \u0026HumanAddr\n) -\u003e StdResult\u003cOption\u003cAccount\u003cHumanAddr\u003e\u003e\u003e {\n    let addr_raw = deps.api.canonical_address(address)?;\n    let lp_token_raw = deps.api.canonical_address(lp_token_addr)?;\n\n    let key = generate_account_key(\u0026addr_raw, \u0026lp_token_raw);\n    let result: Option\u003cAccount\u003cCanonicalAddr\u003e\u003e = ns_load(\u0026deps.storage, ACCOUNTS_KEY, \u0026key)?;\n\n    if let Some(acc) = result {\n        Ok(Some(acc.humanize(\u0026deps.api)?))\n    } else {\n        Ok(None)\n    }\n}\n\nfn set_current_pools_inactive\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e\n) -\u003e StdResult\u003c()\u003e {\n    let index: Vec\u003cCanonicalAddr\u003e = \n        load(\u0026mut deps.storage, POOL_INDEX)?.unwrap_or(vec![]);\n\n    for addr in index {\n        let mut pool: RewardPool\u003cCanonicalAddr\u003e = \n            ns_load(\u0026mut deps.storage, POOLS_KEY, addr.as_slice())?\n            .ok_or_else(||\n                StdError::generic_err(\n                    format!(\"Pool {} doesn't exist in active pool index.\", addr)\n                )\n            )?;\n        \n        // The pool share will be provided in the configuration if the\n        // pool is restored, while the size is effectively being reset.\n        // We don't have to keep the size information in order to allow\n        // users to withdraw their LP tokens, because the specific amount\n        // for each user is stored in their account, for which, we only\n        // need the LP token address.\n        pool.share = Uint128::zero();\n        pool.size = Uint128::zero();\n\n        ns_save(\n            \u0026mut deps.storage,\n            INACTIVE_POOLS_KEY,\n            pool.lp_token.address.as_slice(),\n            \u0026pool\n        )?;\n            \n        ns_remove(\u0026mut deps.storage, POOLS_KEY, addr.as_slice());\n    }\n\n    save(\u0026mut deps.storage, POOL_INDEX, \u0026Vec::\u003cCanonicalAddr\u003e::new())\n}\n\nfn generate_account_key(\n    owner: \u0026CanonicalAddr,\n    lp_token_addr: \u0026CanonicalAddr\n) -\u003e Vec\u003cu8\u003e {\n    [ owner.as_slice(), lp_token_addr.as_slice() ].concat()\n}\n\nimpl Humanize\u003cConfig\u003cHumanAddr\u003e\u003e for Config\u003cCanonicalAddr\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cConfig\u003cHumanAddr\u003e\u003e {\n        Ok(Config {\n            reward_token: self.reward_token.humanize(api)?,\n            this_contract: self.this_contract.humanize(api)?,\n            token_decimals: self.token_decimals,\n            viewing_key: self.viewing_key.clone(),\n            prng_seed: self.prng_seed.clone(),\n            claim_interval: self.claim_interval\n        })\n    }\n}\n\nimpl Canonize\u003cConfig\u003cCanonicalAddr\u003e\u003e for Config\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cConfig\u003cCanonicalAddr\u003e\u003e {\n        Ok(Config {\n            reward_token: self.reward_token.canonize(api)?,\n            this_contract: self.this_contract.canonize(api)?,\n            token_decimals: self.token_decimals,\n            viewing_key: self.viewing_key.clone(),\n            prng_seed: self.prng_seed.clone(),\n            claim_interval: self.claim_interval\n        })\n    }\n}\n","traces":[{"line":30,"address":[798528,798876],"length":1,"stats":{"Line":2},"fn_name":"save_config\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":34,"address":[798574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[799676,798928],"length":1,"stats":{"Line":2},"fn_name":"load_config\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":40,"address":[798957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[799210,799384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[799744,803087],"length":1,"stats":{"Line":2},"fn_name":"replace_active_pools\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":49,"address":[799810],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[799884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[803118,799941,800147],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[803303,800189,800445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[800435,800710],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[800730,800946,803274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[801216,800911],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[801309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[801356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[803219,801615,801518,800137],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[802000,801549,802891,801864],"length":1,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[802351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[802817,802502],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[802912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[803584,805693],"length":1,"stats":{"Line":1},"fn_name":"get_pools\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":90,"address":[803614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[803943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[804171,805426,803978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[804326,805859,804541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[804506,804787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[804885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[805436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[806192,807772],"length":1,"stats":{"Line":2},"fn_name":"get_pool\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":111,"address":[806230,806381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[806495,807919,806661,806349],"length":1,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[806958,806626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[807456,807056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[806912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[808048,809628],"length":1,"stats":{"Line":1},"fn_name":"get_inactive_pool\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":127,"address":[808086,808237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[808517,809775,808205,808351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[808814,808482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[809312,808912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[808768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[809904,810386],"length":1,"stats":{"Line":2},"fn_name":"save_pool\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":143,"address":[809955,810203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[810171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[811007,810432],"length":1,"stats":{"Line":2},"fn_name":"save_account\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":157,"address":[810483,810746],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[810721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[810856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[811669,811072],"length":1,"stats":{"Line":2},"fn_name":"get_or_create_account\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":173,"address":[811279,811122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[811410,811506,811250],"length":1,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[811441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[811512,811403,811716],"length":1,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[813981,811792],"length":1,"stats":{"Line":2},"fn_name":"get_account\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":187,"address":[811843,811986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[812221,814152,812102,811963],"length":1,"stats":{"Line":4},"fn_name":null},{"line":190,"address":[812211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[812477,814147,812693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[812658,812990],"length":1,"stats":{"Line":4},"fn_name":null},{"line":194,"address":[813104,813564],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[812944],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[817009,814368],"length":1,"stats":{"Line":2},"fn_name":"set_current_pools_inactive\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":203,"address":[814695,817085,814431],"length":1,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[814750,814949,816786],"length":1,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[815404,817112,815108,815918,816155,815728],"length":1,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[817344,815396],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":210,"address":[817526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[817368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[816177,815888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[816193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[816259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[816410,816725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[816812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[817552],"length":1,"stats":{"Line":2},"fn_name":"generate_account_key"},{"line":241,"address":[817594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":86,"coverable":90},{"path":["/","home","runner","work","sienna","sienna","contracts","rewards","src","test_helpers.rs"],"content":"use cosmwasm_std::{\n    Querier, QueryRequest, Empty, SystemError, from_slice,\n    WasmQuery, to_binary, QuerierResult, Uint128, Extern,\n    HumanAddr, from_binary, Env, MessageInfo, ContractInfo as StdContractInfo,\n    BlockInfo\n};\nuse cosmwasm_std::testing::{MockApi, MockStorage, MOCK_CONTRACT_ADDR};\nuse serde::{Serialize, Deserialize};\nuse secret_toolkit::snip20::query::{Balance, TokenInfo};\nuse fadroma_scrt_callback::ContractInstance;\n\npub fn mock_dependencies(\n    canonical_length: usize,\n    reward_token: ContractInstance\u003cHumanAddr\u003e,\n    reward_token_supply: Uint128,\n    reward_token_decimals: u8\n) -\u003e Extern\u003cMockStorage, MockApi, MockSnip20Querier\u003e {\n    Extern {\n        storage: MockStorage::default(),\n        api: MockApi::new(canonical_length),\n        querier: MockSnip20Querier {\n            reward_token,\n            reward_token_supply,\n            reward_token_decimals\n        }\n    }\n}\n\npub fn mock_env_with_time(sender: impl Into\u003cHumanAddr\u003e, time: u64) -\u003e Env {\n    Env {\n        block: BlockInfo {\n            height: 12_345,\n            time,\n            chain_id: \"cosmos-testnet-14002\".to_string(),\n        },\n        message: MessageInfo {\n            sender: sender.into(),\n            sent_funds: vec![],\n        },\n        contract: StdContractInfo {\n            address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n        },\n        contract_key: Some(\"\".to_string()),\n        contract_code_hash: \"\".to_string(),\n    }\n}\n\npub struct MockSnip20Querier {\n    pub reward_token_supply: Uint128,\n    reward_token: ContractInstance\u003cHumanAddr\u003e,\n    reward_token_decimals: u8\n}\n\n// Redefine here, so we can deserialize\n#[derive(Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\nenum QueryMsg {\n    TokenInfo {},\n    Balance {\n        address: HumanAddr,\n        key: String,\n    }\n}\n\n#[derive(Serialize, Deserialize)]\nstruct TokenInfoResponse {\n    pub token_info: TokenInfo,\n}\n\n#[derive(Serialize, Deserialize)]\nstruct BalanceResponse {\n    pub balance: Balance,\n}\n\nimpl Querier for MockSnip20Querier {\n    fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n        let request: QueryRequest\u003cEmpty\u003e = match from_slice(bin_request) {\n            Ok(v) =\u003e v,\n            Err(e) =\u003e {\n                return Err(SystemError::InvalidRequest {\n                    error: format!(\"Parsing query request: {}\", e),\n                    request: bin_request.into(),\n                });\n            }\n        };\n\n        match request {\n            QueryRequest::Wasm(WasmQuery::Smart { \n                callback_code_hash, contract_addr, msg\n             }) =\u003e {\n                let msg: QueryMsg = from_binary(\u0026msg).unwrap();\n\n                match msg {\n                    QueryMsg::Balance { .. } =\u003e {\n                        let info = ContractInstance {\n                            code_hash: callback_code_hash,\n                            address: contract_addr\n                        };\n        \n                        if info != self.reward_token {\n                            panic!(\"MockSnip20Querier: Expected balance query for {:?}\", self.reward_token)\n                        }\n        \n                        Ok(to_binary(\u0026BalanceResponse { \n                            balance: Balance {\n                                amount: self.reward_token_supply\n                            }\n                        }))\n                    },\n                    QueryMsg::TokenInfo { } =\u003e {\n                        Ok(to_binary(\u0026TokenInfoResponse { \n                                token_info: TokenInfo {\n                                name: \"reward_token\".into(),\n                                symbol: \"REWARD\".into(),\n                                decimals: self.reward_token_decimals,\n                                total_supply: None\n                            }\n                        }))\n                    }\n                }\n\n            },\n            _ =\u003e panic!(\"MockSnip20Querier: Expected WasmQuery::Smart.\")\n        }\n    }\n}\n","traces":[{"line":12,"address":[986397,986064],"length":1,"stats":{"Line":2},"fn_name":"mock_dependencies"},{"line":19,"address":[986177],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[986189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[986257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[986464,987106],"length":1,"stats":{"Line":2},"fn_name":"mock_env_with_time\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":31,"address":[986498,986547],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[986654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[986740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[986772],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[986830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[987296,989450],"length":1,"stats":{"Line":2},"fn_name":"raw_query"},{"line":77,"address":[987368,987598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[988049,987677],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[988200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[988294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[988237],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[988445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":26,"coverable":37},{"path":["/","home","runner","work","sienna","sienna","contracts","rewards","src","tests.rs"],"content":"\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse cosmwasm_std::{\n    Api, Extern, HumanAddr, Querier, StdResult,\n    Storage, Uint128, StdError, to_binary, from_binary\n};\nuse cosmwasm_std::testing::{mock_env, MockStorage, MockApi};\nuse rand::{Rng, thread_rng};\nuse fadroma_scrt_callback::ContractInstance;\nuse cosmwasm_utils::convert::get_whole_token_representation;\n\nuse crate::contract::*;\nuse crate::msg::{\n    HandleMsg, InitMsg, QueryMsg, RewardPoolConfig, QueryMsgResponse\n};\nuse crate::state::{get_inactive_pool, get_pools, load_config};\nuse crate::data::RewardPool;\nuse crate::test_helpers::{\n    mock_dependencies, mock_env_with_time, MockSnip20Querier\n};\n\n#[test]\nfn test_init() {\n    let reward_token = ContractInstance {\n        address: \"reward_token\".into(),\n        code_hash: \"reward_token_hash\".into()\n    };\n\n    let decimals = 18;\n    let claim_interval = 100;\n    let prng_seed = to_binary(\u0026\"whatever\").unwrap();\n\n    let reward_pools = vec![\n        RewardPoolConfig {\n            share: Uint128(100),\n            lp_token: ContractInstance {\n                address: \"pool1\".into(),\n                code_hash: \"pool1_hash\".into()\n            }\n        },\n        RewardPoolConfig {\n            share: Uint128(200),\n            lp_token: ContractInstance {\n                address: \"pool2\".into(),\n                code_hash: \"pool2_hash\".into()\n            }\n        }\n    ];\n\n    let ref mut deps = mock_dependencies(20, reward_token.clone(), Uint128(1), decimals);\n\n    let msg = InitMsg {\n        admin: None,\n        reward_token: reward_token.clone(),\n        claim_interval,\n        reward_pools: Some(reward_pools.clone()),\n        prng_seed: prng_seed.clone(),\n        entropy: to_binary(\u0026\"whatever\").unwrap()\n    };\n\n    init(deps, mock_env(\"admin\", \u0026[]), msg).unwrap();\n\n    let config = load_config(deps).unwrap();\n    assert_eq!(config.reward_token, reward_token);\n    assert_eq!(config.token_decimals, decimals);\n    assert_eq!(config.claim_interval, claim_interval);\n    assert_eq!(config.prng_seed, prng_seed);\n\n    let pools = into_pools(reward_pools);\n    let stored_pools = get_pools(deps).unwrap();\n\n    assert_pools_eq(\u0026pools, \u0026stored_pools);\n\n    let result = query(deps, QueryMsg::TokenInfo { }).unwrap();\n    let response: QueryMsgResponse = from_binary(\u0026result).unwrap();\n\n    match response {\n        QueryMsgResponse::TokenInfo { name, symbol, decimals, total_supply } =\u003e {\n            assert_eq!(name, \"Sienna Rewards\");\n            assert_eq!(symbol, \"SRW\");\n            assert_eq!(decimals, 1);\n            assert_eq!(total_supply, None);\n        },\n        _ =\u003e panic!(\"Expected QueryMsgResponse::TokenInfo\")\n    }\n}\n\n#[test]\nfn test_change_pools() {\n    fn assert_pools_inactive\u003cS: Storage, A: Api, Q: Querier\u003e(\n        deps: \u0026Extern\u003cS, A, Q\u003e,\n        pools: \u0026Vec\u003cRewardPool\u003cHumanAddr\u003e\u003e\n    ) {\n        for pool in pools {\n            assert_eq!(\n                get_inactive_pool(deps, \u0026pool.lp_token.address).unwrap().unwrap(),\n                *pool\n            );\n        }\n    }\n\n    let reward_token = ContractInstance {\n        address: \"reward_token\".into(),\n        code_hash: \"reward_token_hash\".into()\n    };\n\n    let initial_pools = vec![\n        RewardPoolConfig {\n            share: Uint128(100),\n            lp_token: ContractInstance {\n                address: \"pool1\".into(),\n                code_hash: \"pool1_hash\".into()\n            }\n        },\n        RewardPoolConfig {\n            share: Uint128(200),\n            lp_token: ContractInstance {\n                address: \"pool2\".into(),\n                code_hash: \"pool2_hash\".into()\n            }\n        }\n    ];\n\n    let ref mut deps = mock_dependencies(20, reward_token.clone(), Uint128(1), 18);\n\n    let msg = InitMsg {\n        admin: None,\n        reward_token,\n        claim_interval: 100,\n        reward_pools: Some(initial_pools.clone()),\n        prng_seed: to_binary(\u0026\"whatever\").unwrap(),\n        entropy: to_binary(\u0026\"whatever\").unwrap()\n    };\n\n    init(deps, mock_env(\"admin\", \u0026[]), msg).unwrap();\n\n    let err = handle(deps, mock_env(\"unauthorized\", \u0026[]), HandleMsg::ChangePools {\n        pools: vec![],\n        total_share: Uint128(100)\n    }).unwrap_err();\n\n    assert_eq!(err, StdError::unauthorized());\n\n    let third_pool = RewardPoolConfig {\n        share: Uint128(300),\n        lp_token: ContractInstance {\n            address: \"pool3\".into(),\n            code_hash: \"pool3_hash\".into()\n        }\n    };\n\n    let new_pools = vec![ \n        initial_pools[0].clone(),\n        initial_pools[1].clone(),\n        third_pool\n    ];\n\n    let err = handle(deps, mock_env(\"admin\", \u0026[]), HandleMsg::ChangePools {\n        pools: new_pools.clone(),\n        total_share: Uint128(599)\n    }).unwrap_err();\n\n    match err {\n        StdError::GenericErr { msg, .. } =\u003e assert!(msg.starts_with(\"Total pool share(\")),\n        _ =\u003e panic!(\"Expected StdError::GenericErr, got: {}\", err)\n    }\n    \n    handle(deps, mock_env(\"admin\", \u0026[]), HandleMsg::ChangePools {\n        pools: new_pools,\n        total_share: Uint128(600)\n    }).unwrap();\n\n    let second_pools = vec![ \n        RewardPoolConfig {\n            share: Uint128(300),\n            lp_token: ContractInstance {\n                address: \"pool3\".into(),\n                code_hash: \"pool3_hash\".into()\n            }\n        },\n        RewardPoolConfig {\n            share: Uint128(400),\n            lp_token: ContractInstance {\n                address: \"pool4\".into(),\n                code_hash: \"pool4_hash\".into()\n            }\n        }\n    ];\n\n    handle(deps, mock_env(\"admin\", \u0026[]), HandleMsg::ChangePools {\n        pools: second_pools.clone(),\n        total_share: Uint128(700)\n    }).unwrap();\n\n    assert_pools_eq(\u0026get_pools(deps).unwrap(), \u0026into_pools(second_pools.clone()));\n    assert_pools_inactive(deps, \u0026into_pools(initial_pools.clone()));\n\n    let locked_tokens = Uint128(9999);\n\n    lock_tokens(\n        deps,\n        mock_env(\"user\", \u0026[]),\n        locked_tokens,\n        second_pools[0].lp_token.address.clone()\n    ).unwrap();\n\n    let third_pools = vec![\n        initial_pools[0].clone(),\n        initial_pools[1].clone(),\n        second_pools[0].clone()\n    ];\n\n    handle(deps, mock_env(\"admin\", \u0026[]), HandleMsg::ChangePools {\n        pools: third_pools.clone(),\n        total_share: Uint128(600)\n    }).unwrap();\n\n    let mut third_pools = into_pools(third_pools);\n    third_pools[2].size = locked_tokens;\n\n    assert_pools_eq(\u0026get_pools(deps).unwrap(), \u0026third_pools);\n    assert_pools_inactive(deps, \u0026into_pools([ second_pools[1].clone() ].to_vec()));\n}\n\n#[test]\nfn test_calc_reward_share() {\n    let pool = create_pool(\n        500_000_000_000_000_000_000,\n        1000_000_000\n    );\n\n    // If owning 15% of pool share, then receive 15% of 500 = 75\n    let result = calc_reward_share(150_000_000, \u0026pool, 18).unwrap();\n    assert_eq!(result, 75_000_000_000_000_000_000);\n\n    // Absorb the entire pool if owning 100% of pool share.\n    let result = calc_reward_share(1000_000_000, \u0026pool, 18).unwrap();\n    assert_eq!(result, 500_000_000_000_000_000_000);\n\n    let result = calc_reward_share(0, \u0026pool, 18).unwrap();\n    assert_eq!(result, 0);\n}\n\n#[test]\nfn test_claim() {\n    let runs = 100;\n\n    for _ in 0..runs {\n        claim_run();\n    }\n}\n\n#[test]\nfn test_calc_portions() {\n    let now = SystemTime::now();\n    let time = now.duration_since(UNIX_EPOCH).unwrap().as_secs();\n    let claim_interval = 86400; // 1 day\n\n    assert_eq!(0, calc_portions(\n        time - claim_interval + 1,\n        claim_interval,\n        time\n    ).unwrap());\n\n    assert_eq!(1, calc_portions(\n        time - claim_interval - 1000,\n        claim_interval,\n        time\n    ).unwrap());\n\n    assert_eq!(2, calc_portions(\n        time - claim_interval * 2,\n        claim_interval,\n        time\n    ).unwrap());\n\n    assert_eq!(1, calc_portions(\n        (time - claim_interval * 2) + 1,\n        claim_interval,\n        time\n    ).unwrap());\n\n    assert_eq!(10, calc_portions(\n        time - claim_interval * 10,\n        claim_interval,\n        time\n    ).unwrap());\n}\n\n#[test]\nfn test_claim_with_lock_unlock() {\n    let reward_token = ContractInstance {\n        address: \"reward_token\".into(),\n        code_hash: \"reward_token_hash\".into()\n    };\n\n    let lp_token_decimals = 6;\n    let pool_addr = HumanAddr::from(\"pool\");\n\n    let share = get_whole_token_representation(lp_token_decimals) * 600;\n    let pool = RewardPoolConfig {\n        share: Uint128(share),\n        lp_token: ContractInstance {\n            address: pool_addr.clone(),\n            code_hash: \"pool_hash\".into()\n        }\n    };\n\n    let ref mut deps = mock_dependencies(20, reward_token.clone(), pool.share, 18);\n\n    let claim_interval = 100;\n    let msg = InitMsg {\n        admin: None,\n        reward_token,\n        claim_interval,\n        reward_pools: Some(vec![pool]),\n        prng_seed: to_binary(\u0026\"whatever\").unwrap(),\n        entropy: to_binary(\u0026\"whatever\").unwrap()\n    };\n\n    init(deps, mock_env(\"admin\", \u0026[]), msg).unwrap();\n\n    let mut time = claim_interval;\n\n    let sender1 = HumanAddr::from(\"sender1\");\n    let sender2 = HumanAddr::from(\"sender2\");\n    let sender3 = HumanAddr::from(\"sender3\");\n    let sender4 = HumanAddr::from(\"sender4\");\n\n    let deposit_amount = share / 4;\n\n    lock_tokens(\n        deps,\n        mock_env_with_time(sender1.clone(), time),\n        Uint128(deposit_amount),\n        pool_addr.clone()\n    ).unwrap();\n\n    lock_tokens(\n        deps,\n        mock_env_with_time(sender2.clone(), time),\n        Uint128(deposit_amount),\n        pool_addr.clone()\n    ).unwrap();\n\n    time += claim_interval;\n\n    let (empty, amount) = execute_claim(deps, time, sender1.clone(), pool_addr.clone()).unwrap();\n    assert_eq!(empty, false);\n    assert_eq!(amount, share / 2);\n    \n    let (empty, amount) = execute_claim(deps, time, sender2.clone(), pool_addr.clone()).unwrap();\n    assert_eq!(empty, false);\n    assert_eq!(amount, share / 2);\n\n    // User locks tokens and claims while the pool is still empty\n    lock_tokens(\n        deps,\n        mock_env_with_time(sender3.clone(), time),\n        Uint128(deposit_amount),\n        pool_addr.clone()\n    ).unwrap();\n\n    let (empty, amount) = execute_claim(deps, time, sender3.clone(), pool_addr.clone()).unwrap();\n    assert_eq!(empty, true);\n    assert_eq!(amount, 0);\n\n    lock_tokens(\n        deps,\n        mock_env_with_time(sender4.clone(), time),\n        Uint128(deposit_amount),\n        pool_addr.clone()\n    ).unwrap();\n\n    deps.querier.reward_token_supply += Uint128(share);\n    time += claim_interval;\n\n    let (empty, amount) = execute_claim(deps, time, sender1.clone(), pool_addr.clone()).unwrap();\n    assert_eq!(empty, false);\n    assert_eq!(amount, share / 4);\n\n    let (empty, amount) = execute_claim(deps, time, sender2.clone(), pool_addr.clone()).unwrap();\n    assert_eq!(empty, false);\n    assert_eq!(amount, share / 4);\n\n    let (empty, amount) = execute_claim(deps, time, sender3.clone(), pool_addr.clone()).unwrap();\n    assert_eq!(empty, false);\n    assert_eq!(amount, share / 4);\n\n    let (empty, amount) = execute_claim(deps, time, sender4.clone(), pool_addr.clone()).unwrap();\n    assert_eq!(empty, false);\n    assert_eq!(amount, share / 4);\n\n    assert_eq!(deps.querier.reward_token_supply.u128(), 0);\n\n    deps.querier.reward_token_supply += Uint128(share);\n    time += claim_interval;\n\n    retrieve_tokens(\n        deps,\n        mock_env(sender1.clone(), \u0026[]),\n        Uint128(deposit_amount),\n        pool_addr.clone()\n    ).unwrap();\n\n    let expected_amount = 198000000u128;\n\n    let (empty, amount) = execute_claim(deps, time, sender2.clone(), pool_addr.clone()).unwrap();\n    assert_eq!(empty, false);\n    assert_eq!(amount, expected_amount);\n\n    let (empty, amount) = execute_claim(deps, time, sender3.clone(), pool_addr.clone()).unwrap();\n    assert_eq!(empty, false);\n    assert_eq!(amount, expected_amount);\n\n    let (empty, amount) = execute_claim(deps, time, sender4.clone(), pool_addr.clone()).unwrap();\n    assert_eq!(empty, false);\n    assert_eq!(amount, expected_amount);\n}\n\n#[test]\nfn test_cant_claim_twice_by_retrieving_tokens() {\n    let reward_token = ContractInstance {\n        address: \"reward_token\".into(),\n        code_hash: \"reward_token_hash\".into()\n    };\n\n    let lp_token_addr = HumanAddr(\"lp_token_hash\".into());\n    let share = 500u128;\n\n    let pool = RewardPoolConfig {\n        share: Uint128(share),\n        lp_token: ContractInstance {\n            address: lp_token_addr.clone(),\n            code_hash: \"lp_token_hash\".into()\n        }\n    };\n\n    let ref mut deps = mock_dependencies(20, reward_token.clone(), Uint128(share * 2), 18);\n\n    let claim_interval = 100;\n\n    init(deps, mock_env(\"admin\", \u0026[]), InitMsg {\n        claim_interval,\n        admin: None,\n        reward_token,\n        reward_pools: Some(vec![pool]),\n        prng_seed: to_binary(\u0026\"whatever\").unwrap(),\n        entropy: to_binary(\u0026\"whatever\").unwrap()\n    }).unwrap();\n\n    let user = HumanAddr(\"user\".into());\n    let lp_amount = Uint128(100);\n\n    let mut time = claim_interval;\n\n    handle(deps, mock_env_with_time(user.clone(), time), HandleMsg::LockTokens {\n        amount: lp_amount,\n        lp_token: lp_token_addr.clone()\n    }).unwrap();\n\n    time += claim_interval;\n\n    let (_, amount) = execute_claim(deps, time, user.clone(), lp_token_addr.clone()).unwrap();\n    assert_eq!(amount, share);\n    assert_eq!(deps.querier.reward_token_supply, Uint128(share));\n\n    handle(deps, mock_env(user.clone(), \u0026[]), HandleMsg::RetrieveTokens {\n        amount: lp_amount,\n        lp_token: lp_token_addr.clone()\n    }).unwrap();\n\n    handle(deps, mock_env_with_time(user.clone(), time), HandleMsg::LockTokens {\n        amount: lp_amount,\n        lp_token: lp_token_addr.clone()\n    }).unwrap();\n\n    time += claim_interval / 2;\n\n    let err = claim(\n        deps,\n        mock_env_with_time(user.clone(), time),\n        vec![ lp_token_addr.clone() ]\n    ).unwrap_err();\n\n    match err {\n        StdError::GenericErr { msg, .. } =\u003e {\n            if !(msg == format!(\"Reward amount for {} is zero.\", lp_token_addr)) {\n                panic!(\"Expecting reward amount to be 0.\")\n            }\n        },\n        _ =\u003e panic!(\"Expecting StdError::GenericErr\")\n    }\n}\n\n#[test]\nfn test_cant_claim_instantly() {\n    let reward_token = ContractInstance {\n        address: \"reward_token\".into(),\n        code_hash: \"reward_token_hash\".into()\n    };\n\n    let lp_token_addr = HumanAddr(\"lp_token_hash\".into());\n    let share = 500u128;\n\n    let pool = RewardPoolConfig {\n        share: Uint128(share),\n        lp_token: ContractInstance {\n            address: lp_token_addr.clone(),\n            code_hash: \"lp_token_hash\".into()\n        }\n    };\n\n    let ref mut deps = mock_dependencies(20, reward_token.clone(), Uint128(share * 2), 18);\n\n    init(deps, mock_env(\"admin\", \u0026[]), InitMsg {\n        claim_interval: 100,\n        admin: None,\n        reward_token,\n        reward_pools: Some(vec![pool]),\n        prng_seed: to_binary(\u0026\"whatever\").unwrap(),\n        entropy: to_binary(\u0026\"whatever\").unwrap()\n    }).unwrap();\n\n    let user = HumanAddr(\"user\".into());\n    let lp_amount = Uint128(100);\n\n    let mut time = 100;\n\n    handle(deps, mock_env_with_time(user.clone(), time), HandleMsg::LockTokens {\n        amount: lp_amount,\n        lp_token: lp_token_addr.clone()\n    }).unwrap();\n\n    time += 50;\n\n    let err = claim(\n        deps,\n        mock_env_with_time(user.clone(), time),\n        vec![ lp_token_addr.clone() ]\n    ).unwrap_err();\n\n    match err {\n        StdError::GenericErr { msg, .. } =\u003e {\n            if !(msg == format!(\"Reward amount for {} is zero.\", lp_token_addr)) {\n                panic!(\"Expecting reward amount to be 0.\")\n            }\n        },\n        _ =\u003e panic!(\"Expecting StdError::GenericErr\")\n    }\n}\n\nfn create_pool(share: u128, size: u128) -\u003e RewardPool\u003cHumanAddr\u003e {\n    RewardPool {\n        lp_token: ContractInstance {\n            address: HumanAddr::from(\"lp_token\"),\n            code_hash: \"lp_token\".into()\n        },\n        share: Uint128(share),\n        size: Uint128(size)\n    }\n}\n\nfn assert_pools_eq(lhs: \u0026Vec\u003cRewardPool\u003cHumanAddr\u003e\u003e, rhs: \u0026Vec\u003cRewardPool\u003cHumanAddr\u003e\u003e) {\n    assert_eq!(lhs.len(), rhs.len());\n\n    for (i, pool) in lhs.iter().enumerate() {\n        let other = \u0026rhs[i];\n\n        assert_eq!(pool.lp_token, other.lp_token);\n        assert_eq!(pool.share, other.share);\n        assert_eq!(pool.size, other.size);\n    }\n}\n\nfn execute_claim(\n    deps: \u0026mut Extern\u003cMockStorage, MockApi, MockSnip20Querier\u003e,\n    time: u64,\n    user: HumanAddr,\n    lp_token: HumanAddr\n) -\u003e StdResult\u003c(bool, u128)\u003e {\n    let result = claim(\n        deps,\n        mock_env_with_time(user.clone(), time),\n        vec![ lp_token ]\n    );\n\n    if result.is_err() { \n        let err = result.unwrap_err();\n\n        match \u0026err {\n            StdError::GenericErr { msg, .. } =\u003e {\n                if msg == \"The reward token pool is currently empty.\" {\n                    return Ok((true, 0));\n                } else if msg.starts_with(\"Reward amount for\") {\n                    // It is possible for the user share to be so small that\n                    // the reward amount calculated would be zero. So this \n                    // this shouldn't be counted as a program error.\n                    return Ok((false, 0));\n                }\n\n                return Err(err);\n            },\n            _ =\u003e return Err(err)\n        }\n    }\n\n    let result = result.unwrap();\n    let claimed = result.log.iter().find(|e|\n        e.key == \"claimed_amount\"\n    ).unwrap();\n\n    let value = claimed.value.parse::\u003cu128\u003e().unwrap();\n\n    // Subtract to simulate SNIP20 transfer message\n    let supply = deps.querier.reward_token_supply.u128();\n    deps.querier.reward_token_supply = Uint128(supply - value);\n\n    Ok((false, value))\n}\n\nfn claim_run() {\n    const NUM_POOLS: usize = 3;\n    \n    fn pools_to_call(index: usize) -\u003e usize {\n        if index % NUM_POOLS == 0 {\n            NUM_POOLS\n        } else {\n            1\n        }\n    }\n\n    let mut rng = thread_rng();\n\n    let iterations = rng.gen_range(5..20);\n    let claim_interval = 86400; // 1 day\n    let num_users = rng.gen_range(5..20);\n\n    let reward_token_decimals = 18;\n    let reward_token = ContractInstance {\n        address: \"reward_token\".into(),\n        code_hash: \"reward_token_hash\".into()\n    };\n\n    let mut pools = Vec::with_capacity(NUM_POOLS);\n\n    for i in 0..NUM_POOLS {\n        pools.push(RewardPoolConfig {\n            lp_token: ContractInstance {\n                address: HumanAddr(format!(\"lp_token_{}\", i)),\n                code_hash: format!(\"lp_token_hash_{}\", i)\n            },\n            share: Uint128(rng.gen_range(100_000_000_000_000_000_000..800_000_000_000_000_000_000))\n        });\n    }\n\n    let total_share: u128 = pools.iter().map(|p| p.share.u128()).sum();\n    let reward_token_supply = total_share * iterations;\n\n    let ref mut deps = mock_dependencies(\n        20,\n        reward_token.clone(),\n        Uint128(reward_token_supply),\n        reward_token_decimals\n    );\n\n    init(deps, mock_env(\"admin\", \u0026[]), InitMsg {\n        reward_token,\n        admin: None,\n        reward_pools: Some(pools.clone()),\n        claim_interval,\n        prng_seed: to_binary(\u0026\"whatever\").unwrap(),\n        entropy: to_binary(\u0026\"whatever\").unwrap()\n    }).unwrap();\n\n    let pools = into_pools(pools);\n    let mut users = Vec::with_capacity(num_users);\n\n    for i in 0..num_users {\n        let user = HumanAddr(format!(\"User {}\", i + 1));\n        users.push(user.clone());\n\n        let pools_to_lock = pools_to_call(i);\n\n        for p in 0..pools_to_lock{\n            lock_tokens(\n                deps,\n                mock_env(user.clone(), \u0026[]),\n                Uint128(rng.gen_range(10_000_000..100_000_000)),\n                pools[p].lp_token.address.clone()\n            ).unwrap();\n        }\n    }\n\n    let now = SystemTime::now();\n    let mut time = now.duration_since(UNIX_EPOCH).unwrap().as_secs();\n\n    let mut total_claimed = 0;\n    let mut is_done = false;\n\n    while !is_done {\n        for _ in 0..iterations {\n            for (i, user) in users.clone().into_iter().enumerate() {\n                let rand = rng.gen_range(0..20);\n\n                // Skip claiming for some users to simulate them\n                // not getting their rewards every time they can\n                if rand % 2 == 0 {\n                    let pools_to_claim = pools_to_call(i);\n\n                    for p in 0..pools_to_claim {\n                        let (depleted, claimed) = execute_claim(\n                            deps,\n                            time,\n                            user.clone(),\n                            pools[p].lp_token.address.clone()\n                        ).unwrap();\n\n                        total_claimed += claimed;\n                        is_done = depleted;\n                    }\n                }\n\n                // Let a tiny amount of time to pass to introduce some entropy\n                time += rand;\n            }\n            \n            // Ensure that the claim interval has passed\n            time += claim_interval;\n        }\n    }\n\n    // Final run to claim any remaining rewards\n    while !is_done {\n        for user in users.clone() {\n            let (depleted, claimed) = execute_claim(\n                deps,\n                time,\n                user,\n                pools[0].lp_token.address.clone()\n            ).unwrap();\n\n            total_claimed += claimed;\n            is_done = depleted;\n        }\n\n        // Ensure that the claim interval has passed\n        time += claim_interval;\n    }\n\n    assert_eq!(total_claimed, reward_token_supply);\n}\n","traces":[{"line":23,"address":[1061701,1065449,1061696,1061728],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":25,"address":[1061767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1061792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1061887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1061895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1061907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1065369,1065684,1062405,1061969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[1062131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1061985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[1062067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1062009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1062036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[1062333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1062269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1062211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1062238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1062568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[1062696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1062735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[1062790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[1062797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1063049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1063234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1063279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1063445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1063614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1063773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1063929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1064008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1064061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[1064068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[1064157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1064257,1064210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[1064407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[1064562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1064709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[1064866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[1064224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1066240,1066208,1072620,1066213],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":90,"address":[1074208,1074592],"length":1,"stats":{"Line":1},"fn_name":"assert_pools_inactive\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,sienna_rewards::test_helpers::MockSnip20Querier\u003e"},{"line":94,"address":[1074577,1074327,1074249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[1074582,1074444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1074368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1066341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1066366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1066479,1073124,1066915,1072569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[1066641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1066495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1066577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1066519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[1066546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[1066843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[1066779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1066721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1066748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[1067070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[1067251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[1067290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[1067342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1067590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[1067821,1067944,1067759],"length":1,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[1067814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[1067936,1073063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[1072437,1067974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[1068190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1068272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[1068640,1072403,1073015,1068434],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[1068447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[1068507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1068568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[1069040,1068847,1068917],"length":1,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[1068910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[1069070,1069032,1072960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[1069160,1072384,1069078],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[1069097,1069390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[1069335,1069514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[1069474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[1069659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[1070112,1069676,1072347,1072866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[1069838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[1069692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[1069774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[1069716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1069743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[1070040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1069976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[1069918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[1069945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1070441,1070318,1070248],"length":1,"stats":{"Line":3},"fn_name":null},{"line":191,"address":[1070311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1070433,1070479,1072832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[1070502,1072289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1072274,1070654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1070722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[1070746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[1070793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1070819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[1070993,1072780,1071169,1072243],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[1071006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1071060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1071115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1071373,1071443,1071566],"length":1,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[1071436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[1071604,1071558,1072719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[1071611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1071674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[1072212,1071774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[1071849,1072184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[1075511,1074640,1074672,1074645],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":233,"address":[1074742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1074821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1075005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1075084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1075263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1075345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[1075557,1075552,1075584],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":246,"address":[1075588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[1075709,1075690,1075596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[1075704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[1075717,1075712,1075744],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":255,"address":[1075751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[1075776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[1075884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[1075968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[1077264,1075896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1076247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[1077324,1076179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1076512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[1076438,1077384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[1076802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[1076703,1077444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[1077067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[1077534,1076993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[1077600,1077632,1077605,1087314],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":293,"address":[1077789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[1077814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[1077917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[1077925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[1088010,1077961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[1078106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[1078176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[1078344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1078417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[1078507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[1078686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[1078738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[1078986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[1079155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[1079167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[1079198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[1079229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[1079260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[1079307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[1079367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[1079429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[1079461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[1079600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[1079662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[1079694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[1088342,1079817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[1079864,1087737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[1080123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[1080285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[1080485,1087703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[1080744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[1080906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[1081122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[1081184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[1081216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[1087635,1081339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[1081598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[1081750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[1081921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[1081983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[1082015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[1082154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[1088500,1082205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[1087567,1082252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[1082511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[1082673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[1082874,1087533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[1083133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[1083295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[1083496,1087499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[1083755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":388,"address":[1083917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[1087465,1084118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[1084377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[1084539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[1084740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[1084992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[1085043,1088633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":401,"address":[1085106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[1085169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[1085201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[1085324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[1085348,1087397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[1085607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[1085761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[1087363,1085926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[1086173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[1086315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[1087329,1086468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[1086697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[1086839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[1088768,1088800,1092750,1088773],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":424,"address":[1088887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[1088912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[1089015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[1089078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[1089102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[1089188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[1089356,1093137,1093352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[1089534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[1089546,1089954,1090197],"length":1,"stats":{"Line":3},"fn_name":null},{"line":445,"address":[1089593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[1089605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[1089671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[1089850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[1089902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[1090235,1093103,1090189,1092626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[1090242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[1090305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[1090329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[1090589,1090474,1090357],"length":1,"stats":{"Line":3},"fn_name":null},{"line":458,"address":[1090403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[1090451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[1093069,1090627,1090581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[1090634,1093584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[1093035,1090681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[1090898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[1091051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[1091255,1091361,1091476],"length":1,"stats":{"Line":3},"fn_name":null},{"line":469,"address":[1091302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[1091344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[1091468,1091514,1093001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[1091757,1091537,1091642],"length":1,"stats":{"Line":3},"fn_name":null},{"line":474,"address":[1091583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[1091625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[1091749,1091795,1092967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":478,"address":[1093692,1091802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[1091859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[1091915,1092918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[1092106,1092150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[1092577,1092198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[1092447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[1092117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[1096553,1093856,1093861,1093888],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":499,"address":[1093951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[1093973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[1094061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[1094124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[1094148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[1094226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[1096838,1097050,1094391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[1094541,1094940,1095183],"length":1,"stats":{"Line":3},"fn_name":null},{"line":518,"address":[1094588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[1094600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[1094657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[1094836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[1094888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[1095221,1095175,1096804,1096432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":525,"address":[1095228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[1095291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[1095315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[1095343,1095448,1095563],"length":1,"stats":{"Line":3},"fn_name":null},{"line":531,"address":[1095389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[1095431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[1095555,1096770,1095601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":535,"address":[1095608,1097282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[1095665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[1096721,1095721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[1095912,1095956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":545,"address":[1096004,1096383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":546,"address":[1096253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[1095923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[1050000,1050322],"length":1,"stats":{"Line":1},"fn_name":"create_pool"},{"line":555,"address":[1050151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[1050197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[1050213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[1050368],"length":1,"stats":{"Line":1},"fn_name":"assert_pools_eq"},{"line":565,"address":[1050407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[1051343,1050796,1050604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":568,"address":[1050875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[1050910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[1051053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":572,"address":[1051204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[1053113,1051360],"length":1,"stats":{"Line":1},"fn_name":"execute_claim"},{"line":584,"address":[1051504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[1051560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":588,"address":[1051721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[1051753,1052027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":592,"address":[1052130,1052035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":593,"address":[1052146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[1052198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[1052243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[1052338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[1052383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[1052046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[1051890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[1052467,1053408],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":610,"address":[1053422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[1052620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[1052748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":617,"address":[1052815,1053370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[1052916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":622,"address":[1060565,1053456],"length":1,"stats":{"Line":1},"fn_name":"claim_run"},{"line":625,"address":[1061632],"length":1,"stats":{"Line":1},"fn_name":"pools_to_call"},{"line":626,"address":[1061668,1061644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":627,"address":[1061660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[1061670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":633,"address":[1053469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":635,"address":[1053547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":636,"address":[1053696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[1053708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[1053790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[1053798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":642,"address":[1053825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[1053941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":647,"address":[1053948,1054191,1054989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":648,"address":[1054886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":649,"address":[1054661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[1054233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":651,"address":[1054467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":653,"address":[1054735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":657,"address":[1061568,1054159,1055010,1061593],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":658,"address":[1060983,1055177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":662,"address":[1055349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":663,"address":[1055356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":667,"address":[1055971,1055728,1055454],"length":1,"stats":{"Line":3},"fn_name":null},{"line":668,"address":[1055501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[1055557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[1055585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":672,"address":[1055624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":673,"address":[1055676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[1060407,1055963,1056009,1060748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":676,"address":[1056016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":677,"address":[1056095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[1057392,1056110,1056337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":680,"address":[1061190,1056379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":681,"address":[1056668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[1056706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":685,"address":[1056953,1056740,1057387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":688,"address":[1057011],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[1057058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":690,"address":[1057215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[1056301,1057413],"length":1,"stats":{"Line":2},"fn_name":null},{"line":696,"address":[1057429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":698,"address":[1057585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":699,"address":[1057609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":701,"address":[1057617,1057995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":702,"address":[1058000,1057651,1059302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":703,"address":[1058244,1058050,1059254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[1058414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[1058532,1058744,1058496],"length":1,"stats":{"Line":3},"fn_name":null},{"line":709,"address":[1058514,1058545],"length":1,"stats":{"Line":2},"fn_name":null},{"line":711,"address":[1058553,1059177,1058749],"length":1,"stats":{"Line":2},"fn_name":null},{"line":714,"address":[1058791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":715,"address":[1058823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[1058846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":719,"address":[1061348,1059089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[1059168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[1059190,1061381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":729,"address":[1059259,1061414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":734,"address":[1059307,1060166,1057630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":735,"address":[1060120,1059431,1059617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[1059763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[1059776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[1059816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[1061497,1060030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[1060103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[1060125,1061530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[1059328,1060181],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":356,"coverable":373},{"path":["/","home","runner","work","sienna","sienna","contracts","rewards","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests.\n//! 1. First copy them over verbatum,\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","rpt","examples","rpt_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse sienna_rpt::msg;\nuse sienna_rpt::State;\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(State),         \u0026out_dir);\n    export_schema(\u0026schema_for!(msg::Init),     \u0026out_dir);\n    export_schema(\u0026schema_for!(msg::Handle),   \u0026out_dir);\n    export_schema(\u0026schema_for!(msg::Query),    \u0026out_dir);\n    export_schema(\u0026schema_for!(msg::Response), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","rpt","src","lib.rs"],"content":"#[macro_use] extern crate fadroma;\n\n// TODO(fadroma): we don't really need these to be public (see note in `mgmt`)\npub use secret_toolkit::{snip20::handle::transfer_msg, utils::space_pad};\npub use sienna_mgmt::msg::{Query as MGMTQuery, Response as MGMTResponse, Handle as MGMTHandle};\npub use sienna_migration::{ContractStatus, ContractStatusLevel, is_operational, can_set_status};\npub use linear_map::LinearMap;\npub use cosmwasm_std::{QueryRequest, WasmQuery};\n\n/// Default value for Secret Network block size (used for padding)\npub const BLOCK_SIZE: usize = 256;\n\n/// Into what parts to split the received amount\npub type Config\u003cT\u003e = LinearMap\u003cT, Uint128\u003e;\n\n/// Code hashes for MGMT and SNIP20\npub type CodeHash = String;\n\n/// Pair of address and code hash\npub type ContractLink\u003cT\u003e = (T, CodeHash);\n\n/// Error messages\n#[macro_export] macro_rules! RPTError {\n    (CORRUPTED) =\u003e { \"Contract has entered a state that violates core assumptions.\" };\n    (TOTAL: $x:expr, $y:expr) =\u003e { format!(\"Allocations must add up to {}, not {}\", \u0026$x, \u0026$y) };\n    (MGMT) =\u003e { \"Main vesting contract returned unexpected response.\" };\n}\n\ncontract!(\n    [State] {\n        /// The admin of the contract. Immutable.\n        admin:   CanonicalAddr,\n        /// The portion size of the RPT pool. Immutable as per requirements.\n        portion: Uint128,\n        /// How the portion is split. Must add up to `portion`.\n        config:  Config\u003cCanonicalAddr\u003e,\n        /// A link to the token.\n        token:   ContractLink\u003cCanonicalAddr\u003e,\n        /// A link to the management contract which gives tokens.\n        mgmt:    ContractLink\u003cCanonicalAddr\u003e,\n        /// The paused/migration flag.\n        status:  ContractStatus\n    }\n\n    /// Requires MGMT and SNIP20 to be deployed. Their addresses and hashes,\n    /// as well as the pool and account names, can't be changed after init.\n    [Init] (deps, env, msg: {\n        portion: Uint128,\n        config:  Config\u003cHumanAddr\u003e,\n        token:   ContractLink\u003cHumanAddr\u003e,\n        mgmt:    ContractLink\u003cHumanAddr\u003e\n    }) {\n        validate(portion, \u0026config)?;\n        State {\n            portion,\n            admin:  deps.api.canonical_address(\u0026env.message.sender)?,\n            config: config.canonize(\u0026deps.api)?,\n            token:  (deps.api.canonical_address(\u0026token.0)?, token.1),\n            mgmt:   (deps.api.canonical_address(\u0026mgmt.0)?,  mgmt.1),\n            status: ContractStatus::default()\n        }\n    }\n\n    [Query] (deps, state, msg) -\u003e Response {\n        Status () {\n            Ok(Response::Status {\n                portion: state.portion,\n                status:  state.status,\n                config:  state.config.humanize(\u0026deps.api)?,\n                token:   (deps.api.human_address(\u0026state.token.0)?, state.token.1.clone()),\n                mgmt:    (deps.api.human_address(\u0026state.mgmt.0)?,  state.mgmt.1.clone())\n            })\n        }\n    }\n\n    [Response] {\n        Status {\n            portion: Uint128,\n            config:  Config\u003cHumanAddr\u003e,\n            token:   ContractLink\u003cHumanAddr\u003e,\n            mgmt:    ContractLink\u003cHumanAddr\u003e,\n            status:  ContractStatus\n        }\n    }\n\n    [Handle] (deps, env, state, msg) -\u003e Response {\n\n        /// Set the contract status.\n        /// Used to pause the contract operation in case of errors,\n        /// and to initiate a migration to a fixed version of the contract.\n        SetStatus (level: ContractStatusLevel, reason: String, new_address: Option\u003cHumanAddr\u003e) {\n            is_admin(\u0026deps, \u0026env, \u0026state)?;\n            can_set_status(\u0026state.status, \u0026level)?;\n\n            state.status = ContractStatus { level, reason, new_address };\n\n            save_state!();\n            Ok(HandleResponse::default())\n        }\n\n        /// The current admin can make someone else the admin.\n        SetOwner (new_admin: HumanAddr) {\n            is_admin(\u0026deps, \u0026env, \u0026state)?;\n            is_operational(\u0026state.status)?;\n\n            state.admin = deps.api.canonical_address(\u0026new_admin)?;\n\n            save_state!();\n            Ok(HandleResponse::default())\n        }\n\n        /// Set how funds will be split.\n        Configure (config: Config\u003cHumanAddr\u003e) {\n            is_admin(\u0026deps, \u0026env, \u0026state)?;\n            is_operational(\u0026state.status)?;\n            validate(state.portion, \u0026config)?;\n\n            state.config = config.canonize(\u0026deps.api)?;\n\n            save_state!();\n            Ok(HandleResponse::default())\n        }\n\n        /// Receive and distribute funds.\n        /// `WARNING` a cliff on the RPT account could confuse this?\n        Vest () {\n            is_operational(\u0026state.status)?;\n\n            let claimable = query_claimable(\u0026deps, \u0026env, \u0026state.mgmt)?;\n            let mut messages = vec![];\n            let mut msg = to_binary(\u0026MGMTHandle::Claim {})?;\n            space_pad(\u0026mut msg.0, BLOCK_SIZE);\n            messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr:      deps.api.human_address(\u0026state.mgmt.0)?,\n                callback_code_hash: state.mgmt.1.clone(),\n                send:               vec![],\n                msg,\n            }));\n            let claimable = claimable.u128();\n            let portion   = state.portion.u128();\n            let portions  = claimable / portion;\n            let remainder = claimable % portion;\n            for (addr, amount) in state.config.0.iter() {\n                let msg = transfer(\u0026deps.api, \u0026state, addr, Uint128::from(amount.u128()*portions));\n                messages.push(msg?);\n            }\n\n            let mut log = vec![];\n            if remainder \u003e 0 {\n                log.push(LogAttribute {\n                    key: \"remainder (locked forever)\".to_string(),\n                    value: remainder.to_string()\n                });\n            }\n\n            save_state!();\n            Ok(HandleResponse { messages, data: None, log })\n        }\n    }\n);\n\nfn query_claimable \u003cS:Storage,A:Api,Q:Querier\u003e (\n    deps: \u0026Extern\u003cS,A,Q\u003e, env: \u0026Env, mgmt: \u0026ContractLink\u003cCanonicalAddr\u003e\n) -\u003e StdResult\u003cUint128\u003e {\n    let msg = MGMTQuery::Progress { address: env.contract.address.clone(), time: env.block.time };\n    let mut msg = to_binary(\u0026msg)?;\n    space_pad(\u0026mut msg.0, BLOCK_SIZE);\n    let response = deps.querier.query::\u003cMGMTResponse\u003e(\n        \u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr:      deps.api.human_address(\u0026mgmt.0)?,\n            callback_code_hash: mgmt.1.clone(),\n            msg,\n        })\n    );\n    if let MGMTResponse::Progress { unlocked, claimed, .. } = response? {\n        Ok((unlocked - claimed)?)\n    } else {\n        Err(StdError::GenericErr { msg: RPTError!(MGMT).to_string(), backtrace: None })\n    }\n}\n\nfn validate \u003cT\u003e (portion: Uint128, config: \u0026Config\u003cT\u003e) -\u003e StdResult\u003c()\u003e {\n    let total = sum_config(\u0026config);\n    if portion == total {\n        Ok(())\n    } else {\n        Err(StdError::GenericErr { msg: RPTError!(TOTAL: portion, total), backtrace: None })\n    }\n}\n\nfn sum_config \u003cT\u003e (map: \u0026LinearMap\u003cT, Uint128\u003e) -\u003e Uint128 {\n    let mut total = Uint128::zero();\n    for (_, amount) in map.0.iter() { total += *amount; }\n    total\n}\n\nfn is_admin \u003cS:Storage,A:Api,Q:Querier\u003e (\n    deps: \u0026Extern\u003cS,A,Q\u003e, env: \u0026Env, state: \u0026State\n) -\u003e StdResult\u003c()\u003e {\n    if state.admin == deps.api.canonical_address(\u0026env.message.sender)? {\n        Ok(())\n    } else {\n        Err(StdError::Unauthorized { backtrace: None })\n    }\n}\n\nfn transfer \u003cA:Api\u003e (\n    api: \u0026A, state: \u0026State, recipient: \u0026CanonicalAddr, amount: Uint128\n) -\u003e StdResult\u003cCosmosMsg\u003e {\n    let (token_addr, token_hash) = \u0026state.token;\n    let token_addr = api.human_address(\u0026token_addr)?;\n    let recipient  = api.human_address(\u0026recipient)?;\n    transfer_msg(recipient, amount, None, BLOCK_SIZE, token_hash.clone(), token_addr)\n}\n","traces":[{"line":29,"address":[543688,552024,544163,567257,552117,560151,567167,555456,567503,552202,543939,559667,543777,543858,567339,553825,560617,567421,569409],"length":1,"stats":{"Line":12},"fn_name":null},{"line":53,"address":[895669,892182,892276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[894321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[892246,892658,892538,895761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[892631,893042,892918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[893011,893321,893552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[893518,893831,894048],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[894026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[934628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[933145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[933163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[933389,933223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[934058,933359,933668,935023],"length":1,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[934564,934946,934122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[932617,930771,930881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[932615,930843,931143,931357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[931177,932271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[932370,932179,931624,932610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[931963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[924613,924715,926519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[924977,924685,925047,926514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[925008,926317,925309,926509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[926504,926387,926230,925683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[926022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[927463,929705,927565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[929700,927535,927894,927827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[928222,928156,927858,929695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[928484,929492,929690,928187],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[928858,929568,929685,929405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[929197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[918776,918892,923481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[919247,918858,923476,919157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[919237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[919496,923471,919661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[919634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[920391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[920083,919910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[920053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[920332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[920351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[920678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[920751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[923790,920824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[923823,920955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[921242,921026,922244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[921293,923856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[921542,923433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[921232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[922249,922415,922299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[922328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[922272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[922301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[923224,922417,923428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[922806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[886896,889401],"length":1,"stats":{"Line":1},"fn_name":"query_claimable\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,test::MockQuerier\u003e"},{"line":165,"address":[886960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[887046,889562,887196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[887169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[887452,888150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[887938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[887464,887622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[887596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[887898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[888183,888579,888755,889416],"length":1,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[888760,888643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[889041,888549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[900016],"length":1,"stats":{"Line":1},"fn_name":"validate\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":183,"address":[900048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[900068,900109],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[900102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[900114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[886528],"length":1,"stats":{"Line":1},"fn_name":"sum_config\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":192,"address":[886545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[886569,886711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[898288,898728],"length":1,"stats":{"Line":1},"fn_name":"is_admin\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,test::MockQuerier\u003e"},{"line":200,"address":[898747,898334,898717,898563,898591],"length":1,"stats":{"Line":4},"fn_name":null},{"line":201,"address":[898584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[898598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[899842,898784],"length":1,"stats":{"Line":1},"fn_name":"transfer\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":210,"address":[898856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[899060,898917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[899036,899177,899371,899917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[899820,899655,899281,899857],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":69,"coverable":83},{"path":["/","home","runner","work","sienna","sienna","contracts","rpt","tests","test.rs"],"content":"#![cfg(test)]\n#![allow(dead_code)]\n#![allow(unused_macros)]\n#![allow(unused_imports)]\n#![allow(non_snake_case)]\n\n#[macro_use] extern crate kukumba;\n\nuse cosmwasm_std::{\n    Extern, Storage, Api, testing::{MockStorage, MockApi},\n    SystemResult, StdResult, StdError,\n    Env, BlockInfo, MessageInfo, ContractInfo,\n    Querier, QueryRequest, Empty, WasmQuery, QuerierResult,\n    CosmosMsg, WasmMsg,\n    HandleResponse,\n    Binary, from_binary, from_slice, to_binary,\n    HumanAddr, Uint128,\n};\nuse sienna_rpt::{\n    init, query, handle,\n    msg::{Init as RPTInit, Query as RPTQuery, Handle as RPTHandle, Response as RPTResponse},\n    ContractStatus, ContractStatusLevel\n};\nuse sienna_mgmt::msg::{Query as MGMTQuery, Response as MGMTResponse, Handle as MGMTHandle};\nuse snip20_sienna::msg::{HandleMsg as TokenHandle};\nuse linear_map::LinearMap;\n\nkukumba!(\n\n    #[rpt]\n    given \"the contract is not yet deployed\" {\n        let ADMIN    = HumanAddr::from(\"secret1ADMIN\");\n        let TOKEN1   = HumanAddr::from(\"secret1TOKEN1\");\n        let TOKEN2   = HumanAddr::from(\"secret1TOKEN2\");\n        let STRANGER = HumanAddr::from(\"secret1STRANGER\");\n        let mut deps = Extern {\n            storage: MockStorage::default(),\n            api:     MockApi::new(45),\n            querier: MockQuerier { portion: 2500 } }\n        let initial_config = LinearMap(vec![\n            (ADMIN.clone(), Uint128::from(2500u128))]);\n        let updated_config = LinearMap(vec![\n            (TOKEN1.clone(), Uint128::from(1000u128)),\n            (TOKEN2.clone(), Uint128::from(1500u128)) ]);\n        let invalid_config = LinearMap(vec![\n            (TOKEN1.clone(), Uint128::from(1001u128)),\n            (TOKEN2.clone(), Uint128::from(1500u128)) ]); }\n    when \"someone deploys the contract\" {\n        assert_eq!(\n            0,\n            init(\u0026mut deps, mock_env(0, 0, \u0026ADMIN), RPTInit {\n                portion: Uint128::from(2500u128),\n                config:  initial_config.clone(),\n                token:   (HumanAddr::from(\"token\"), String::new()),\n                mgmt:    (HumanAddr::from(\"mgmt\"),  String::new()),\n            }).unwrap().messages.len(),\n            \"deploy failed\" ); }\n    then \"they become admin\"\n    and \"they can set the configuration\"\n    and \"noone else can\"\n    and \"it has to be a valid configuration\" {\n        let status_initial = RPTResponse::Status {\n            portion: Uint128::from(2500u128),\n            config:  initial_config,\n            token:   (HumanAddr::from(\"token\"), String::new()),\n            mgmt:    (HumanAddr::from(\"mgmt\"),  String::new()),\n            status:  ContractStatus {\n                level: ContractStatusLevel::Operational,\n                reason: String::new(),\n                new_address: None\n            }\n        }\n        assert_eq!(status_initial.clone(), status(\u0026deps), \"querying status failed\");\n\n        let expected_unauth = (\n            Err(cosmwasm_std::StdError::Unauthorized { backtrace: None }),\n            status_initial.clone());\n        let actual_unauth = (\n            handle(\u0026mut deps, mock_env(1, 1, \u0026STRANGER), RPTHandle::Configure {\n                config: updated_config.clone()\n            }),\n            status(\u0026deps));\n        assert_eq!(expected_unauth, actual_unauth, \"wrong user was able to set config\");\n\n        let expected_invalid = status_initial.clone();\n        let actual_invalid = {\n            handle(\u0026mut deps, mock_env(2, 2, \u0026ADMIN), RPTHandle::Configure {\n                config: invalid_config.clone()\n            });\n            status(\u0026deps) }\n        assert_eq!(expected_invalid, actual_invalid, \"admin was able to set invalid config\");\n\n        let expected_valid = RPTResponse::Status {\n            portion: Uint128::from(2500u128),\n            config:  updated_config.clone(),\n            token:   (HumanAddr::from(\"token\"), String::new()),\n            mgmt:    (HumanAddr::from(\"mgmt\"),  String::new()),\n            status:  ContractStatus {\n                level: ContractStatusLevel::Operational,\n                reason: String::new(),\n                new_address: None\n            }\n        };\n        let actual_valid = {\n            handle(\u0026mut deps, mock_env(2, 2, \u0026ADMIN), RPTHandle::Configure {\n                config: updated_config.clone()\n            }).unwrap();\n            status(\u0026deps) };\n        assert_eq!(expected_valid, actual_valid, \"admin was unable to set valid config\"); }\n    when \"anyone calls the vest method\"\n    then \"the contract claims funds from mgmt\"\n    and \"it distributes them to the configured recipients\" {\n        let messages = handle(\n            \u0026mut deps, mock_env(2, 2, \u0026STRANGER), RPTHandle::Vest {}\n        ).unwrap().messages;\n        assert_eq!(messages.len(), 3, \"unexpected message count\");\n\n        // check claim from token\n        if let CosmosMsg::Wasm(WasmMsg::Execute { msg, .. }) = messages.get(0).unwrap() {\n            if let MGMTHandle::Claim {..} = from_binary::\u003cMGMTHandle\u003e(\u0026msg).unwrap() {} else {\n                panic!(\"unexpected 1st message\");\n            }\n        } else {\n            panic!(\"unexpected 1st message\");\n        }\n        // check vestings to recipients\n        for i in 1..3 {\n            if let CosmosMsg::Wasm(WasmMsg::Execute { msg, .. }) = messages.get(i).unwrap() {\n                if let TokenHandle::Transfer {recipient,amount,..} = from_binary::\u003cTokenHandle\u003e(\u0026msg).unwrap() {\n                    let (expected_recipient, expected_amount) = updated_config.0.get(i-1).unwrap();\n                    assert_eq!(*expected_recipient, recipient);\n                    assert_eq!(*expected_amount,    amount);\n                } else {\n                    panic!(\"unexpected message #{}\", i+1);\n                }\n            } else {\n                panic!(\"unexpected message #{}\", i+1);\n            }\n        }\n    }\n\n);\n\nfn mock_env (height: u64, time: u64, sender: \u0026HumanAddr) -\u003e Env {\n    Env {\n        block: BlockInfo { height, time, chain_id: \"secret\".into() },\n        message: MessageInfo { sender: sender.into(), sent_funds: vec![] },\n        contract: ContractInfo { address: \"rpt\".into() },\n        contract_key: Some(\"\".into()),\n        contract_code_hash: \"0\".into()\n    }\n}\n\nfn status\u003cS:Storage,A:Api,Q:Querier\u003e (deps: \u0026Extern\u003cS,A,Q\u003e) -\u003e RPTResponse {\n    from_binary::\u003cRPTResponse\u003e(\n        \u0026query(\u0026deps, RPTQuery::Status {}).unwrap()\n    ).unwrap()\n}\n\n//fn print_type_of\u003cT\u003e(_: \u0026T) {\n    //println!(\"{}\", std::any::type_name::\u003cT\u003e())\n//}\nstruct MockQuerier {\n    portion: u128\n}\nimpl Querier for MockQuerier {\n    fn raw_query (\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n        let request: QueryRequest\u003cEmpty\u003e = from_slice(bin_request).unwrap();\n        match \u0026request {\n            QueryRequest::Wasm(msg) =\u003e {\n                match msg {\n                    WasmQuery::Smart { contract_addr, .. } =\u003e {\n                        let mgmt = HumanAddr::from(\"mgmt\");\n                        match \u0026contract_addr {\n                            mgmt =\u003e {\n                                let response = MGMTResponse::Progress {\n                                    time:     0u64,\n                                    launched: 0u64,\n                                    elapsed:  0u64,\n                                    unlocked: Uint128::from(2500u128),\n                                    claimed:  Uint128::zero(),\n                                };\n                                QuerierResult::Ok(to_binary(\u0026response))\n                            },\n                            _ =\u003e unimplemented!()\n                        }\n                    },\n                    _ =\u003e unimplemented!(),\n                }\n            },\n            _ =\u003e unimplemented!(),\n        }\n    }\n}\n","traces":[{"line":32,"address":[1392331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1392357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1392388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1392419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[1392524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1392458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1392465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[1403730,1392500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1392606,1392751,1404228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[1392638,1403696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1393146,1404179,1403658,1392872],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[1403677,1392904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1403644,1393033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1393569,1393295,1403587,1404161],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[1393327,1403606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[1393456,1403573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1403479,1394692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1394620,1394098,1394421],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[1394116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1394158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[1403524,1394185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1394295,1403494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1403538,1403508,1404127,1394612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1396669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1396252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1396294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1403449,1396334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1403419,1396444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1396597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1396562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1396585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1396893,1403356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[1397397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[1397210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[1397390,1403341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1397707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1397544,1397589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[1397562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[1397700,1403313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[1398030,1397841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1398007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1398171,1398126],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[1398144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1398297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1398520,1398312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1398957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1398462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[1398595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1398622,1403242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[1403212,1398732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1398885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[1398850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[1398873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1399186,1399231,1399326],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[1399204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1404025,1399318,1399364],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[1399387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1399402,1399678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[1400708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[1400658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[1400777,1403844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[1403823,1400807,1401009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[1400964,1401109,1401215],"length":1,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[1401242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1401309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[1401174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1401578,1403894,1401361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[1401790,1401628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[1401817,1401928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[1405664,1402000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[1402159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[1402312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1405581,1401900,1402510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[1405548,1402686,1401754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1390320,1390937],"length":1,"stats":{"Line":1},"fn_name":"mock_env"},{"line":146,"address":[1390376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[1390912,1390452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1390539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1390598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1390658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[1391072,1391225],"length":1,"stats":{"Line":1},"fn_name":"status\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,test::MockQuerier\u003e"},{"line":156,"address":[1391094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":87,"coverable":94},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","src","contract.rs"],"content":"/// This contract implements SNIP-20 standard:\n/// https://github.com/SecretFoundation/SNIPs/blob/master/SNIP-20.md\nuse cosmwasm_std::{\n    log, to_binary, Api, BankMsg, Binary, CanonicalAddr, Coin, CosmosMsg, Env, Extern,\n    HandleResponse, HumanAddr, InitResponse, Querier, QueryResult, ReadonlyStorage, StdError,\n    StdResult, Storage, Uint128,\n};\n\nuse crate::msg::{\n    space_pad, ContractStatusLevel, HandleAnswer, HandleMsg, InitMsg, QueryAnswer, QueryMsg,\n    ResponseStatus::Success,\n};\nuse crate::rand::sha_256;\nuse crate::receiver::Snip20ReceiveMsg;\nuse crate::state::{\n    get_receiver_hash, get_transfers, read_allowance, read_viewing_key, set_receiver_hash,\n    store_transfer, write_allowance, write_viewing_key, Balances, Config, Constants,\n    ReadonlyBalances, ReadonlyConfig,\n};\nuse crate::viewing_key::{ViewingKey, VIEWING_KEY_SIZE};\n\n/// We make sure that responses from `handle` are padded to a multiple of this size.\npub const RESPONSE_BLOCK_SIZE: usize = 256;\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let init_config = msg.config();\n    let mut total_supply: u128 = 0;\n    {\n        let mut balances = Balances::from_storage(\u0026mut deps.storage);\n        let initial_balances = msg.initial_balances.unwrap_or_default();\n        for balance in initial_balances {\n            let balance_address = deps.api.canonical_address(\u0026balance.address)?;\n            let amount = balance.amount.u128();\n            balances.set_account_balance(\u0026balance_address, amount);\n            if let Some(new_total_supply) = total_supply.checked_add(amount) {\n                total_supply = new_total_supply;\n            } else {\n                return Err(StdError::generic_err(\n                    \"The sum of all initial balances exceeds the maximum possible total supply\",\n                ));\n            }\n        }\n    }\n\n    // Check name, symbol, decimals\n    if !is_valid_name(\u0026msg.name) {\n        return Err(StdError::generic_err(\n            \"Name is not in the expected format (3-30 UTF-8 bytes)\",\n        ));\n    }\n    if !is_valid_symbol(\u0026msg.symbol) {\n        return Err(StdError::generic_err(\n            \"Ticker symbol is not in expected format [A-Z]{3,6}\",\n        ));\n    }\n    if msg.decimals \u003e 18 {\n        return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n    }\n\n    let admin = msg.admin.unwrap_or(env.message.sender);\n\n    let prng_seed_hashed = sha_256(\u0026msg.prng_seed.0);\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    config.set_constants(\u0026Constants {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n        admin: admin.clone(),\n        prng_seed: prng_seed_hashed.to_vec(),\n        total_supply_is_public: init_config.public_total_supply(),\n        deposit_is_enabled: init_config.deposit_enabled(),\n        redeem_is_enabled: init_config.redeem_enabled(),\n        mint_is_enabled: init_config.mint_enabled(),\n        burn_is_enabled: init_config.burn_enabled(),\n    })?;\n    config.set_total_supply(total_supply);\n    config.set_contract_status(ContractStatusLevel::NormalRun);\n    let minters = if init_config.mint_enabled() {\n        Vec::from([admin])\n    } else {\n        Vec::new()\n    };\n    config.set_minters(minters)?;\n\n    Ok(InitResponse::default())\n}\n\nfn pad_response(response: StdResult\u003cHandleResponse\u003e) -\u003e StdResult\u003cHandleResponse\u003e {\n    response.map(|mut response| {\n        response.data = response.data.map(|mut data| {\n            space_pad(RESPONSE_BLOCK_SIZE, \u0026mut data.0);\n            data\n        });\n        response\n    })\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let contract_status = ReadonlyConfig::from_storage(\u0026deps.storage).contract_status();\n\n    match contract_status {\n        ContractStatusLevel::StopAll | ContractStatusLevel::StopAllButRedeems =\u003e {\n            let response = match msg {\n                HandleMsg::SetContractStatus { level, .. } =\u003e set_contract_status(deps, env, level),\n                HandleMsg::Redeem { amount, .. }\n                    if contract_status == ContractStatusLevel::StopAllButRedeems =\u003e\n                {\n                    try_redeem(deps, env, amount)\n                }\n                _ =\u003e Err(StdError::generic_err(\n                    \"This contract is stopped and this action is not allowed\",\n                )),\n            };\n            return pad_response(response);\n        }\n        ContractStatusLevel::NormalRun =\u003e {} // If it's a normal run just continue\n    }\n\n    let response = match msg {\n        // Native\n        HandleMsg::Deposit { .. } =\u003e try_deposit(deps, env),\n        HandleMsg::Redeem { amount, .. } =\u003e try_redeem(deps, env, amount),\n\n        // Base\n        HandleMsg::Transfer {\n            recipient, amount, ..\n        } =\u003e try_transfer(deps, env, \u0026recipient, amount),\n        HandleMsg::Send {\n            recipient,\n            amount,\n            msg,\n            ..\n        } =\u003e try_send(deps, env, \u0026recipient, amount, msg),\n        HandleMsg::Burn { amount, .. } =\u003e try_burn(deps, env, amount),\n        HandleMsg::RegisterReceive { code_hash, .. } =\u003e try_register_receive(deps, env, code_hash),\n        HandleMsg::CreateViewingKey { entropy, .. } =\u003e try_create_key(deps, env, entropy),\n        HandleMsg::SetViewingKey { key, .. } =\u003e try_set_key(deps, env, key),\n\n        // Allowance\n        HandleMsg::IncreaseAllowance {\n            spender,\n            amount,\n            expiration,\n            ..\n        } =\u003e try_increase_allowance(deps, env, spender, amount, expiration),\n        HandleMsg::DecreaseAllowance {\n            spender,\n            amount,\n            expiration,\n            ..\n        } =\u003e try_decrease_allowance(deps, env, spender, amount, expiration),\n        HandleMsg::TransferFrom {\n            owner,\n            recipient,\n            amount,\n            ..\n        } =\u003e try_transfer_from(deps, env, \u0026owner, \u0026recipient, amount),\n        HandleMsg::SendFrom {\n            owner,\n            recipient,\n            amount,\n            msg,\n            ..\n        } =\u003e try_send_from(deps, env, \u0026owner, \u0026recipient, amount, msg),\n        HandleMsg::BurnFrom { owner, amount, .. } =\u003e try_burn_from(deps, env, \u0026owner, amount),\n\n        // Mint\n        HandleMsg::Mint {\n            recipient, amount, ..\n        } =\u003e try_mint(deps, env, recipient, amount),\n\n        // Other\n        HandleMsg::ChangeAdmin { address, .. } =\u003e change_admin(deps, env, address),\n        HandleMsg::SetContractStatus { level, .. } =\u003e set_contract_status(deps, env, level),\n        HandleMsg::AddMinters { minters, .. } =\u003e add_minters(deps, env, minters),\n        HandleMsg::RemoveMinters { minters, .. } =\u003e remove_minters(deps, env, minters),\n        HandleMsg::SetMinters { minters, .. } =\u003e set_minters(deps, env, minters),\n    };\n\n    pad_response(response)\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e, msg: QueryMsg) -\u003e QueryResult {\n    match msg {\n        QueryMsg::TokenInfo {} =\u003e query_token_info(\u0026deps.storage),\n        QueryMsg::TokenConfig {} =\u003e query_token_config(\u0026deps.storage),\n        QueryMsg::ExchangeRate {} =\u003e query_exchange_rate(\u0026deps.storage),\n        QueryMsg::Minters { .. } =\u003e query_minters(deps),\n        _ =\u003e authenticated_queries(deps, msg),\n    }\n}\n\npub fn authenticated_queries\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e QueryResult {\n    let (addresses, key) = msg.get_validation_params();\n\n    for address in addresses {\n        let canonical_addr = deps.api.canonical_address(address)?;\n\n        let expected_key = read_viewing_key(\u0026deps.storage, \u0026canonical_addr);\n\n        if expected_key.is_none() {\n            // Checking the key will take significant time. We don't want to exit immediately if it isn't set\n            // in a way which will allow to time the command and determine if a viewing key doesn't exist\n            key.check_viewing_key(\u0026[0u8; VIEWING_KEY_SIZE]);\n        } else if key.check_viewing_key(expected_key.unwrap().as_slice()) {\n            return match msg {\n                // Base\n                QueryMsg::Balance { address, .. } =\u003e query_balance(\u0026deps, \u0026address),\n                QueryMsg::TransferHistory {\n                    address,\n                    page,\n                    page_size,\n                    ..\n                } =\u003e query_transactions(\u0026deps, \u0026address, page.unwrap_or(0), page_size),\n                QueryMsg::Allowance { owner, spender, .. } =\u003e {\n                    try_check_allowance(deps, owner, spender)\n                }\n                _ =\u003e panic!(\"This query type does not require authentication\"),\n            };\n        }\n    }\n\n    Ok(to_binary(\u0026QueryAnswer::ViewingKeyError {\n        msg: \"Wrong viewing key for this address or viewing key not set\".to_string(),\n    })?)\n}\n\nfn query_exchange_rate\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n    let constants = config.constants()?;\n\n    if constants.deposit_is_enabled || constants.redeem_is_enabled {\n        let rate: Uint128;\n        let denom: String;\n        // if token has more decimals than SCRT, you get magnitudes of SCRT per token\n        if constants.decimals \u003e= 6 {\n            rate = Uint128(10u128.pow(constants.decimals as u32 - 6));\n            denom = \"SCRT\".to_string();\n        // if token has less decimals, you get magnitudes token for SCRT\n        } else {\n            rate = Uint128(10u128.pow(6 - constants.decimals as u32));\n            denom = constants.symbol;\n        }\n        return to_binary(\u0026QueryAnswer::ExchangeRate { rate, denom });\n    }\n    to_binary(\u0026QueryAnswer::ExchangeRate {\n        rate: Uint128(0),\n        denom: String::new(),\n    })\n}\n\nfn query_token_info\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n    let constants = config.constants()?;\n\n    let total_supply = if constants.total_supply_is_public {\n        Some(Uint128(config.total_supply()))\n    } else {\n        None\n    };\n\n    to_binary(\u0026QueryAnswer::TokenInfo {\n        name: constants.name,\n        symbol: constants.symbol,\n        decimals: constants.decimals,\n        total_supply,\n    })\n}\n\nfn query_token_config\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n    let constants = config.constants()?;\n\n    to_binary(\u0026QueryAnswer::TokenConfig {\n        public_total_supply: constants.total_supply_is_public,\n        deposit_enabled: constants.deposit_is_enabled,\n        redeem_enabled: constants.redeem_is_enabled,\n        mint_enabled: constants.mint_is_enabled,\n        burn_enabled: constants.burn_is_enabled,\n    })\n}\n\npub fn query_transactions\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n    page: u32,\n    page_size: u32,\n) -\u003e StdResult\u003cBinary\u003e {\n    let address = deps.api.canonical_address(account).unwrap();\n    let (txs, total) = get_transfers(\u0026deps.api, \u0026deps.storage, \u0026address, page, page_size)?;\n\n    let result = QueryAnswer::TransferHistory { txs, total: Some(total) };\n    to_binary(\u0026result)\n}\n\npub fn query_balance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n) -\u003e StdResult\u003cBinary\u003e {\n    let address = deps.api.canonical_address(account)?;\n\n    let amount = Uint128(ReadonlyBalances::from_storage(\u0026deps.storage).account_amount(\u0026address));\n    let response = QueryAnswer::Balance { amount };\n    to_binary(\u0026response)\n}\n\nfn query_minters\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cBinary\u003e {\n    let minters = ReadonlyConfig::from_storage(\u0026deps.storage).minters();\n\n    let response = QueryAnswer::Minters { minters };\n    to_binary(\u0026response)\n}\n\nfn change_admin\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    address: HumanAddr,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    let mut consts = config.constants()?;\n    consts.admin = address;\n    config.set_constants(\u0026consts)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::ChangeAdmin { status: Success })?),\n    })\n}\n\nfn try_mint\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    address: HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    let minters = config.minters();\n    if !minters.contains(\u0026env.message.sender) {\n        return Err(StdError::generic_err(\n            \"Minting is allowed to minter accounts only\",\n        ));\n    }\n\n    let amount = amount.u128();\n\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_add(amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"This mint attempt would increase the total supply above the supported maximum\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    let receipient_account = \u0026deps.api.canonical_address(\u0026address)?;\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n\n    let mut account_balance = balances.balance(receipient_account);\n\n    if let Some(new_balance) = account_balance.checked_add(amount) {\n        account_balance = new_balance;\n    } else {\n        // This error literally can not happen, since the account's funds are a subset\n        // of the total supply, both are stored as u128, and we check for overflow of\n        // the total supply just a couple lines before.\n        // Still, writing this to cover all overflows.\n        return Err(StdError::generic_err(\n            \"This mint attempt would increase the account's balance above the supported maximum\",\n        ));\n    }\n\n    balances.set_account_balance(receipient_account, account_balance);\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Mint { status: Success })?),\n    };\n\n    Ok(res)\n}\n\npub fn try_set_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    key: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let vk = ViewingKey(key);\n\n    let message_sender = deps.api.canonical_address(\u0026env.message.sender)?;\n    write_viewing_key(\u0026mut deps.storage, \u0026message_sender, \u0026vk);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetViewingKey { status: Success })?),\n    })\n}\n\npub fn try_create_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    entropy: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let constants = ReadonlyConfig::from_storage(\u0026deps.storage).constants()?;\n    let prng_seed = constants.prng_seed;\n\n    let key = ViewingKey::new(\u0026env, \u0026prng_seed, (\u0026entropy).as_ref());\n\n    let message_sender = deps.api.canonical_address(\u0026env.message.sender)?;\n    write_viewing_key(\u0026mut deps.storage, \u0026message_sender, \u0026key);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::CreateViewingKey { key })?),\n    })\n}\n\nfn set_contract_status\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    status_level: ContractStatusLevel,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.set_contract_status(status_level);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetContractStatus {\n            status: Success,\n        })?),\n    })\n}\n\npub fn try_check_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    owner: HumanAddr,\n    spender: HumanAddr,\n) -\u003e StdResult\u003cBinary\u003e {\n    let owner_address = deps.api.canonical_address(\u0026owner)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n\n    let response = QueryAnswer::Allowance {\n        owner,\n        spender,\n        allowance: Uint128(allowance.amount),\n        expiration: allowance.expiration,\n    };\n    to_binary(\u0026response)\n}\n\nfn try_deposit\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut amount = Uint128::zero();\n\n    for coin in \u0026env.message.sent_funds {\n        if coin.denom == \"uscrt\" {\n            amount = coin.amount\n        }\n    }\n\n    if amount.is_zero() {\n        return Err(StdError::generic_err(\"No funds were sent to be deposited\"));\n    }\n\n    let amount = amount.u128();\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.deposit_is_enabled {\n        return Err(StdError::generic_err(\n            \"Deposit functionality is not enabled for this token.\",\n        ));\n    }\n    let total_supply = config.total_supply();\n    if let Some(total_supply) = total_supply.checked_add(amount) {\n        config.set_total_supply(total_supply);\n    } else {\n        return Err(StdError::generic_err(\n            \"This deposit would overflow the currency's total supply\",\n        ));\n    }\n\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let account_balance = balances.balance(\u0026sender_address);\n    if let Some(account_balance) = account_balance.checked_add(amount) {\n        balances.set_account_balance(\u0026sender_address, account_balance);\n    } else {\n        return Err(StdError::generic_err(\n            \"This deposit would overflow your balance\",\n        ));\n    }\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Deposit { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_redeem\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n    let constants = config.constants()?;\n    if !constants.redeem_is_enabled {\n        return Err(StdError::generic_err(\n            \"Redeem functionality is not enabled for this token.\",\n        ));\n    }\n\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let amount_raw = amount.u128();\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let account_balance = balances.balance(\u0026sender_address);\n\n    if let Some(account_balance) = account_balance.checked_sub(amount_raw) {\n        balances.set_account_balance(\u0026sender_address, account_balance);\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to redeem: balance={}, required={}\",\n            account_balance, amount_raw\n        )));\n    }\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let total_supply = config.total_supply();\n    if let Some(total_supply) = total_supply.checked_sub(amount_raw) {\n        config.set_total_supply(total_supply);\n    } else {\n        return Err(StdError::generic_err(\n            \"You are tyring to redeem more tokens than what is available in the total supply\",\n        ));\n    }\n\n    let token_reserve = deps\n        .querier\n        .query_balance(\u0026env.contract.address, \"uscrt\")?\n        .amount;\n    if amount \u003e token_reserve {\n        return Err(StdError::generic_err(\n            \"You are trying to redeem for more SCRT than the token has in its deposit reserve.\",\n        ));\n    }\n\n    let withdrawal_coins: Vec\u003cCoin\u003e = vec![Coin {\n        denom: \"uscrt\".to_string(),\n        amount,\n    }];\n\n    let res = HandleResponse {\n        messages: vec![CosmosMsg::Bank(BankMsg::Send {\n            from_address: env.contract.address,\n            to_address: env.message.sender,\n            amount: withdrawal_coins,\n        })],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Redeem { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_transfer_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let recipient_address = deps.api.canonical_address(recipient)?;\n\n    perform_transfer(\n        \u0026mut deps.storage,\n        \u0026sender_address,\n        \u0026recipient_address,\n        amount.u128(),\n    )?;\n\n    let symbol = Config::from_storage(\u0026mut deps.storage).constants()?.symbol;\n\n    store_transfer(\n        \u0026mut deps.storage,\n        \u0026sender_address,\n        \u0026sender_address,\n        \u0026recipient_address,\n        amount,\n        symbol,\n        env.block\n    )?;\n\n    Ok(())\n}\n\nfn try_transfer\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    try_transfer_impl(deps, env, recipient, amount)?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Transfer { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_add_receiver_api_callback\u003cS: ReadonlyStorage\u003e(\n    messages: \u0026mut Vec\u003cCosmosMsg\u003e,\n    storage: \u0026S,\n    recipient: \u0026HumanAddr,\n    msg: Option\u003cBinary\u003e,\n    sender: HumanAddr,\n    from: HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let receiver_hash = get_receiver_hash(storage, recipient);\n    if let Some(receiver_hash) = receiver_hash {\n        let receiver_hash = receiver_hash?;\n        let receiver_msg = Snip20ReceiveMsg::new(sender, from, amount, msg);\n        let callback_msg = receiver_msg.into_cosmos_msg(receiver_hash, recipient.clone())?;\n\n        messages.push(callback_msg);\n    }\n    Ok(())\n}\n\nfn try_send\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n    msg: Option\u003cBinary\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender = env.message.sender.clone();\n    try_transfer_impl(deps, env, recipient, amount)?;\n\n    let mut messages = vec![];\n\n    try_add_receiver_api_callback(\n        \u0026mut messages,\n        \u0026deps.storage,\n        recipient,\n        msg,\n        sender.clone(),\n        sender,\n        amount,\n    )?;\n\n    let res = HandleResponse {\n        messages,\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Send { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_register_receive\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    code_hash: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    set_receiver_hash(\u0026mut deps.storage, \u0026env.message.sender, code_hash);\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![log(\"register_status\", \"success\")],\n        data: Some(to_binary(\u0026HandleAnswer::RegisterReceive {\n            status: Success,\n        })?),\n    };\n    Ok(res)\n}\n\nfn insufficient_allowance(allowance: u128, required: u128) -\u003e StdError {\n    StdError::generic_err(format!(\n        \"insufficient allowance: allowance={}, required={}\",\n        allowance, required\n    ))\n}\n\nfn try_transfer_from_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let spender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let owner_address = deps.api.canonical_address(owner)?;\n    let recipient_address = deps.api.canonical_address(recipient)?;\n    let amount_raw = amount.u128();\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n\n    if allowance.expiration.map(|ex| ex \u003c env.block.time) == Some(true) {\n        allowance.amount = 0;\n        write_allowance(\n            \u0026mut deps.storage,\n            \u0026owner_address,\n            \u0026spender_address,\n            allowance,\n        )?;\n        return Err(insufficient_allowance(0, amount_raw));\n    }\n\n    if let Some(new_allowance) = allowance.amount.checked_sub(amount_raw) {\n        allowance.amount = new_allowance;\n    } else {\n        return Err(insufficient_allowance(allowance.amount, amount_raw));\n    }\n\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n    perform_transfer(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026recipient_address,\n        amount_raw,\n    )?;\n\n    let symbol = Config::from_storage(\u0026mut deps.storage).constants()?.symbol;\n\n    store_transfer(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        \u0026recipient_address,\n        amount,\n        symbol,\n        env.block,\n    )?;\n\n    Ok(())\n}\n\nfn try_transfer_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    try_transfer_from_impl(deps, env, owner, recipient, amount)?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::TransferFrom { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_send_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n    msg: Option\u003cBinary\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender = env.message.sender.clone();\n    try_transfer_from_impl(deps, env, owner, recipient, amount)?;\n\n    let mut messages = vec![];\n\n    try_add_receiver_api_callback(\n        \u0026mut messages,\n        \u0026deps.storage,\n        recipient,\n        msg,\n        sender,\n        owner.clone(),\n        amount,\n    )?;\n\n    let res = HandleResponse {\n        messages,\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SendFrom { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_burn_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n    let constants = config.constants()?;\n    if !constants.burn_is_enabled {\n        return Err(StdError::generic_err(\n            \"Burn functionality is not enabled for this token.\",\n        ));\n    }\n\n    let spender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let owner_address = deps.api.canonical_address(owner)?;\n    let amount = amount.u128();\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n\n    if allowance.expiration.map(|ex| ex \u003c env.block.time) == Some(true) {\n        allowance.amount = 0;\n        write_allowance(\n            \u0026mut deps.storage,\n            \u0026owner_address,\n            \u0026spender_address,\n            allowance,\n        )?;\n        return Err(insufficient_allowance(0, amount));\n    }\n\n    if let Some(new_allowance) = allowance.amount.checked_sub(amount) {\n        allowance.amount = new_allowance;\n    } else {\n        return Err(insufficient_allowance(allowance.amount, amount));\n    }\n\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    // subtract from owner account\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let mut account_balance = balances.balance(\u0026owner_address);\n\n    if let Some(new_balance) = account_balance.checked_sub(amount) {\n        account_balance = new_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to burn: balance={}, required={}\",\n            account_balance, amount\n        )));\n    }\n    balances.set_account_balance(\u0026owner_address, account_balance);\n\n    // remove from supply\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_sub(amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"You're trying to burn more than is available in the total supply\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::BurnFrom { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_increase_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    spender: HumanAddr,\n    amount: Uint128,\n    expiration: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let owner_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n    allowance.amount = allowance.amount.saturating_add(amount.u128());\n    if expiration.is_some() {\n        allowance.expiration = expiration;\n    }\n    let new_amount = allowance.amount;\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::IncreaseAllowance {\n            owner: env.message.sender,\n            spender,\n            allowance: Uint128(new_amount),\n        })?),\n    };\n    Ok(res)\n}\n\nfn try_decrease_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    spender: HumanAddr,\n    amount: Uint128,\n    expiration: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let owner_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n    allowance.amount = allowance.amount.saturating_sub(amount.u128());\n    if expiration.is_some() {\n        allowance.expiration = expiration;\n    }\n    let new_amount = allowance.amount;\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::DecreaseAllowance {\n            owner: env.message.sender,\n            spender,\n            allowance: Uint128(new_amount),\n        })?),\n    };\n    Ok(res)\n}\n\nfn add_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_add: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.add_minters(minters_to_add)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::AddMinters { status: Success })?),\n    })\n}\n\nfn remove_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_remove: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.remove_minters(minters_to_remove)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::RemoveMinters { status: Success })?),\n    })\n}\n\nfn set_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_set: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.set_minters(minters_to_set)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetMinters { status: Success })?),\n    })\n}\n\n/// Burn tokens\n///\n/// Remove `amount` tokens from the system irreversibly, from signer account\n///\n/// @param amount the amount of money to burn\nfn try_burn\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n    let constants = config.constants()?;\n    if !constants.burn_is_enabled {\n        return Err(StdError::generic_err(\n            \"Burn functionality is not enabled for this token.\",\n        ));\n    }\n\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let amount = amount.u128();\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let mut account_balance = balances.balance(\u0026sender_address);\n\n    if let Some(new_account_balance) = account_balance.checked_sub(amount) {\n        account_balance = new_account_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to burn: balance={}, required={}\",\n            account_balance, amount\n        )));\n    }\n\n    balances.set_account_balance(\u0026sender_address, account_balance);\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_sub(amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"You're trying to burn more than is available in the total supply\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Burn { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn perform_transfer\u003cT: Storage\u003e(\n    store: \u0026mut T,\n    from: \u0026CanonicalAddr,\n    to: \u0026CanonicalAddr,\n    amount: u128,\n) -\u003e StdResult\u003c()\u003e {\n    let mut balances = Balances::from_storage(store);\n\n    let mut from_balance = balances.balance(from);\n    if let Some(new_from_balance) = from_balance.checked_sub(amount) {\n        from_balance = new_from_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds: balance={}, required={}\",\n            from_balance, amount\n        )));\n    }\n    balances.set_account_balance(from, from_balance);\n\n    let mut to_balance = balances.balance(to);\n    to_balance = to_balance.checked_add(amount).ok_or_else(|| {\n        StdError::generic_err(\"This tx will literally make them too rich. Try transferring less\")\n    })?;\n    balances.set_account_balance(to, to_balance);\n\n    Ok(())\n}\n\nfn is_admin\u003cS: Storage\u003e(config: \u0026Config\u003cS\u003e, account: \u0026HumanAddr) -\u003e StdResult\u003cbool\u003e {\n    let consts = config.constants()?;\n    if \u0026consts.admin != account {\n        return Ok(false);\n    }\n\n    Ok(true)\n}\n\nfn check_if_admin\u003cS: Storage\u003e(config: \u0026Config\u003cS\u003e, account: \u0026HumanAddr) -\u003e StdResult\u003c()\u003e {\n    if !is_admin(config, account)? {\n        return Err(StdError::generic_err(\n            \"This is an admin command. Admin commands can only be run from admin address\",\n        ));\n    }\n\n    Ok(())\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let len = name.len();\n    (3..=30).contains(\u0026len)\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let len = symbol.len();\n    let len_is_valid = (3..=6).contains(\u0026len);\n\n    len_is_valid \u0026\u0026 symbol.bytes().all(|byte| (b'A'..=b'Z').contains(\u0026byte))\n}\n\n// pub fn migrate\u003cS: Storage, A: Api, Q: Querier\u003e(\n//     _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n//     _env: Env,\n//     _msg: MigrateMsg,\n// ) -\u003e StdResult\u003cMigrateResponse\u003e {\n//     Ok(MigrateResponse::default())\n// }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::msg::ResponseStatus;\n    use crate::msg::{InitConfig, InitialBalance};\n    use cosmwasm_std::testing::*;\n    use cosmwasm_std::{from_binary, BlockInfo, ContractInfo, MessageInfo, QueryResponse, WasmMsg};\n    use std::any::Any;\n\n    // Helper functions\n\n    fn init_helper(\n        initial_balances: Vec\u003cInitialBalance\u003e,\n    ) -\u003e (\n        StdResult\u003cInitResponse\u003e,\n        Extern\u003cMockStorage, MockApi, MockQuerier\u003e,\n    ) {\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n\n        let init_msg = InitMsg {\n            name: \"sec-sec\".to_string(),\n            admin: Some(HumanAddr(\"admin\".to_string())),\n            symbol: \"SECSEC\".to_string(),\n            decimals: 8,\n            initial_balances: Some(initial_balances),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: None,\n        };\n\n        (init(\u0026mut deps, env, init_msg), deps)\n    }\n\n    fn init_helper_with_config(\n        initial_balances: Vec\u003cInitialBalance\u003e,\n        enable_deposit: bool,\n        enable_redeem: bool,\n        enable_mint: bool,\n        enable_burn: bool,\n        contract_bal: u128,\n    ) -\u003e (\n        StdResult\u003cInitResponse\u003e,\n        Extern\u003cMockStorage, MockApi, MockQuerier\u003e,\n    ) {\n        let mut deps = mock_dependencies(\n            20,\n            \u0026[Coin {\n                denom: \"uscrt\".to_string(),\n                amount: Uint128(contract_bal),\n            }],\n        );\n\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":false,\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                enable_deposit, enable_redeem, enable_mint, enable_burn\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: \"sec-sec\".to_string(),\n            admin: Some(HumanAddr(\"admin\".to_string())),\n            symbol: \"SECSEC\".to_string(),\n            decimals: 8,\n            initial_balances: Some(initial_balances),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n\n        (init(\u0026mut deps, env, init_msg), deps)\n    }\n\n    /// Will return a ViewingKey only for the first account in `initial_balances`\n    fn _auth_query_helper(\n        initial_balances: Vec\u003cInitialBalance\u003e,\n    ) -\u003e (ViewingKey, Extern\u003cMockStorage, MockApi, MockQuerier\u003e) {\n        let (init_result, mut deps) = init_helper(initial_balances.clone());\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let account = initial_balances[0].address.clone();\n        let create_vk_msg = HandleMsg::CreateViewingKey {\n            entropy: \"42\".to_string(),\n            padding: None,\n        };\n        let handle_response = handle(\u0026mut deps, mock_env(account.0, \u0026[]), create_vk_msg).unwrap();\n        let vk = match from_binary(\u0026handle_response.data.unwrap()).unwrap() {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"Unexpected result from handle\"),\n        };\n\n        (vk, deps)\n    }\n\n    fn extract_error_msg\u003cT: Any\u003e(error: StdResult\u003cT\u003e) -\u003e String {\n        match error {\n            Ok(response) =\u003e {\n                let bin_err = (\u0026response as \u0026dyn Any)\n                    .downcast_ref::\u003cQueryResponse\u003e()\n                    .expect(\"An error was expected, but no error could be extracted\");\n                match from_binary(bin_err).unwrap() {\n                    QueryAnswer::ViewingKeyError { msg } =\u003e msg,\n                    _ =\u003e panic!(\"Unexpected query answer\"),\n                }\n            }\n            Err(err) =\u003e match err {\n                StdError::GenericErr { msg, .. } =\u003e msg,\n                _ =\u003e panic!(\"Unexpected result from init\"),\n            },\n        }\n    }\n\n    fn ensure_success(handle_result: HandleResponse) -\u003e bool {\n        let handle_result: HandleAnswer = from_binary(\u0026handle_result.data.unwrap()).unwrap();\n\n        match handle_result {\n            HandleAnswer::Deposit { status }\n            | HandleAnswer::Redeem { status }\n            | HandleAnswer::Transfer { status }\n            | HandleAnswer::Send { status }\n            | HandleAnswer::Burn { status }\n            | HandleAnswer::RegisterReceive { status }\n            | HandleAnswer::SetViewingKey { status }\n            | HandleAnswer::TransferFrom { status }\n            | HandleAnswer::SendFrom { status }\n            | HandleAnswer::BurnFrom { status }\n            | HandleAnswer::Mint { status }\n            | HandleAnswer::ChangeAdmin { status }\n            | HandleAnswer::SetContractStatus { status }\n            | HandleAnswer::SetMinters { status }\n            | HandleAnswer::AddMinters { status }\n            | HandleAnswer::RemoveMinters { status } =\u003e {\n                matches!(status, ResponseStatus::Success { .. })\n            }\n            _ =\u003e panic!(\"HandleAnswer not supported for success extraction\"),\n        }\n    }\n\n    // Init tests\n\n    #[test]\n    fn test_init_sanity() {\n        let (init_result, deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert_eq!(init_result.unwrap(), InitResponse::default());\n\n        let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n        let constants = config.constants().unwrap();\n        assert_eq!(config.total_supply(), 5000);\n        assert_eq!(config.contract_status(), ContractStatusLevel::NormalRun);\n        assert_eq!(constants.name, \"sec-sec\".to_string());\n        assert_eq!(constants.admin, HumanAddr(\"admin\".to_string()));\n        assert_eq!(constants.symbol, \"SECSEC\".to_string());\n        assert_eq!(constants.decimals, 8);\n        assert_eq!(\n            constants.prng_seed,\n            sha_256(\"lolz fun yay\".to_owned().as_bytes())\n        );\n        assert_eq!(constants.total_supply_is_public, false);\n    }\n\n    #[test]\n    fn test_init_with_config_sanity() {\n        let (init_result, deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            true,\n            true,\n            true,\n            true,\n            0,\n        );\n        assert_eq!(init_result.unwrap(), InitResponse::default());\n\n        let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n        let constants = config.constants().unwrap();\n        assert_eq!(config.total_supply(), 5000);\n        assert_eq!(config.contract_status(), ContractStatusLevel::NormalRun);\n        assert_eq!(constants.name, \"sec-sec\".to_string());\n        assert_eq!(constants.admin, HumanAddr(\"admin\".to_string()));\n        assert_eq!(constants.symbol, \"SECSEC\".to_string());\n        assert_eq!(constants.decimals, 8);\n        assert_eq!(\n            constants.prng_seed,\n            sha_256(\"lolz fun yay\".to_owned().as_bytes())\n        );\n        assert_eq!(constants.total_supply_is_public, false);\n        assert_eq!(constants.deposit_is_enabled, true);\n        assert_eq!(constants.redeem_is_enabled, true);\n        assert_eq!(constants.mint_is_enabled, true);\n        assert_eq!(constants.burn_is_enabled, true);\n    }\n\n    #[test]\n    fn test_total_supply_overflow() {\n        let (init_result, _deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(u128::max_value()),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result, _deps) = init_helper(vec![\n            InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(u128::max_value()),\n            },\n            InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: Uint128(1),\n            },\n        ]);\n        let error = extract_error_msg(init_result);\n        assert_eq!(\n            error,\n            \"The sum of all initial balances exceeds the maximum possible total supply\"\n        );\n    }\n\n    // Handle tests\n\n    #[test]\n    fn test_handle_transfer() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n        let balances = ReadonlyBalances::from_storage(\u0026deps.storage);\n        assert_eq!(5000 - 1000, balances.account_amount(\u0026bob_canonical));\n        assert_eq!(1000, balances.account_amount(\u0026alice_canonical));\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(10000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient funds\"));\n    }\n\n    #[test]\n    fn test_handle_send() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let handle_msg = HandleMsg::Send {\n            recipient: HumanAddr(\"contract\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n            msg: Some(to_binary(\"hey hey you you\").unwrap()),\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result.clone()));\n        assert!(result.messages.contains(\u0026CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: HumanAddr(\"contract\".to_string()),\n            callback_code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            msg: Snip20ReceiveMsg::new(\n                HumanAddr(\"bob\".to_string()),\n                HumanAddr(\"bob\".to_string()),\n                Uint128(100),\n                Some(to_binary(\"hey hey you you\").unwrap())\n            )\n            .into_binary()\n            .unwrap(),\n            send: vec![]\n        })));\n    }\n\n    #[test]\n    fn test_handle_register_receive() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let hash = get_receiver_hash(\u0026deps.storage, \u0026HumanAddr(\"contract\".to_string()))\n            .unwrap()\n            .unwrap();\n        assert_eq!(hash, \"this_is_a_hash_of_a_code\".to_string());\n    }\n\n    #[test]\n    fn test_handle_create_viewing_key() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::CreateViewingKey {\n            entropy: \"\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let answer: HandleAnswer = from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n\n        let key = match answer {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"NOPE\"),\n        };\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let saved_vk = read_viewing_key(\u0026deps.storage, \u0026bob_canonical).unwrap();\n        assert!(key.check_viewing_key(saved_vk.as_slice()));\n    }\n\n    #[test]\n    fn test_handle_set_viewing_key() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Set VK\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"hi lol\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        // Set valid VK\n        let actual_vk = ViewingKey(\"x\".to_string().repeat(VIEWING_KEY_SIZE));\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: actual_vk.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey { status: Success }).unwrap(),\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let saved_vk = read_viewing_key(\u0026deps.storage, \u0026bob_canonical).unwrap();\n        assert!(actual_vk.check_viewing_key(\u0026saved_vk));\n    }\n\n    #[test]\n    fn test_handle_transfer_from() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Transfer before allowance\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Transfer more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: Some(1_571_797_420),\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Transfer after allowance expired\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n        };\n        let handle_result = handle(\n            \u0026mut deps,\n            Env {\n                block: BlockInfo {\n                    height: 12_345,\n                    time: 1_571_797_420,\n                    chain_id: \"cosmos-testnet-14002\".to_string(),\n                },\n                message: MessageInfo {\n                    sender: HumanAddr(\"bob\".to_string()),\n                    sent_funds: vec![],\n                },\n                contract: ContractInfo {\n                    address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n                },\n                contract_key: Some(\"\".to_string()),\n                contract_code_hash: \"\".to_string(),\n            },\n            handle_msg,\n        );\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        let alice_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026alice_canonical);\n        assert_eq!(bob_balance, 5000 - 2000);\n        assert_eq!(alice_balance, 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 5000);\n\n        // Second send more than allowance\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_send_from() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Send before allowance\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Send more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"lolz\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let send_msg = Binary::from(r#\"{ \"some_msg\": { \"some_key\": \"some_val\" } }\"#.as_bytes());\n        let snip20_msg = Snip20ReceiveMsg::new(\n            HumanAddr(\"alice\".to_string()),\n            HumanAddr(\"bob\".to_string()),\n            Uint128(2000),\n            Some(send_msg.clone()),\n        );\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"contract\".to_string()),\n            amount: Uint128(2000),\n            msg: Some(send_msg),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        assert!(handle_result.unwrap().messages.contains(\n            \u0026snip20_msg\n                .into_cosmos_msg(\"lolz\".to_string(), HumanAddr(\"contract\".to_string()))\n                .unwrap()\n        ));\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let contract_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"contract\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        let contract_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026contract_canonical);\n        assert_eq!(bob_balance, 5000 - 2000);\n        assert_eq!(contract_balance, 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 5000);\n\n        // Second send more than allowance\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1),\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_burn_from() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(10000),\n            }],\n            false,\n            false,\n            false,\n            true,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(10000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when burn disabled\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Burn functionality is not enabled for this token.\"));\n\n        // Burn before allowance\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Burn more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        assert_eq!(bob_balance, 10000 - 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 10000 - 2000);\n\n        // Second burn more than allowance\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(1),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_decrease_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::DecreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 0,\n                expiration: None\n            }\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::DecreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(50),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 1950,\n                expiration: None\n            }\n        );\n    }\n\n    #[test]\n    fn test_handle_increase_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 2000,\n                expiration: None\n            }\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 4000,\n                expiration: None\n            }\n        );\n    }\n\n    #[test]\n    fn test_handle_change_admin() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::ChangeAdmin {\n            address: HumanAddr(\"bob\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let admin = ReadonlyConfig::from_storage(\u0026deps.storage)\n            .constants()\n            .unwrap()\n            .admin;\n        assert_eq!(admin, HumanAddr(\"bob\".to_string()));\n    }\n\n    #[test]\n    fn test_handle_set_contract_status() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"admin\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAll,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let contract_status = ReadonlyConfig::from_storage(\u0026deps.storage).contract_status();\n        assert!(matches!(\n            contract_status,\n            ContractStatusLevel::StopAll { .. }\n        ));\n    }\n\n    #[test]\n    fn test_handle_redeem() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"butler\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            true,\n            false,\n            false,\n            1000,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_no_reserve, mut deps_no_reserve) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"butler\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            true,\n            false,\n            false,\n            0,\n        );\n        assert!(\n            init_result_no_reserve.is_ok(),\n            \"Init failed: {}\",\n            init_result_no_reserve.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"butler\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when redeem disabled\n        let handle_msg = HandleMsg::Redeem {\n            amount: Uint128(1000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"butler\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Redeem functionality is not enabled for this token.\"));\n\n        // try to redeem when contract has 0 balance\n        let handle_msg = HandleMsg::Redeem {\n            amount: Uint128(1000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_no_reserve, mock_env(\"butler\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\n            \"You are trying to redeem for more SCRT than the token has in its deposit reserve.\"\n        ));\n\n        let handle_msg = HandleMsg::Redeem {\n            amount: Uint128(1000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"butler\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let balances = ReadonlyBalances::from_storage(\u0026deps.storage);\n        let canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"butler\".to_string()))\n            .unwrap();\n        assert_eq!(balances.account_amount(\u0026canonical), 4000)\n    }\n\n    #[test]\n    fn test_handle_deposit() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            true,\n            false,\n            false,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when deposit disabled\n        let handle_msg = HandleMsg::Deposit { padding: None };\n        let handle_result = handle(\n            \u0026mut deps_for_failure,\n            mock_env(\n                \"lebron\",\n                \u0026[Coin {\n                    denom: \"uscrt\".to_string(),\n                    amount: Uint128(1000),\n                }],\n            ),\n            handle_msg,\n        );\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Deposit functionality is not enabled for this token.\"));\n\n        let handle_msg = HandleMsg::Deposit { padding: None };\n        let handle_result = handle(\n            \u0026mut deps,\n            mock_env(\n                \"lebron\",\n                \u0026[Coin {\n                    denom: \"uscrt\".to_string(),\n                    amount: Uint128(1000),\n                }],\n            ),\n            handle_msg,\n        );\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let balances = ReadonlyBalances::from_storage(\u0026deps.storage);\n        let canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"lebron\".to_string()))\n            .unwrap();\n        assert_eq!(balances.account_amount(\u0026canonical), 6000)\n    }\n\n    #[test]\n    fn test_handle_burn() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            false,\n            true,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when burn disabled\n        let handle_msg = HandleMsg::Burn {\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"lebron\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Burn functionality is not enabled for this token.\"));\n\n        let supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        let burn_amount: u128 = 100;\n        let handle_msg = HandleMsg::Burn {\n            amount: Uint128(burn_amount),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let new_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(new_supply, supply - burn_amount);\n    }\n\n    #[test]\n    fn test_handle_mint() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try to mint when mint is disabled\n        let mint_amount: u128 = 100;\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(mint_amount),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        let mint_amount: u128 = 100;\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(mint_amount),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let new_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(new_supply, supply + mint_amount);\n    }\n\n    #[test]\n    fn test_handle_admin_commands() {\n        let admin_err = \"Admin commands can only be run from admin address\".to_string();\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAllButRedeems,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), pause_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"not_admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"not_admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let change_admin_msg = HandleMsg::ChangeAdmin {\n            address: HumanAddr(\"not_admin\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), change_admin_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n    }\n\n    #[test]\n    fn test_handle_pause_with_withdrawals() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            true,\n            false,\n            false,\n            5000,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAllButRedeems,\n            padding: None,\n        };\n\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), pause_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let send_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"account\".to_string()),\n            amount: Uint128(123),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), send_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n\n        let withdraw_msg = HandleMsg::Redeem {\n            amount: Uint128(5000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), withdraw_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Withdraw failed: {}\",\n            handle_result.err().unwrap()\n        );\n    }\n\n    #[test]\n    fn test_handle_pause_all() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAll,\n            padding: None,\n        };\n\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), pause_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let send_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"account\".to_string()),\n            amount: Uint128(123),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), send_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n\n        let withdraw_msg = HandleMsg::Redeem {\n            amount: Uint128(5000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), withdraw_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_handle_set_minters() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try when mint disabled\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n    }\n\n    #[test]\n    fn test_handle_add_minters() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try when mint disabled\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n    }\n\n    #[test]\n    fn test_handle_remove_minters() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try when mint disabled\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        // Removing another extra time to ensure nothing funky happens\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n    }\n\n    // Query tests\n\n    #[test]\n    fn test_authenticated_queries() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"giannis\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let no_vk_yet_query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: \"no_vk_yet\".to_string(),\n        };\n        let query_result = query(\u0026deps, no_vk_yet_query_msg);\n        let error = extract_error_msg(query_result);\n        assert_eq!(\n            error,\n            \"Wrong viewing key for this address or viewing key not set\".to_string()\n        );\n\n        let create_vk_msg = HandleMsg::CreateViewingKey {\n            entropy: \"34\".to_string(),\n            padding: None,\n        };\n        let handle_response = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), create_vk_msg).unwrap();\n        let vk = match from_binary(\u0026handle_response.data.unwrap()).unwrap() {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"Unexpected result from handle\"),\n        };\n\n        let query_balance_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: vk.0,\n        };\n\n        let query_response = query(\u0026deps, query_balance_msg).unwrap();\n        let balance = match from_binary(\u0026query_response).unwrap() {\n            QueryAnswer::Balance { amount } =\u003e amount,\n            _ =\u003e panic!(\"Unexpected result from query\"),\n        };\n        assert_eq!(balance, Uint128(5000));\n\n        let wrong_vk_query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: \"wrong_vk\".to_string(),\n        };\n        let query_result = query(\u0026deps, wrong_vk_query_msg);\n        let error = extract_error_msg(query_result);\n        assert_eq!(\n            error,\n            \"Wrong viewing key for this address or viewing key not set\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_query_token_info() {\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 8;\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            r#\"{ \"public_total_supply\": true }\"#.as_bytes(),\n        ))\n        .unwrap();\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::TokenInfo {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::TokenInfo {\n                name,\n                symbol,\n                decimals,\n                total_supply,\n            } =\u003e {\n                assert_eq!(name, init_name);\n                assert_eq!(symbol, init_symbol);\n                assert_eq!(decimals, init_decimals);\n                assert_eq!(total_supply, Some(Uint128(5000)));\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n    }\n\n    #[test]\n    fn test_query_token_config() {\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 8;\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, false, false, true, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::TokenConfig {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::TokenConfig {\n                public_total_supply,\n                deposit_enabled,\n                redeem_enabled,\n                mint_enabled,\n                burn_enabled,\n            } =\u003e {\n                assert_eq!(public_total_supply, true);\n                assert_eq!(deposit_enabled, false);\n                assert_eq!(redeem_enabled, false);\n                assert_eq!(mint_enabled, true);\n                assert_eq!(burn_enabled, false);\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n    }\n\n    #[test]\n    fn test_query_exchange_rate() {\n        // test more dec than SCRT\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 8;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, true, false, false, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(100));\n                assert_eq!(denom, \"SCRT\");\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n\n        // test same number of decimals as SCRT\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 6;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, true, false, false, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(1));\n                assert_eq!(denom, \"SCRT\");\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n\n        // test less decimal places than SCRT\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 3;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, true, false, false, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(1000));\n                assert_eq!(denom, \"SECSEC\");\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n\n        // test depost/redeem not enabled\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 3;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: None,\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(0));\n                assert_eq!(denom, String::new());\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n    }\n\n    #[test]\n    fn test_query_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"giannis\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let vk1 = ViewingKey(\"key1\".to_string());\n        let vk2 = ViewingKey(\"key2\".to_string());\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk1.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Query failed: {}\",\n            query_result.err().unwrap()\n        );\n        let error = extract_error_msg(query_result);\n        assert!(error.contains(\"Wrong viewing key\"));\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: vk1.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: vk2.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk1.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(2000));\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk2.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(2000));\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"lebron\".to_string()),\n            spender: HumanAddr(\"giannis\".to_string()),\n            key: vk2.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(0));\n    }\n\n    #[test]\n    fn test_query_balance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"key\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"wrong_key\".to_string(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let error = extract_error_msg(query_result);\n        assert!(error.contains(\"Wrong viewing key\"));\n\n        let query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let balance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Balance { amount } =\u003e amount,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(balance, Uint128(5000));\n    }\n\n    #[test]\n    fn test_query_transfer_history() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"key\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"banana\".to_string()),\n            amount: Uint128(500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"mango\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 0,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        // let a: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        // println!(\"{:?}\", a);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, total } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert!(transfers.is_empty());\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 10,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, total } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(transfers.len(), 3);\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 2,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, total } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(transfers.len(), 2);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\nmod rand;\npub mod receiver;\npub mod state;\nmod utils;\nmod viewing_key;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","src","msg.rs"],"content":"#![allow(clippy::field_reassign_with_default)] // This is triggered in `#[derive(JsonSchema)]`\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Binary, HumanAddr, StdError, StdResult, Uint128};\n\nuse crate::state::Tx;\nuse crate::viewing_key::ViewingKey;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct InitialBalance {\n    pub address: HumanAddr,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema)]\npub struct InitMsg {\n    pub name: String,\n    pub admin: Option\u003cHumanAddr\u003e,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Option\u003cVec\u003cInitialBalance\u003e\u003e,\n    pub prng_seed: Binary,\n    pub config: Option\u003cInitConfig\u003e,\n}\n\nimpl InitMsg {\n    pub fn config(\u0026self) -\u003e InitConfig {\n        self.config.clone().unwrap_or_default()\n    }\n}\n\n/// This type represents optional configuration values which can be overridden.\n/// All values are optional and have defaults which are more private by default,\n/// but can be overridden if necessary\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Default, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct InitConfig {\n    /// Indicates whether the total supply is public or should be kept secret.\n    /// default: False\n    public_total_supply: Option\u003cbool\u003e,\n    /// Indicates whether deposit functionality should be enabled\n    /// default: False\n    enable_deposit: Option\u003cbool\u003e,\n    /// Indicates whether redeem functionality should be enabled\n    /// default: False\n    enable_redeem: Option\u003cbool\u003e,\n    /// Indicates whether mint functionality should be enabled\n    /// default: False\n    enable_mint: Option\u003cbool\u003e,\n    /// Indicates whether burn functionality should be enabled\n    /// default: False\n    enable_burn: Option\u003cbool\u003e,\n}\n\nimpl InitConfig {\n    pub fn public_total_supply(\u0026self) -\u003e bool {\n        self.public_total_supply.unwrap_or(false)\n    }\n\n    pub fn deposit_enabled(\u0026self) -\u003e bool {\n        self.enable_deposit.unwrap_or(false)\n    }\n\n    pub fn redeem_enabled(\u0026self) -\u003e bool {\n        self.enable_redeem.unwrap_or(false)\n    }\n\n    pub fn mint_enabled(\u0026self) -\u003e bool {\n        self.enable_mint.unwrap_or(false)\n    }\n\n    pub fn burn_enabled(\u0026self) -\u003e bool {\n        self.enable_burn.unwrap_or(false)\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    // Native coin interactions\n    Redeem {\n        amount: Uint128,\n        denom: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    Deposit {\n        padding: Option\u003cString\u003e,\n    },\n\n    // Base ERC-20 stuff\n    Transfer {\n        recipient: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    Send {\n        recipient: HumanAddr,\n        amount: Uint128,\n        msg: Option\u003cBinary\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    Burn {\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    RegisterReceive {\n        code_hash: String,\n        padding: Option\u003cString\u003e,\n    },\n    CreateViewingKey {\n        entropy: String,\n        padding: Option\u003cString\u003e,\n    },\n    SetViewingKey {\n        key: String,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Allowance\n    IncreaseAllowance {\n        spender: HumanAddr,\n        amount: Uint128,\n        expiration: Option\u003cu64\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    DecreaseAllowance {\n        spender: HumanAddr,\n        amount: Uint128,\n        expiration: Option\u003cu64\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    TransferFrom {\n        owner: HumanAddr,\n        recipient: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    SendFrom {\n        owner: HumanAddr,\n        recipient: HumanAddr,\n        amount: Uint128,\n        msg: Option\u003cBinary\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    BurnFrom {\n        owner: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Mint\n    Mint {\n        recipient: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    AddMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    RemoveMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    SetMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Admin\n    ChangeAdmin {\n        address: HumanAddr,\n        padding: Option\u003cString\u003e,\n    },\n    SetContractStatus {\n        level: ContractStatusLevel,\n        padding: Option\u003cString\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleAnswer {\n    // Native\n    Deposit {\n        status: ResponseStatus,\n    },\n    Redeem {\n        status: ResponseStatus,\n    },\n\n    // Base\n    Transfer {\n        status: ResponseStatus,\n    },\n    Send {\n        status: ResponseStatus,\n    },\n    Burn {\n        status: ResponseStatus,\n    },\n    RegisterReceive {\n        status: ResponseStatus,\n    },\n    CreateViewingKey {\n        key: ViewingKey,\n    },\n    SetViewingKey {\n        status: ResponseStatus,\n    },\n\n    // Allowance\n    IncreaseAllowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n    },\n    DecreaseAllowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n    },\n    TransferFrom {\n        status: ResponseStatus,\n    },\n    SendFrom {\n        status: ResponseStatus,\n    },\n    BurnFrom {\n        status: ResponseStatus,\n    },\n\n    // Mint\n    Mint {\n        status: ResponseStatus,\n    },\n    AddMinters {\n        status: ResponseStatus,\n    },\n    RemoveMinters {\n        status: ResponseStatus,\n    },\n    SetMinters {\n        status: ResponseStatus,\n    },\n\n    // Other\n    ChangeAdmin {\n        status: ResponseStatus,\n    },\n    SetContractStatus {\n        status: ResponseStatus,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    TokenInfo {},\n    TokenConfig {},\n    ExchangeRate {},\n    Allowance {\n        owner: HumanAddr,\n        spender: HumanAddr,\n        key: String,\n    },\n    Balance {\n        address: HumanAddr,\n        key: String,\n    },\n    TransferHistory {\n        address: HumanAddr,\n        key: String,\n        page: Option\u003cu32\u003e,\n        page_size: u32,\n    },\n    Minters {},\n}\n\nimpl QueryMsg {\n    pub fn get_validation_params(\u0026self) -\u003e (Vec\u003c\u0026HumanAddr\u003e, ViewingKey) {\n        match self {\n            Self::Balance { address, key } =\u003e (vec![address], ViewingKey(key.clone())),\n            Self::TransferHistory { address, key, .. } =\u003e (vec![address], ViewingKey(key.clone())),\n            Self::Allowance {\n                owner,\n                spender,\n                key,\n                ..\n            } =\u003e (vec![owner, spender], ViewingKey(key.clone())),\n            _ =\u003e panic!(\"This query type does not require authentication\"),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryAnswer {\n    TokenInfo {\n        name: String,\n        symbol: String,\n        decimals: u8,\n        total_supply: Option\u003cUint128\u003e,\n    },\n    TokenConfig {\n        public_total_supply: bool,\n        deposit_enabled: bool,\n        redeem_enabled: bool,\n        mint_enabled: bool,\n        burn_enabled: bool,\n    },\n    ExchangeRate {\n        rate: Uint128,\n        denom: String,\n    },\n    Allowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n        expiration: Option\u003cu64\u003e,\n    },\n    Balance {\n        amount: Uint128,\n    },\n    TransferHistory {\n        txs: Vec\u003cTx\u003e,\n        total: Option\u003cu64\u003e,\n    },\n\n    ViewingKeyError {\n        msg: String,\n    },\n    Minters {\n        minters: Vec\u003cHumanAddr\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct CreateViewingKeyResponse {\n    pub key: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ResponseStatus {\n    Success,\n    Failure,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ContractStatusLevel {\n    NormalRun,\n    StopAllButRedeems,\n    StopAll,\n}\n\npub fn status_level_to_u8(status_level: ContractStatusLevel) -\u003e u8 {\n    match status_level {\n        ContractStatusLevel::NormalRun =\u003e 0,\n        ContractStatusLevel::StopAllButRedeems =\u003e 1,\n        ContractStatusLevel::StopAll =\u003e 2,\n    }\n}\n\npub fn u8_to_status_level(status_level: u8) -\u003e StdResult\u003cContractStatusLevel\u003e {\n    match status_level {\n        0 =\u003e Ok(ContractStatusLevel::NormalRun),\n        1 =\u003e Ok(ContractStatusLevel::StopAllButRedeems),\n        2 =\u003e Ok(ContractStatusLevel::StopAll),\n        _ =\u003e Err(StdError::generic_err(\"Invalid state level\")),\n    }\n}\n\n// Take a Vec\u003cu8\u003e and pad it up to a multiple of `block_size`, using spaces at the end.\npub fn space_pad(block_size: usize, message: \u0026mut Vec\u003cu8\u003e) -\u003e \u0026mut Vec\u003cu8\u003e {\n    let len = message.len();\n    let surplus = len % block_size;\n    if surplus == 0 {\n        return message;\n    }\n\n    let missing = block_size - surplus;\n    message.reserve(missing);\n    message.extend(std::iter::repeat(b' ').take(missing));\n    message\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::{from_slice, StdResult};\n\n    #[derive(Serialize, Deserialize, JsonSchema, Debug, PartialEq)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum Something {\n        Var { padding: Option\u003cString\u003e },\n    }\n\n    #[test]\n    fn test_deserialization_of_missing_option_fields() -\u003e StdResult\u003c()\u003e {\n        let input = b\"{ \\\"var\\\": {} }\";\n        let obj: Something = from_slice(input)?;\n        assert_eq!(\n            obj,\n            Something::Var { padding: None },\n            \"unexpected value: {:?}\",\n            obj\n        );\n        Ok(())\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":23},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","src","rand.rs"],"content":"use rand_chacha::ChaChaRng;\nuse rand_core::{RngCore, SeedableRng};\n\nuse sha2::{Digest, Sha256};\n\npub fn sha_256(data: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    let hash = hasher.finalize();\n\n    let mut result = [0u8; 32];\n    result.copy_from_slice(hash.as_slice());\n    result\n}\n\npub struct Prng {\n    rng: ChaChaRng,\n}\n\nimpl Prng {\n    pub fn new(seed: \u0026[u8], entropy: \u0026[u8]) -\u003e Self {\n        let mut hasher = Sha256::new();\n\n        // write input message\n        hasher.update(\u0026seed);\n        hasher.update(\u0026entropy);\n        let hash = hasher.finalize();\n\n        let mut hash_bytes = [0u8; 32];\n        hash_bytes.copy_from_slice(hash.as_slice());\n\n        let rng: ChaChaRng = ChaChaRng::from_seed(hash_bytes);\n\n        Self { rng }\n    }\n\n    pub fn rand_bytes(\u0026mut self) -\u003e [u8; 32] {\n        let mut bytes = [0u8; 32];\n        self.rng.fill_bytes(\u0026mut bytes);\n\n        bytes\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// This test checks that the rng is stateful and generates\n    /// different random bytes every time it is called.\n    #[test]\n    fn test_rng() {\n        let mut rng = Prng::new(b\"foo\", b\"bar!\");\n        let r1: [u8; 32] = [\n            155, 11, 21, 97, 252, 65, 160, 190, 100, 126, 85, 251, 47, 73, 160, 49, 216, 182, 93,\n            30, 185, 67, 166, 22, 34, 10, 213, 112, 21, 136, 49, 214,\n        ];\n        let r2: [u8; 32] = [\n            46, 135, 19, 242, 111, 125, 59, 215, 114, 130, 122, 155, 202, 23, 36, 118, 83, 11, 6,\n            180, 97, 165, 218, 136, 134, 243, 191, 191, 149, 178, 7, 149,\n        ];\n        let r3: [u8; 32] = [\n            9, 2, 131, 50, 199, 170, 6, 68, 168, 28, 242, 182, 35, 114, 15, 163, 65, 139, 101, 221,\n            207, 147, 119, 110, 81, 195, 6, 134, 14, 253, 245, 244,\n        ];\n        let r4: [u8; 32] = [\n            68, 196, 114, 205, 225, 64, 201, 179, 18, 77, 216, 197, 211, 13, 21, 196, 11, 102, 106,\n            195, 138, 250, 29, 185, 51, 38, 183, 0, 5, 169, 65, 190,\n        ];\n        assert_eq!(r1, rng.rand_bytes());\n        assert_eq!(r2, rng.rand_bytes());\n        assert_eq!(r3, rng.rand_bytes());\n        assert_eq!(r4, rng.rand_bytes());\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","src","receiver.rs"],"content":"#![allow(clippy::field_reassign_with_default)] // This is triggered in `#[derive(JsonSchema)]`\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{to_binary, Binary, CosmosMsg, HumanAddr, StdResult, Uint128, WasmMsg};\n\nuse crate::{contract::RESPONSE_BLOCK_SIZE, msg::space_pad};\n\n/// Snip20ReceiveMsg should be de/serialized under `Receive()` variant in a HandleMsg\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct Snip20ReceiveMsg {\n    pub sender: HumanAddr,\n    pub from: HumanAddr,\n    pub amount: Uint128,\n    pub msg: Option\u003cBinary\u003e,\n}\n\nimpl Snip20ReceiveMsg {\n    pub fn new(sender: HumanAddr, from: HumanAddr, amount: Uint128, msg: Option\u003cBinary\u003e) -\u003e Self {\n        Self {\n            sender,\n            from,\n            amount,\n            msg,\n        }\n    }\n\n    /// serializes the message, and pads it to 256 bytes\n    pub fn into_binary(self) -\u003e StdResult\u003cBinary\u003e {\n        let msg = ReceiverHandleMsg::Receive(self);\n        let mut data = to_binary(\u0026msg)?;\n        space_pad(RESPONSE_BLOCK_SIZE, \u0026mut data.0);\n        Ok(data)\n    }\n\n    /// creates a cosmos_msg sending this struct to the named contract\n    pub fn into_cosmos_msg(\n        self,\n        callback_code_hash: String,\n        contract_addr: HumanAddr,\n    ) -\u003e StdResult\u003cCosmosMsg\u003e {\n        let msg = self.into_binary()?;\n        let execute = WasmMsg::Execute {\n            msg,\n            callback_code_hash,\n            contract_addr,\n            send: vec![],\n        };\n        Ok(execute.into())\n    }\n}\n\n// This is just a helper to properly serialize the above message\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\nenum ReceiverHandleMsg {\n    Receive(Snip20ReceiveMsg),\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","src","state.rs"],"content":"use std::any::type_name;\nuse std::convert::TryFrom;\n\nuse cosmwasm_std::{\n    Api, CanonicalAddr, Coin, HumanAddr, ReadonlyStorage, StdError, StdResult, Storage, Uint128,\n};\nuse cosmwasm_storage::{PrefixedStorage, ReadonlyPrefixedStorage};\n\nuse secret_toolkit::storage::{AppendStore, AppendStoreMut, TypedStore, TypedStoreMut};\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::msg::{status_level_to_u8, u8_to_status_level, ContractStatusLevel};\nuse crate::viewing_key::ViewingKey;\nuse serde::de::DeserializeOwned;\n\npub static CONFIG_KEY: \u0026[u8] = b\"config\";\npub const PREFIX_TXS: \u0026[u8] = b\"transfers\";\n\npub const KEY_CONSTANTS: \u0026[u8] = b\"constants\";\npub const KEY_TOTAL_SUPPLY: \u0026[u8] = b\"total_supply\";\npub const KEY_CONTRACT_STATUS: \u0026[u8] = b\"contract_status\";\npub const KEY_MINTERS: \u0026[u8] = b\"minters\";\npub const KEY_TX_COUNT: \u0026[u8] = b\"tx-count\";\n\npub const PREFIX_CONFIG: \u0026[u8] = b\"config\";\npub const PREFIX_BALANCES: \u0026[u8] = b\"balances\";\npub const PREFIX_ALLOWANCES: \u0026[u8] = b\"allowances\";\npub const PREFIX_VIEW_KEY: \u0026[u8] = b\"viewingkey\";\npub const PREFIX_RECEIVERS: \u0026[u8] = b\"receivers\";\n\n// Note that id is a globally incrementing counter.\n// Since it's 64 bits long, even at 50 tx/s it would take\n// over 11 billion years for it to rollback. I'm pretty sure\n// we'll have bigger issues by then.\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\npub struct Tx {\n    pub id: u64,\n    pub from: HumanAddr,\n    pub sender: HumanAddr,\n    pub receiver: HumanAddr,\n    pub coins: Coin,\n    // The timestamp and block height are optional so that the JSON schema\n    // reflects that some SNIP-20 contracts may not include this info.\n    pub timestamp: Option\u003cu64\u003e,\n    pub block_height: Option\u003cu64\u003e,\n}\n\nimpl Tx {\n    pub fn into_stored\u003cA: Api\u003e(self, api: \u0026A) -\u003e StdResult\u003cStoredTx\u003e {\n        let tx = StoredTx {\n            id: self.id,\n            from: api.canonical_address(\u0026self.from)?,\n            sender: api.canonical_address(\u0026self.sender)?,\n            receiver: api.canonical_address(\u0026self.receiver)?,\n            coins: self.coins,\n            timestamp: self.timestamp.unwrap_or(0),\n            block_height: self.block_height.unwrap_or(0),\n        };\n        Ok(tx)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct StoredTx {\n    pub id: u64,\n    pub from: CanonicalAddr,\n    pub sender: CanonicalAddr,\n    pub receiver: CanonicalAddr,\n    pub coins: Coin,\n    pub timestamp: u64,\n    pub block_height: u64,\n}\n\nimpl StoredTx {\n    pub fn into_humanized\u003cA: Api\u003e(self, api: \u0026A) -\u003e StdResult\u003cTx\u003e {\n        let tx = Tx {\n            id: self.id,\n            from: api.human_address(\u0026self.from)?,\n            sender: api.human_address(\u0026self.sender)?,\n            receiver: api.human_address(\u0026self.receiver)?,\n            coins: self.coins,\n            timestamp: Some(self.timestamp),\n            block_height: Some(self.block_height),\n        };\n        Ok(tx)\n    }\n}\n\npub fn store_transfer\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    owner: \u0026CanonicalAddr,\n    sender: \u0026CanonicalAddr,\n    receiver: \u0026CanonicalAddr,\n    amount: Uint128,\n    denom: String,\n    block: cosmwasm_std::BlockInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let mut config = Config::from_storage(store);\n    let id = config.tx_count() + 1;\n    config.set_tx_count(id)?;\n\n    let coins = Coin { denom, amount };\n    let tx = StoredTx {\n        id,\n        from: owner.clone(),\n        sender: sender.clone(),\n        receiver: receiver.clone(),\n        coins,\n        timestamp: block.time,\n        block_height: block.height,\n    };\n\n    if owner != sender {\n        append_tx(store, tx.clone(), \u0026owner)?;\n    }\n    append_tx(store, tx.clone(), \u0026sender)?;\n    append_tx(store, tx, \u0026receiver)?;\n\n    Ok(())\n}\n\nfn append_tx\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    tx: StoredTx,\n    for_address: \u0026CanonicalAddr,\n) -\u003e StdResult\u003c()\u003e {\n    let mut store = PrefixedStorage::multilevel(\u0026[PREFIX_TXS, for_address.as_slice()], store);\n    let mut store = AppendStoreMut::attach_or_create(\u0026mut store)?;\n    store.push(\u0026tx)\n}\n\npub fn get_transfers\u003cA: Api, S: ReadonlyStorage\u003e(\n    api: \u0026A,\n    storage: \u0026S,\n    for_address: \u0026CanonicalAddr,\n    page: u32,\n    page_size: u32,\n) -\u003e StdResult\u003c(Vec\u003cTx\u003e, u64)\u003e {\n    let store = ReadonlyPrefixedStorage::multilevel(\u0026[PREFIX_TXS, for_address.as_slice()], storage);\n\n    // Try to access the storage of txs for the account.\n    // If it doesn't exist yet, return an empty list of transfers.\n    let store = if let Some(result) = AppendStore::\u003cStoredTx, _\u003e::attach(\u0026store) {\n        result?\n    } else {\n        return Ok((vec![], 0));\n    };\n\n    // Take `page_size` txs starting from the latest tx, potentially skipping `page * page_size`\n    // txs from the start.\n    let tx_iter = store\n        .iter()\n        .rev()\n        .skip((page * page_size) as _)\n        .take(page_size as _);\n    // The `and_then` here flattens the `StdResult\u003cStdResult\u003cTx\u003e\u003e` to an `StdResult\u003cTx\u003e`\n    let txs: StdResult\u003cVec\u003cTx\u003e\u003e = tx_iter\n        .map(|tx| tx.map(|tx| tx.into_humanized(api)).and_then(|x| x))\n        .collect();\n    txs.map(|txs| (txs, store.len() as u64))\n}\n\n// Config\n\n#[derive(Serialize, Debug, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct Constants {\n    pub name: String,\n    pub admin: HumanAddr,\n    pub symbol: String,\n    pub decimals: u8,\n    pub prng_seed: Vec\u003cu8\u003e,\n    // privacy configuration\n    pub total_supply_is_public: bool,\n    // is deposit enabled\n    pub deposit_is_enabled: bool,\n    // is redeem enabled\n    pub redeem_is_enabled: bool,\n    // is mint enabled\n    pub mint_is_enabled: bool,\n    // is burn enabled\n    pub burn_is_enabled: bool,\n}\n\npub struct ReadonlyConfig\u003c'a, S: ReadonlyStorage\u003e {\n    storage: ReadonlyPrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyConfig\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a S) -\u003e Self {\n        Self {\n            storage: ReadonlyPrefixedStorage::new(PREFIX_CONFIG, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyConfigImpl\u003cReadonlyPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyConfigImpl(\u0026self.storage)\n    }\n\n    pub fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        self.as_readonly().constants()\n    }\n\n    pub fn total_supply(\u0026self) -\u003e u128 {\n        self.as_readonly().total_supply()\n    }\n\n    pub fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        self.as_readonly().contract_status()\n    }\n\n    pub fn minters(\u0026self) -\u003e Vec\u003cHumanAddr\u003e {\n        self.as_readonly().minters()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        self.as_readonly().tx_count()\n    }\n}\n\nfn set_bin_data\u003cT: Serialize, S: Storage\u003e(storage: \u0026mut S, key: \u0026[u8], data: \u0026T) -\u003e StdResult\u003c()\u003e {\n    let bin_data =\n        bincode2::serialize(\u0026data).map_err(|e| StdError::serialize_err(type_name::\u003cT\u003e(), e))?;\n\n    storage.set(key, \u0026bin_data);\n    Ok(())\n}\n\nfn get_bin_data\u003cT: DeserializeOwned, S: ReadonlyStorage\u003e(storage: \u0026S, key: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n    let bin_data = storage.get(key);\n\n    match bin_data {\n        None =\u003e Err(StdError::not_found(\"Key not found in storage\")),\n        Some(bin_data) =\u003e Ok(bincode2::deserialize::\u003cT\u003e(\u0026bin_data)\n            .map_err(|e| StdError::serialize_err(type_name::\u003cT\u003e(), e))?),\n    }\n}\n\npub struct Config\u003c'a, S: Storage\u003e {\n    storage: PrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: Storage\u003e Config\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a mut S) -\u003e Self {\n        Self {\n            storage: PrefixedStorage::new(PREFIX_CONFIG, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyConfigImpl\u003cPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyConfigImpl(\u0026self.storage)\n    }\n\n    pub fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        self.as_readonly().constants()\n    }\n\n    pub fn set_constants(\u0026mut self, constants: \u0026Constants) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_CONSTANTS, constants)\n    }\n\n    pub fn total_supply(\u0026self) -\u003e u128 {\n        self.as_readonly().total_supply()\n    }\n\n    pub fn set_total_supply(\u0026mut self, supply: u128) {\n        self.storage.set(KEY_TOTAL_SUPPLY, \u0026supply.to_be_bytes());\n    }\n\n    pub fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        self.as_readonly().contract_status()\n    }\n\n    pub fn set_contract_status(\u0026mut self, status: ContractStatusLevel) {\n        let status_u8 = status_level_to_u8(status);\n        self.storage\n            .set(KEY_CONTRACT_STATUS, \u0026status_u8.to_be_bytes());\n    }\n\n    pub fn set_minters(\u0026mut self, minters_to_set: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_MINTERS, \u0026minters_to_set)\n    }\n\n    pub fn add_minters(\u0026mut self, minters_to_add: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        let mut minters = self.minters();\n        minters.extend(minters_to_add);\n\n        self.set_minters(minters)\n    }\n\n    pub fn remove_minters(\u0026mut self, minters_to_remove: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        let mut minters = self.minters();\n\n        for minter in minters_to_remove {\n            minters.retain(|x| x != \u0026minter);\n        }\n\n        self.set_minters(minters)\n    }\n\n    pub fn minters(\u0026mut self) -\u003e Vec\u003cHumanAddr\u003e {\n        self.as_readonly().minters()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        self.as_readonly().tx_count()\n    }\n\n    pub fn set_tx_count(\u0026mut self, count: u64) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_TX_COUNT, \u0026count)\n    }\n}\n\n/// This struct refactors out the readonly methods that we need for `Config` and `ReadonlyConfig`\n/// in a way that is generic over their mutability.\n///\n/// This was the only way to prevent code duplication of these methods because of the way\n/// that `ReadonlyPrefixedStorage` and `PrefixedStorage` are implemented in `cosmwasm-std`\nstruct ReadonlyConfigImpl\u003c'a, S: ReadonlyStorage\u003e(\u0026'a S);\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyConfigImpl\u003c'a, S\u003e {\n    fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        let consts_bytes = self\n            .0\n            .get(KEY_CONSTANTS)\n            .ok_or_else(|| StdError::generic_err(\"no constants stored in configuration\"))?;\n        bincode2::deserialize::\u003cConstants\u003e(\u0026consts_bytes)\n            .map_err(|e| StdError::serialize_err(type_name::\u003cConstants\u003e(), e))\n    }\n\n    fn total_supply(\u0026self) -\u003e u128 {\n        let supply_bytes = self\n            .0\n            .get(KEY_TOTAL_SUPPLY)\n            .expect(\"no total supply stored in config\");\n        // This unwrap is ok because we know we stored things correctly\n        slice_to_u128(\u0026supply_bytes).unwrap()\n    }\n\n    fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        let supply_bytes = self\n            .0\n            .get(KEY_CONTRACT_STATUS)\n            .expect(\"no contract status stored in config\");\n\n        // These unwraps are ok because we know we stored things correctly\n        let status = slice_to_u8(\u0026supply_bytes).unwrap();\n        u8_to_status_level(status).unwrap()\n    }\n\n    fn minters(\u0026self) -\u003e Vec\u003cHumanAddr\u003e {\n        get_bin_data(self.0, KEY_MINTERS).unwrap()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        get_bin_data(self.0, KEY_TX_COUNT).unwrap_or_default()\n    }\n}\n\n// Balances\n\npub struct ReadonlyBalances\u003c'a, S: ReadonlyStorage\u003e {\n    storage: ReadonlyPrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyBalances\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a S) -\u003e Self {\n        Self {\n            storage: ReadonlyPrefixedStorage::new(PREFIX_BALANCES, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyBalancesImpl\u003cReadonlyPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyBalancesImpl(\u0026self.storage)\n    }\n\n    pub fn account_amount(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        self.as_readonly().account_amount(account)\n    }\n}\n\npub struct Balances\u003c'a, S: Storage\u003e {\n    storage: PrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: Storage\u003e Balances\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a mut S) -\u003e Self {\n        Self {\n            storage: PrefixedStorage::new(PREFIX_BALANCES, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyBalancesImpl\u003cPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyBalancesImpl(\u0026self.storage)\n    }\n\n    pub fn balance(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        self.as_readonly().account_amount(account)\n    }\n\n    pub fn set_account_balance(\u0026mut self, account: \u0026CanonicalAddr, amount: u128) {\n        self.storage.set(account.as_slice(), \u0026amount.to_be_bytes())\n    }\n}\n\n/// This struct refactors out the readonly methods that we need for `Balances` and `ReadonlyBalances`\n/// in a way that is generic over their mutability.\n///\n/// This was the only way to prevent code duplication of these methods because of the way\n/// that `ReadonlyPrefixedStorage` and `PrefixedStorage` are implemented in `cosmwasm-std`\nstruct ReadonlyBalancesImpl\u003c'a, S: ReadonlyStorage\u003e(\u0026'a S);\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyBalancesImpl\u003c'a, S\u003e {\n    pub fn account_amount(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        let account_bytes = account.as_slice();\n        let result = self.0.get(account_bytes);\n        match result {\n            // This unwrap is ok because we know we stored things correctly\n            Some(balance_bytes) =\u003e slice_to_u128(\u0026balance_bytes).unwrap(),\n            None =\u003e 0,\n        }\n    }\n}\n\n// Allowances\n\n#[derive(Serialize, Debug, Deserialize, Clone, PartialEq, Default, JsonSchema)]\npub struct Allowance {\n    pub amount: u128,\n    pub expiration: Option\u003cu64\u003e,\n}\n\npub fn read_allowance\u003cS: Storage\u003e(\n    store: \u0026S,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n) -\u003e StdResult\u003cAllowance\u003e {\n    let owner_store =\n        ReadonlyPrefixedStorage::multilevel(\u0026[PREFIX_ALLOWANCES, owner.as_slice()], store);\n    let owner_store = TypedStore::attach(\u0026owner_store);\n    let allowance = owner_store.may_load(spender.as_slice());\n    allowance.map(Option::unwrap_or_default)\n}\n\npub fn write_allowance\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n    allowance: Allowance,\n) -\u003e StdResult\u003c()\u003e {\n    let mut owner_store =\n        PrefixedStorage::multilevel(\u0026[PREFIX_ALLOWANCES, owner.as_slice()], store);\n    let mut owner_store = TypedStoreMut::attach(\u0026mut owner_store);\n\n    owner_store.store(spender.as_slice(), \u0026allowance)\n}\n\n// Viewing Keys\n\npub fn write_viewing_key\u003cS: Storage\u003e(store: \u0026mut S, owner: \u0026CanonicalAddr, key: \u0026ViewingKey) {\n    let mut balance_store = PrefixedStorage::new(PREFIX_VIEW_KEY, store);\n    balance_store.set(owner.as_slice(), \u0026key.to_hashed());\n}\n\npub fn read_viewing_key\u003cS: Storage\u003e(store: \u0026S, owner: \u0026CanonicalAddr) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n    let balance_store = ReadonlyPrefixedStorage::new(PREFIX_VIEW_KEY, store);\n    balance_store.get(owner.as_slice())\n}\n\n// Receiver Interface\n\npub fn get_receiver_hash\u003cS: ReadonlyStorage\u003e(\n    store: \u0026S,\n    account: \u0026HumanAddr,\n) -\u003e Option\u003cStdResult\u003cString\u003e\u003e {\n    let store = ReadonlyPrefixedStorage::new(PREFIX_RECEIVERS, store);\n    store.get(account.as_str().as_bytes()).map(|data| {\n        String::from_utf8(data)\n            .map_err(|_err| StdError::invalid_utf8(\"stored code hash was not a valid String\"))\n    })\n}\n\npub fn set_receiver_hash\u003cS: Storage\u003e(store: \u0026mut S, account: \u0026HumanAddr, code_hash: String) {\n    let mut store = PrefixedStorage::new(PREFIX_RECEIVERS, store);\n    store.set(account.as_str().as_bytes(), code_hash.as_bytes());\n}\n\n// Helpers\n\n/// Converts 16 bytes value into u128\n/// Errors if data found that is not 16 bytes\nfn slice_to_u128(data: \u0026[u8]) -\u003e StdResult\u003cu128\u003e {\n    match \u003c[u8; 16]\u003e::try_from(data) {\n        Ok(bytes) =\u003e Ok(u128::from_be_bytes(bytes)),\n        Err(_) =\u003e Err(StdError::generic_err(\n            \"Corrupted data found. 16 byte expected.\",\n        )),\n    }\n}\n\n/// Converts 1 byte value into u8\n/// Errors if data found that is not 1 byte\nfn slice_to_u8(data: \u0026[u8]) -\u003e StdResult\u003cu8\u003e {\n    if data.len() == 1 {\n        Ok(data[0])\n    } else {\n        Err(StdError::generic_err(\n            \"Corrupted data found. 1 byte expected.\",\n        ))\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":109},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","src","utils.rs"],"content":"use crate::viewing_key::VIEWING_KEY_SIZE;\nuse sha2::{Digest, Sha256};\nuse std::convert::TryInto;\nuse subtle::ConstantTimeEq;\n\npub fn ct_slice_compare(s1: \u0026[u8], s2: \u0026[u8]) -\u003e bool {\n    bool::from(s1.ct_eq(s2))\n}\n\npub fn create_hashed_password(s1: \u0026str) -\u003e [u8; VIEWING_KEY_SIZE] {\n    Sha256::digest(s1.as_bytes())\n        .as_slice()\n        .try_into()\n        .expect(\"Wrong password length\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","src","viewing_key.rs"],"content":"use std::fmt;\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::Env;\n\nuse crate::rand::{sha_256, Prng};\nuse crate::utils::{create_hashed_password, ct_slice_compare};\n\npub const VIEWING_KEY_SIZE: usize = 32;\npub const VIEWING_KEY_PREFIX: \u0026str = \"api_key_\";\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\npub struct ViewingKey(pub String);\n\nimpl ViewingKey {\n    pub fn check_viewing_key(\u0026self, hashed_pw: \u0026[u8]) -\u003e bool {\n        let mine_hashed = create_hashed_password(\u0026self.0);\n\n        ct_slice_compare(\u0026mine_hashed, hashed_pw)\n    }\n\n    pub fn new(env: \u0026Env, seed: \u0026[u8], entropy: \u0026[u8]) -\u003e Self {\n        // 16 here represents the lengths in bytes of the block height and time.\n        let entropy_len = 16 + env.message.sender.len() + entropy.len();\n        let mut rng_entropy = Vec::with_capacity(entropy_len);\n        rng_entropy.extend_from_slice(\u0026env.block.height.to_be_bytes());\n        rng_entropy.extend_from_slice(\u0026env.block.time.to_be_bytes());\n        rng_entropy.extend_from_slice(\u0026env.message.sender.0.as_bytes());\n        rng_entropy.extend_from_slice(entropy);\n\n        let mut rng = Prng::new(seed, \u0026rng_entropy);\n\n        let rand_slice = rng.rand_bytes();\n\n        let key = sha_256(\u0026rand_slice);\n\n        Self(VIEWING_KEY_PREFIX.to_string() + \u0026base64::encode(key))\n    }\n\n    pub fn to_hashed(\u0026self) -\u003e [u8; VIEWING_KEY_SIZE] {\n        create_hashed_password(\u0026self.0)\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        self.0.as_bytes()\n    }\n}\n\nimpl fmt::Display for ViewingKey {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":20},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","tests","example-receiver","src","contract.rs"],"content":"use cosmwasm_std::{\n    from_binary, to_binary, Api, BankMsg, Binary, Coin, Context, CosmosMsg, Env, Extern,\n    HandleResponse, HumanAddr, InitResponse, Querier, StdError, StdResult, Storage, Uint128,\n    WasmMsg,\n};\n\nuse crate::msg::{CountResponse, HandleMsg, InitMsg, QueryMsg, Snip20Msg};\nuse crate::state::{config, config_read, State};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let state = State {\n        count: msg.count,\n        owner: deps.api.canonical_address(\u0026env.message.sender)?,\n        known_snip_20: vec![],\n    };\n\n    config(\u0026mut deps.storage).save(\u0026state)?;\n\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Increment {} =\u003e try_increment(deps, env),\n        HandleMsg::Reset { count } =\u003e try_reset(deps, env, count),\n        HandleMsg::Register { reg_addr, reg_hash } =\u003e try_register(deps, env, reg_addr, reg_hash),\n        HandleMsg::Receive {\n            sender,\n            from,\n            amount,\n            msg,\n        } =\u003e try_receive(deps, env, sender, from, amount, msg),\n        HandleMsg::Redeem {\n            addr,\n            hash,\n            to,\n            amount,\n        } =\u003e try_redeem(deps, env, addr, hash, to, amount),\n        HandleMsg::Fail {} =\u003e try_fail(),\n    }\n}\n\npub fn try_increment\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut count = 0;\n    config(\u0026mut deps.storage).update(|mut state| {\n        state.count += 1;\n        count = state.count;\n        Ok(state)\n    })?;\n\n    let mut context = Context::new();\n    context.add_log(\"count\", count.to_string());\n\n    Ok(context.into())\n}\n\npub fn try_reset\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    count: i32,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender_address_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n    config(\u0026mut deps.storage).update(|mut state| {\n        if sender_address_raw != state.owner {\n            return Err(StdError::Unauthorized { backtrace: None });\n        }\n        state.count = count;\n        Ok(state)\n    })?;\n    Ok(HandleResponse::default())\n}\n\npub fn try_register\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    reg_addr: HumanAddr,\n    reg_hash: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut conf = config(\u0026mut deps.storage);\n    let mut state = conf.load()?;\n    if !state.known_snip_20.contains(\u0026reg_addr) {\n        state.known_snip_20.push(reg_addr.clone());\n    }\n    conf.save(\u0026state)?;\n\n    let msg = to_binary(\u0026Snip20Msg::register_receive(env.contract_code_hash))?;\n    let message = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: reg_addr,\n        callback_code_hash: reg_hash,\n        msg,\n        send: vec![],\n    });\n\n    Ok(HandleResponse {\n        messages: vec![message],\n        log: vec![],\n        data: None,\n    })\n}\n\npub fn try_receive\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    _sender: HumanAddr,\n    _from: HumanAddr,\n    _amount: Uint128,\n    msg: Binary,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let msg: HandleMsg = from_binary(\u0026msg)?;\n\n    if matches!(msg, HandleMsg::Receive { .. }) {\n        return Err(StdError::generic_err(\n            \"Recursive call to receive() is not allowed\",\n        ));\n    }\n\n    let state = config_read(\u0026deps.storage).load()?;\n    if !state.known_snip_20.contains(\u0026env.message.sender) {\n        return Err(StdError::generic_err(format!(\n            \"{} is not a known SNIP-20 coin that this contract registered to\",\n            env.message.sender\n        )));\n    }\n\n    /* use sender \u0026 amount */\n    handle(deps, env, msg)\n}\n\nfn try_redeem\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    addr: HumanAddr,\n    hash: String,\n    to: HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let state = config_read(\u0026deps.storage).load()?;\n    if !state.known_snip_20.contains(\u0026addr) {\n        return Err(StdError::generic_err(format!(\n            \"{} is not a known SNIP-20 coin that this contract registered to\",\n            addr\n        )));\n    }\n\n    let msg = to_binary(\u0026Snip20Msg::redeem(amount))?;\n    let secret_redeem = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: addr,\n        callback_code_hash: hash,\n        msg,\n        send: vec![],\n    });\n    let redeem = CosmosMsg::Bank(BankMsg::Send {\n        amount: vec![Coin::new(amount.u128(), \"uscrt\")],\n        from_address: env.contract.address,\n        to_address: to,\n    });\n\n    Ok(HandleResponse {\n        messages: vec![secret_redeem, redeem],\n        log: vec![],\n        data: None,\n    })\n}\n\nfn try_fail() -\u003e StdResult\u003cHandleResponse\u003e {\n    Err(StdError::generic_err(\"intentional failure\"))\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::GetCount {} =\u003e to_binary(\u0026query_count(deps)?),\n    }\n}\n\nfn query_count\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cCountResponse\u003e {\n    let state = config_read(\u0026deps.storage).load()?;\n    Ok(CountResponse { count: state.count })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","tests","example-receiver","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\npub mod state;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","tests","example-receiver","src","msg.rs"],"content":"use cosmwasm_std::{Binary, HumanAddr, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n    pub count: i32,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    Increment {},\n    Reset {\n        count: i32,\n    },\n    Register {\n        reg_addr: HumanAddr,\n        reg_hash: String,\n    },\n    Receive {\n        sender: HumanAddr,\n        from: HumanAddr,\n        amount: Uint128,\n        msg: Binary,\n    },\n    Redeem {\n        addr: HumanAddr,\n        hash: String,\n        to: HumanAddr,\n        amount: Uint128,\n    },\n    Fail {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    // GetCount returns the current count as a json-encoded number\n    GetCount {},\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct CountResponse {\n    pub count: i32,\n}\n\n// Messages sent to SNIP-20 contracts\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum Snip20Msg {\n    RegisterReceive {\n        code_hash: String,\n        padding: Option\u003cString\u003e,\n    },\n    Redeem {\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n}\n\nimpl Snip20Msg {\n    pub fn register_receive(code_hash: String) -\u003e Self {\n        Snip20Msg::RegisterReceive {\n            code_hash,\n            padding: None, // TODO add padding calculation\n        }\n    }\n\n    pub fn redeem(amount: Uint128) -\u003e Self {\n        Snip20Msg::Redeem {\n            amount,\n            padding: None, // TODO add padding calculation\n        }\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","tests","example-receiver","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{CanonicalAddr, HumanAddr, Storage};\nuse cosmwasm_storage::{singleton, singleton_read, ReadonlySingleton, Singleton};\n\npub static CONFIG_KEY: \u0026[u8] = b\"config\";\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct State {\n    pub count: i32,\n    pub owner: CanonicalAddr,\n    pub known_snip_20: Vec\u003cHumanAddr\u003e,\n}\n\npub fn config\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, State\u003e {\n    singleton(storage, CONFIG_KEY)\n}\n\npub fn config_read\u003cS: Storage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, State\u003e {\n    singleton_read(storage, CONFIG_KEY)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend","tests","integration.rs"],"content":"#[test]\n#[ignore]\nfn empty_test() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","src","contract.rs"],"content":"/// This contract implements SNIP-20 standard:\n/// https://github.com/SecretFoundation/SNIPs/blob/master/SNIP-20.md\nuse cosmwasm_std::{\n    log, to_binary, Api, BankMsg, Binary, CanonicalAddr, Coin, CosmosMsg, Env, Extern,\n    HandleResponse, HumanAddr, InitResponse, Querier, QueryResult, ReadonlyStorage, StdError,\n    StdResult, Storage, Uint128,\n};\n\nuse crate::msg::{\n    space_pad, ContractStatusLevel, HandleAnswer, HandleMsg, InitMsg, QueryAnswer, QueryMsg,\n    ResponseStatus::Success,\n};\nuse crate::rand::sha_256;\nuse crate::receiver::Snip20ReceiveMsg;\nuse crate::state::{\n    self, get_receiver_hash, get_transfers, read_allowance, read_viewing_key, set_receiver_hash,\n    store_transfer, write_allowance, write_viewing_key, Balances, Config, Constants,\n    ReadonlyBalances, ReadonlyConfig,\n};\nuse crate::viewing_key::{ViewingKey, VIEWING_KEY_SIZE};\n\n/// We make sure that responses from `handle` are padded to a multiple of this size.\npub const RESPONSE_BLOCK_SIZE: usize = 256;\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let init_config = msg.config();\n    let mut total_supply: u128 = 0;\n    {\n        let mut balances = Balances::from_storage(\u0026mut deps.storage);\n        let initial_balances = msg.initial_balances.unwrap_or_default();\n        for balance in initial_balances {\n            let balance_address = deps.api.canonical_address(\u0026balance.address)?;\n            let amount = balance.amount.u128();\n            balances.set_account_balance(\u0026balance_address, amount);\n            if let Some(new_total_supply) = total_supply.checked_add(amount) {\n                total_supply = new_total_supply;\n            } else {\n                return Err(StdError::generic_err(\n                    \"The sum of all initial balances exceeds the maximum possible total supply\",\n                ));\n            }\n        }\n    }\n\n    // Check name, symbol, decimals\n    if !is_valid_name(\u0026msg.name) {\n        return Err(StdError::generic_err(\n            \"Name is not in the expected format (3-30 UTF-8 bytes)\",\n        ));\n    }\n    if !is_valid_symbol(\u0026msg.symbol) {\n        return Err(StdError::generic_err(\n            \"Ticker symbol is not in expected format [A-Z]{3,6}\",\n        ));\n    }\n    if msg.decimals \u003e 18 {\n        return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n    }\n\n    let admin = msg.admin.unwrap_or(env.message.sender);\n\n    let prng_seed_hashed = sha_256(\u0026msg.prng_seed.0);\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    config.set_constants(\u0026Constants {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n        admin: admin.clone(),\n        prng_seed: prng_seed_hashed.to_vec(),\n        total_supply_is_public: init_config.public_total_supply(),\n        deposit_is_enabled: init_config.deposit_enabled(),\n        redeem_is_enabled: init_config.redeem_enabled(),\n        mint_is_enabled: init_config.mint_enabled(),\n        burn_is_enabled: init_config.burn_enabled(),\n    })?;\n    config.set_total_supply(total_supply);\n    config.set_contract_status(ContractStatusLevel::NormalRun);\n    let minters = if init_config.mint_enabled() {\n        Vec::from([admin])\n    } else {\n        Vec::new()\n    };\n    config.set_minters(minters)?;\n\n    Ok(InitResponse::default())\n}\n\nfn pad_response(response: StdResult\u003cHandleResponse\u003e) -\u003e StdResult\u003cHandleResponse\u003e {\n    response.map(|mut response| {\n        response.data = response.data.map(|mut data| {\n            space_pad(RESPONSE_BLOCK_SIZE, \u0026mut data.0);\n            data\n        });\n        response\n    })\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let contract_status = ReadonlyConfig::from_storage(\u0026deps.storage).contract_status();\n\n    match contract_status {\n        ContractStatusLevel::StopAll | ContractStatusLevel::StopAllButRedeems =\u003e {\n            let response = match msg {\n                HandleMsg::SetContractStatus { level, .. } =\u003e set_contract_status(deps, env, level),\n                HandleMsg::Redeem { amount, .. }\n                    if contract_status == ContractStatusLevel::StopAllButRedeems =\u003e\n                {\n                    try_redeem(deps, env, amount)\n                }\n                _ =\u003e Err(StdError::generic_err(\n                    \"This contract is stopped and this action is not allowed\",\n                )),\n            };\n            return pad_response(response);\n        }\n        ContractStatusLevel::NormalRun =\u003e {} // If it's a normal run just continue\n    }\n\n    let response = match msg {\n        // Native\n        HandleMsg::Deposit { .. } =\u003e try_deposit(deps, env),\n        HandleMsg::Redeem { amount, .. } =\u003e try_redeem(deps, env, amount),\n\n        // Base\n        HandleMsg::Transfer {\n            recipient, amount, ..\n        } =\u003e try_transfer(deps, env, \u0026recipient, amount),\n        HandleMsg::Send {\n            recipient,\n            amount,\n            msg,\n            ..\n        } =\u003e try_send(deps, env, \u0026recipient, amount, msg),\n        HandleMsg::Burn { amount, .. } =\u003e try_burn(deps, env, amount),\n        HandleMsg::RegisterReceive { code_hash, .. } =\u003e try_register_receive(deps, env, code_hash),\n        HandleMsg::CreateViewingKey { entropy, .. } =\u003e try_create_key(deps, env, entropy),\n        HandleMsg::SetViewingKey { key, .. } =\u003e try_set_key(deps, env, key),\n\n        // Allowance\n        HandleMsg::IncreaseAllowance {\n            spender,\n            amount,\n            expiration,\n            ..\n        } =\u003e try_increase_allowance(deps, env, spender, amount, expiration),\n        HandleMsg::DecreaseAllowance {\n            spender,\n            amount,\n            expiration,\n            ..\n        } =\u003e try_decrease_allowance(deps, env, spender, amount, expiration),\n        HandleMsg::TransferFrom {\n            owner,\n            recipient,\n            amount,\n            ..\n        } =\u003e try_transfer_from(deps, env, \u0026owner, \u0026recipient, amount),\n        HandleMsg::SendFrom {\n            owner,\n            recipient,\n            amount,\n            msg,\n            ..\n        } =\u003e try_send_from(deps, env, \u0026owner, \u0026recipient, amount, msg),\n        HandleMsg::BurnFrom { owner, amount, .. } =\u003e try_burn_from(deps, env, \u0026owner, amount),\n\n        // Mint\n        HandleMsg::Mint {\n            recipient, amount, ..\n        } =\u003e try_mint(deps, env, recipient, amount),\n\n        // Other\n        HandleMsg::ChangeAdmin { address, .. } =\u003e change_admin(deps, env, address),\n        HandleMsg::SetContractStatus { level, .. } =\u003e set_contract_status(deps, env, level),\n        HandleMsg::AddMinters { minters, .. } =\u003e add_minters(deps, env, minters),\n        HandleMsg::RemoveMinters { minters, .. } =\u003e remove_minters(deps, env, minters),\n        HandleMsg::SetMinters { minters, .. } =\u003e set_minters(deps, env, minters),\n    };\n\n    pad_response(response)\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e, msg: QueryMsg) -\u003e QueryResult {\n    match msg {\n        QueryMsg::TokenInfo {} =\u003e query_token_info(\u0026deps.storage),\n        QueryMsg::TokenConfig {} =\u003e query_token_config(\u0026deps.storage),\n        QueryMsg::ExchangeRate {} =\u003e query_exchange_rate(\u0026deps.storage),\n        QueryMsg::Minters { .. } =\u003e query_minters(deps),\n        QueryMsg::LastUserIndex { account } =\u003e query_get_user_index(\u0026account, \u0026deps),\n        QueryMsg::InterestedRedirectionAddress { account } =\u003e {\n            query_get_interested_redirection_address(\u0026account, \u0026deps)\n        }\n        QueryMsg::RedirectedBalance { account } =\u003e query_get_redirected_balance(\u0026account, \u0026deps),\n        _ =\u003e authenticated_queries(deps, msg),\n    }\n}\n\npub fn authenticated_queries\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e QueryResult {\n    let (addresses, key) = msg.get_validation_params();\n\n    for address in addresses {\n        let canonical_addr = deps.api.canonical_address(address)?;\n\n        let expected_key = read_viewing_key(\u0026deps.storage, \u0026canonical_addr);\n\n        if expected_key.is_none() {\n            // Checking the key will take significant time. We don't want to exit immediately if it isn't set\n            // in a way which will allow to time the command and determine if a viewing key doesn't exist\n            key.check_viewing_key(\u0026[0u8; VIEWING_KEY_SIZE]);\n        } else if key.check_viewing_key(expected_key.unwrap().as_slice()) {\n            return match msg {\n                // Base\n                QueryMsg::Balance { address, .. } =\u003e query_balance(\u0026deps, \u0026address),\n                QueryMsg::PrincpleBalanceOf { address } =\u003e {\n                    query_principal_balance_of(\u0026deps, \u0026address)\n                }\n                QueryMsg::TransferHistory {\n                    address,\n                    page,\n                    page_size,\n                    ..\n                } =\u003e query_transactions(\u0026deps, \u0026address, page.unwrap_or(0), page_size),\n                QueryMsg::Allowance { owner, spender, .. } =\u003e {\n                    try_check_allowance(deps, owner, spender)\n                }\n                _ =\u003e panic!(\"This query type does not require authentication\"),\n            };\n        }\n    }\n\n    Ok(to_binary(\u0026QueryAnswer::ViewingKeyError {\n        msg: \"Wrong viewing key for this address or viewing key not set\".to_string(),\n    })?)\n}\n\nfn query_exchange_rate\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n    let constants = config.constants()?;\n\n    if constants.deposit_is_enabled || constants.redeem_is_enabled {\n        let rate: Uint128;\n        let denom: String;\n        // if token has more decimals than SCRT, you get magnitudes of SCRT per token\n        if constants.decimals \u003e= 6 {\n            rate = Uint128(10u128.pow(constants.decimals as u32 - 6));\n            denom = \"SCRT\".to_string();\n        // if token has less decimals, you get magnitudes token for SCRT\n        } else {\n            rate = Uint128(10u128.pow(6 - constants.decimals as u32));\n            denom = constants.symbol;\n        }\n        return to_binary(\u0026QueryAnswer::ExchangeRate { rate, denom });\n    }\n    to_binary(\u0026QueryAnswer::ExchangeRate {\n        rate: Uint128(0),\n        denom: String::new(),\n    })\n}\n\nfn query_token_info\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n    let constants = config.constants()?;\n\n    let total_supply = if constants.total_supply_is_public {\n        Some(Uint128(config.total_supply()))\n    } else {\n        None\n    };\n\n    to_binary(\u0026QueryAnswer::TokenInfo {\n        name: constants.name,\n        symbol: constants.symbol,\n        decimals: constants.decimals,\n        total_supply,\n    })\n}\n\nfn query_token_config\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n    let constants = config.constants()?;\n\n    to_binary(\u0026QueryAnswer::TokenConfig {\n        public_total_supply: constants.total_supply_is_public,\n        deposit_enabled: constants.deposit_is_enabled,\n        redeem_enabled: constants.redeem_is_enabled,\n        mint_enabled: constants.mint_is_enabled,\n        burn_enabled: constants.burn_is_enabled,\n    })\n}\n\npub fn query_get_user_index\u003cS: Storage, A: Api, Q: Querier\u003e(\n    account: \u0026HumanAddr,\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e QueryResult {\n    match state::get_user_index(\u0026deps.storage, account) {\n        Some(result) =\u003e Ok(result),\n        None =\u003e {\n            return Err(StdError::generic_err(\n                \"Сouldn't find last index of the user\",\n            ));\n        }\n    }\n}\n\npub fn query_get_interested_redirection_address\u003cS: Storage, A: Api, Q: Querier\u003e(\n    account: \u0026HumanAddr,\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e QueryResult {\n    match state::get_interested_redirection_address(\u0026deps.storage, account) {\n        Some(result) =\u003e Ok(result),\n        None =\u003e {\n            let zero_bin = [0_u8];\n            Ok(Binary::from(zero_bin))\n        }\n    }\n}\n\npub fn query_get_redirected_balance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    account: \u0026HumanAddr,\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e QueryResult {\n    match state::get_redirection_balance(\u0026deps.storage, account) {\n        Some(result) =\u003e Ok(result),\n        None =\u003e {\n            return Err(StdError::generic_err(\n                \"Couldn't find the total redirected balance\",\n            ));\n        }\n    }\n}\npub fn query_principal_balance_of\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n) -\u003e QueryResult {\n    query_balance(deps, account)\n}\npub fn query_transactions\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n    page: u32,\n    page_size: u32,\n) -\u003e StdResult\u003cBinary\u003e {\n    let address = deps.api.canonical_address(account).unwrap();\n    let (txs, total) = get_transfers(\u0026deps.api, \u0026deps.storage, \u0026address, page, page_size)?;\n\n    let result = QueryAnswer::TransferHistory {\n        txs,\n        total: Some(total),\n    };\n    to_binary(\u0026result)\n}\n\npub fn query_balance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n) -\u003e StdResult\u003cBinary\u003e {\n    let address = deps.api.canonical_address(account)?;\n\n    let amount = Uint128(ReadonlyBalances::from_storage(\u0026deps.storage).account_amount(\u0026address));\n    let response = QueryAnswer::Balance { amount };\n    to_binary(\u0026response)\n}\n\nfn query_minters\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cBinary\u003e {\n    let minters = ReadonlyConfig::from_storage(\u0026deps.storage).minters();\n\n    let response = QueryAnswer::Minters { minters };\n    to_binary(\u0026response)\n}\n\nfn change_admin\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    address: HumanAddr,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    let mut consts = config.constants()?;\n    consts.admin = address;\n    config.set_constants(\u0026consts)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::ChangeAdmin { status: Success })?),\n    })\n}\n\nfn try_mint\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    address: HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    let minters = config.minters();\n    if !minters.contains(\u0026env.message.sender) {\n        return Err(StdError::generic_err(\n            \"Minting is allowed to minter accounts only\",\n        ));\n    }\n\n    let amount = amount.u128();\n\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_add(amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"This mint attempt would increase the total supply above the supported maximum\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    let receipient_account = \u0026deps.api.canonical_address(\u0026address)?;\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n\n    let mut account_balance = balances.balance(receipient_account);\n\n    if let Some(new_balance) = account_balance.checked_add(amount) {\n        account_balance = new_balance;\n    } else {\n        // This error literally can not happen, since the account's funds are a subset\n        // of the total supply, both are stored as u128, and we check for overflow of\n        // the total supply just a couple lines before.\n        // Still, writing this to cover all overflows.\n        return Err(StdError::generic_err(\n            \"This mint attempt would increase the account's balance above the supported maximum\",\n        ));\n    }\n\n    balances.set_account_balance(receipient_account, account_balance);\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Mint { status: Success })?),\n    };\n\n    Ok(res)\n}\n\npub fn try_set_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    key: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let vk = ViewingKey(key);\n\n    let message_sender = deps.api.canonical_address(\u0026env.message.sender)?;\n    write_viewing_key(\u0026mut deps.storage, \u0026message_sender, \u0026vk);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetViewingKey { status: Success })?),\n    })\n}\n\npub fn try_create_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    entropy: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let constants = ReadonlyConfig::from_storage(\u0026deps.storage).constants()?;\n    let prng_seed = constants.prng_seed;\n\n    let key = ViewingKey::new(\u0026env, \u0026prng_seed, (\u0026entropy).as_ref());\n\n    let message_sender = deps.api.canonical_address(\u0026env.message.sender)?;\n    write_viewing_key(\u0026mut deps.storage, \u0026message_sender, \u0026key);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::CreateViewingKey { key })?),\n    })\n}\n\nfn set_contract_status\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    status_level: ContractStatusLevel,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.set_contract_status(status_level);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetContractStatus {\n            status: Success,\n        })?),\n    })\n}\n\npub fn try_check_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    owner: HumanAddr,\n    spender: HumanAddr,\n) -\u003e StdResult\u003cBinary\u003e {\n    let owner_address = deps.api.canonical_address(\u0026owner)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n\n    let response = QueryAnswer::Allowance {\n        owner,\n        spender,\n        allowance: Uint128(allowance.amount),\n        expiration: allowance.expiration,\n    };\n    to_binary(\u0026response)\n}\n\nfn try_deposit\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut amount = Uint128::zero();\n\n    for coin in \u0026env.message.sent_funds {\n        if coin.denom == \"uscrt\" {\n            amount = coin.amount\n        }\n    }\n\n    if amount.is_zero() {\n        return Err(StdError::generic_err(\"No funds were sent to be deposited\"));\n    }\n\n    let amount = amount.u128();\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.deposit_is_enabled {\n        return Err(StdError::generic_err(\n            \"Deposit functionality is not enabled for this token.\",\n        ));\n    }\n    let total_supply = config.total_supply();\n    if let Some(total_supply) = total_supply.checked_add(amount) {\n        config.set_total_supply(total_supply);\n    } else {\n        return Err(StdError::generic_err(\n            \"This deposit would overflow the currency's total supply\",\n        ));\n    }\n\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let account_balance = balances.balance(\u0026sender_address);\n    if let Some(account_balance) = account_balance.checked_add(amount) {\n        balances.set_account_balance(\u0026sender_address, account_balance);\n    } else {\n        return Err(StdError::generic_err(\n            \"This deposit would overflow your balance\",\n        ));\n    }\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Deposit { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_redeem\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n    let constants = config.constants()?;\n    if !constants.redeem_is_enabled {\n        return Err(StdError::generic_err(\n            \"Redeem functionality is not enabled for this token.\",\n        ));\n    }\n\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let amount_raw = amount.u128();\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let account_balance = balances.balance(\u0026sender_address);\n\n    if let Some(account_balance) = account_balance.checked_sub(amount_raw) {\n        balances.set_account_balance(\u0026sender_address, account_balance);\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to redeem: balance={}, required={}\",\n            account_balance, amount_raw\n        )));\n    }\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let total_supply = config.total_supply();\n    if let Some(total_supply) = total_supply.checked_sub(amount_raw) {\n        config.set_total_supply(total_supply);\n    } else {\n        return Err(StdError::generic_err(\n            \"You are tyring to redeem more tokens than what is available in the total supply\",\n        ));\n    }\n\n    let token_reserve = deps\n        .querier\n        .query_balance(\u0026env.contract.address, \"uscrt\")?\n        .amount;\n    if amount \u003e token_reserve {\n        return Err(StdError::generic_err(\n            \"You are trying to redeem for more SCRT than the token has in its deposit reserve.\",\n        ));\n    }\n\n    let withdrawal_coins: Vec\u003cCoin\u003e = vec![Coin {\n        denom: \"uscrt\".to_string(),\n        amount,\n    }];\n\n    let res = HandleResponse {\n        messages: vec![CosmosMsg::Bank(BankMsg::Send {\n            from_address: env.contract.address,\n            to_address: env.message.sender,\n            amount: withdrawal_coins,\n        })],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Redeem { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_transfer_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let recipient_address = deps.api.canonical_address(recipient)?;\n\n    perform_transfer(\n        \u0026mut deps.storage,\n        \u0026sender_address,\n        \u0026recipient_address,\n        amount.u128(),\n    )?;\n\n    let symbol = Config::from_storage(\u0026mut deps.storage).constants()?.symbol;\n\n    store_transfer(\n        \u0026mut deps.storage,\n        \u0026sender_address,\n        \u0026sender_address,\n        \u0026recipient_address,\n        amount,\n        symbol,\n        env.block,\n    )?;\n\n    Ok(())\n}\n\nfn try_transfer\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    try_transfer_impl(deps, env, recipient, amount)?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Transfer { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_add_receiver_api_callback\u003cS: ReadonlyStorage\u003e(\n    messages: \u0026mut Vec\u003cCosmosMsg\u003e,\n    storage: \u0026S,\n    recipient: \u0026HumanAddr,\n    msg: Option\u003cBinary\u003e,\n    sender: HumanAddr,\n    from: HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let receiver_hash = get_receiver_hash(storage, recipient);\n    if let Some(receiver_hash) = receiver_hash {\n        let receiver_hash = receiver_hash?;\n        let receiver_msg = Snip20ReceiveMsg::new(sender, from, amount, msg);\n        let callback_msg = receiver_msg.into_cosmos_msg(receiver_hash, recipient.clone())?;\n\n        messages.push(callback_msg);\n    }\n    Ok(())\n}\n\nfn try_send\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n    msg: Option\u003cBinary\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender = env.message.sender.clone();\n    try_transfer_impl(deps, env, recipient, amount)?;\n\n    let mut messages = vec![];\n\n    try_add_receiver_api_callback(\n        \u0026mut messages,\n        \u0026deps.storage,\n        recipient,\n        msg,\n        sender.clone(),\n        sender,\n        amount,\n    )?;\n\n    let res = HandleResponse {\n        messages,\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Send { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_register_receive\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    code_hash: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    set_receiver_hash(\u0026mut deps.storage, \u0026env.message.sender, code_hash);\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![log(\"register_status\", \"success\")],\n        data: Some(to_binary(\u0026HandleAnswer::RegisterReceive {\n            status: Success,\n        })?),\n    };\n    Ok(res)\n}\n\nfn insufficient_allowance(allowance: u128, required: u128) -\u003e StdError {\n    StdError::generic_err(format!(\n        \"insufficient allowance: allowance={}, required={}\",\n        allowance, required\n    ))\n}\n\nfn try_transfer_from_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let spender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let owner_address = deps.api.canonical_address(owner)?;\n    let recipient_address = deps.api.canonical_address(recipient)?;\n    let amount_raw = amount.u128();\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n\n    if allowance.expiration.map(|ex| ex \u003c env.block.time) == Some(true) {\n        allowance.amount = 0;\n        write_allowance(\n            \u0026mut deps.storage,\n            \u0026owner_address,\n            \u0026spender_address,\n            allowance,\n        )?;\n        return Err(insufficient_allowance(0, amount_raw));\n    }\n\n    if let Some(new_allowance) = allowance.amount.checked_sub(amount_raw) {\n        allowance.amount = new_allowance;\n    } else {\n        return Err(insufficient_allowance(allowance.amount, amount_raw));\n    }\n\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n    perform_transfer(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026recipient_address,\n        amount_raw,\n    )?;\n\n    let symbol = Config::from_storage(\u0026mut deps.storage).constants()?.symbol;\n\n    store_transfer(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        \u0026recipient_address,\n        amount,\n        symbol,\n        env.block,\n    )?;\n\n    Ok(())\n}\n\nfn try_transfer_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    try_transfer_from_impl(deps, env, owner, recipient, amount)?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::TransferFrom { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_send_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n    msg: Option\u003cBinary\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender = env.message.sender.clone();\n    try_transfer_from_impl(deps, env, owner, recipient, amount)?;\n\n    let mut messages = vec![];\n\n    try_add_receiver_api_callback(\n        \u0026mut messages,\n        \u0026deps.storage,\n        recipient,\n        msg,\n        sender,\n        owner.clone(),\n        amount,\n    )?;\n\n    let res = HandleResponse {\n        messages,\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SendFrom { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_burn_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n    let constants = config.constants()?;\n    if !constants.burn_is_enabled {\n        return Err(StdError::generic_err(\n            \"Burn functionality is not enabled for this token.\",\n        ));\n    }\n\n    let spender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let owner_address = deps.api.canonical_address(owner)?;\n    let amount = amount.u128();\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n\n    if allowance.expiration.map(|ex| ex \u003c env.block.time) == Some(true) {\n        allowance.amount = 0;\n        write_allowance(\n            \u0026mut deps.storage,\n            \u0026owner_address,\n            \u0026spender_address,\n            allowance,\n        )?;\n        return Err(insufficient_allowance(0, amount));\n    }\n\n    if let Some(new_allowance) = allowance.amount.checked_sub(amount) {\n        allowance.amount = new_allowance;\n    } else {\n        return Err(insufficient_allowance(allowance.amount, amount));\n    }\n\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    // subtract from owner account\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let mut account_balance = balances.balance(\u0026owner_address);\n\n    if let Some(new_balance) = account_balance.checked_sub(amount) {\n        account_balance = new_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to burn: balance={}, required={}\",\n            account_balance, amount\n        )));\n    }\n    balances.set_account_balance(\u0026owner_address, account_balance);\n\n    // remove from supply\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_sub(amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"You're trying to burn more than is available in the total supply\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::BurnFrom { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_increase_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    spender: HumanAddr,\n    amount: Uint128,\n    expiration: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let owner_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n    allowance.amount = allowance.amount.saturating_add(amount.u128());\n    if expiration.is_some() {\n        allowance.expiration = expiration;\n    }\n    let new_amount = allowance.amount;\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::IncreaseAllowance {\n            owner: env.message.sender,\n            spender,\n            allowance: Uint128(new_amount),\n        })?),\n    };\n    Ok(res)\n}\n\nfn try_decrease_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    spender: HumanAddr,\n    amount: Uint128,\n    expiration: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let owner_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n    allowance.amount = allowance.amount.saturating_sub(amount.u128());\n    if expiration.is_some() {\n        allowance.expiration = expiration;\n    }\n    let new_amount = allowance.amount;\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::DecreaseAllowance {\n            owner: env.message.sender,\n            spender,\n            allowance: Uint128(new_amount),\n        })?),\n    };\n    Ok(res)\n}\n\nfn add_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_add: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.add_minters(minters_to_add)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::AddMinters { status: Success })?),\n    })\n}\n\nfn remove_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_remove: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.remove_minters(minters_to_remove)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::RemoveMinters { status: Success })?),\n    })\n}\n\nfn set_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_set: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let constants = config.constants()?;\n    if !constants.mint_is_enabled {\n        return Err(StdError::generic_err(\n            \"Mint functionality is not enabled for this token.\",\n        ));\n    }\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.set_minters(minters_to_set)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetMinters { status: Success })?),\n    })\n}\n\n/// Burn tokens\n///\n/// Remove `amount` tokens from the system irreversibly, from signer account\n///\n/// @param amount the amount of money to burn\nfn try_burn\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n    let constants = config.constants()?;\n    if !constants.burn_is_enabled {\n        return Err(StdError::generic_err(\n            \"Burn functionality is not enabled for this token.\",\n        ));\n    }\n\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let amount = amount.u128();\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let mut account_balance = balances.balance(\u0026sender_address);\n\n    if let Some(new_account_balance) = account_balance.checked_sub(amount) {\n        account_balance = new_account_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to burn: balance={}, required={}\",\n            account_balance, amount\n        )));\n    }\n\n    balances.set_account_balance(\u0026sender_address, account_balance);\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_sub(amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"You're trying to burn more than is available in the total supply\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Burn { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn perform_transfer\u003cT: Storage\u003e(\n    store: \u0026mut T,\n    from: \u0026CanonicalAddr,\n    to: \u0026CanonicalAddr,\n    amount: u128,\n) -\u003e StdResult\u003c()\u003e {\n    let mut balances = Balances::from_storage(store);\n\n    let mut from_balance = balances.balance(from);\n    if let Some(new_from_balance) = from_balance.checked_sub(amount) {\n        from_balance = new_from_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds: balance={}, required={}\",\n            from_balance, amount\n        )));\n    }\n    balances.set_account_balance(from, from_balance);\n\n    let mut to_balance = balances.balance(to);\n    to_balance = to_balance.checked_add(amount).ok_or_else(|| {\n        StdError::generic_err(\"This tx will literally make them too rich. Try transferring less\")\n    })?;\n    balances.set_account_balance(to, to_balance);\n\n    Ok(())\n}\n\nfn is_admin\u003cS: Storage\u003e(config: \u0026Config\u003cS\u003e, account: \u0026HumanAddr) -\u003e StdResult\u003cbool\u003e {\n    let consts = config.constants()?;\n    if \u0026consts.admin != account {\n        return Ok(false);\n    }\n\n    Ok(true)\n}\n\nfn check_if_admin\u003cS: Storage\u003e(config: \u0026Config\u003cS\u003e, account: \u0026HumanAddr) -\u003e StdResult\u003c()\u003e {\n    if !is_admin(config, account)? {\n        return Err(StdError::generic_err(\n            \"This is an admin command. Admin commands can only be run from admin address\",\n        ));\n    }\n\n    Ok(())\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let len = name.len();\n    (3..=30).contains(\u0026len)\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let len = symbol.len();\n    let len_is_valid = (3..=6).contains(\u0026len);\n\n    len_is_valid \u0026\u0026 symbol.bytes().all(|byte| (b'A'..=b'Z').contains(\u0026byte))\n}\n\n// pub fn migrate\u003cS: Storage, A: Api, Q: Querier\u003e(\n//     _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n//     _env: Env,\n//     _msg: MigrateMsg,\n// ) -\u003e StdResult\u003cMigrateResponse\u003e {\n//     Ok(MigrateResponse::default())\n// }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::msg::ResponseStatus;\n    use crate::msg::{InitConfig, InitialBalance};\n    use cosmwasm_std::testing::*;\n    use cosmwasm_std::{from_binary, BlockInfo, ContractInfo, MessageInfo, QueryResponse, WasmMsg};\n    use std::any::Any;\n\n    // Helper functions\n\n    fn init_helper(\n        initial_balances: Vec\u003cInitialBalance\u003e,\n    ) -\u003e (\n        StdResult\u003cInitResponse\u003e,\n        Extern\u003cMockStorage, MockApi, MockQuerier\u003e,\n    ) {\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n\n        let init_msg = InitMsg {\n            name: \"sec-sec\".to_string(),\n            admin: Some(HumanAddr(\"admin\".to_string())),\n            symbol: \"SECSEC\".to_string(),\n            decimals: 8,\n            initial_balances: Some(initial_balances),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: None,\n        };\n\n        (init(\u0026mut deps, env, init_msg), deps)\n    }\n\n    fn init_helper_with_config(\n        initial_balances: Vec\u003cInitialBalance\u003e,\n        enable_deposit: bool,\n        enable_redeem: bool,\n        enable_mint: bool,\n        enable_burn: bool,\n        contract_bal: u128,\n    ) -\u003e (\n        StdResult\u003cInitResponse\u003e,\n        Extern\u003cMockStorage, MockApi, MockQuerier\u003e,\n    ) {\n        let mut deps = mock_dependencies(\n            20,\n            \u0026[Coin {\n                denom: \"uscrt\".to_string(),\n                amount: Uint128(contract_bal),\n            }],\n        );\n\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":false,\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                enable_deposit, enable_redeem, enable_mint, enable_burn\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: \"sec-sec\".to_string(),\n            admin: Some(HumanAddr(\"admin\".to_string())),\n            symbol: \"SECSEC\".to_string(),\n            decimals: 8,\n            initial_balances: Some(initial_balances),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n\n        (init(\u0026mut deps, env, init_msg), deps)\n    }\n\n    /// Will return a ViewingKey only for the first account in `initial_balances`\n    fn _auth_query_helper(\n        initial_balances: Vec\u003cInitialBalance\u003e,\n    ) -\u003e (ViewingKey, Extern\u003cMockStorage, MockApi, MockQuerier\u003e) {\n        let (init_result, mut deps) = init_helper(initial_balances.clone());\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let account = initial_balances[0].address.clone();\n        let create_vk_msg = HandleMsg::CreateViewingKey {\n            entropy: \"42\".to_string(),\n            padding: None,\n        };\n        let handle_response = handle(\u0026mut deps, mock_env(account.0, \u0026[]), create_vk_msg).unwrap();\n        let vk = match from_binary(\u0026handle_response.data.unwrap()).unwrap() {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"Unexpected result from handle\"),\n        };\n\n        (vk, deps)\n    }\n\n    fn extract_error_msg\u003cT: Any\u003e(error: StdResult\u003cT\u003e) -\u003e String {\n        match error {\n            Ok(response) =\u003e {\n                let bin_err = (\u0026response as \u0026dyn Any)\n                    .downcast_ref::\u003cQueryResponse\u003e()\n                    .expect(\"An error was expected, but no error could be extracted\");\n                match from_binary(bin_err).unwrap() {\n                    QueryAnswer::ViewingKeyError { msg } =\u003e msg,\n                    _ =\u003e panic!(\"Unexpected query answer\"),\n                }\n            }\n            Err(err) =\u003e match err {\n                StdError::GenericErr { msg, .. } =\u003e msg,\n                _ =\u003e panic!(\"Unexpected result from init\"),\n            },\n        }\n    }\n\n    fn ensure_success(handle_result: HandleResponse) -\u003e bool {\n        let handle_result: HandleAnswer = from_binary(\u0026handle_result.data.unwrap()).unwrap();\n\n        match handle_result {\n            HandleAnswer::Deposit { status }\n            | HandleAnswer::Redeem { status }\n            | HandleAnswer::Transfer { status }\n            | HandleAnswer::Send { status }\n            | HandleAnswer::Burn { status }\n            | HandleAnswer::RegisterReceive { status }\n            | HandleAnswer::SetViewingKey { status }\n            | HandleAnswer::TransferFrom { status }\n            | HandleAnswer::SendFrom { status }\n            | HandleAnswer::BurnFrom { status }\n            | HandleAnswer::Mint { status }\n            | HandleAnswer::ChangeAdmin { status }\n            | HandleAnswer::SetContractStatus { status }\n            | HandleAnswer::SetMinters { status }\n            | HandleAnswer::AddMinters { status }\n            | HandleAnswer::RemoveMinters { status } =\u003e {\n                matches!(status, ResponseStatus::Success { .. })\n            }\n            _ =\u003e panic!(\"HandleAnswer not supported for success extraction\"),\n        }\n    }\n\n    // Init tests\n\n    #[test]\n    fn test_init_sanity() {\n        let (init_result, deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert_eq!(init_result.unwrap(), InitResponse::default());\n\n        let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n        let constants = config.constants().unwrap();\n        assert_eq!(config.total_supply(), 5000);\n        assert_eq!(config.contract_status(), ContractStatusLevel::NormalRun);\n        assert_eq!(constants.name, \"sec-sec\".to_string());\n        assert_eq!(constants.admin, HumanAddr(\"admin\".to_string()));\n        assert_eq!(constants.symbol, \"SECSEC\".to_string());\n        assert_eq!(constants.decimals, 8);\n        assert_eq!(\n            constants.prng_seed,\n            sha_256(\"lolz fun yay\".to_owned().as_bytes())\n        );\n        assert_eq!(constants.total_supply_is_public, false);\n    }\n\n    #[test]\n    fn test_init_with_config_sanity() {\n        let (init_result, deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            true,\n            true,\n            true,\n            true,\n            0,\n        );\n        assert_eq!(init_result.unwrap(), InitResponse::default());\n\n        let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n        let constants = config.constants().unwrap();\n        assert_eq!(config.total_supply(), 5000);\n        assert_eq!(config.contract_status(), ContractStatusLevel::NormalRun);\n        assert_eq!(constants.name, \"sec-sec\".to_string());\n        assert_eq!(constants.admin, HumanAddr(\"admin\".to_string()));\n        assert_eq!(constants.symbol, \"SECSEC\".to_string());\n        assert_eq!(constants.decimals, 8);\n        assert_eq!(\n            constants.prng_seed,\n            sha_256(\"lolz fun yay\".to_owned().as_bytes())\n        );\n        assert_eq!(constants.total_supply_is_public, false);\n        assert_eq!(constants.deposit_is_enabled, true);\n        assert_eq!(constants.redeem_is_enabled, true);\n        assert_eq!(constants.mint_is_enabled, true);\n        assert_eq!(constants.burn_is_enabled, true);\n    }\n\n    #[test]\n    fn test_total_supply_overflow() {\n        let (init_result, _deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(u128::max_value()),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result, _deps) = init_helper(vec![\n            InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(u128::max_value()),\n            },\n            InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: Uint128(1),\n            },\n        ]);\n        let error = extract_error_msg(init_result);\n        assert_eq!(\n            error,\n            \"The sum of all initial balances exceeds the maximum possible total supply\"\n        );\n    }\n\n    // Handle tests\n\n    #[test]\n    fn test_handle_transfer() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n        let balances = ReadonlyBalances::from_storage(\u0026deps.storage);\n        assert_eq!(5000 - 1000, balances.account_amount(\u0026bob_canonical));\n        assert_eq!(1000, balances.account_amount(\u0026alice_canonical));\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(10000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient funds\"));\n    }\n\n    #[test]\n    fn test_handle_send() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let handle_msg = HandleMsg::Send {\n            recipient: HumanAddr(\"contract\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n            msg: Some(to_binary(\"hey hey you you\").unwrap()),\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result.clone()));\n        assert!(result.messages.contains(\u0026CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: HumanAddr(\"contract\".to_string()),\n            callback_code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            msg: Snip20ReceiveMsg::new(\n                HumanAddr(\"bob\".to_string()),\n                HumanAddr(\"bob\".to_string()),\n                Uint128(100),\n                Some(to_binary(\"hey hey you you\").unwrap())\n            )\n            .into_binary()\n            .unwrap(),\n            send: vec![]\n        })));\n    }\n\n    #[test]\n    fn test_handle_register_receive() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let hash = get_receiver_hash(\u0026deps.storage, \u0026HumanAddr(\"contract\".to_string()))\n            .unwrap()\n            .unwrap();\n        assert_eq!(hash, \"this_is_a_hash_of_a_code\".to_string());\n    }\n\n    #[test]\n    fn test_handle_create_viewing_key() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::CreateViewingKey {\n            entropy: \"\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let answer: HandleAnswer = from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n\n        let key = match answer {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"NOPE\"),\n        };\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let saved_vk = read_viewing_key(\u0026deps.storage, \u0026bob_canonical).unwrap();\n        assert!(key.check_viewing_key(saved_vk.as_slice()));\n    }\n\n    #[test]\n    fn test_handle_set_viewing_key() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Set VK\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"hi lol\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        // Set valid VK\n        let actual_vk = ViewingKey(\"x\".to_string().repeat(VIEWING_KEY_SIZE));\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: actual_vk.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey { status: Success }).unwrap(),\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let saved_vk = read_viewing_key(\u0026deps.storage, \u0026bob_canonical).unwrap();\n        assert!(actual_vk.check_viewing_key(\u0026saved_vk));\n    }\n\n    #[test]\n    fn test_handle_transfer_from() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Transfer before allowance\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Transfer more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: Some(1_571_797_420),\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Transfer after allowance expired\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n        };\n        let handle_result = handle(\n            \u0026mut deps,\n            Env {\n                block: BlockInfo {\n                    height: 12_345,\n                    time: 1_571_797_420,\n                    chain_id: \"cosmos-testnet-14002\".to_string(),\n                },\n                message: MessageInfo {\n                    sender: HumanAddr(\"bob\".to_string()),\n                    sent_funds: vec![],\n                },\n                contract: ContractInfo {\n                    address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n                },\n                contract_key: Some(\"\".to_string()),\n                contract_code_hash: \"\".to_string(),\n            },\n            handle_msg,\n        );\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        let alice_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026alice_canonical);\n        assert_eq!(bob_balance, 5000 - 2000);\n        assert_eq!(alice_balance, 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 5000);\n\n        // Second send more than allowance\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_send_from() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Send before allowance\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Send more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"lolz\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let send_msg = Binary::from(r#\"{ \"some_msg\": { \"some_key\": \"some_val\" } }\"#.as_bytes());\n        let snip20_msg = Snip20ReceiveMsg::new(\n            HumanAddr(\"alice\".to_string()),\n            HumanAddr(\"bob\".to_string()),\n            Uint128(2000),\n            Some(send_msg.clone()),\n        );\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"contract\".to_string()),\n            amount: Uint128(2000),\n            msg: Some(send_msg),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        assert!(handle_result.unwrap().messages.contains(\n            \u0026snip20_msg\n                .into_cosmos_msg(\"lolz\".to_string(), HumanAddr(\"contract\".to_string()))\n                .unwrap()\n        ));\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let contract_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"contract\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        let contract_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026contract_canonical);\n        assert_eq!(bob_balance, 5000 - 2000);\n        assert_eq!(contract_balance, 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 5000);\n\n        // Second send more than allowance\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1),\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_burn_from() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(10000),\n            }],\n            false,\n            false,\n            false,\n            true,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(10000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when burn disabled\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Burn functionality is not enabled for this token.\"));\n\n        // Burn before allowance\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Burn more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        assert_eq!(bob_balance, 10000 - 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 10000 - 2000);\n\n        // Second burn more than allowance\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(1),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_decrease_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::DecreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 0,\n                expiration: None\n            }\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::DecreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(50),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 1950,\n                expiration: None\n            }\n        );\n    }\n\n    #[test]\n    fn test_handle_increase_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 2000,\n                expiration: None\n            }\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 4000,\n                expiration: None\n            }\n        );\n    }\n\n    #[test]\n    fn test_handle_change_admin() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::ChangeAdmin {\n            address: HumanAddr(\"bob\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let admin = ReadonlyConfig::from_storage(\u0026deps.storage)\n            .constants()\n            .unwrap()\n            .admin;\n        assert_eq!(admin, HumanAddr(\"bob\".to_string()));\n    }\n\n    #[test]\n    fn test_handle_set_contract_status() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"admin\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAll,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let contract_status = ReadonlyConfig::from_storage(\u0026deps.storage).contract_status();\n        assert!(matches!(\n            contract_status,\n            ContractStatusLevel::StopAll { .. }\n        ));\n    }\n\n    #[test]\n    fn test_handle_redeem() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"butler\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            true,\n            false,\n            false,\n            1000,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_no_reserve, mut deps_no_reserve) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"butler\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            true,\n            false,\n            false,\n            0,\n        );\n        assert!(\n            init_result_no_reserve.is_ok(),\n            \"Init failed: {}\",\n            init_result_no_reserve.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"butler\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when redeem disabled\n        let handle_msg = HandleMsg::Redeem {\n            amount: Uint128(1000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"butler\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Redeem functionality is not enabled for this token.\"));\n\n        // try to redeem when contract has 0 balance\n        let handle_msg = HandleMsg::Redeem {\n            amount: Uint128(1000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_no_reserve, mock_env(\"butler\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\n            \"You are trying to redeem for more SCRT than the token has in its deposit reserve.\"\n        ));\n\n        let handle_msg = HandleMsg::Redeem {\n            amount: Uint128(1000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"butler\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let balances = ReadonlyBalances::from_storage(\u0026deps.storage);\n        let canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"butler\".to_string()))\n            .unwrap();\n        assert_eq!(balances.account_amount(\u0026canonical), 4000)\n    }\n\n    #[test]\n    fn test_handle_deposit() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            true,\n            false,\n            false,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when deposit disabled\n        let handle_msg = HandleMsg::Deposit { padding: None };\n        let handle_result = handle(\n            \u0026mut deps_for_failure,\n            mock_env(\n                \"lebron\",\n                \u0026[Coin {\n                    denom: \"uscrt\".to_string(),\n                    amount: Uint128(1000),\n                }],\n            ),\n            handle_msg,\n        );\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Deposit functionality is not enabled for this token.\"));\n\n        let handle_msg = HandleMsg::Deposit { padding: None };\n        let handle_result = handle(\n            \u0026mut deps,\n            mock_env(\n                \"lebron\",\n                \u0026[Coin {\n                    denom: \"uscrt\".to_string(),\n                    amount: Uint128(1000),\n                }],\n            ),\n            handle_msg,\n        );\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let balances = ReadonlyBalances::from_storage(\u0026deps.storage);\n        let canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"lebron\".to_string()))\n            .unwrap();\n        assert_eq!(balances.account_amount(\u0026canonical), 6000)\n    }\n\n    #[test]\n    fn test_handle_burn() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            false,\n            true,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // test when burn disabled\n        let handle_msg = HandleMsg::Burn {\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"lebron\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Burn functionality is not enabled for this token.\"));\n\n        let supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        let burn_amount: u128 = 100;\n        let handle_msg = HandleMsg::Burn {\n            amount: Uint128(burn_amount),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let new_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(new_supply, supply - burn_amount);\n    }\n\n    #[test]\n    fn test_handle_mint() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try to mint when mint is disabled\n        let mint_amount: u128 = 100;\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(mint_amount),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        let mint_amount: u128 = 100;\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(mint_amount),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let new_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(new_supply, supply + mint_amount);\n    }\n\n    #[test]\n    fn test_handle_admin_commands() {\n        let admin_err = \"Admin commands can only be run from admin address\".to_string();\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAllButRedeems,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), pause_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"not_admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"not_admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let change_admin_msg = HandleMsg::ChangeAdmin {\n            address: HumanAddr(\"not_admin\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), change_admin_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n    }\n\n    #[test]\n    fn test_handle_pause_with_withdrawals() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            true,\n            false,\n            false,\n            5000,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAllButRedeems,\n            padding: None,\n        };\n\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), pause_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let send_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"account\".to_string()),\n            amount: Uint128(123),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), send_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n\n        let withdraw_msg = HandleMsg::Redeem {\n            amount: Uint128(5000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), withdraw_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Withdraw failed: {}\",\n            handle_result.err().unwrap()\n        );\n    }\n\n    #[test]\n    fn test_handle_pause_all() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAll,\n            padding: None,\n        };\n\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), pause_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let send_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"account\".to_string()),\n            amount: Uint128(123),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), send_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n\n        let withdraw_msg = HandleMsg::Redeem {\n            amount: Uint128(5000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), withdraw_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_handle_set_minters() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try when mint disabled\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n    }\n\n    #[test]\n    fn test_handle_add_minters() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try when mint disabled\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n    }\n\n    #[test]\n    fn test_handle_remove_minters() {\n        let (init_result, mut deps) = init_helper_with_config(\n            vec![InitialBalance {\n                address: HumanAddr(\"bob\".to_string()),\n                amount: Uint128(5000),\n            }],\n            false,\n            false,\n            true,\n            false,\n            0,\n        );\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n        let (init_result_for_failure, mut deps_for_failure) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result_for_failure.is_ok(),\n            \"Init failed: {}\",\n            init_result_for_failure.err().unwrap()\n        );\n        // try when mint disabled\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps_for_failure, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Mint functionality is not enabled for this token\"));\n\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        // Removing another extra time to ensure nothing funky happens\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n    }\n\n    // Query tests\n\n    #[test]\n    fn test_authenticated_queries() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"giannis\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let no_vk_yet_query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: \"no_vk_yet\".to_string(),\n        };\n        let query_result = query(\u0026deps, no_vk_yet_query_msg);\n        let error = extract_error_msg(query_result);\n        assert_eq!(\n            error,\n            \"Wrong viewing key for this address or viewing key not set\".to_string()\n        );\n\n        let create_vk_msg = HandleMsg::CreateViewingKey {\n            entropy: \"34\".to_string(),\n            padding: None,\n        };\n        let handle_response = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), create_vk_msg).unwrap();\n        let vk = match from_binary(\u0026handle_response.data.unwrap()).unwrap() {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"Unexpected result from handle\"),\n        };\n\n        let query_balance_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: vk.0,\n        };\n\n        let query_response = query(\u0026deps, query_balance_msg).unwrap();\n        let balance = match from_binary(\u0026query_response).unwrap() {\n            QueryAnswer::Balance { amount } =\u003e amount,\n            _ =\u003e panic!(\"Unexpected result from query\"),\n        };\n        assert_eq!(balance, Uint128(5000));\n\n        let wrong_vk_query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: \"wrong_vk\".to_string(),\n        };\n        let query_result = query(\u0026deps, wrong_vk_query_msg);\n        let error = extract_error_msg(query_result);\n        assert_eq!(\n            error,\n            \"Wrong viewing key for this address or viewing key not set\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_query_token_info() {\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 8;\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            r#\"{ \"public_total_supply\": true }\"#.as_bytes(),\n        ))\n        .unwrap();\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::TokenInfo {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::TokenInfo {\n                name,\n                symbol,\n                decimals,\n                total_supply,\n            } =\u003e {\n                assert_eq!(name, init_name);\n                assert_eq!(symbol, init_symbol);\n                assert_eq!(decimals, init_decimals);\n                assert_eq!(total_supply, Some(Uint128(5000)));\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n    }\n\n    #[test]\n    fn test_query_token_config() {\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 8;\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, false, false, true, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::TokenConfig {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::TokenConfig {\n                public_total_supply,\n                deposit_enabled,\n                redeem_enabled,\n                mint_enabled,\n                burn_enabled,\n            } =\u003e {\n                assert_eq!(public_total_supply, true);\n                assert_eq!(deposit_enabled, false);\n                assert_eq!(redeem_enabled, false);\n                assert_eq!(mint_enabled, true);\n                assert_eq!(burn_enabled, false);\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n    }\n\n    #[test]\n    fn test_query_exchange_rate() {\n        // test more dec than SCRT\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 8;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, true, false, false, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(100));\n                assert_eq!(denom, \"SCRT\");\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n\n        // test same number of decimals as SCRT\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 6;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, true, false, false, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(1));\n                assert_eq!(denom, \"SCRT\");\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n\n        // test less decimal places than SCRT\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 3;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            format!(\n                \"{{\\\"public_total_supply\\\":{},\n            \\\"enable_deposit\\\":{},\n            \\\"enable_redeem\\\":{},\n            \\\"enable_mint\\\":{},\n            \\\"enable_burn\\\":{}}}\",\n                true, true, false, false, false\n            )\n            .as_bytes(),\n        ))\n        .unwrap();\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(1000));\n                assert_eq!(denom, \"SECSEC\");\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n\n        // test depost/redeem not enabled\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 3;\n\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: None,\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::ExchangeRate {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::ExchangeRate { rate, denom } =\u003e {\n                assert_eq!(rate, Uint128(0));\n                assert_eq!(denom, String::new());\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n    }\n\n    #[test]\n    fn test_query_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"giannis\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let vk1 = ViewingKey(\"key1\".to_string());\n        let vk2 = ViewingKey(\"key2\".to_string());\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk1.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Query failed: {}\",\n            query_result.err().unwrap()\n        );\n        let error = extract_error_msg(query_result);\n        assert!(error.contains(\"Wrong viewing key\"));\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: vk1.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: vk2.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk1.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(2000));\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk2.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(2000));\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"lebron\".to_string()),\n            spender: HumanAddr(\"giannis\".to_string()),\n            key: vk2.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(0));\n    }\n\n    #[test]\n    fn test_query_balance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"key\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"wrong_key\".to_string(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let error = extract_error_msg(query_result);\n        assert!(error.contains(\"Wrong viewing key\"));\n\n        let query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let balance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Balance { amount } =\u003e amount,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(balance, Uint128(5000));\n    }\n\n    #[test]\n    fn test_query_transfer_history() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"key\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"banana\".to_string()),\n            amount: Uint128(500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"mango\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 0,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        // let a: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        // println!(\"{:?}\", a);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, total } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert!(transfers.is_empty());\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 10,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, total } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(transfers.len(), 3);\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 2,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs, total } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(transfers.len(), 2);\n    }\n}\n","traces":[{"line":25,"address":[2873288,2869280],"length":1,"stats":{"Line":1},"fn_name":"init\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":30,"address":[2869349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2869527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2869559],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[2869574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[2869820,2869629,2870856],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[2870211,2874085,2870038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[2870470,2870173],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[2870502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[2870519,2870657],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[2870689],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[2870732,2870626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[2870884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[2871016,2870942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[2870981,2871068],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[2871148,2871093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2871132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[2871340,2871190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[2871237,2871390],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[2871398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[2871470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[2872268,2871743,2872031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[2871485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[2871516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[2871548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[2871571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[2871578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[2871618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[2871639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[2871660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[2871681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[2871702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[2872293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[2872324],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[2872363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[2874383,2872386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[2874388,2872492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[2872502,2872630,2874041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[2872884,2872620],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[2875072],"length":1,"stats":{"Line":1},"fn_name":"pad_response"},{"line":94,"address":[2875086,2875248,2875357],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":95,"address":[2875136,2875266,2875220],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":96,"address":[2875160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[2875182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[2875337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[2875424,2880517],"length":1,"stats":{"Line":1},"fn_name":"handle\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":108,"address":[2880485,2875488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[2875936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2875876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[2876034,2883522,2875946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[2876139,2876214],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[2876151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[2876254,2883527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[2876342,2875984],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[2876392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[2876720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[2883537,2875901,2876730],"length":1,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[2876818,2883542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[2880466,2877034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[2877197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[2883547,2877446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[2883552,2877590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[2877750,2883557],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[2883562,2877910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[2878070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[2878384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[2878698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[2878934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[2879246,2880362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[2879497,2883577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[2883582,2879629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[2879783,2883587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[2883592,2879884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[2880038,2883597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[2876576,2883532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[2880184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[2884827,2884336],"length":1,"stats":{"Line":1},"fn_name":"query\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":194,"address":[2884363,2884951,2884518],"length":1,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[2884953,2884538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[2884955,2884558],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[2884957,2884578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[2884603,2884814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[2884667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[2884685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[2884731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[2884949,2884423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[2887604,2885056],"length":1,"stats":{"Line":1},"fn_name":"authenticated_queries\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":211,"address":[2885094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[2885481,2886775,2885277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[2885515,2885678,2888036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[2885928,2885647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[2886064,2885944,2886207],"length":1,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[2885967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[2886069,2887540,2885994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[2886255,2887521,2886169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[2886339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[2886371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[2886418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[2886450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[2886470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[2886484,2887483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[2886575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[2886639,2888334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[2886212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[2887028,2886915,2886807,2887254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[2886780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[2890150,2888800],"length":1,"stats":{"Line":1},"fn_name":"query_exchange_rate\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":249,"address":[2888825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[2890370,2888983,2888856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[2888964,2889233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[2889269,2889555],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[2889323,2889399,2890422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[2889480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[2889351,2889573,2890476],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[2889652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[2890122,2889761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[2889903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[2889281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[2889313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[2891545,2890688],"length":1,"stats":{"Line":1},"fn_name":"query_token_info\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":273,"address":[2890713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[2891625,2890736,2890855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[2890836,2891155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[2891167,2891120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[2891143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[2891319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[2891232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[2891258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[2891287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[2891295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[2892573,2891808],"length":1,"stats":{"Line":1},"fn_name":"query_token_config\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":291,"address":[2891832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[2892222,2891855,2892588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[2892157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[2892118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[2892126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[2892134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[2892142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[2892150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[2892720],"length":1,"stats":{"Line":0},"fn_name":"query_get_user_index\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":307,"address":[2892764,2892819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[2892826,2892774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[2892927,2892794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[2892976],"length":1,"stats":{"Line":0},"fn_name":"query_get_interested_redirection_address\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":321,"address":[2893087,2893188,2893020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[2893094,2893030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[2893050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[2893055,2893195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[2893248],"length":1,"stats":{"Line":0},"fn_name":"query_get_redirected_balance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":334,"address":[2893292,2893347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[2893302,2893354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[2893322,2893455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[2893504],"length":1,"stats":{"Line":0},"fn_name":"query_principal_balance_of\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":347,"address":[2893525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[2894350,2893552],"length":1,"stats":{"Line":1},"fn_name":"query_transactions\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":355,"address":[2893614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[2893674,2894019,2894392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[2893909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[2894009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[2894496,2894972],"length":1,"stats":{"Line":1},"fn_name":"query_balance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":369,"address":[2894656,2894534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[2894649,2894770,2894948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":372,"address":[2894839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[2894887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[2895271,2895056],"length":1,"stats":{"Line":0},"fn_name":"query_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":377,"address":[2895080,2895261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[2895139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[2895209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[2895376,2897551],"length":1,"stats":{"Line":1},"fn_name":"change_admin\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":388,"address":[2895413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[2897724,2895534,2895446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[2897719,2895784,2896092,2895524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[2896039,2897566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[2897714,2897669,2896354,2896403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[2896843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[2896393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[2896670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[2897024,2896677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[2901193,2898128],"length":1,"stats":{"Line":1},"fn_name":"try_mint\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":409,"address":[2898210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[2898233,2898358,2901212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[2898336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[2898669,2898607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":417,"address":[2898654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[2898719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[2898801,2898875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":424,"address":[2898832,2898927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[2898951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[2899010,2899148],"length":1,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[2899180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[2899235,2899117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[2899196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[2899462,2901210,2899293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[2899452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[2899727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[2899786,2899924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[2899956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[2900019,2899893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[2899972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[2900069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[2900084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[2900091,2900521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[2900356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[2901568,2902913],"length":1,"stats":{"Line":1},"fn_name":"try_set_key\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":470,"address":[2901602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[2901639,2902930,2901789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[2901779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[2902241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[2902053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[2902068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[2902423,2902075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[2905598,2903200],"length":1,"stats":{"Line":1},"fn_name":"try_create_key\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":487,"address":[2905563,2903243,2906070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[2903835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[2903875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[2905984,2904008,2904170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[2904160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[2904698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[2904437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[2904452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[2904459,2904883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[2907849,2906656],"length":1,"stats":{"Line":1},"fn_name":"set_contract_status\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":507,"address":[2906704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[2906715,2907866,2906802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[2906784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":513,"address":[2907242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":514,"address":[2907054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[2907069],"length":1,"stats":{"Line":2},"fn_name":null},{"line":516,"address":[2907146,2907076,2907654,2907420],"length":1,"stats":{"Line":4},"fn_name":null},{"line":522,"address":[2909724,2908096],"length":1,"stats":{"Line":1},"fn_name":"try_check_allowance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":527,"address":[2909743,2908136,2908313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[2908570,2908694,2909741,2908287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[2908684,2908960,2909314,2909739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":535,"address":[2909128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[2909160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[2909304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[2913075,2910000],"length":1,"stats":{"Line":1},"fn_name":"try_deposit\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":545,"address":[2910047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[2910283,2910385,2910120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":548,"address":[2910322,2910381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[2910357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[2910258,2910394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":554,"address":[2910400,2910474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[2910534,2910431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":559,"address":[2910558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[2913094,2910706,2910581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[2910684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[2910955,2911025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[2911087,2910994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":567,"address":[2911103,2911225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":568,"address":[2911265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[2911323,2911194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[2913092,2911381,2911288,2911495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":577,"address":[2911485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":578,"address":[2911760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[2911939,2911819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":580,"address":[2911987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":582,"address":[2911908,2912017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[2912002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[2912067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[2912504,2912074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":593,"address":[2912339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[2913392,2917757],"length":1,"stats":{"Line":1},"fn_name":"try_redeem\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":601,"address":[2913458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":602,"address":[2918244,2913521,2913646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[2913624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[2913977,2913895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":609,"address":[2913942,2914167,2918239,2914035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[2914123,2914440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":612,"address":[2914464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[2914487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":615,"address":[2914792,2914548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":616,"address":[2914840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":618,"address":[2914697,2914898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[2914863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":625,"address":[2915167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[2915354,2915216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":627,"address":[2915394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[2915323,2915461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[2915425,2915933,2915696,2915546,2915519,2915417],"length":1,"stats":{"Line":4},"fn_name":null},{"line":636,"address":[2915421,2915526,2915698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":637,"address":[2915674,2918234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[2915945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[2915988,2916080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":644,"address":[2916029,2918215,2916138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":645,"address":[2916045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[2916122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[2916387,2916271],"length":1,"stats":{"Line":2},"fn_name":null},{"line":655,"address":[2916698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":656,"address":[2917135,2916705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":659,"address":[2916970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":662,"address":[2918976,2921504],"length":1,"stats":{"Line":1},"fn_name":"try_transfer_impl\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":668,"address":[2919222,2919034,2921959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[2919196,2921954,2919484,2919617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":675,"address":[2919582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[2921443,2921944,2921527,2919966,2920238],"length":1,"stats":{"Line":3},"fn_name":null},{"line":685,"address":[2920843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[2920853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[2920893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":690,"address":[2921049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[2923642,2922560],"length":1,"stats":{"Line":1},"fn_name":"try_transfer\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":699,"address":[2922755,2922642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":702,"address":[2922740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":703,"address":[2922859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":704,"address":[2923289,2922866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[2923219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":709,"address":[2923760,2925913],"length":1,"stats":{"Line":1},"fn_name":"try_add_receiver_api_callback\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":718,"address":[2923880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":719,"address":[2923988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[2924118,2924492,2926183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":721,"address":[2924357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":722,"address":[2926104,2924743,2925866,2925447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":724,"address":[2925293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[2925719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":729,"address":[2926480,2928478],"length":1,"stats":{"Line":1},"fn_name":"try_send\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":736,"address":[2926586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":737,"address":[2928633,2926671,2926811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":739,"address":[2926801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":745,"address":[2927080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":746,"address":[2927132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[2927159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":753,"address":[2927365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[2927621,2928060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":756,"address":[2927974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[2930021,2929008],"length":1,"stats":{"Line":1},"fn_name":"try_register_receive\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":764,"address":[2929057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":766,"address":[2929098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[2930038,2929115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[2929882,2929307,2929648,2929242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":772,"address":[2929571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":775,"address":[2930224],"length":1,"stats":{"Line":1},"fn_name":"insufficient_allowance"},{"line":776,"address":[2930261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":782,"address":[2930544,2935149],"length":1,"stats":{"Line":1},"fn_name":"try_transfer_from_impl\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":789,"address":[2930829,2930638,2935627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":790,"address":[2930803,2931215,2935622,2931091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":791,"address":[2931603,2931477,2931189,2935617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":792,"address":[2931864,2931565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":794,"address":[2935612,2932068,2931904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":796,"address":[2936365,2932020,2932318,2936352],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":797,"address":[2932372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[2932396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[2932604,2932868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[2932906,2932987,2932477],"length":1,"stats":{"Line":3},"fn_name":null},{"line":808,"address":[2933019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":810,"address":[2932951,2933111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":817,"address":[2933035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":826,"address":[2935071,2933808,2933536,2935172,2935592],"length":1,"stats":{"Line":3},"fn_name":null},{"line":833,"address":[2934413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":834,"address":[2934429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":835,"address":[2934469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":838,"address":[2934633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[2936384,2937498],"length":1,"stats":{"Line":1},"fn_name":"try_transfer_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":848,"address":[2936611,2936487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":851,"address":[2936596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[2936715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":853,"address":[2937145,2936722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[2937075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":858,"address":[2939700,2937616],"length":1,"stats":{"Line":1},"fn_name":"try_send_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":866,"address":[2937743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":867,"address":[2937987,2939877,2937836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":869,"address":[2937977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":875,"address":[2938261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":876,"address":[2938300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":877,"address":[2938353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":883,"address":[2938568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":884,"address":[2938824,2939263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":886,"address":[2939177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[2940256,2945572],"length":1,"stats":{"Line":1},"fn_name":"try_burn_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":895,"address":[2940352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":896,"address":[2940375,2940500,2945599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":897,"address":[2940478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":898,"address":[2940831,2940749],"length":1,"stats":{"Line":2},"fn_name":null},{"line":903,"address":[2940889,2940796,2941019,2945597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":904,"address":[2945595,2940993,2941416,2941284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":905,"address":[2941689,2941372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":907,"address":[2941899,2945593,2941729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":909,"address":[2941848,2946061,2942155,2946048],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":910,"address":[2942218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[2942242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[2942451,2942747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":920,"address":[2942903,2942313,2942813],"length":1,"stats":{"Line":3},"fn_name":null},{"line":921,"address":[2942935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":923,"address":[2942848,2943030],"length":1,"stats":{"Line":2},"fn_name":null},{"line":930,"address":[2942951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":934,"address":[2943135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":935,"address":[2943410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":937,"address":[2943471,2943703],"length":1,"stats":{"Line":2},"fn_name":null},{"line":938,"address":[2943735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":940,"address":[2943608,2943818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[2943751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":948,"address":[2944095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[2944110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":950,"address":[2944311,2944159],"length":1,"stats":{"Line":2},"fn_name":null},{"line":951,"address":[2944343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":953,"address":[2944398,2944280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":957,"address":[2944359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":960,"address":[2944448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":961,"address":[2944463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":962,"address":[2944470,2944900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":965,"address":[2944735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":968,"address":[2949268,2946080],"length":1,"stats":{"Line":1},"fn_name":"try_increase_allowance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":975,"address":[2946162,2949724,2946361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[2949719,2946335,2946750,2946623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":978,"address":[2947012,2946740,2947161,2949714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":979,"address":[2947532,2947100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":980,"address":[2947556,2947611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":981,"address":[2947579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[2947620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":988,"address":[2947661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":992,"address":[2947787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":993,"address":[2948051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":994,"address":[2948771,2948327,2948537,2948157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1000,"address":[2948801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1003,"address":[2950448,2953631],"length":1,"stats":{"Line":1},"fn_name":"try_decrease_allowance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1010,"address":[2950530,2950729,2954087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1011,"address":[2950991,2951118,2950703,2954082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1013,"address":[2951380,2951108,2954077,2951529],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1014,"address":[2951895,2951468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1015,"address":[2951974,2951919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1016,"address":[2951942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1018,"address":[2951983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1023,"address":[2952024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1027,"address":[2952150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1028,"address":[2952414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1029,"address":[2953134,2952520,2952690,2952900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1035,"address":[2953164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1038,"address":[2954800,2956902],"length":1,"stats":{"Line":1},"fn_name":"add_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1043,"address":[2954838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1044,"address":[2956953,2954879,2955001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1045,"address":[2954979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1046,"address":[2955247,2955312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1051,"address":[2955367,2956951,2955465,2955283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1053,"address":[2955403,2955727,2956949,2955776],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1055,"address":[2956203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1056,"address":[2955766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1057,"address":[2956030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1058,"address":[2956037,2956381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1062,"address":[2959430,2957328],"length":1,"stats":{"Line":1},"fn_name":"remove_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1067,"address":[2957366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1068,"address":[2957407,2957529,2959481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1069,"address":[2957507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":[2957775,2957840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1075,"address":[2957895,2957993,2957811,2959479],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1077,"address":[2957931,2958255,2959477,2958304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1079,"address":[2958731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1080,"address":[2958294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[2958558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1082,"address":[2958565,2958909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1086,"address":[2959856,2961958],"length":1,"stats":{"Line":1},"fn_name":"set_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1091,"address":[2959894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1092,"address":[2960057,2959935,2962009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1093,"address":[2960035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1094,"address":[2960368,2960303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1099,"address":[2960339,2960423,2960521,2962007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1101,"address":[2960459,2960832,2962005,2960783],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1103,"address":[2961259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1104,"address":[2960822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1105,"address":[2961086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1106,"address":[2961437,2961093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1115,"address":[2962384,2965554],"length":1,"stats":{"Line":1},"fn_name":"try_burn\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1120,"address":[2962458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1121,"address":[2965573,2962481,2962606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1122,"address":[2962584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1123,"address":[2962855,2962937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1128,"address":[2962902,2962995,2963127,2965571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1129,"address":[2963083,2963400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1131,"address":[2963424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1132,"address":[2963447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1134,"address":[2963508,2963740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1135,"address":[2963772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1137,"address":[2963645,2963855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[2963788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1145,"address":[2964132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1146,"address":[2964147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1147,"address":[2964196,2964348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1148,"address":[2964380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1150,"address":[2964317,2964435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1154,"address":[2964396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1157,"address":[2964485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1158,"address":[2964500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1159,"address":[2964937,2964507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1162,"address":[2964772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1165,"address":[2965888,2967272],"length":1,"stats":{"Line":1},"fn_name":"perform_transfer\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":1171,"address":[2965967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1173,"address":[2965996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1174,"address":[2966057,2966303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1175,"address":[2966335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1177,"address":[2966200,2966410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1182,"address":[2966351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1184,"address":[2966668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1185,"address":[2966717,2967191,2966954,2966872,2967344],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":1186,"address":[2967356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[2966920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1190,"address":[2967208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1193,"address":[2967900,2967392],"length":1,"stats":{"Line":1},"fn_name":"is_admin\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":1194,"address":[2967721,2967422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1195,"address":[2967825,2967682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1196,"address":[2967836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1202,"address":[2967952],"length":1,"stats":{"Line":1},"fn_name":"check_if_admin\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":1203,"address":[2967984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1204,"address":[2968187,2968142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1209,"address":[2968174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1212,"address":[2968224],"length":1,"stats":{"Line":2},"fn_name":"is_valid_name"},{"line":1213,"address":[2968238],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1214,"address":[2968248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1217,"address":[2968288],"length":1,"stats":{"Line":2},"fn_name":"is_valid_symbol"},{"line":1218,"address":[2968312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1219,"address":[2968322],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1221,"address":[2968407,2968353,2968448,2968464],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}"},{"line":1243,"address":[1958850,1957840],"length":1,"stats":{"Line":1},"fn_name":"init_helper"},{"line":1249,"address":[1957862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1250,"address":[1957917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1253,"address":[1957964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1254,"address":[1957991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1255,"address":[1958082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1257,"address":[1958114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1258,"address":[1958260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1262,"address":[1958483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1265,"address":[1959072,1961330],"length":1,"stats":{"Line":1},"fn_name":"init_helper_with_config"},{"line":1278,"address":[1959316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1279,"address":[1959257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1280,"address":[1959300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1284,"address":[1959481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1285,"address":[1960169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1286,"address":[1959536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1298,"address":[1960332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1299,"address":[1960359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1300,"address":[1960450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1302,"address":[1960485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1303,"address":[1960631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1304,"address":[1960650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1307,"address":[1960902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1311,"address":[1963218,1961632],"length":1,"stats":{"Line":0},"fn_name":"_auth_query_helper"},{"line":1314,"address":[1961654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1315,"address":[1961879,1963175,1962077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1316,"address":[1961862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1318,"address":[1962039,1961887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1321,"address":[1962238,1962010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1323,"address":[1962253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1326,"address":[1962372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1327,"address":[1962649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[1962764,1962811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1329,"address":[1962778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1332,"address":[1962930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1335,"address":[1965861,1963760,1964380,1964480,1965142,1965248],"length":1,"stats":{"Line":3},"fn_name":"extract_error_msg\u003ccosmwasm_std::init_handle::InitResponse\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":1336,"address":[1965327,1963839,1964559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1337,"address":[1964502,1965270,1963846,1963782,1964566,1965334],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1338,"address":[1963873,1964611,1965352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1341,"address":[1965439,1963960,1964698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1342,"address":[1964043,1963994,1964735,1964787,1965473,1965522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1343,"address":[1965484,1964749,1964005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1346,"address":[1963797,1964517,1965285],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1347,"address":[1964539,1964175,1965307,1963819,1964931,1965654],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1348,"address":[1964893,1964137,1965616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1353,"address":[1965968,1966549],"length":1,"stats":{"Line":1},"fn_name":"ensure_success"},{"line":1354,"address":[1966533,1965980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1356,"address":[1966441,1966282,1966459,1966222,1966267,1966387,1966315,1966207,1966252,1966237,1966369,1966405,1966423,1966297,1966351,1966333],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1357,"address":[1966338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1373,"address":[1966167,1966464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1375,"address":[1966134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1382,"address":[1969505,1966768,1966800,1966773],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1383,"address":[1966900,1969547,1966807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1384,"address":[1966841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1387,"address":[1967163,1969464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1389,"address":[1967532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1390,"address":[1967555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1391,"address":[1967600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1392,"address":[1967845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1393,"address":[1968064,1969422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1394,"address":[1969406,1968284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1395,"address":[1968540,1969390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1396,"address":[1968752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1397,"address":[1968905,1969374,1969006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1399,"address":[1968918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1401,"address":[1969173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1405,"address":[1969845,1969872,1969840,1973232],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1407,"address":[1973274,1969972,1969897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1408,"address":[1969913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1417,"address":[1973191,1970268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1419,"address":[1970637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1420,"address":[1970660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1421,"address":[1970705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1422,"address":[1970950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1423,"address":[1973149,1971169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1424,"address":[1973133,1971389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1425,"address":[1971657,1973117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1426,"address":[1971893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1427,"address":[1972058,1973101,1972171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1429,"address":[1972074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1431,"address":[1972338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1432,"address":[1972480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1433,"address":[1972620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1434,"address":[1972760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1435,"address":[1972900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1439,"address":[1973573,1973568,1973600,1975339],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1440,"address":[1973607,1975420,1973748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1441,"address":[1973649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1442,"address":[1973724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1444,"address":[1975310,1974026,1974240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1445,"address":[1974009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1447,"address":[1974202,1974034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1450,"address":[1974156,1974639,1975295,1975381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1451,"address":[1974460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1452,"address":[1974172,1974388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1453,"address":[1974436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1455,"address":[1974583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1456,"address":[1974524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1460,"address":[1974903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1461,"address":[1975038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1470,"address":[1975669,1975664,1978814,1975696],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1471,"address":[1975812,1975703,1978916],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1472,"address":[1975753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1475,"address":[1978785,1976106,1976309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1476,"address":[1976083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1478,"address":[1976114,1976271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1482,"address":[1976241,1976463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1483,"address":[1976495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1486,"address":[1976643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1487,"address":[1976857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1488,"address":[1976983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1489,"address":[1977206,1977129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1491,"address":[1977142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1493,"address":[1977359,1977282],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1495,"address":[1977295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1497,"address":[1977451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1498,"address":[1977474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1499,"address":[1977699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1502,"address":[1977908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1503,"address":[1977967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1506,"address":[1978115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1507,"address":[1978329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1508,"address":[1978456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1512,"address":[1979264,1979232,1982484,1979237],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1513,"address":[1979396,1979271,1982639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1514,"address":[1979337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1517,"address":[1979866,1979672,1982452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1518,"address":[1979655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1520,"address":[1979680,1979828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1524,"address":[1979798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1527,"address":[1980106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1528,"address":[1980320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1529,"address":[1980446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1532,"address":[1980592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1533,"address":[1980651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1535,"address":[1980687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1537,"address":[1980920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1538,"address":[1981134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1539,"address":[1981276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1540,"address":[1981357,1981902,1982328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1541,"address":[1981400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1542,"address":[1981459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1543,"address":[1981836,1981733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1544,"address":[1981486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1545,"address":[1981553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1546,"address":[1981620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1547,"address":[1981644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1551,"address":[1981873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1556,"address":[1983008,1983013,1984860,1983040],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1557,"address":[1983047,1983148,1984926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1558,"address":[1983089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1561,"address":[1984831,1983612,1983421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1562,"address":[1983404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1564,"address":[1983429,1983574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1568,"address":[1983544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1571,"address":[1983852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1572,"address":[1984066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1573,"address":[1984192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1575,"address":[1984351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1578,"address":[1984517,1984785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1582,"address":[1985152,1985184,1987537,1985157],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1583,"address":[1985191,1987902,1985308],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1584,"address":[1985249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1587,"address":[1987505,1985777,1985584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1588,"address":[1985567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1590,"address":[1985592,1985739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1594,"address":[1985710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1597,"address":[1986017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1598,"address":[1987486,1986264,1986580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1599,"address":[1986247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1601,"address":[1986542,1986275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1603,"address":[1987597,1987467,1987552,1987684,1986728,1986405,1987778],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1606,"address":[1986906,1987574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1607,"address":[1986873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1609,"address":[1986978,1987055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1611,"address":[1986991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1613,"address":[1987155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1614,"address":[1987192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1618,"address":[1991675,1988320,1988325,1988352],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1619,"address":[1992084,1988359,1988468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1620,"address":[1988409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1623,"address":[1991643,1988756,1988959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1624,"address":[1988739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1626,"address":[1988921,1988764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1631,"address":[1988891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1634,"address":[1989199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1635,"address":[1991624,1989413,1991690,1991735,1991947],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1637,"address":[1991578,1989766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1638,"address":[1989676,1991725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1639,"address":[1989706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1646,"address":[1991562,1989952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1648,"address":[1990096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1651,"address":[1990215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1652,"address":[1991528,1990429,1991765,1991813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1654,"address":[1991482,1990782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1655,"address":[1990692,1991803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1656,"address":[1990722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1658,"address":[1991045,1990968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1660,"address":[1990981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1662,"address":[1991145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1663,"address":[1991182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1667,"address":[1992741,1992768,1992736,2000630],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1668,"address":[2000924,1992781,1992938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1669,"address":[1992879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1672,"address":[1993435,2000598,1993232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1673,"address":[1993209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1675,"address":[1993240,1993397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1680,"address":[1993595,1993367],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1681,"address":[1993627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1682,"address":[1993686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1685,"address":[1993866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1686,"address":[1994080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1687,"address":[1994207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1691,"address":[1994328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1692,"address":[1994387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1694,"address":[1994423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1696,"address":[1994591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1697,"address":[1995047,2000544,1994844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1698,"address":[1994821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1700,"address":[1994852,1995009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1703,"address":[1995207,1994979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1704,"address":[1995239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1705,"address":[1995298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1708,"address":[1995478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1709,"address":[1995692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1710,"address":[1995819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1714,"address":[1995940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1715,"address":[1995999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1716,"address":[1996058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1721,"address":[1996610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1722,"address":[1996265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1725,"address":[1996238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1727,"address":[1996399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1728,"address":[1996321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1729,"address":[1996380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1731,"address":[1996494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1732,"address":[1996463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1734,"address":[1996526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1735,"address":[1996584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1737,"address":[1996802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1739,"address":[1996977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1740,"address":[1997104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1744,"address":[1997225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1745,"address":[1997284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1746,"address":[1997343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1749,"address":[1997523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1750,"address":[1997995,1997776,2000363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1751,"address":[1997753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1753,"address":[1997957,1997784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1755,"address":[1997911,1998195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1757,"address":[1997927,1998163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1759,"address":[1998271,1998354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1761,"address":[1998287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1763,"address":[1998446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1764,"address":[1998526,2000282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1765,"address":[1998549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1766,"address":[1998629,2000267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1767,"address":[1998644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1768,"address":[1998808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1769,"address":[2000252,1998980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1770,"address":[1999067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1774,"address":[1999223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1775,"address":[1999282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1776,"address":[1999341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1779,"address":[1999521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1780,"address":[1999735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1781,"address":[1999862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1785,"address":[2001829,2010465,2001824,2001856],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1786,"address":[2010946,2001869,2002082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1787,"address":[2002023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1790,"address":[2002579,2010433,2002376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1791,"address":[2002353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1793,"address":[2002384,2002541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1798,"address":[2002739,2002511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1799,"address":[2002771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1800,"address":[2002830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1804,"address":[2003054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1805,"address":[2003268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1806,"address":[2003395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1810,"address":[2003516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1811,"address":[2003575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1815,"address":[2003767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1816,"address":[2004020,2004223,2010379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1817,"address":[2003997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1819,"address":[2004028,2004185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1822,"address":[2004155,2004383],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1823,"address":[2004415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1824,"address":[2004474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1828,"address":[2004698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1829,"address":[2004912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1830,"address":[2005039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1834,"address":[2005160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1837,"address":[2005279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1838,"address":[2005789,2005532,2010322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1839,"address":[2005509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1841,"address":[2005540,2005751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1843,"address":[2005965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1845,"address":[2005992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1846,"address":[2006059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1847,"address":[2006126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1848,"address":[2006166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1851,"address":[2006300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1852,"address":[2006359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1853,"address":[2006418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1854,"address":[2006442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1857,"address":[2006702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1858,"address":[2007271,2006955,2010265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1859,"address":[2006932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1861,"address":[2006966,2007233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1863,"address":[2007096,2007831,2010234,2007439],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1864,"address":[2007706,2007777,2007500],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1865,"address":[2007612,2010513,2007761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1868,"address":[2007940,2008023],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1870,"address":[2007956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1872,"address":[2008099,2008176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1874,"address":[2008112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1876,"address":[2008268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1877,"address":[2010153,2008348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1878,"address":[2008371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1879,"address":[2010138,2008451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1880,"address":[2008466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1881,"address":[2008630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1882,"address":[2008802,2010123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1883,"address":[2008889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1887,"address":[2009045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1888,"address":[2009104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1889,"address":[2009163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1893,"address":[2009387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1894,"address":[2009601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1895,"address":[2009728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1899,"address":[2011952,2011920,2019013,2011925],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1901,"address":[2012130,2019358,2012055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1902,"address":[2012071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1911,"address":[2012688,2018981,2012459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1912,"address":[2012436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1914,"address":[2012650,2012467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1917,"address":[2012604,2012880,2019307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1918,"address":[2012848,2012620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1921,"address":[2013398,2013195,2018949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1922,"address":[2013172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1924,"address":[2013360,2013203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1928,"address":[2013330,2013558],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1929,"address":[2013590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1932,"address":[2013738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1933,"address":[2013952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1934,"address":[2014079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1938,"address":[2014200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1939,"address":[2014259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1942,"address":[2014407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1943,"address":[2014621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1944,"address":[2014748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1948,"address":[2014869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1949,"address":[2014928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1953,"address":[2015120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1954,"address":[2015373,2015576,2018892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1955,"address":[2015350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1957,"address":[2015381,2015538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1960,"address":[2015508,2015736],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1961,"address":[2015768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1964,"address":[2015916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1965,"address":[2016130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1966,"address":[2016257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1970,"address":[2016378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1971,"address":[2016437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1974,"address":[2016585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1975,"address":[2016838,2017057,2018854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1976,"address":[2016815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1978,"address":[2016846,2017019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1980,"address":[2017245,2016973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1982,"address":[2016989,2017213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1984,"address":[2017337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1985,"address":[2018803,2017417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1986,"address":[2017432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1987,"address":[2017604,2018788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1988,"address":[2017691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1992,"address":[2017847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1993,"address":[2017906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1996,"address":[2018054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1997,"address":[2018268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1998,"address":[2018395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2002,"address":[2020064,2020032,2024404,2020037],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2003,"address":[2024626,2020077,2020218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2004,"address":[2020159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2007,"address":[2024372,2020715,2020512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2008,"address":[2020489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2010,"address":[2020677,2020520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2014,"address":[2020647,2020875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2015,"address":[2020907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2019,"address":[2021099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2020,"address":[2024353,2021568,2021352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2021,"address":[2021329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2023,"address":[2021360,2021530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2026,"address":[2021753,2021487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2028,"address":[2021500,2021721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2030,"address":[2021906,2021829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2032,"address":[2021842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2035,"address":[2022014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2036,"address":[2022059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2045,"address":[2022206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2046,"address":[2022265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2050,"address":[2022457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2051,"address":[2024266,2022907,2022704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2052,"address":[2022687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2054,"address":[2022712,2022869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2058,"address":[2023055,2022839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2059,"address":[2023087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2063,"address":[2023279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2064,"address":[2024247,2023526,2023741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2065,"address":[2023509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2067,"address":[2023703,2023534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2070,"address":[2023889,2023693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2071,"address":[2023927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2081,"address":[2025077,2025072,2025104,2028537],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2082,"address":[2025111,2025236,2028705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2083,"address":[2025177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2086,"address":[2028505,2025530,2025733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2087,"address":[2025507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2089,"address":[2025695,2025538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2093,"address":[2025665,2025887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2094,"address":[2025919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2098,"address":[2026111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2099,"address":[2026574,2028489,2026358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2100,"address":[2026341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2102,"address":[2026366,2026536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2105,"address":[2026759,2026493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2107,"address":[2026727,2026506],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2109,"address":[2026912,2026835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2111,"address":[2026848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2114,"address":[2027020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2115,"address":[2027065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2124,"address":[2027212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2125,"address":[2027271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2129,"address":[2027463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2130,"address":[2028402,2027710,2027925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2131,"address":[2027693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2133,"address":[2027887,2027718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2136,"address":[2027877,2028073],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2137,"address":[2028111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2147,"address":[2029072,2029077,2029104,2031105],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2148,"address":[2029111,2029220,2031309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2149,"address":[2029161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2152,"address":[2029496,2031073,2029690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2153,"address":[2029479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2155,"address":[2029504,2029652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2159,"address":[2029622,2029838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2162,"address":[2029962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2163,"address":[2030408,2031054,2030209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2164,"address":[2030192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2166,"address":[2030217,2030370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2169,"address":[2030572,2030360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2172,"address":[2031004,2031036,2031128,2030641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2173,"address":[2030663,2030988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2177,"address":[2031664,2031669,2031696,2033332],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2178,"address":[2031812,2033425,2031703],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2179,"address":[2031753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2182,"address":[2032370,2033303,2032085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2183,"address":[2032068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2185,"address":[2032332,2032093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2192,"address":[2032290,2032518],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2193,"address":[2032925,2032726,2033287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2194,"address":[2032709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2196,"address":[2032734,2032887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2199,"address":[2033081,2033272,2032877],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2200,"address":[2033134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2202,"address":[2033120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2207,"address":[2038786,2033648,2033680,2033653],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2209,"address":[2039062,2033759,2033834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2210,"address":[2033775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2219,"address":[2034162,2034391,2038754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2220,"address":[2034139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2222,"address":[2034353,2034170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2226,"address":[2039011,2034583,2034307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2227,"address":[2034551,2034323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2236,"address":[2035159,2034930,2038722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2237,"address":[2034907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2239,"address":[2035121,2034938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2242,"address":[2035351,2035075,2038960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2243,"address":[2035091,2035319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2246,"address":[2038690,2035666,2036047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2247,"address":[2035643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2249,"address":[2035677,2036009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2253,"address":[2035807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2257,"address":[2036201,2035967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2258,"address":[2036376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2259,"address":[2036503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2263,"address":[2036606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2267,"address":[2036766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2268,"address":[2036980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2269,"address":[2037107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2274,"address":[2037210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2278,"address":[2037370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2279,"address":[2037816,2038633,2037617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2280,"address":[2037600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2282,"address":[2037625,2037778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2285,"address":[2037768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2286,"address":[2038041,2037964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2288,"address":[2037977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2290,"address":[2038133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2294,"address":[2039632,2039664,2039637,2043406],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2296,"address":[2043625,2039735,2039810],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2297,"address":[2039751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2306,"address":[2040367,2043374,2040138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2307,"address":[2040115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2309,"address":[2040329,2040146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2312,"address":[2040283,2040553,2043574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2313,"address":[2040521,2040299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2316,"address":[2043342,2040862,2041125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2317,"address":[2040845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2319,"address":[2041087,2040870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2322,"address":[2040997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2325,"address":[2041377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2327,"address":[2041273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2328,"address":[2041057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2332,"address":[2041418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2334,"address":[2041616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2335,"address":[2041751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2337,"address":[2041854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2340,"address":[2042045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2342,"address":[2041941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2343,"address":[2041914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2347,"address":[2042086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2349,"address":[2042309,2042508,2043268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2350,"address":[2042292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2352,"address":[2042317,2042470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2355,"address":[2042460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2356,"address":[2042733,2042656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2358,"address":[2042669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2360,"address":[2042825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2364,"address":[2044133,2044160,2044128,2047656],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2366,"address":[2047848,2044217,2044292],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2367,"address":[2044233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2376,"address":[2047624,2044621,2044850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2377,"address":[2044598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2379,"address":[2044812,2044629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2382,"address":[2044766,2047797,2045042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2383,"address":[2045010,2044782],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2386,"address":[2045357,2045694,2047592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2387,"address":[2045334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2389,"address":[2045368,2045656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2393,"address":[2045498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2396,"address":[2045614,2045854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2397,"address":[2046029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2398,"address":[2046156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2400,"address":[2047560,2046275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2401,"address":[2046354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2403,"address":[2046378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2406,"address":[2046494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2407,"address":[2047544,2046741,2046940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2408,"address":[2046724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2410,"address":[2046902,2046749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2413,"address":[2047526,2046892,2047096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2414,"address":[2047170,2048190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2418,"address":[2048320,2048288,2048293,2052022],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2420,"address":[2048458,2052214,2048383],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2421,"address":[2048399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2430,"address":[2048787,2051990,2049016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2431,"address":[2048764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2433,"address":[2048795,2048978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2435,"address":[2048932,2049208,2052163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2436,"address":[2048948,2049176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2439,"address":[2051958,2049523,2049750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2440,"address":[2049500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2442,"address":[2049531,2049712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2445,"address":[2049658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2447,"address":[2049682,2049910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2448,"address":[2049942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2451,"address":[2050090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2452,"address":[2050304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2453,"address":[2050431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2455,"address":[2050550,2051926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2456,"address":[2050629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2458,"address":[2050653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2459,"address":[2050712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2462,"address":[2050860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2463,"address":[2051306,2051910,2051107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2464,"address":[2051090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2466,"address":[2051115,2051268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2469,"address":[2051258,2051462,2051892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2470,"address":[2052556,2051536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2474,"address":[2057533,2052640,2052645,2052672],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2475,"address":[2052685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2477,"address":[2052768,2052843,2057800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2478,"address":[2052784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2487,"address":[2057487,2053191,2053488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2488,"address":[2053168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2490,"address":[2053450,2053199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2497,"address":[2053648,2053408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2498,"address":[2053823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2499,"address":[2057454,2053950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2502,"address":[2057716,2054170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2505,"address":[2054396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2506,"address":[2054610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2507,"address":[2057421,2054737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2510,"address":[2054957,2057665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2513,"address":[2055183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2514,"address":[2055397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2515,"address":[2055524,2057388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2518,"address":[2055720,2057614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2521,"address":[2055946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2522,"address":[2056160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2523,"address":[2057355,2056287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2526,"address":[2056461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2529,"address":[2056612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2530,"address":[2056826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2531,"address":[2056953,2057322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2535,"address":[2058405,2061565,2058400,2058432],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2537,"address":[2058572,2061754,2058497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2538,"address":[2058513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2547,"address":[2058888,2059182,2061533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2548,"address":[2058871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2550,"address":[2059144,2058896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2558,"address":[2059102,2059330],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2559,"address":[2059741,2059538,2061514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2560,"address":[2059521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2562,"address":[2059546,2059703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2566,"address":[2059889,2059673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2567,"address":[2059921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2570,"address":[2060069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2571,"address":[2060283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2572,"address":[2060437,2061481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2574,"address":[2060402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2578,"address":[2060604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2582,"address":[2060764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2583,"address":[2061465,2061011,2061202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2584,"address":[2060994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2586,"address":[2061164,2061019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2591,"address":[2065179,2062128,2062101,2062096],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2592,"address":[2062135,2062260,2065338],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2593,"address":[2062201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2596,"address":[2062539,2062830,2065147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2597,"address":[2062522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2599,"address":[2062547,2062792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2607,"address":[2062750,2062978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2608,"address":[2063186,2063389,2065131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2609,"address":[2063169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2611,"address":[2063194,2063351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2615,"address":[2063321,2063537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2616,"address":[2063569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2619,"address":[2063717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2620,"address":[2063931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2621,"address":[2064085,2065101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2623,"address":[2064050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2627,"address":[2064252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2631,"address":[2064412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2632,"address":[2064626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2633,"address":[2065071,2064780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2635,"address":[2064745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2640,"address":[2065712,2065685,2065680,2070809],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2642,"address":[2065866,2071115,2065791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2643,"address":[2065807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2652,"address":[2066424,2070777,2066195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2653,"address":[2066172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2655,"address":[2066203,2066386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2657,"address":[2071064,2066340,2066610],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2658,"address":[2066356,2066578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2661,"address":[2070745,2066919,2067148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2662,"address":[2066902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2664,"address":[2067110,2066927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2668,"address":[2067064,2071013,2067296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2671,"address":[2067479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2672,"address":[2067693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2673,"address":[2067820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2676,"address":[2067933,2070962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2679,"address":[2068159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2680,"address":[2068373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2681,"address":[2068500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2684,"address":[2070911,2068613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2687,"address":[2068839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2688,"address":[2069053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2691,"address":[2069245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2692,"address":[2069304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2695,"address":[2069452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2696,"address":[2069666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2699,"address":[2069858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2700,"address":[2069917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2703,"address":[2070065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2704,"address":[2070279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2705,"address":[2070406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2709,"address":[2071648,2076645,2071616,2071621],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2711,"address":[2071727,2071802,2076948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2712,"address":[2071743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2721,"address":[2072119,2076613,2072345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2722,"address":[2072102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2724,"address":[2072127,2072307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2726,"address":[2076900,2072261,2072525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2727,"address":[2072493,2072277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2730,"address":[2076581,2072834,2073063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2731,"address":[2072817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2733,"address":[2072842,2073025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2737,"address":[2073211,2072979,2076849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2740,"address":[2073394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2741,"address":[2073608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2742,"address":[2073735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2745,"address":[2073848,2076798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2748,"address":[2074074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2749,"address":[2074288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2750,"address":[2074415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2753,"address":[2074528,2076747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2756,"address":[2074754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2757,"address":[2074968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2760,"address":[2075160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2761,"address":[2075219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2764,"address":[2075367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2765,"address":[2075581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2768,"address":[2075773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2769,"address":[2075832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2772,"address":[2075980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2773,"address":[2076194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2777,"address":[2077429,2077424,2084745,2077456],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2779,"address":[2085168,2077559,2077634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2780,"address":[2077575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2789,"address":[2077963,2078192,2084713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2790,"address":[2077940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2792,"address":[2077971,2078154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2794,"address":[2078108,2085117,2078384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2795,"address":[2078124,2078352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2798,"address":[2084681,2078699,2078928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2799,"address":[2078676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2801,"address":[2078890,2078707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2805,"address":[2085066,2078844,2079088],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2808,"address":[2079271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2809,"address":[2079485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2810,"address":[2079612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2813,"address":[2085015,2079743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2816,"address":[2079969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2817,"address":[2080183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2818,"address":[2080310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2821,"address":[2080429,2084964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2824,"address":[2080655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2825,"address":[2080869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2828,"address":[2081061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2829,"address":[2081120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2832,"address":[2081268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2833,"address":[2081482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2834,"address":[2081609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2837,"address":[2081712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2838,"address":[2081771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2841,"address":[2081919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2842,"address":[2082133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2843,"address":[2082260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2847,"address":[2082373,2084853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2850,"address":[2082599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2851,"address":[2082813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2854,"address":[2083005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2855,"address":[2083064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2858,"address":[2083212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2859,"address":[2083426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2860,"address":[2083553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2863,"address":[2083656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2864,"address":[2083715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2867,"address":[2083863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2868,"address":[2084077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2869,"address":[2084204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2875,"address":[2085845,2085840,2085872,2089366],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2876,"address":[2085988,2089607,2085879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2877,"address":[2085929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2880,"address":[2086464,2086267,2089334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2881,"address":[2086250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2883,"address":[2086426,2086275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2887,"address":[2086612,2086396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2888,"address":[2086644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2890,"address":[2086746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2891,"address":[2086857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2892,"address":[2089288,2087011],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2894,"address":[2086976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2898,"address":[2087178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2901,"address":[2087297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2902,"address":[2087541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2903,"address":[2087703,2087656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2904,"address":[2087670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2908,"address":[2087830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2909,"address":[2087889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2912,"address":[2088004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2913,"address":[2088161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2914,"address":[2088198,2088245],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2915,"address":[2088212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2917,"address":[2088316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2920,"address":[2088463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2921,"address":[2088522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2923,"address":[2088624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2924,"address":[2088735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2925,"address":[2088889,2089159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2927,"address":[2088854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2932,"address":[2090112,2090144,2093886,2090117],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2933,"address":[2090151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2934,"address":[2090216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2935,"address":[2090275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2936,"address":[2090302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2937,"address":[2090405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2941,"address":[2090555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2943,"address":[2090579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2944,"address":[2090613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2946,"address":[2090660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2947,"address":[2090703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2948,"address":[2090742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2949,"address":[2090777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2950,"address":[2094103,2090894,2090803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2954,"address":[2091140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2955,"address":[2091166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2957,"address":[2091417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2958,"address":[2093736,2091669,2091967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2959,"address":[2091646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2961,"address":[2091677,2091929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2964,"address":[2091804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2965,"address":[2091815,2092121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2966,"address":[2092154,2093717,2092470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2967,"address":[2092137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2969,"address":[2092432,2092165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2971,"address":[2092634,2092295,2093698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2973,"address":[2092753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2979,"address":[2092903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2980,"address":[2093059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2981,"address":[2093207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2982,"address":[2093366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2984,"address":[2092720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2989,"address":[2094640,2094645,2094672,2099129],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2990,"address":[2094682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2991,"address":[2094731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2992,"address":[2094790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2993,"address":[2094817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2994,"address":[2095664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2995,"address":[2094825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3007,"address":[2095833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3009,"address":[2095857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3010,"address":[2095891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3012,"address":[2095938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3013,"address":[2095981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3014,"address":[2096020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3015,"address":[2096055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3016,"address":[2096172,2099198,2096081],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3020,"address":[2096418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3021,"address":[2096444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3023,"address":[2096695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3024,"address":[2097239,2098965,2096941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3025,"address":[2096924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3027,"address":[2096949,2097201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3030,"address":[2097076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3031,"address":[2097087,2097387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3032,"address":[2098946,2097420,2097736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3033,"address":[2097403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3035,"address":[2097698,2097431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3037,"address":[2097900,2097561,2098927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3039,"address":[2098045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3046,"address":[2098081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3047,"address":[2098221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3048,"address":[2098363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3049,"address":[2098505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3050,"address":[2098645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3052,"address":[2097970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3057,"address":[2099717,2099744,2099712,2115229],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3059,"address":[2099760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3060,"address":[2099913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3061,"address":[2099972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3062,"address":[2099999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3064,"address":[2100007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3066,"address":[2100031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3067,"address":[2100065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3068,"address":[2100951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3069,"address":[2100112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3081,"address":[2101120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3082,"address":[2101163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3083,"address":[2101202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3084,"address":[2101237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3085,"address":[2101263,2101354,2116056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3089,"address":[2101600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3090,"address":[2101626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3092,"address":[2101877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3093,"address":[2102427,2102129,2115062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3094,"address":[2102106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3096,"address":[2102389,2102137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3099,"address":[2102264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3100,"address":[2102275,2102587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3101,"address":[2102626,2115043,2102942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3102,"address":[2102603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3104,"address":[2102637,2102904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3106,"address":[2103118,2102767,2115024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3108,"address":[2103182,2103229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3109,"address":[2103309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3110,"address":[2103482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3112,"address":[2103196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3116,"address":[2103666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3117,"address":[2103693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3118,"address":[2103752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3119,"address":[2103779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3121,"address":[2103787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3123,"address":[2103811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3124,"address":[2103845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3125,"address":[2104731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3126,"address":[2103892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3138,"address":[2104900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3139,"address":[2104943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3140,"address":[2104982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3141,"address":[2105017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3142,"address":[2105043,2105134,2115889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3146,"address":[2105380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3147,"address":[2105406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3149,"address":[2105657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3150,"address":[2114833,2105909,2106207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3151,"address":[2105886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3153,"address":[2106169,2105917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3156,"address":[2106044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3157,"address":[2106367,2106055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3158,"address":[2106406,2114814,2106722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3159,"address":[2106383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3161,"address":[2106417,2106684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3163,"address":[2114795,2106547,2106898],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3165,"address":[2107009,2106962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3166,"address":[2107089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3167,"address":[2107262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3169,"address":[2106976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3173,"address":[2107446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3174,"address":[2107473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3175,"address":[2107532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3176,"address":[2107559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3178,"address":[2107567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3180,"address":[2107591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3181,"address":[2107625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3182,"address":[2108511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3183,"address":[2107672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3195,"address":[2108680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3196,"address":[2108723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3197,"address":[2108762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3198,"address":[2108797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3199,"address":[2115722,2108914,2108823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3203,"address":[2109160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3204,"address":[2109186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3206,"address":[2109437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3207,"address":[2109689,2109987,2114604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3208,"address":[2109666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3210,"address":[2109949,2109697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3213,"address":[2109824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3214,"address":[2109835,2110147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3215,"address":[2110502,2114585,2110186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3216,"address":[2110163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3218,"address":[2110197,2110464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3220,"address":[2110678,2114566,2110327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3222,"address":[2110742,2110789],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3223,"address":[2110869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3224,"address":[2111042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3226,"address":[2110756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3230,"address":[2111226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3231,"address":[2111253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3232,"address":[2111312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3233,"address":[2111339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3235,"address":[2111347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3237,"address":[2111371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3238,"address":[2111405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3240,"address":[2111452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3241,"address":[2111495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3242,"address":[2111534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3243,"address":[2111569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3244,"address":[2115555,2111683,2111592],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3248,"address":[2111917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3251,"address":[2112143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3252,"address":[2112681,2112383,2114408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3253,"address":[2112366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3255,"address":[2112643,2112391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3258,"address":[2112518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3259,"address":[2112529,2112829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3260,"address":[2112862,2113178,2114389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3261,"address":[2112845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3263,"address":[2113140,2112873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3265,"address":[2114370,2113003,2113342],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3267,"address":[2113406,2113453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3268,"address":[2113533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3269,"address":[2114337,2113688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3271,"address":[2113420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3276,"address":[2125613,2118000,2118032,2118005],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3277,"address":[2118045,2126118,2118178],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3278,"address":[2118119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3281,"address":[2118675,2125581,2118472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3282,"address":[2118449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3284,"address":[2118637,2118480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3288,"address":[2118835,2118607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3289,"address":[2118867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3293,"address":[2119059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3294,"address":[2125562,2119515,2119312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3295,"address":[2119289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3297,"address":[2119477,2119320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3300,"address":[2119447,2119675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3301,"address":[2119707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3304,"address":[2119766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3305,"address":[2119825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3306,"address":[2119884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3308,"address":[2120018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3309,"address":[2120168,2125484,2120477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3310,"address":[2120145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3312,"address":[2120439,2120179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3314,"address":[2120309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3315,"address":[2120645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3318,"address":[2120754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3321,"address":[2120873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3322,"address":[2125628,2125446,2125676,2121087,2125888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3324,"address":[2121440,2125400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3325,"address":[2121350,2125666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3326,"address":[2121380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3333,"address":[2121626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3336,"address":[2121745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3337,"address":[2125706,2121959,2125381,2125754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3339,"address":[2122312,2125335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3340,"address":[2125744,2122222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3341,"address":[2122252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3348,"address":[2122498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3349,"address":[2122557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3350,"address":[2122616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3352,"address":[2122750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3353,"address":[2122861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3354,"address":[2123087,2123040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3355,"address":[2123054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3357,"address":[2123177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3360,"address":[2123324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3361,"address":[2123383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3362,"address":[2123442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3364,"address":[2123576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3365,"address":[2123687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3366,"address":[2123866,2123913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3367,"address":[2123880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3369,"address":[2124003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3372,"address":[2124150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3373,"address":[2124209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3374,"address":[2124268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3376,"address":[2124402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3377,"address":[2124513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3378,"address":[2124739,2124692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3379,"address":[2124706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3381,"address":[2124829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3385,"address":[2130301,2127205,2127200,2127232],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3386,"address":[2130525,2127340,2127239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3387,"address":[2127281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3390,"address":[2127619,2127816,2130269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3391,"address":[2127602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3393,"address":[2127778,2127627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3397,"address":[2127748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3400,"address":[2128056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3401,"address":[2128270,2130250,2130316,2130361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3403,"address":[2130204,2128623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3404,"address":[2130351,2128533],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3405,"address":[2128563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3412,"address":[2128809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3413,"address":[2128868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3415,"address":[2128970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3416,"address":[2129081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3417,"address":[2129208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3420,"address":[2129311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3421,"address":[2129370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3423,"address":[2129472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3424,"address":[2129583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3425,"address":[2129762,2129809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3426,"address":[2129776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3428,"address":[2129899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3432,"address":[2130981,2131008,2137255,2130976],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":3433,"address":[2131146,2137525,2131021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3434,"address":[2131087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3437,"address":[2131422,2137223,2131616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3438,"address":[2131405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3440,"address":[2131430,2131578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3444,"address":[2131548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3447,"address":[2131856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3448,"address":[2132070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3451,"address":[2132262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3452,"address":[2132321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3455,"address":[2132469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3456,"address":[2132683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3457,"address":[2132809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3459,"address":[2132955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3460,"address":[2133014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3463,"address":[2133162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3464,"address":[2133376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3465,"address":[2133502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3467,"address":[2133648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3468,"address":[2133707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3471,"address":[2133855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3472,"address":[2134069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3473,"address":[2134195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3476,"address":[2134341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3477,"address":[2134400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3481,"address":[2134552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3484,"address":[2134663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3485,"address":[2134889,2134842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3486,"address":[2134856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3488,"address":[2135048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3491,"address":[2135106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3492,"address":[2135165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3496,"address":[2135317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3497,"address":[2135428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3498,"address":[2135607,2135654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3499,"address":[2135621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3501,"address":[2135813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3504,"address":[2135991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3505,"address":[2136050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3509,"address":[2136202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3510,"address":[2136313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3511,"address":[2136492,2136539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3512,"address":[2136506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3514,"address":[2136698],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1446,"coverable":1604},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\nmod rand;\npub mod receiver;\npub mod state;\nmod utils;\nmod viewing_key;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","src","msg.rs"],"content":"#![allow(clippy::field_reassign_with_default)] // This is triggered in `#[derive(JsonSchema)]`\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Binary, HumanAddr, StdError, StdResult, Uint128};\n\nuse crate::state::Tx;\nuse crate::viewing_key::ViewingKey;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct InitialBalance {\n    pub address: HumanAddr,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema)]\npub struct InitMsg {\n    pub name: String,\n    pub admin: Option\u003cHumanAddr\u003e,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Option\u003cVec\u003cInitialBalance\u003e\u003e,\n    pub prng_seed: Binary,\n    pub config: Option\u003cInitConfig\u003e,\n}\n\nimpl InitMsg {\n    pub fn config(\u0026self) -\u003e InitConfig {\n        self.config.clone().unwrap_or_default()\n    }\n}\n\n/// This type represents optional configuration values which can be overridden.\n/// All values are optional and have defaults which are more private by default,\n/// but can be overridden if necessary\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Default, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct InitConfig {\n    /// Indicates whether the total supply is public or should be kept secret.\n    /// default: False\n    public_total_supply: Option\u003cbool\u003e,\n    /// Indicates whether deposit functionality should be enabled\n    /// default: False\n    enable_deposit: Option\u003cbool\u003e,\n    /// Indicates whether redeem functionality should be enabled\n    /// default: False\n    enable_redeem: Option\u003cbool\u003e,\n    /// Indicates whether mint functionality should be enabled\n    /// default: False\n    enable_mint: Option\u003cbool\u003e,\n    /// Indicates whether burn functionality should be enabled\n    /// default: False\n    enable_burn: Option\u003cbool\u003e,\n}\n\nimpl InitConfig {\n    pub fn public_total_supply(\u0026self) -\u003e bool {\n        self.public_total_supply.unwrap_or(false)\n    }\n\n    pub fn deposit_enabled(\u0026self) -\u003e bool {\n        self.enable_deposit.unwrap_or(false)\n    }\n\n    pub fn redeem_enabled(\u0026self) -\u003e bool {\n        self.enable_redeem.unwrap_or(false)\n    }\n\n    pub fn mint_enabled(\u0026self) -\u003e bool {\n        self.enable_mint.unwrap_or(false)\n    }\n\n    pub fn burn_enabled(\u0026self) -\u003e bool {\n        self.enable_burn.unwrap_or(false)\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    // Native coin interactions\n    Redeem {\n        amount: Uint128,\n        denom: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    Deposit {\n        padding: Option\u003cString\u003e,\n    },\n\n    // Base ERC-20 stuff\n    Transfer {\n        recipient: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    Send {\n        recipient: HumanAddr,\n        amount: Uint128,\n        msg: Option\u003cBinary\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    Burn {\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    RegisterReceive {\n        code_hash: String,\n        padding: Option\u003cString\u003e,\n    },\n    CreateViewingKey {\n        entropy: String,\n        padding: Option\u003cString\u003e,\n    },\n    SetViewingKey {\n        key: String,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Allowance\n    IncreaseAllowance {\n        spender: HumanAddr,\n        amount: Uint128,\n        expiration: Option\u003cu64\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    DecreaseAllowance {\n        spender: HumanAddr,\n        amount: Uint128,\n        expiration: Option\u003cu64\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    TransferFrom {\n        owner: HumanAddr,\n        recipient: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    SendFrom {\n        owner: HumanAddr,\n        recipient: HumanAddr,\n        amount: Uint128,\n        msg: Option\u003cBinary\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    BurnFrom {\n        owner: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Mint\n    Mint {\n        recipient: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    AddMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    RemoveMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    SetMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Admin\n    ChangeAdmin {\n        address: HumanAddr,\n        padding: Option\u003cString\u003e,\n    },\n    SetContractStatus {\n        level: ContractStatusLevel,\n        padding: Option\u003cString\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleAnswer {\n    // Native\n    Deposit {\n        status: ResponseStatus,\n    },\n    Redeem {\n        status: ResponseStatus,\n    },\n\n    // Base\n    Transfer {\n        status: ResponseStatus,\n    },\n    Send {\n        status: ResponseStatus,\n    },\n    Burn {\n        status: ResponseStatus,\n    },\n    RegisterReceive {\n        status: ResponseStatus,\n    },\n    CreateViewingKey {\n        key: ViewingKey,\n    },\n    SetViewingKey {\n        status: ResponseStatus,\n    },\n\n    // Allowance\n    IncreaseAllowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n    },\n    DecreaseAllowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n    },\n    TransferFrom {\n        status: ResponseStatus,\n    },\n    SendFrom {\n        status: ResponseStatus,\n    },\n    BurnFrom {\n        status: ResponseStatus,\n    },\n\n    // Mint\n    Mint {\n        status: ResponseStatus,\n    },\n    AddMinters {\n        status: ResponseStatus,\n    },\n    RemoveMinters {\n        status: ResponseStatus,\n    },\n    SetMinters {\n        status: ResponseStatus,\n    },\n\n    // Other\n    ChangeAdmin {\n        status: ResponseStatus,\n    },\n    SetContractStatus {\n        status: ResponseStatus,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    TokenInfo {},\n    TokenConfig {},\n    ExchangeRate {},\n    Allowance {\n        owner: HumanAddr,\n        spender: HumanAddr,\n        key: String,\n    },\n    Balance {\n        address: HumanAddr,\n        key: String,\n    },\n    TransferHistory {\n        address: HumanAddr,\n        key: String,\n        page: Option\u003cu32\u003e,\n        page_size: u32,\n    },\n    Minters {},\n    LastUserIndex {\n        account: HumanAddr,\n    },\n    InterestedRedirectionAddress {\n        account: HumanAddr,\n    },\n    RedirectedBalance {\n        account: HumanAddr,\n    },\n    PrincpleBalanceOf {\n        address: HumanAddr,\n    },\n}\n\nimpl QueryMsg {\n    pub fn get_validation_params(\u0026self) -\u003e (Vec\u003c\u0026HumanAddr\u003e, ViewingKey) {\n        match self {\n            Self::Balance { address, key } =\u003e (vec![address], ViewingKey(key.clone())),\n            Self::TransferHistory { address, key, .. } =\u003e (vec![address], ViewingKey(key.clone())),\n            Self::Allowance {\n                owner,\n                spender,\n                key,\n                ..\n            } =\u003e (vec![owner, spender], ViewingKey(key.clone())),\n            _ =\u003e panic!(\"This query type does not require authentication\"),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryAnswer {\n    TokenInfo {\n        name: String,\n        symbol: String,\n        decimals: u8,\n        total_supply: Option\u003cUint128\u003e,\n    },\n    TokenConfig {\n        public_total_supply: bool,\n        deposit_enabled: bool,\n        redeem_enabled: bool,\n        mint_enabled: bool,\n        burn_enabled: bool,\n    },\n    ExchangeRate {\n        rate: Uint128,\n        denom: String,\n    },\n    Allowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n        expiration: Option\u003cu64\u003e,\n    },\n    Balance {\n        amount: Uint128,\n    },\n    TransferHistory {\n        txs: Vec\u003cTx\u003e,\n        total: Option\u003cu64\u003e,\n    },\n\n    ViewingKeyError {\n        msg: String,\n    },\n    Minters {\n        minters: Vec\u003cHumanAddr\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct CreateViewingKeyResponse {\n    pub key: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ResponseStatus {\n    Success,\n    Failure,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ContractStatusLevel {\n    NormalRun,\n    StopAllButRedeems,\n    StopAll,\n}\n\npub fn status_level_to_u8(status_level: ContractStatusLevel) -\u003e u8 {\n    match status_level {\n        ContractStatusLevel::NormalRun =\u003e 0,\n        ContractStatusLevel::StopAllButRedeems =\u003e 1,\n        ContractStatusLevel::StopAll =\u003e 2,\n    }\n}\n\npub fn u8_to_status_level(status_level: u8) -\u003e StdResult\u003cContractStatusLevel\u003e {\n    match status_level {\n        0 =\u003e Ok(ContractStatusLevel::NormalRun),\n        1 =\u003e Ok(ContractStatusLevel::StopAllButRedeems),\n        2 =\u003e Ok(ContractStatusLevel::StopAll),\n        _ =\u003e Err(StdError::generic_err(\"Invalid state level\")),\n    }\n}\n\n// Take a Vec\u003cu8\u003e and pad it up to a multiple of `block_size`, using spaces at the end.\npub fn space_pad(block_size: usize, message: \u0026mut Vec\u003cu8\u003e) -\u003e \u0026mut Vec\u003cu8\u003e {\n    let len = message.len();\n    let surplus = len % block_size;\n    if surplus == 0 {\n        return message;\n    }\n\n    let missing = block_size - surplus;\n    message.reserve(missing);\n    message.extend(std::iter::repeat(b' ').take(missing));\n    message\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::{from_slice, StdResult};\n\n    #[derive(Serialize, Deserialize, JsonSchema, Debug, PartialEq)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum Something {\n        Var { padding: Option\u003cString\u003e },\n    }\n\n    #[test]\n    fn test_deserialization_of_missing_option_fields() -\u003e StdResult\u003c()\u003e {\n        let input = b\"{ \\\"var\\\": {} }\";\n        let obj: Something = from_slice(input)?;\n        assert_eq!(\n            obj,\n            Something::Var { padding: None },\n            \"unexpected value: {:?}\",\n            obj\n        );\n        Ok(())\n    }\n}\n","traces":[{"line":29,"address":[6261776],"length":1,"stats":{"Line":1},"fn_name":"config"},{"line":30,"address":[6261785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[6261904],"length":1,"stats":{"Line":2},"fn_name":"public_total_supply"},{"line":59,"address":[6261913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[6261952],"length":1,"stats":{"Line":2},"fn_name":"deposit_enabled"},{"line":63,"address":[6261961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[6262000],"length":1,"stats":{"Line":2},"fn_name":"redeem_enabled"},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[6263120],"length":1,"stats":{"Line":2},"fn_name":"status_level_to_u8"},{"line":373,"address":[6263164,6263173],"length":1,"stats":{"Line":3},"fn_name":null},{"line":374,"address":[6263131,6263168],"length":1,"stats":{"Line":4},"fn_name":null},{"line":375,"address":[6263175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[6263159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[6263200],"length":1,"stats":{"Line":1},"fn_name":"u8_to_status_level"},{"line":381,"address":[6263286,6263312,6263299],"length":1,"stats":{"Line":3},"fn_name":null},{"line":382,"address":[6263279,6263224],"length":1,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[6263292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[6263305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":385,"address":[6263250,6263318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[6263360],"length":1,"stats":{"Line":1},"fn_name":"space_pad"},{"line":391,"address":[6263397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[6263418,6263608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[6263458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[6263469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[6263486,6263638],"length":1,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[6263520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[6263526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[6263593],"length":1,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[2382713,2383355,2382752,2382704],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":416,"address":[2382769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[2382784,2382979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[2382901,2383195,2383083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":424,"address":[2383163],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":40,"coverable":48},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","src","rand.rs"],"content":"use rand_chacha::ChaChaRng;\nuse rand_core::{RngCore, SeedableRng};\n\nuse sha2::{Digest, Sha256};\n\npub fn sha_256(data: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    let hash = hasher.finalize();\n\n    let mut result = [0u8; 32];\n    result.copy_from_slice(hash.as_slice());\n    result\n}\n\npub struct Prng {\n    rng: ChaChaRng,\n}\n\nimpl Prng {\n    pub fn new(seed: \u0026[u8], entropy: \u0026[u8]) -\u003e Self {\n        let mut hasher = Sha256::new();\n\n        // write input message\n        hasher.update(\u0026seed);\n        hasher.update(\u0026entropy);\n        let hash = hasher.finalize();\n\n        let mut hash_bytes = [0u8; 32];\n        hash_bytes.copy_from_slice(hash.as_slice());\n\n        let rng: ChaChaRng = ChaChaRng::from_seed(hash_bytes);\n\n        Self { rng }\n    }\n\n    pub fn rand_bytes(\u0026mut self) -\u003e [u8; 32] {\n        let mut bytes = [0u8; 32];\n        self.rng.fill_bytes(\u0026mut bytes);\n\n        bytes\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// This test checks that the rng is stateful and generates\n    /// different random bytes every time it is called.\n    #[test]\n    fn test_rng() {\n        let mut rng = Prng::new(b\"foo\", b\"bar!\");\n        let r1: [u8; 32] = [\n            155, 11, 21, 97, 252, 65, 160, 190, 100, 126, 85, 251, 47, 73, 160, 49, 216, 182, 93,\n            30, 185, 67, 166, 22, 34, 10, 213, 112, 21, 136, 49, 214,\n        ];\n        let r2: [u8; 32] = [\n            46, 135, 19, 242, 111, 125, 59, 215, 114, 130, 122, 155, 202, 23, 36, 118, 83, 11, 6,\n            180, 97, 165, 218, 136, 134, 243, 191, 191, 149, 178, 7, 149,\n        ];\n        let r3: [u8; 32] = [\n            9, 2, 131, 50, 199, 170, 6, 68, 168, 28, 242, 182, 35, 114, 15, 163, 65, 139, 101, 221,\n            207, 147, 119, 110, 81, 195, 6, 134, 14, 253, 245, 244,\n        ];\n        let r4: [u8; 32] = [\n            68, 196, 114, 205, 225, 64, 201, 179, 18, 77, 216, 197, 211, 13, 21, 196, 11, 102, 106,\n            195, 138, 250, 29, 185, 51, 38, 183, 0, 5, 169, 65, 190,\n        ];\n        assert_eq!(r1, rng.rand_bytes());\n        assert_eq!(r2, rng.rand_bytes());\n        assert_eq!(r3, rng.rand_bytes());\n        assert_eq!(r4, rng.rand_bytes());\n    }\n}\n","traces":[{"line":6,"address":[7200224],"length":1,"stats":{"Line":2},"fn_name":"sha_256"},{"line":7,"address":[7200267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[7200287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[7200297],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[7200346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[7200367],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2383440,2383408,2383413],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":53,"address":[2383447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2383482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[2383738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[2383994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[2384250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[2384506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[2384673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[2384840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[2385007],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":28},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","src","receiver.rs"],"content":"#![allow(clippy::field_reassign_with_default)] // This is triggered in `#[derive(JsonSchema)]`\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{to_binary, Binary, CosmosMsg, HumanAddr, StdResult, Uint128, WasmMsg};\n\nuse crate::{contract::RESPONSE_BLOCK_SIZE, msg::space_pad};\n\n/// Snip20ReceiveMsg should be de/serialized under `Receive()` variant in a HandleMsg\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct Snip20ReceiveMsg {\n    pub sender: HumanAddr,\n    pub from: HumanAddr,\n    pub amount: Uint128,\n    pub msg: Option\u003cBinary\u003e,\n}\n\nimpl Snip20ReceiveMsg {\n    pub fn new(sender: HumanAddr, from: HumanAddr, amount: Uint128, msg: Option\u003cBinary\u003e) -\u003e Self {\n        Self {\n            sender,\n            from,\n            amount,\n            msg,\n        }\n    }\n\n    /// serializes the message, and pads it to 256 bytes\n    pub fn into_binary(self) -\u003e StdResult\u003cBinary\u003e {\n        let msg = ReceiverHandleMsg::Receive(self);\n        let mut data = to_binary(\u0026msg)?;\n        space_pad(RESPONSE_BLOCK_SIZE, \u0026mut data.0);\n        Ok(data)\n    }\n\n    /// creates a cosmos_msg sending this struct to the named contract\n    pub fn into_cosmos_msg(\n        self,\n        callback_code_hash: String,\n        contract_addr: HumanAddr,\n    ) -\u003e StdResult\u003cCosmosMsg\u003e {\n        let msg = self.into_binary()?;\n        let execute = WasmMsg::Execute {\n            msg,\n            callback_code_hash,\n            contract_addr,\n            send: vec![],\n        };\n        Ok(execute.into())\n    }\n}\n\n// This is just a helper to properly serialize the above message\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\nenum ReceiverHandleMsg {\n    Receive(Snip20ReceiveMsg),\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","src","state.rs"],"content":"use std::any::type_name;\nuse std::convert::TryFrom;\n\nuse cosmwasm_std::Binary;\nuse cosmwasm_std::{\n    Api, CanonicalAddr, Coin, HumanAddr, ReadonlyStorage, StdError, StdResult, Storage, Uint128,\n};\nuse cosmwasm_storage::singleton;\nuse cosmwasm_storage::{PrefixedStorage, ReadonlyPrefixedStorage};\n\nuse secret_toolkit::storage::{AppendStore, AppendStoreMut, TypedStore, TypedStoreMut};\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::msg::{status_level_to_u8, u8_to_status_level, ContractStatusLevel};\nuse crate::viewing_key::ViewingKey;\nuse serde::de::DeserializeOwned;\n\npub static CONFIG_KEY: \u0026[u8] = b\"config\";\npub const PREFIX_TXS: \u0026[u8] = b\"transfers\";\n\npub const KEY_CONSTANTS: \u0026[u8] = b\"constants\";\npub const KEY_TOTAL_SUPPLY: \u0026[u8] = b\"total_supply\";\npub const KEY_CONTRACT_STATUS: \u0026[u8] = b\"contract_status\";\npub const KEY_MINTERS: \u0026[u8] = b\"minters\";\npub const KEY_TX_COUNT: \u0026[u8] = b\"tx-count\";\n\npub const PREFIX_CONFIG: \u0026[u8] = b\"config\";\npub const PREFIX_BALANCES: \u0026[u8] = b\"balances\";\npub const PREFIX_ALLOWANCES: \u0026[u8] = b\"allowances\";\npub const PREFIX_VIEW_KEY: \u0026[u8] = b\"viewingkey\";\npub const PREFIX_RECEIVERS: \u0026[u8] = b\"receivers\";\npub const PREFIX_USER_INDEXIS: \u0026[u8] = b\"user_indexes\";\npub const INTERESTED_REDIRECTION_ADDRESS: \u0026[u8] = b\"interestRedirectionAddresses\";\npub const REDIRECTED_BALANCES: \u0026[u8] = b\"redirectedBalances\";\n\n// Note that id is a globally incrementing counter.\n// Since it's 64 bits long, even at 50 tx/s it would take\n// over 11 billion years for it to rollback. I'm pretty sure\n// we'll have bigger issues by then.\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\npub struct Tx {\n    pub id: u64,\n    pub from: HumanAddr,\n    pub sender: HumanAddr,\n    pub receiver: HumanAddr,\n    pub coins: Coin,\n    // The timestamp and block height are optional so that the JSON schema\n    // reflects that some SNIP-20 contracts may not include this info.\n    pub timestamp: Option\u003cu64\u003e,\n    pub block_height: Option\u003cu64\u003e,\n}\n\nimpl Tx {\n    pub fn into_stored\u003cA: Api\u003e(self, api: \u0026A) -\u003e StdResult\u003cStoredTx\u003e {\n        let tx = StoredTx {\n            id: self.id,\n            from: api.canonical_address(\u0026self.from)?,\n            sender: api.canonical_address(\u0026self.sender)?,\n            receiver: api.canonical_address(\u0026self.receiver)?,\n            coins: self.coins,\n            timestamp: self.timestamp.unwrap_or(0),\n            block_height: self.block_height.unwrap_or(0),\n        };\n        Ok(tx)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct StoredTx {\n    pub id: u64,\n    pub from: CanonicalAddr,\n    pub sender: CanonicalAddr,\n    pub receiver: CanonicalAddr,\n    pub coins: Coin,\n    pub timestamp: u64,\n    pub block_height: u64,\n}\n\nimpl StoredTx {\n    pub fn into_humanized\u003cA: Api\u003e(self, api: \u0026A) -\u003e StdResult\u003cTx\u003e {\n        let tx = Tx {\n            id: self.id,\n            from: api.human_address(\u0026self.from)?,\n            sender: api.human_address(\u0026self.sender)?,\n            receiver: api.human_address(\u0026self.receiver)?,\n            coins: self.coins,\n            timestamp: Some(self.timestamp),\n            block_height: Some(self.block_height),\n        };\n        Ok(tx)\n    }\n}\n\npub fn store_transfer\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    owner: \u0026CanonicalAddr,\n    sender: \u0026CanonicalAddr,\n    receiver: \u0026CanonicalAddr,\n    amount: Uint128,\n    denom: String,\n    block: cosmwasm_std::BlockInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let mut config = Config::from_storage(store);\n    let id = config.tx_count() + 1;\n    config.set_tx_count(id)?;\n\n    let coins = Coin { denom, amount };\n    let tx = StoredTx {\n        id,\n        from: owner.clone(),\n        sender: sender.clone(),\n        receiver: receiver.clone(),\n        coins,\n        timestamp: block.time,\n        block_height: block.height,\n    };\n\n    if owner != sender {\n        append_tx(store, tx.clone(), \u0026owner)?;\n    }\n    append_tx(store, tx.clone(), \u0026sender)?;\n    append_tx(store, tx, \u0026receiver)?;\n\n    Ok(())\n}\n\nfn append_tx\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    tx: StoredTx,\n    for_address: \u0026CanonicalAddr,\n) -\u003e StdResult\u003c()\u003e {\n    let mut store = PrefixedStorage::multilevel(\u0026[PREFIX_TXS, for_address.as_slice()], store);\n    let mut store = AppendStoreMut::attach_or_create(\u0026mut store)?;\n    store.push(\u0026tx)\n}\n\npub fn get_transfers\u003cA: Api, S: ReadonlyStorage\u003e(\n    api: \u0026A,\n    storage: \u0026S,\n    for_address: \u0026CanonicalAddr,\n    page: u32,\n    page_size: u32,\n) -\u003e StdResult\u003c(Vec\u003cTx\u003e, u64)\u003e {\n    let store = ReadonlyPrefixedStorage::multilevel(\u0026[PREFIX_TXS, for_address.as_slice()], storage);\n\n    // Try to access the storage of txs for the account.\n    // If it doesn't exist yet, return an empty list of transfers.\n    let store = if let Some(result) = AppendStore::\u003cStoredTx, _\u003e::attach(\u0026store) {\n        result?\n    } else {\n        return Ok((vec![], 0));\n    };\n\n    // Take `page_size` txs starting from the latest tx, potentially skipping `page * page_size`\n    // txs from the start.\n    let tx_iter = store\n        .iter()\n        .rev()\n        .skip((page * page_size) as _)\n        .take(page_size as _);\n    // The `and_then` here flattens the `StdResult\u003cStdResult\u003cTx\u003e\u003e` to an `StdResult\u003cTx\u003e`\n    let txs: StdResult\u003cVec\u003cTx\u003e\u003e = tx_iter\n        .map(|tx| tx.map(|tx| tx.into_humanized(api)).and_then(|x| x))\n        .collect();\n    txs.map(|txs| (txs, store.len() as u64))\n}\n\n// Config\n\n#[derive(Serialize, Debug, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct Constants {\n    pub name: String,\n    pub admin: HumanAddr,\n    pub symbol: String,\n    pub decimals: u8,\n    pub prng_seed: Vec\u003cu8\u003e,\n    // privacy configuration\n    pub total_supply_is_public: bool,\n    // is deposit enabled\n    pub deposit_is_enabled: bool,\n    // is redeem enabled\n    pub redeem_is_enabled: bool,\n    // is mint enabled\n    pub mint_is_enabled: bool,\n    // is burn enabled\n    pub burn_is_enabled: bool,\n}\n\npub struct ReadonlyConfig\u003c'a, S: ReadonlyStorage\u003e {\n    storage: ReadonlyPrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyConfig\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a S) -\u003e Self {\n        Self {\n            storage: ReadonlyPrefixedStorage::new(PREFIX_CONFIG, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyConfigImpl\u003cReadonlyPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyConfigImpl(\u0026self.storage)\n    }\n\n    pub fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        self.as_readonly().constants()\n    }\n\n    pub fn total_supply(\u0026self) -\u003e u128 {\n        self.as_readonly().total_supply()\n    }\n\n    pub fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        self.as_readonly().contract_status()\n    }\n\n    pub fn minters(\u0026self) -\u003e Vec\u003cHumanAddr\u003e {\n        self.as_readonly().minters()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        self.as_readonly().tx_count()\n    }\n}\n\nfn set_bin_data\u003cT: Serialize, S: Storage\u003e(storage: \u0026mut S, key: \u0026[u8], data: \u0026T) -\u003e StdResult\u003c()\u003e {\n    let bin_data =\n        bincode2::serialize(\u0026data).map_err(|e| StdError::serialize_err(type_name::\u003cT\u003e(), e))?;\n\n    storage.set(key, \u0026bin_data);\n    Ok(())\n}\n\nfn get_bin_data\u003cT: DeserializeOwned, S: ReadonlyStorage\u003e(storage: \u0026S, key: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n    let bin_data = storage.get(key);\n\n    match bin_data {\n        None =\u003e Err(StdError::not_found(\"Key not found in storage\")),\n        Some(bin_data) =\u003e Ok(bincode2::deserialize::\u003cT\u003e(\u0026bin_data)\n            .map_err(|e| StdError::serialize_err(type_name::\u003cT\u003e(), e))?),\n    }\n}\n\npub struct Config\u003c'a, S: Storage\u003e {\n    storage: PrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: Storage\u003e Config\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a mut S) -\u003e Self {\n        Self {\n            storage: PrefixedStorage::new(PREFIX_CONFIG, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyConfigImpl\u003cPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyConfigImpl(\u0026self.storage)\n    }\n\n    pub fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        self.as_readonly().constants()\n    }\n\n    pub fn set_constants(\u0026mut self, constants: \u0026Constants) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_CONSTANTS, constants)\n    }\n\n    pub fn total_supply(\u0026self) -\u003e u128 {\n        self.as_readonly().total_supply()\n    }\n\n    pub fn set_total_supply(\u0026mut self, supply: u128) {\n        self.storage.set(KEY_TOTAL_SUPPLY, \u0026supply.to_be_bytes());\n    }\n\n    pub fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        self.as_readonly().contract_status()\n    }\n\n    pub fn set_contract_status(\u0026mut self, status: ContractStatusLevel) {\n        let status_u8 = status_level_to_u8(status);\n        self.storage\n            .set(KEY_CONTRACT_STATUS, \u0026status_u8.to_be_bytes());\n    }\n\n    pub fn set_minters(\u0026mut self, minters_to_set: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_MINTERS, \u0026minters_to_set)\n    }\n\n    pub fn add_minters(\u0026mut self, minters_to_add: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        let mut minters = self.minters();\n        minters.extend(minters_to_add);\n\n        self.set_minters(minters)\n    }\n\n    pub fn remove_minters(\u0026mut self, minters_to_remove: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        let mut minters = self.minters();\n\n        for minter in minters_to_remove {\n            minters.retain(|x| x != \u0026minter);\n        }\n\n        self.set_minters(minters)\n    }\n\n    pub fn minters(\u0026mut self) -\u003e Vec\u003cHumanAddr\u003e {\n        self.as_readonly().minters()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        self.as_readonly().tx_count()\n    }\n\n    pub fn set_tx_count(\u0026mut self, count: u64) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_TX_COUNT, \u0026count)\n    }\n}\n\n/// This struct refactors out the readonly methods that we need for `Config` and `ReadonlyConfig`\n/// in a way that is generic over their mutability.\n///\n/// This was the only way to prevent code duplication of these methods because of the way\n/// that `ReadonlyPrefixedStorage` and `PrefixedStorage` are implemented in `cosmwasm-std`\nstruct ReadonlyConfigImpl\u003c'a, S: ReadonlyStorage\u003e(\u0026'a S);\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyConfigImpl\u003c'a, S\u003e {\n    fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        let consts_bytes = self\n            .0\n            .get(KEY_CONSTANTS)\n            .ok_or_else(|| StdError::generic_err(\"no constants stored in configuration\"))?;\n        bincode2::deserialize::\u003cConstants\u003e(\u0026consts_bytes)\n            .map_err(|e| StdError::serialize_err(type_name::\u003cConstants\u003e(), e))\n    }\n\n    fn total_supply(\u0026self) -\u003e u128 {\n        let supply_bytes = self\n            .0\n            .get(KEY_TOTAL_SUPPLY)\n            .expect(\"no total supply stored in config\");\n        // This unwrap is ok because we know we stored things correctly\n        slice_to_u128(\u0026supply_bytes).unwrap()\n    }\n\n    fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        let supply_bytes = self\n            .0\n            .get(KEY_CONTRACT_STATUS)\n            .expect(\"no contract status stored in config\");\n\n        // These unwraps are ok because we know we stored things correctly\n        let status = slice_to_u8(\u0026supply_bytes).unwrap();\n        u8_to_status_level(status).unwrap()\n    }\n\n    fn minters(\u0026self) -\u003e Vec\u003cHumanAddr\u003e {\n        get_bin_data(self.0, KEY_MINTERS).unwrap()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        get_bin_data(self.0, KEY_TX_COUNT).unwrap_or_default()\n    }\n}\n\n// Balances\n\npub struct ReadonlyBalances\u003c'a, S: ReadonlyStorage\u003e {\n    storage: ReadonlyPrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyBalances\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a S) -\u003e Self {\n        Self {\n            storage: ReadonlyPrefixedStorage::new(PREFIX_BALANCES, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyBalancesImpl\u003cReadonlyPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyBalancesImpl(\u0026self.storage)\n    }\n\n    pub fn account_amount(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        self.as_readonly().account_amount(account)\n    }\n}\n\npub struct Balances\u003c'a, S: Storage\u003e {\n    storage: PrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: Storage\u003e Balances\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a mut S) -\u003e Self {\n        Self {\n            storage: PrefixedStorage::new(PREFIX_BALANCES, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyBalancesImpl\u003cPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyBalancesImpl(\u0026self.storage)\n    }\n\n    pub fn balance(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        self.as_readonly().account_amount(account)\n    }\n\n    pub fn set_account_balance(\u0026mut self, account: \u0026CanonicalAddr, amount: u128) {\n        self.storage.set(account.as_slice(), \u0026amount.to_be_bytes())\n    }\n}\n\n/// This struct refactors out the readonly methods that we need for `Balances` and `ReadonlyBalances`\n/// in a way that is generic over their mutability.\n///\n/// This was the only way to prevent code duplication of these methods because of the way\n/// that `ReadonlyPrefixedStorage` and `PrefixedStorage` are implemented in `cosmwasm-std`\nstruct ReadonlyBalancesImpl\u003c'a, S: ReadonlyStorage\u003e(\u0026'a S);\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyBalancesImpl\u003c'a, S\u003e {\n    pub fn account_amount(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        let account_bytes = account.as_slice();\n        let result = self.0.get(account_bytes);\n        match result {\n            // This unwrap is ok because we know we stored things correctly\n            Some(balance_bytes) =\u003e slice_to_u128(\u0026balance_bytes).unwrap(),\n            None =\u003e 0,\n        }\n    }\n}\n\n#[derive(Serialize, Debug, Deserialize, Clone, PartialEq, Default, JsonSchema)]\npub struct Allowance {\n    pub amount: u128,\n    pub expiration: Option\u003cu64\u003e,\n}\n\npub fn read_allowance\u003cS: Storage\u003e(\n    store: \u0026S,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n) -\u003e StdResult\u003cAllowance\u003e {\n    let owner_store =\n        ReadonlyPrefixedStorage::multilevel(\u0026[PREFIX_ALLOWANCES, owner.as_slice()], store);\n    let owner_store = TypedStore::attach(\u0026owner_store);\n    let allowance = owner_store.may_load(spender.as_slice());\n    allowance.map(Option::unwrap_or_default)\n}\n\npub fn write_allowance\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n    allowance: Allowance,\n) -\u003e StdResult\u003c()\u003e {\n    let mut owner_store =\n        PrefixedStorage::multilevel(\u0026[PREFIX_ALLOWANCES, owner.as_slice()], store);\n    let mut owner_store = TypedStoreMut::attach(\u0026mut owner_store);\n\n    owner_store.store(spender.as_slice(), \u0026allowance)\n}\n\n// Viewing Keys\n\npub fn write_viewing_key\u003cS: Storage\u003e(store: \u0026mut S, owner: \u0026CanonicalAddr, key: \u0026ViewingKey) {\n    let mut balance_store = PrefixedStorage::new(PREFIX_VIEW_KEY, store);\n    balance_store.set(owner.as_slice(), \u0026key.to_hashed());\n}\n\npub fn read_viewing_key\u003cS: Storage\u003e(store: \u0026S, owner: \u0026CanonicalAddr) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n    let balance_store = ReadonlyPrefixedStorage::new(PREFIX_VIEW_KEY, store);\n    balance_store.get(owner.as_slice())\n}\n\n// Receiver Interface\n\npub fn get_receiver_hash\u003cS: ReadonlyStorage\u003e(\n    store: \u0026S,\n    account: \u0026HumanAddr,\n) -\u003e Option\u003cStdResult\u003cString\u003e\u003e {\n    let store = ReadonlyPrefixedStorage::new(PREFIX_RECEIVERS, store);\n    store.get(account.as_str().as_bytes()).map(|data| {\n        String::from_utf8(data)\n            .map_err(|_err| StdError::invalid_utf8(\"stored code hash was not a valid String\"))\n    })\n}\n// Get user index inteface\npub fn get_user_index\u003cS: ReadonlyStorage\u003e(storage: \u0026S, account: \u0026HumanAddr) -\u003e Option\u003cBinary\u003e {\n    let store = ReadonlyPrefixedStorage::new(PREFIX_USER_INDEXIS, storage);\n    let result = store.get(account.as_str().as_bytes())?;\n    Some(Binary::from(result.as_slice()))\n}\n\n// Get interested redirection address\npub fn get_interested_redirection_address\u003cS: ReadonlyStorage\u003e(\n    storage: \u0026S,\n    account: \u0026HumanAddr,\n) -\u003e Option\u003cBinary\u003e {\n    let store = ReadonlyPrefixedStorage::new(INTERESTED_REDIRECTION_ADDRESS, storage);\n    let result = store.get(account.as_str().as_bytes())?;\n    Some(Binary::from(result.as_slice()))\n}\n\n// Get the total redirected balance\npub fn get_redirection_balance\u003cS: ReadonlyStorage\u003e(\n    storage: \u0026S,\n    account: \u0026HumanAddr,\n) -\u003e Option\u003cBinary\u003e {\n    let store = ReadonlyPrefixedStorage::new(REDIRECTED_BALANCES, storage);\n    let result = store.get(account.as_str().as_bytes())?;\n    Some(Binary::from(result.as_slice()))\n}\n\npub fn set_receiver_hash\u003cS: Storage\u003e(store: \u0026mut S, account: \u0026HumanAddr, code_hash: String) {\n    let mut store = PrefixedStorage::new(PREFIX_RECEIVERS, store);\n    store.set(account.as_str().as_bytes(), code_hash.as_bytes());\n}\n\n// Helpers\n\n/// Converts 16 bytes value into u128\n/// Errors if data found that is not 16 bytes\nfn slice_to_u128(data: \u0026[u8]) -\u003e StdResult\u003cu128\u003e {\n    match \u003c[u8; 16]\u003e::try_from(data) {\n        Ok(bytes) =\u003e Ok(u128::from_be_bytes(bytes)),\n        Err(_) =\u003e Err(StdError::generic_err(\n            \"Corrupted data found. 16 byte expected.\",\n        )),\n    }\n}\n\n/// Converts 1 byte value into u8\n/// Errors if data found that is not 1 byte\nfn slice_to_u8(data: \u0026[u8]) -\u003e StdResult\u003cu8\u003e {\n    if data.len() == 1 {\n        Ok(data[0])\n    } else {\n        Err(StdError::generic_err(\n            \"Corrupted data found. 1 byte expected.\",\n        ))\n    }\n}\n","traces":[{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[540912,543168],"length":1,"stats":{"Line":1},"fn_name":"store_transfer\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":105,"address":[541033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[543400,541088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[541336,543314,541157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[541226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[541313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[541582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[541602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[541691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[541688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[541927,542012,541881],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[543251,541920,542017,541937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[542279,542442,543249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[542781,542366,542704,543247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[542740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[544268,543664],"length":1,"stats":{"Line":1},"fn_name":"append_tx\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":134,"address":[543720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[543948,544283,543828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[543938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[544352,545734],"length":1,"stats":{"Line":1},"fn_name":"get_transfers\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":146,"address":[544434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[544543,544609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[544713,544928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[544599,545179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[545402,544918,545315,545371],"length":1,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[545330,545931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[545382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[545409,545470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[545462,546011,546064,546076,546096,545968,546137],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":167,"address":[545529,546240,546273],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[547623,546800,547191,547232,547664,548055],"length":1,"stats":{"Line":5},"fn_name":"set_bin_data\u003calloc::vec::Vec\u003ccosmwasm_std::addresses::HumanAddr, alloc::alloc::Global\u003e,cosmwasm_storage::prefixed_storage::PrefixedStorage\u003ccosmwasm_std::storage::MemoryStorage\u003e\u003e"},{"line":228,"address":[547293,547016,548114,548258,548402,548096,546861,548240,547880,548384,547725,547448],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}\u003calloc::vec::Vec\u003ccosmwasm_std::addresses::HumanAddr, alloc::alloc::Global\u003e,cosmwasm_storage::prefixed_storage::PrefixedStorage\u003ccosmwasm_std::storage::MemoryStorage\u003e\u003e"},{"line":231,"address":[546985,548001,547417,547137,547569,547849],"length":1,"stats":{"Line":10},"fn_name":null},{"line":232,"address":[547149,547581,548013],"length":1,"stats":{"Line":5},"fn_name":null},{"line":235,"address":[548528,550817,550080,549265,549328,550008],"length":1,"stats":{"Line":2},"fn_name":"get_bin_data\u003calloc::vec::Vec\u003ccosmwasm_std::addresses::HumanAddr, alloc::alloc::Global\u003e,cosmwasm_storage::prefixed_storage::ReadonlyPrefixedStorage\u003ccosmwasm_std::storage::MemoryStorage\u003e\u003e"},{"line":236,"address":[549369,550121,548569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[550269,549458,548657,548717,549518,550209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[549379,550131,549460,550211,548579,548659],"length":1,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[549209,548817,549718,549672,550761,550291,548739,548975,548597,549397,549533,550369,549952,550527,550149],"length":1,"stats":{"Line":6},"fn_name":null},{"line":241,"address":[550815,551024,549650,550344,550880,551168,548792,550768,551042,549216,549699,549959,550508,549245,549263,550797,551186,548956,548977,549720,550529,550006,549988,550898],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003calloc::vec::Vec\u003ccosmwasm_std::addresses::HumanAddr, alloc::alloc::Global\u003e,cosmwasm_storage::prefixed_storage::PrefixedStorage\u003ccosmwasm_std::storage::MemoryStorage\u003e\u003e"},{"line":250,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[557234,556832],"length":1,"stats":{"Line":1},"fn_name":"read_allowance\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":442,"address":[556896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[556992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[557025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[557090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[557280,557571],"length":1,"stats":{"Line":1},"fn_name":"write_allowance\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":455,"address":[557349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[557445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[557478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[557616,557804],"length":1,"stats":{"Line":1},"fn_name":"write_viewing_key\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":465,"address":[557654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[557681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[557856,557997],"length":1,"stats":{"Line":1},"fn_name":"read_viewing_key\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":470,"address":[557888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[557915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[558269,558032],"length":1,"stats":{"Line":1},"fn_name":"get_receiver_hash\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":480,"address":[558070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[558097,558212,558416],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":482,"address":[558430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[558336,558320],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":487,"address":[558496,558982],"length":1,"stats":{"Line":0},"fn_name":"get_user_index\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":488,"address":[558537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[558564,558828,558997,558682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[558875,558796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[559072,559558],"length":1,"stats":{"Line":0},"fn_name":"get_interested_redirection_address\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":498,"address":[559113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[559258,559140,559573,559404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[559451,559372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[559648,560134],"length":1,"stats":{"Line":0},"fn_name":"get_redirection_balance\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":508,"address":[559689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[560149,559834,559980,559716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[560027,559948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[560224,560513],"length":1,"stats":{"Line":1},"fn_name":"set_receiver_hash\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":514,"address":[560257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[560406,560286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":522,"address":[560576],"length":1,"stats":{"Line":1},"fn_name":"slice_to_u128"},{"line":523,"address":[560609,560733,560656],"length":1,"stats":{"Line":3},"fn_name":null},{"line":524,"address":[560620,560658],"length":1,"stats":{"Line":4},"fn_name":null},{"line":525,"address":[560631,560740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[560784],"length":1,"stats":{"Line":1},"fn_name":"slice_to_u8"},{"line":534,"address":[560843,560927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":535,"address":[560979,560919,560870],"length":1,"stats":{"Line":2},"fn_name":null},{"line":537,"address":[560934,560884],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":154,"coverable":192},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","src","utils.rs"],"content":"use crate::viewing_key::VIEWING_KEY_SIZE;\nuse sha2::{Digest, Sha256};\nuse std::convert::TryInto;\nuse subtle::ConstantTimeEq;\n\npub fn ct_slice_compare(s1: \u0026[u8], s2: \u0026[u8]) -\u003e bool {\n    bool::from(s1.ct_eq(s2))\n}\n\npub fn create_hashed_password(s1: \u0026str) -\u003e [u8; VIEWING_KEY_SIZE] {\n    Sha256::digest(s1.as_bytes())\n        .as_slice()\n        .try_into()\n        .expect(\"Wrong password length\")\n}\n","traces":[{"line":6,"address":[2668288],"length":1,"stats":{"Line":1},"fn_name":"ct_slice_compare"},{"line":7,"address":[2668312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[2668352],"length":1,"stats":{"Line":1},"fn_name":"create_hashed_password"},{"line":11,"address":[2668450],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","src","viewing_key.rs"],"content":"use std::fmt;\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::Env;\n\nuse crate::rand::{sha_256, Prng};\nuse crate::utils::{create_hashed_password, ct_slice_compare};\n\npub const VIEWING_KEY_SIZE: usize = 32;\npub const VIEWING_KEY_PREFIX: \u0026str = \"api_key_\";\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\npub struct ViewingKey(pub String);\n\nimpl ViewingKey {\n    pub fn check_viewing_key(\u0026self, hashed_pw: \u0026[u8]) -\u003e bool {\n        let mine_hashed = create_hashed_password(\u0026self.0);\n\n        ct_slice_compare(\u0026mine_hashed, hashed_pw)\n    }\n\n    pub fn new(env: \u0026Env, seed: \u0026[u8], entropy: \u0026[u8]) -\u003e Self {\n        // 16 here represents the lengths in bytes of the block height and time.\n        let entropy_len = 16 + env.message.sender.len() + entropy.len();\n        let mut rng_entropy = Vec::with_capacity(entropy_len);\n        rng_entropy.extend_from_slice(\u0026env.block.height.to_be_bytes());\n        rng_entropy.extend_from_slice(\u0026env.block.time.to_be_bytes());\n        rng_entropy.extend_from_slice(\u0026env.message.sender.0.as_bytes());\n        rng_entropy.extend_from_slice(entropy);\n\n        let mut rng = Prng::new(seed, \u0026rng_entropy);\n\n        let rand_slice = rng.rand_bytes();\n\n        let key = sha_256(\u0026rand_slice);\n\n        Self(VIEWING_KEY_PREFIX.to_string() + \u0026base64::encode(key))\n    }\n\n    pub fn to_hashed(\u0026self) -\u003e [u8; VIEWING_KEY_SIZE] {\n        create_hashed_password(\u0026self.0)\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        self.0.as_bytes()\n    }\n}\n\nimpl fmt::Display for ViewingKey {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[2373933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[2373978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2374961,2374016],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":26,"address":[2374112,2375004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2374229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":20},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","tests","example-receiver","src","contract.rs"],"content":"use cosmwasm_std::{\n    from_binary, to_binary, Api, BankMsg, Binary, Coin, Context, CosmosMsg, Env, Extern,\n    HandleResponse, HumanAddr, InitResponse, Querier, StdError, StdResult, Storage, Uint128,\n    WasmMsg,\n};\n\nuse crate::msg::{CountResponse, HandleMsg, InitMsg, QueryMsg, Snip20Msg};\nuse crate::state::{config, config_read, State};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let state = State {\n        count: msg.count,\n        owner: deps.api.canonical_address(\u0026env.message.sender)?,\n        known_snip_20: vec![],\n    };\n\n    config(\u0026mut deps.storage).save(\u0026state)?;\n\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Increment {} =\u003e try_increment(deps, env),\n        HandleMsg::Reset { count } =\u003e try_reset(deps, env, count),\n        HandleMsg::Register { reg_addr, reg_hash } =\u003e try_register(deps, env, reg_addr, reg_hash),\n        HandleMsg::Receive {\n            sender,\n            from,\n            amount,\n            msg,\n        } =\u003e try_receive(deps, env, sender, from, amount, msg),\n        HandleMsg::Redeem {\n            addr,\n            hash,\n            to,\n            amount,\n        } =\u003e try_redeem(deps, env, addr, hash, to, amount),\n        HandleMsg::Fail {} =\u003e try_fail(),\n    }\n}\n\npub fn try_increment\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut count = 0;\n    config(\u0026mut deps.storage).update(|mut state| {\n        state.count += 1;\n        count = state.count;\n        Ok(state)\n    })?;\n\n    let mut context = Context::new();\n    context.add_log(\"count\", count.to_string());\n\n    Ok(context.into())\n}\n\npub fn try_reset\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    count: i32,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender_address_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n    config(\u0026mut deps.storage).update(|mut state| {\n        if sender_address_raw != state.owner {\n            return Err(StdError::Unauthorized { backtrace: None });\n        }\n        state.count = count;\n        Ok(state)\n    })?;\n    Ok(HandleResponse::default())\n}\n\npub fn try_register\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    reg_addr: HumanAddr,\n    reg_hash: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut conf = config(\u0026mut deps.storage);\n    let mut state = conf.load()?;\n    if !state.known_snip_20.contains(\u0026reg_addr) {\n        state.known_snip_20.push(reg_addr.clone());\n    }\n    conf.save(\u0026state)?;\n\n    let msg = to_binary(\u0026Snip20Msg::register_receive(env.contract_code_hash))?;\n    let message = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: reg_addr,\n        callback_code_hash: reg_hash,\n        msg,\n        send: vec![],\n    });\n\n    Ok(HandleResponse {\n        messages: vec![message],\n        log: vec![],\n        data: None,\n    })\n}\n\npub fn try_receive\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    _sender: HumanAddr,\n    _from: HumanAddr,\n    _amount: Uint128,\n    msg: Binary,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let msg: HandleMsg = from_binary(\u0026msg)?;\n\n    if matches!(msg, HandleMsg::Receive { .. }) {\n        return Err(StdError::generic_err(\n            \"Recursive call to receive() is not allowed\",\n        ));\n    }\n\n    let state = config_read(\u0026deps.storage).load()?;\n    if !state.known_snip_20.contains(\u0026env.message.sender) {\n        return Err(StdError::generic_err(format!(\n            \"{} is not a known SNIP-20 coin that this contract registered to\",\n            env.message.sender\n        )));\n    }\n\n    /* use sender \u0026 amount */\n    handle(deps, env, msg)\n}\n\nfn try_redeem\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    addr: HumanAddr,\n    hash: String,\n    to: HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let state = config_read(\u0026deps.storage).load()?;\n    if !state.known_snip_20.contains(\u0026addr) {\n        return Err(StdError::generic_err(format!(\n            \"{} is not a known SNIP-20 coin that this contract registered to\",\n            addr\n        )));\n    }\n\n    let msg = to_binary(\u0026Snip20Msg::redeem(amount))?;\n    let secret_redeem = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: addr,\n        callback_code_hash: hash,\n        msg,\n        send: vec![],\n    });\n    let redeem = CosmosMsg::Bank(BankMsg::Send {\n        amount: vec![Coin::new(amount.u128(), \"uscrt\")],\n        from_address: env.contract.address,\n        to_address: to,\n    });\n\n    Ok(HandleResponse {\n        messages: vec![secret_redeem, redeem],\n        log: vec![],\n        data: None,\n    })\n}\n\nfn try_fail() -\u003e StdResult\u003cHandleResponse\u003e {\n    Err(StdError::generic_err(\"intentional failure\"))\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::GetCount {} =\u003e to_binary(\u0026query_count(deps)?),\n    }\n}\n\nfn query_count\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cCountResponse\u003e {\n    let state = config_read(\u0026deps.storage).load()?;\n    Ok(CountResponse { count: state.count })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","tests","example-receiver","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\npub mod state;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","tests","example-receiver","src","msg.rs"],"content":"use cosmwasm_std::{Binary, HumanAddr, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n    pub count: i32,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    Increment {},\n    Reset {\n        count: i32,\n    },\n    Register {\n        reg_addr: HumanAddr,\n        reg_hash: String,\n    },\n    Receive {\n        sender: HumanAddr,\n        from: HumanAddr,\n        amount: Uint128,\n        msg: Binary,\n    },\n    Redeem {\n        addr: HumanAddr,\n        hash: String,\n        to: HumanAddr,\n        amount: Uint128,\n    },\n    Fail {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    // GetCount returns the current count as a json-encoded number\n    GetCount {},\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct CountResponse {\n    pub count: i32,\n}\n\n// Messages sent to SNIP-20 contracts\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum Snip20Msg {\n    RegisterReceive {\n        code_hash: String,\n        padding: Option\u003cString\u003e,\n    },\n    Redeem {\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n}\n\nimpl Snip20Msg {\n    pub fn register_receive(code_hash: String) -\u003e Self {\n        Snip20Msg::RegisterReceive {\n            code_hash,\n            padding: None, // TODO add padding calculation\n        }\n    }\n\n    pub fn redeem(amount: Uint128) -\u003e Self {\n        Snip20Msg::Redeem {\n            amount,\n            padding: None, // TODO add padding calculation\n        }\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","tests","example-receiver","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{CanonicalAddr, HumanAddr, Storage};\nuse cosmwasm_storage::{singleton, singleton_read, ReadonlySingleton, Singleton};\n\npub static CONFIG_KEY: \u0026[u8] = b\"config\";\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct State {\n    pub count: i32,\n    pub owner: CanonicalAddr,\n    pub known_snip_20: Vec\u003cHumanAddr\u003e,\n}\n\npub fn config\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, State\u003e {\n    singleton(storage, CONFIG_KEY)\n}\n\npub fn config_read\u003cS: Storage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, State\u003e {\n    singleton_read(storage, CONFIG_KEY)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-lend-experimental","tests","integration.rs"],"content":"#[test]\n#[ignore]\nfn empty_test() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","src","contract.rs"],"content":"/// This contract implements SNIP-20 standard:\n/// https://github.com/SecretFoundation/SNIPs/blob/master/SNIP-20.md\nuse cosmwasm_std::{\n    log, to_binary, Api, Binary, CanonicalAddr, CosmosMsg, Env, Extern,\n    HandleResponse, HumanAddr, InitResponse, Querier, QueryResult, ReadonlyStorage, StdError,\n    StdResult, Storage, Uint128,\n};\n\nuse crate::msg::{\n    space_pad, ContractStatusLevel, HandleAnswer, HandleMsg, InitMsg, QueryAnswer, QueryMsg,\n    ResponseStatus::Success,\n};\nuse crate::rand::sha_256;\nuse crate::receiver::Snip20ReceiveMsg;\nuse crate::state::{\n    get_receiver_hash, get_transfers, read_allowance, read_viewing_key, set_receiver_hash,\n    store_transfer, write_allowance, write_viewing_key, Balances, Config, Constants,\n    ReadonlyBalances, ReadonlyConfig,\n};\nuse crate::viewing_key::{ViewingKey, VIEWING_KEY_SIZE};\n\n/// We make sure that responses from `handle` are padded to a multiple of this size.\npub const RESPONSE_BLOCK_SIZE: usize = 256;\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let init_config = msg.config();\n    let mut total_supply: u128 = 0;\n    {\n        let mut balances = Balances::from_storage(\u0026mut deps.storage);\n        let initial_balances = msg.initial_balances.unwrap_or_default();\n        for balance in initial_balances {\n            let balance_address = deps.api.canonical_address(\u0026balance.address)?;\n            let amount = balance.amount.u128();\n            balances.set_account_balance(\u0026balance_address, amount);\n            if let Some(new_total_supply) = total_supply.checked_add(amount) {\n                total_supply = new_total_supply;\n            } else {\n                return Err(StdError::generic_err(\n                    \"The sum of all initial balances exceeds the maximum possible total supply\",\n                ));\n            }\n        }\n    }\n\n    // Check name, symbol, decimals\n    if !is_valid_name(\u0026msg.name) {\n        return Err(StdError::generic_err(\n            \"Name is not in the expected format (3-30 UTF-8 bytes)\",\n        ));\n    }\n    if !is_valid_symbol(\u0026msg.symbol) {\n        return Err(StdError::generic_err(\n            \"Ticker symbol is not in expected format [A-Z]{3,6}\",\n        ));\n    }\n    if msg.decimals \u003e 18 {\n        return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n    }\n\n    let admin = msg.admin.unwrap_or_else(|| env.message.sender);\n\n    let prng_seed_hashed = sha_256(\u0026msg.prng_seed.0);\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    config.set_constants(\u0026Constants {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n        admin: admin.clone(),\n        prng_seed: prng_seed_hashed.to_vec(),\n        total_supply_is_public: init_config.public_total_supply(),\n    })?;\n    config.set_total_supply(total_supply);\n    config.set_contract_status(ContractStatusLevel::NormalRun);\n    config.set_minters(Vec::from([admin]))?;\n\n    Ok(InitResponse::default())\n}\n\nfn pad_response(response: StdResult\u003cHandleResponse\u003e) -\u003e StdResult\u003cHandleResponse\u003e {\n    response.map(|mut response| {\n        response.data = response.data.map(|mut data| {\n            space_pad(RESPONSE_BLOCK_SIZE, \u0026mut data.0);\n            data\n        });\n        response\n    })\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let contract_status = ReadonlyConfig::from_storage(\u0026deps.storage).contract_status();\n\n    match contract_status {\n        ContractStatusLevel::StopAll =\u003e {\n            let response = match msg {\n                HandleMsg::SetContractStatus { level, .. } =\u003e set_contract_status(deps, env, level),\n                _ =\u003e Err(StdError::generic_err(\n                    \"This contract is stopped and this action is not allowed\",\n                )),\n            };\n            return pad_response(response);\n        }\n        ContractStatusLevel::NormalRun =\u003e {} // If it's a normal run just continue\n    }\n\n    let response = match msg {\n        HandleMsg::ChangeAdmin { address, .. } =\u003e change_admin(deps, env, address),\n        HandleMsg::SetContractStatus { level, .. } =\u003e set_contract_status(deps, env, level),\n\n        HandleMsg::SetMinters { minters, .. } =\u003e set_minters(deps, env, minters),\n        HandleMsg::AddMinters { minters, .. } =\u003e add_minters(deps, env, minters),\n        HandleMsg::RemoveMinters { minters, .. } =\u003e remove_minters(deps, env, minters),\n        HandleMsg::Mint { recipient, amount, .. } =\u003e try_mint(deps, env, recipient, amount),\n        HandleMsg::Burn { amount, .. } =\u003e try_burn(deps, env, amount),\n        HandleMsg::BurnFrom { owner, amount, .. } =\u003e try_burn_from(deps, env, \u0026owner, amount),\n\n        HandleMsg::Deposit  { .. } =\u003e Err(StdError::generic_err(\"not allowed.\")),\n        HandleMsg::Redeem   { .. } =\u003e Err(StdError::generic_err(\"not allowed.\")),\n\n        HandleMsg::Transfer { recipient, amount, .. } =\u003e\n            try_transfer(deps, env, \u0026recipient, amount),\n        HandleMsg::TransferFrom { owner, recipient, amount, .. } =\u003e\n            try_transfer_from(deps, env, \u0026owner, \u0026recipient, amount),\n        HandleMsg::Send { recipient, amount, msg, .. } =\u003e\n            try_send(deps, env, \u0026recipient, amount, msg),\n        HandleMsg::SendFrom { owner, recipient, amount, msg, .. } =\u003e\n            try_send_from(deps, env, \u0026owner, \u0026recipient, amount, msg),\n\n        HandleMsg::CreateViewingKey { entropy, .. } =\u003e try_create_key(deps, env, entropy),\n        HandleMsg::SetViewingKey { key, .. } =\u003e try_set_key(deps, env, key),\n        HandleMsg::RegisterReceive { code_hash, .. } =\u003e try_register_receive(deps, env, code_hash),\n\n        HandleMsg::IncreaseAllowance { spender, amount, expiration, .. } =\u003e\n            try_increase_allowance(deps, env, spender, amount, expiration),\n        HandleMsg::DecreaseAllowance { spender, amount, expiration, .. } =\u003e\n            try_decrease_allowance(deps, env, spender, amount, expiration),\n    };\n\n    pad_response(response)\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e, msg: QueryMsg) -\u003e QueryResult {\n    match msg {\n        QueryMsg::TokenInfo {} =\u003e query_token_info(\u0026deps.storage),\n        QueryMsg::ExchangeRate {} =\u003e query_exchange_rate(),\n        QueryMsg::Minters { .. } =\u003e query_minters(deps),\n        _ =\u003e authenticated_queries(deps, msg),\n    }\n}\n\npub fn authenticated_queries\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e QueryResult {\n    let (addresses, key) = msg.get_validation_params();\n\n    for address in addresses {\n        let canonical_addr = deps.api.canonical_address(address)?;\n\n        let expected_key = read_viewing_key(\u0026deps.storage, \u0026canonical_addr);\n\n        if expected_key.is_none() {\n            // Checking the key will take significant time. We don't want to exit immediately if it isn't set\n            // in a way which will allow to time the command and determine if a viewing key doesn't exist\n            key.check_viewing_key(\u0026[0u8; VIEWING_KEY_SIZE]);\n        } else if key.check_viewing_key(expected_key.unwrap().as_slice()) {\n            return match msg {\n                // Base\n                QueryMsg::Balance { address, .. } =\u003e query_balance(\u0026deps, \u0026address),\n                QueryMsg::TransferHistory {\n                    address,\n                    page,\n                    page_size,\n                    ..\n                } =\u003e query_transactions(\u0026deps, \u0026address, page.unwrap_or(0), page_size),\n                QueryMsg::Allowance { owner, spender, .. } =\u003e {\n                    try_check_allowance(deps, owner, spender)\n                }\n                _ =\u003e panic!(\"This query type does not require authentication\"),\n            };\n        }\n    }\n\n    Ok(to_binary(\u0026QueryAnswer::ViewingKeyError {\n        msg: \"Wrong viewing key for this address or viewing key not set\".to_string(),\n    })?)\n}\n\n/// This function just returns a constant 1:1 rate to uscrt, since that's the purpose of this\n/// contract.\nfn query_exchange_rate() -\u003e QueryResult {\n    to_binary(\u0026QueryAnswer::ExchangeRate {\n        rate: Uint128(1),\n        denom: \"uscrt\".to_string(),\n    })\n}\n\nfn query_token_info\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e QueryResult {\n    let config = ReadonlyConfig::from_storage(storage);\n    let constants = config.constants()?;\n\n    let total_supply = if constants.total_supply_is_public {\n        Some(Uint128(config.total_supply()))\n    } else {\n        None\n    };\n\n    to_binary(\u0026QueryAnswer::TokenInfo {\n        name: constants.name,\n        symbol: constants.symbol,\n        decimals: constants.decimals,\n        total_supply,\n    })\n}\n\npub fn query_transactions\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n    page: u32,\n    page_size: u32,\n) -\u003e StdResult\u003cBinary\u003e {\n    let address = deps.api.canonical_address(account).unwrap();\n    let txs = get_transfers(\u0026deps.api, \u0026deps.storage, \u0026address, page, page_size)?;\n\n    let result = QueryAnswer::TransferHistory { txs };\n    to_binary(\u0026result)\n}\n\npub fn query_balance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    account: \u0026HumanAddr,\n) -\u003e StdResult\u003cBinary\u003e {\n    let address = deps.api.canonical_address(account)?;\n\n    let amount = Uint128(ReadonlyBalances::from_storage(\u0026deps.storage).account_amount(\u0026address));\n    let response = QueryAnswer::Balance { amount };\n    to_binary(\u0026response)\n}\n\nfn query_minters\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cBinary\u003e {\n    let minters = ReadonlyConfig::from_storage(\u0026deps.storage).minters();\n\n    let response = QueryAnswer::Minters { minters };\n    to_binary(\u0026response)\n}\n\nfn change_admin\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    address: HumanAddr,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    let mut consts = config.constants()?;\n    consts.admin = address;\n    config.set_constants(\u0026consts)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::ChangeAdmin { status: Success })?),\n    })\n}\n\nfn try_mint\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    address: HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    let minters = config.minters();\n    if !minters.contains(\u0026env.message.sender) {\n        return Err(StdError::generic_err(\n            \"Minting is allowed to minter accounts only\",\n        ));\n    }\n\n    let amount = amount.u128();\n\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_add(amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"This mint attempt would increase the total supply above the supported maximum\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    let receipient_account = \u0026deps.api.canonical_address(\u0026address)?;\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n\n    let mut account_balance = balances.balance(receipient_account);\n\n    if let Some(new_balance) = account_balance.checked_add(amount) {\n        account_balance = new_balance;\n    } else {\n        // This error literally can not happen, since the account's funds are a subset\n        // of the total supply, both are stored as u128, and we check for overflow of\n        // the total supply just a couple lines before.\n        // Still, writing this to cover all overflows.\n        return Err(StdError::generic_err(\n            \"This mint attempt would increase the account's balance above the supported maximum\",\n        ));\n    }\n\n    balances.set_account_balance(receipient_account, account_balance);\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Mint { status: Success })?),\n    };\n\n    Ok(res)\n}\n\npub fn try_set_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    key: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let vk = ViewingKey(key);\n\n    let message_sender = deps.api.canonical_address(\u0026env.message.sender)?;\n    write_viewing_key(\u0026mut deps.storage, \u0026message_sender, \u0026vk);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetViewingKey { status: Success })?),\n    })\n}\n\npub fn try_create_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    entropy: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let constants = ReadonlyConfig::from_storage(\u0026deps.storage).constants()?;\n    let prng_seed = constants.prng_seed;\n\n    let key = ViewingKey::new(\u0026env, \u0026prng_seed, (\u0026entropy).as_ref());\n\n    let message_sender = deps.api.canonical_address(\u0026env.message.sender)?;\n    write_viewing_key(\u0026mut deps.storage, \u0026message_sender, \u0026key);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::CreateViewingKey { key })?),\n    })\n}\n\nfn set_contract_status\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    status_level: ContractStatusLevel,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.set_contract_status(status_level);\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetContractStatus {\n            status: Success,\n        })?),\n    })\n}\n\npub fn try_check_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    owner: HumanAddr,\n    spender: HumanAddr,\n) -\u003e StdResult\u003cBinary\u003e {\n    let owner_address = deps.api.canonical_address(\u0026owner)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n\n    let response = QueryAnswer::Allowance {\n        owner,\n        spender,\n        allowance: Uint128(allowance.amount),\n        expiration: allowance.expiration,\n    };\n    to_binary(\u0026response)\n}\n\nfn try_transfer_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let recipient_address = deps.api.canonical_address(recipient)?;\n\n    perform_transfer(\n        \u0026mut deps.storage,\n        \u0026sender_address,\n        \u0026recipient_address,\n        amount.u128(),\n    )?;\n\n    let symbol = Config::from_storage(\u0026mut deps.storage).constants()?.symbol;\n\n    store_transfer(\n        \u0026mut deps.storage,\n        \u0026sender_address,\n        \u0026sender_address,\n        \u0026recipient_address,\n        amount,\n        symbol,\n    )?;\n\n    Ok(())\n}\n\nfn try_transfer\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    try_transfer_impl(deps, env, recipient, amount)?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Transfer { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_add_receiver_api_callback\u003cS: ReadonlyStorage\u003e(\n    messages: \u0026mut Vec\u003cCosmosMsg\u003e,\n    storage: \u0026S,\n    recipient: \u0026HumanAddr,\n    msg: Option\u003cBinary\u003e,\n    sender: HumanAddr,\n    from: HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let receiver_hash = get_receiver_hash(storage, recipient);\n    if let Some(receiver_hash) = receiver_hash {\n        let receiver_hash = receiver_hash?;\n        let receiver_msg = Snip20ReceiveMsg::new(sender, from, amount, msg);\n        let callback_msg = receiver_msg.into_cosmos_msg(receiver_hash, recipient.clone())?;\n\n        messages.push(callback_msg);\n    }\n    Ok(())\n}\n\nfn try_send\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n    msg: Option\u003cBinary\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender = env.message.sender.clone();\n    try_transfer_impl(deps, env, recipient, amount)?;\n\n    let mut messages = vec![];\n\n    try_add_receiver_api_callback(\n        \u0026mut messages,\n        \u0026deps.storage,\n        recipient,\n        msg,\n        sender.clone(),\n        sender,\n        amount,\n    )?;\n\n    let res = HandleResponse {\n        messages,\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Send { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_register_receive\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    code_hash: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    set_receiver_hash(\u0026mut deps.storage, \u0026env.message.sender, code_hash);\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![log(\"register_status\", \"success\")],\n        data: Some(to_binary(\u0026HandleAnswer::RegisterReceive {\n            status: Success,\n        })?),\n    };\n    Ok(res)\n}\n\nfn insufficient_allowance(allowance: u128, required: u128) -\u003e StdError {\n    StdError::generic_err(format!(\n        \"insufficient allowance: allowance={}, required={}\",\n        allowance, required\n    ))\n}\n\nfn try_transfer_from_impl\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let spender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let owner_address = deps.api.canonical_address(owner)?;\n    let recipient_address = deps.api.canonical_address(recipient)?;\n    let amount_raw = amount.u128();\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n\n    if allowance.expiration.map(|ex| ex \u003c env.block.time) == Some(true) {\n        allowance.amount = 0;\n        write_allowance(\n            \u0026mut deps.storage,\n            \u0026owner_address,\n            \u0026spender_address,\n            allowance,\n        )?;\n        return Err(insufficient_allowance(0, amount_raw));\n    }\n\n    if let Some(new_allowance) = allowance.amount.checked_sub(amount_raw) {\n        allowance.amount = new_allowance;\n    } else {\n        return Err(insufficient_allowance(allowance.amount, amount_raw));\n    }\n\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n    perform_transfer(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026recipient_address,\n        amount_raw,\n    )?;\n\n    let symbol = Config::from_storage(\u0026mut deps.storage).constants()?.symbol;\n\n    store_transfer(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        \u0026recipient_address,\n        amount,\n        symbol,\n    )?;\n\n    Ok(())\n}\n\nfn try_transfer_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    try_transfer_from_impl(deps, env, owner, recipient, amount)?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::TransferFrom { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_send_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: Uint128,\n    msg: Option\u003cBinary\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender = env.message.sender.clone();\n    try_transfer_from_impl(deps, env, owner, recipient, amount)?;\n\n    let mut messages = vec![];\n\n    try_add_receiver_api_callback(\n        \u0026mut messages,\n        \u0026deps.storage,\n        recipient,\n        msg,\n        sender,\n        owner.clone(),\n        amount,\n    )?;\n\n    let res = HandleResponse {\n        messages,\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SendFrom { status: Success })?),\n    };\n    Ok(res)\n}\n\nfn try_burn_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let spender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let owner_address = deps.api.canonical_address(owner)?;\n    let amount = amount.u128();\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n\n    if allowance.expiration.map(|ex| ex \u003c env.block.time) == Some(true) {\n        allowance.amount = 0;\n        write_allowance(\n            \u0026mut deps.storage,\n            \u0026owner_address,\n            \u0026spender_address,\n            allowance,\n        )?;\n        return Err(insufficient_allowance(0, amount));\n    }\n\n    if let Some(new_allowance) = allowance.amount.checked_sub(amount) {\n        allowance.amount = new_allowance;\n    } else {\n        return Err(insufficient_allowance(allowance.amount, amount));\n    }\n\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    // subtract from owner account\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let mut account_balance = balances.balance(\u0026owner_address);\n\n    if let Some(new_balance) = account_balance.checked_sub(amount) {\n        account_balance = new_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to burn: balance={}, required={}\",\n            account_balance, amount\n        )));\n    }\n    balances.set_account_balance(\u0026owner_address, account_balance);\n\n    // remove from supply\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_sub(amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"You're trying to burn more than is available in the total supply\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::BurnFrom { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn try_increase_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    spender: HumanAddr,\n    amount: Uint128,\n    expiration: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let owner_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n    allowance.amount = allowance.amount.saturating_add(amount.u128());\n    if expiration.is_some() {\n        allowance.expiration = expiration;\n    }\n    let new_amount = allowance.amount;\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::IncreaseAllowance {\n            owner: env.message.sender,\n            spender,\n            allowance: Uint128(new_amount),\n        })?),\n    };\n    Ok(res)\n}\n\nfn try_decrease_allowance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    spender: HumanAddr,\n    amount: Uint128,\n    expiration: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let owner_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let spender_address = deps.api.canonical_address(\u0026spender)?;\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address, \u0026spender_address)?;\n    allowance.amount = allowance.amount.saturating_sub(amount.u128());\n    if expiration.is_some() {\n        allowance.expiration = expiration;\n    }\n    let new_amount = allowance.amount;\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address,\n        \u0026spender_address,\n        allowance,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::DecreaseAllowance {\n            owner: env.message.sender,\n            spender,\n            allowance: Uint128(new_amount),\n        })?),\n    };\n    Ok(res)\n}\n\nfn add_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_add: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.add_minters(minters_to_add)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::AddMinters { status: Success })?),\n    })\n}\n\nfn remove_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_remove: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.remove_minters(minters_to_remove)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::RemoveMinters { status: Success })?),\n    })\n}\n\nfn set_minters\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    minters_to_set: Vec\u003cHumanAddr\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n\n    check_if_admin(\u0026config, \u0026env.message.sender)?;\n\n    config.set_minters(minters_to_set)?;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::SetMinters { status: Success })?),\n    })\n}\n\n/// Burn tokens\n///\n/// Remove `amount` tokens from the system irreversibly, from signer account\n///\n/// @param amount the amount of money to burn\nfn try_burn\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender_address = deps.api.canonical_address(\u0026env.message.sender)?;\n    let amount = amount.u128();\n\n    let mut balances = Balances::from_storage(\u0026mut deps.storage);\n    let mut account_balance = balances.balance(\u0026sender_address);\n\n    if let Some(new_account_balance) = account_balance.checked_sub(amount) {\n        account_balance = new_account_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to burn: balance={}, required={}\",\n            account_balance, amount\n        )));\n    }\n\n    balances.set_account_balance(\u0026sender_address, account_balance);\n\n    let mut config = Config::from_storage(\u0026mut deps.storage);\n    let mut total_supply = config.total_supply();\n    if let Some(new_total_supply) = total_supply.checked_sub(amount) {\n        total_supply = new_total_supply;\n    } else {\n        return Err(StdError::generic_err(\n            \"You're trying to burn more than is available in the total supply\",\n        ));\n    }\n    config.set_total_supply(total_supply);\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(to_binary(\u0026HandleAnswer::Burn { status: Success })?),\n    };\n\n    Ok(res)\n}\n\nfn perform_transfer\u003cT: Storage\u003e(\n    store: \u0026mut T,\n    from: \u0026CanonicalAddr,\n    to: \u0026CanonicalAddr,\n    amount: u128,\n) -\u003e StdResult\u003c()\u003e {\n    let mut balances = Balances::from_storage(store);\n\n    let mut from_balance = balances.balance(from);\n    if let Some(new_from_balance) = from_balance.checked_sub(amount) {\n        from_balance = new_from_balance;\n    } else {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds: balance={}, required={}\",\n            from_balance, amount\n        )));\n    }\n    balances.set_account_balance(from, from_balance);\n\n    let mut to_balance = balances.balance(to);\n    to_balance = to_balance.checked_add(amount).ok_or_else(|| {\n        StdError::generic_err(\"This tx will literally make them too rich. Try transferring less\")\n    })?;\n    balances.set_account_balance(to, to_balance);\n\n    Ok(())\n}\n\nfn is_admin\u003cS: Storage\u003e(config: \u0026Config\u003cS\u003e, account: \u0026HumanAddr) -\u003e StdResult\u003cbool\u003e {\n    let consts = config.constants()?;\n    if \u0026consts.admin != account {\n        return Ok(false);\n    }\n\n    Ok(true)\n}\n\nfn check_if_admin\u003cS: Storage\u003e(config: \u0026Config\u003cS\u003e, account: \u0026HumanAddr) -\u003e StdResult\u003c()\u003e {\n    if !is_admin(config, account)? {\n        return Err(StdError::generic_err(\n            \"This is an admin command. Admin commands can only be run from admin address\",\n        ));\n    }\n\n    Ok(())\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let len = name.len();\n    3 \u003c= len \u0026\u0026 len \u003c= 30\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let len = symbol.len();\n    let len_is_valid = 3 \u003c= len \u0026\u0026 len \u003c= 6;\n\n    len_is_valid \u0026\u0026 symbol.bytes().all(|byte| b'A' \u003c= byte \u0026\u0026 byte \u003c= b'Z')\n}\n\n// pub fn migrate\u003cS: Storage, A: Api, Q: Querier\u003e(\n//     _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n//     _env: Env,\n//     _msg: MigrateMsg,\n// ) -\u003e StdResult\u003cMigrateResponse\u003e {\n//     Ok(MigrateResponse::default())\n// }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::msg::ResponseStatus;\n    use crate::msg::{InitConfig, InitialBalance};\n    use cosmwasm_std::testing::*;\n    use cosmwasm_std::{from_binary, BlockInfo, ContractInfo, MessageInfo, QueryResponse, WasmMsg};\n    use std::any::Any;\n\n    // Helper functions\n\n    fn init_helper(\n        initial_balances: Vec\u003cInitialBalance\u003e,\n    ) -\u003e (\n        StdResult\u003cInitResponse\u003e,\n        Extern\u003cMockStorage, MockApi, MockQuerier\u003e,\n    ) {\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n\n        let init_msg = InitMsg {\n            name: \"sec-sec\".to_string(),\n            admin: Some(HumanAddr(\"admin\".to_string())),\n            symbol: \"SECSEC\".to_string(),\n            decimals: 8,\n            initial_balances: Some(initial_balances),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: None,\n        };\n\n        (init(\u0026mut deps, env, init_msg), deps)\n    }\n\n    fn extract_error_msg\u003cT: Any\u003e(error: StdResult\u003cT\u003e) -\u003e String {\n        match error {\n            Ok(response) =\u003e {\n                let bin_err = (\u0026response as \u0026dyn Any)\n                    .downcast_ref::\u003cQueryResponse\u003e()\n                    .expect(\"An error was expected, but no error could be extracted\");\n                match from_binary(bin_err).unwrap() {\n                    QueryAnswer::ViewingKeyError { msg } =\u003e msg,\n                    _ =\u003e panic!(\"Unexpected query answer\"),\n                }\n            }\n            Err(err) =\u003e match err {\n                StdError::GenericErr { msg, .. } =\u003e msg,\n                _ =\u003e panic!(\"Unexpected result from init\"),\n            },\n        }\n    }\n\n    fn ensure_success(handle_result: HandleResponse) -\u003e bool {\n        let handle_result: HandleAnswer = from_binary(\u0026handle_result.data.unwrap()).unwrap();\n\n        match handle_result {\n            HandleAnswer::Deposit { status }\n            | HandleAnswer::Redeem { status }\n            | HandleAnswer::Transfer { status }\n            | HandleAnswer::Send { status }\n            | HandleAnswer::Burn { status }\n            | HandleAnswer::RegisterReceive { status }\n            | HandleAnswer::SetViewingKey { status }\n            | HandleAnswer::TransferFrom { status }\n            | HandleAnswer::SendFrom { status }\n            | HandleAnswer::BurnFrom { status }\n            | HandleAnswer::Mint { status }\n            | HandleAnswer::ChangeAdmin { status }\n            | HandleAnswer::SetContractStatus { status }\n            | HandleAnswer::SetMinters { status }\n            | HandleAnswer::AddMinters { status }\n            | HandleAnswer::RemoveMinters { status } =\u003e {\n                matches!(status, ResponseStatus::Success {..})\n            }\n            _ =\u003e panic!(\"HandleAnswer not supported for success extraction\"),\n        }\n    }\n\n    // Init tests\n\n    #[test]\n    fn test_init_sanity() {\n        let (init_result, deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert_eq!(init_result.unwrap(), InitResponse::default());\n\n        let config = ReadonlyConfig::from_storage(\u0026deps.storage);\n        let constants = config.constants().unwrap();\n        assert_eq!(config.total_supply(), 5000);\n        assert_eq!(config.contract_status(), ContractStatusLevel::NormalRun);\n        assert_eq!(constants.name, \"sec-sec\".to_string());\n        assert_eq!(constants.admin, HumanAddr(\"admin\".to_string()));\n        assert_eq!(constants.symbol, \"SECSEC\".to_string());\n        assert_eq!(constants.decimals, 8);\n        assert_eq!(\n            constants.prng_seed,\n            sha_256(\"lolz fun yay\".to_owned().as_bytes())\n        );\n        assert_eq!(constants.total_supply_is_public, false);\n    }\n\n    #[test]\n    fn test_total_supply_overflow() {\n        let (init_result, _deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(u128::max_value()),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let (init_result, _deps) = init_helper(vec![\n            InitialBalance {\n                address: HumanAddr(\"lebron\".to_string()),\n                amount: Uint128(u128::max_value()),\n            },\n            InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: Uint128(1),\n            },\n        ]);\n        let error = extract_error_msg(init_result);\n        assert_eq!(\n            error,\n            \"The sum of all initial balances exceeds the maximum possible total supply\"\n        );\n    }\n\n    // Handle tests\n\n    #[test]\n    fn test_handle_transfer() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n        let balances = ReadonlyBalances::from_storage(\u0026deps.storage);\n        assert_eq!(5000 - 1000, balances.account_amount(\u0026bob_canonical));\n        assert_eq!(1000, balances.account_amount(\u0026alice_canonical));\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(10000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient funds\"));\n    }\n\n    #[test]\n    fn test_handle_send() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let handle_msg = HandleMsg::Send {\n            recipient: HumanAddr(\"contract\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n            msg: Some(to_binary(\"hey hey you you\").unwrap()),\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result.clone()));\n        assert!(result.messages.contains(\u0026CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: HumanAddr(\"contract\".to_string()),\n            callback_code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            msg: Snip20ReceiveMsg::new(\n                HumanAddr(\"bob\".to_string()),\n                HumanAddr(\"bob\".to_string()),\n                Uint128(100),\n                Some(to_binary(\"hey hey you you\").unwrap())\n            )\n            .into_binary()\n            .unwrap(),\n            send: vec![]\n        })));\n    }\n\n    #[test]\n    fn test_handle_register_receive() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"this_is_a_hash_of_a_code\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let hash = get_receiver_hash(\u0026deps.storage, \u0026HumanAddr(\"contract\".to_string()))\n            .unwrap()\n            .unwrap();\n        assert_eq!(hash, \"this_is_a_hash_of_a_code\".to_string());\n    }\n\n    #[test]\n    fn test_handle_create_viewing_key() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::CreateViewingKey {\n            entropy: \"\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let answer: HandleAnswer = from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n\n        let key = match answer {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"NOPE\"),\n        };\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let saved_vk = read_viewing_key(\u0026deps.storage, \u0026bob_canonical).unwrap();\n        assert!(key.check_viewing_key(saved_vk.as_slice()));\n    }\n\n    #[test]\n    fn test_handle_set_viewing_key() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Set VK\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"hi lol\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        // Set valid VK\n        let actual_vk = ViewingKey(\"x\".to_string().repeat(VIEWING_KEY_SIZE));\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: actual_vk.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey { status: Success }).unwrap(),\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let saved_vk = read_viewing_key(\u0026deps.storage, \u0026bob_canonical).unwrap();\n        assert!(actual_vk.check_viewing_key(\u0026saved_vk));\n    }\n\n    #[test]\n    fn test_handle_transfer_from() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Transfer before allowance\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Transfer more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: Some(1_571_797_420),\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Transfer after allowance expired\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n        };\n        let handle_result = handle(\n            \u0026mut deps,\n            Env {\n                block: BlockInfo {\n                    height: 12_345,\n                    time: 1_571_797_420,\n                    chain_id: \"cosmos-testnet-14002\".to_string(),\n                },\n                message: MessageInfo {\n                    sender: HumanAddr(\"bob\".to_string()),\n                    sent_funds: vec![],\n                },\n                contract: ContractInfo {\n                    address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n                },\n                contract_key: Some(\"\".to_string()),\n                contract_code_hash: \"\".to_string(),\n            },\n            handle_msg,\n        );\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        let alice_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026alice_canonical);\n        assert_eq!(bob_balance, 5000 - 2000);\n        assert_eq!(alice_balance, 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 5000);\n\n        // Second send more than allowance\n        let handle_msg = HandleMsg::TransferFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_send_from() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Send before allowance\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Send more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2500),\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::RegisterReceive {\n            code_hash: \"lolz\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"contract\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let send_msg = Binary::from(r#\"{ \"some_msg\": { \"some_key\": \"some_val\" } }\"#.as_bytes());\n        let snip20_msg = Snip20ReceiveMsg::new(\n            HumanAddr(\"alice\".to_string()),\n            HumanAddr(\"bob\".to_string()),\n            Uint128(2000),\n            Some(send_msg.clone()),\n        );\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"contract\".to_string()),\n            amount: Uint128(2000),\n            msg: Some(send_msg),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        assert!(handle_result.unwrap().messages.contains(\n            \u0026snip20_msg\n                .into_cosmos_msg(\"lolz\".to_string(), HumanAddr(\"contract\".to_string()))\n                .unwrap()\n        ));\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let contract_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"contract\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        let contract_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026contract_canonical);\n        assert_eq!(bob_balance, 5000 - 2000);\n        assert_eq!(contract_balance, 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 5000);\n\n        // Second send more than allowance\n        let handle_msg = HandleMsg::SendFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1),\n            msg: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_burn_from() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        // Burn before allowance\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Burn more than allowance\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n\n        // Sanity check\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let bob_balance = crate::state::ReadonlyBalances::from_storage(\u0026deps.storage)\n            .account_amount(\u0026bob_canonical);\n        assert_eq!(bob_balance, 5000 - 2000);\n        let total_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(total_supply, 5000 - 2000);\n\n        // Second burn more than allowance\n        let handle_msg = HandleMsg::BurnFrom {\n            owner: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(1),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"alice\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"insufficient allowance\"));\n    }\n\n    #[test]\n    fn test_handle_decrease_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::DecreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 0,\n                expiration: None\n            }\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::DecreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(50),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 1950,\n                expiration: None\n            }\n        );\n    }\n\n    #[test]\n    fn test_handle_increase_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let bob_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"bob\".to_string()))\n            .unwrap();\n        let alice_canonical = deps\n            .api\n            .canonical_address(\u0026HumanAddr(\"alice\".to_string()))\n            .unwrap();\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 2000,\n                expiration: None\n            }\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let allowance = read_allowance(\u0026deps.storage, \u0026bob_canonical, \u0026alice_canonical).unwrap();\n        assert_eq!(\n            allowance,\n            crate::state::Allowance {\n                amount: 4000,\n                expiration: None\n            }\n        );\n    }\n\n    #[test]\n    fn test_handle_change_admin() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::ChangeAdmin {\n            address: HumanAddr(\"bob\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let admin = ReadonlyConfig::from_storage(\u0026deps.storage)\n            .constants()\n            .unwrap()\n            .admin;\n        assert_eq!(admin, HumanAddr(\"bob\".to_string()));\n    }\n\n    #[test]\n    fn test_handle_set_contract_status() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"admin\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAll,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let contract_status = ReadonlyConfig::from_storage(\u0026deps.storage).contract_status();\n        assert!(matches!(contract_status, ContractStatusLevel::StopAll{..}));\n    }\n\n    #[test]\n    fn test_handle_burn() {\n        let initial_amount: u128 = 5000;\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(initial_amount),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        let burn_amount: u128 = 100;\n        let handle_msg = HandleMsg::Burn {\n            amount: Uint128(burn_amount),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let new_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(new_supply, supply - burn_amount);\n    }\n\n    #[test]\n    fn test_handle_mint() {\n        let initial_amount: u128 = 5000;\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(initial_amount),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        let mint_amount: u128 = 100;\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(mint_amount),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let new_supply = ReadonlyConfig::from_storage(\u0026deps.storage).total_supply();\n        assert_eq!(new_supply, supply + mint_amount);\n    }\n\n    #[test]\n    fn test_handle_admin_commands() {\n        let admin_err = \"Admin commands can only be run from admin address\".to_string();\n\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAll,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), pause_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"not_admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let mint_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"not_admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), mint_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n\n        let change_admin_msg = HandleMsg::ChangeAdmin {\n            address: HumanAddr(\"not_admin\".to_string()),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"not_admin\", \u0026[]), change_admin_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\u0026admin_err.clone()));\n    }\n\n    #[test]\n    fn test_handle_pause_all() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let pause_msg = HandleMsg::SetContractStatus {\n            level: ContractStatusLevel::StopAll,\n            padding: None,\n        };\n\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), pause_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"Pause handle failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let send_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"account\".to_string()),\n            amount: Uint128(123),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), send_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n\n        let withdraw_msg = HandleMsg::Redeem {\n            amount: Uint128(5000),\n            denom: None,\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), withdraw_msg);\n        let error = extract_error_msg(handle_result);\n        assert_eq!(\n            error,\n            \"This contract is stopped and this action is not allowed\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_handle_set_minters() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::SetMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n    }\n\n    #[test]\n    fn test_handle_add_minters() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::AddMinters {\n            minters: vec![HumanAddr(\"bob\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n    }\n\n    #[test]\n    fn test_handle_remove_minters() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"Admin commands can only be run from admin address\"));\n\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        // Removing another extra time to ensure nothing funky happens\n        let handle_msg = HandleMsg::RemoveMinters {\n            minters: vec![HumanAddr(\"admin\".to_string())],\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n\n        let handle_msg = HandleMsg::Mint {\n            recipient: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(100),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"admin\", \u0026[]), handle_msg);\n        let error = extract_error_msg(handle_result);\n        assert!(error.contains(\"allowed to minter accounts only\"));\n    }\n\n    // Query tests\n\n    #[test]\n    fn test_authenticated_queries() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"giannis\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let no_vk_yet_query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: \"no_vk_yet\".to_string(),\n        };\n        let query_result = query(\u0026deps, no_vk_yet_query_msg);\n        let error = extract_error_msg(query_result);\n        assert_eq!(\n            error,\n            \"Wrong viewing key for this address or viewing key not set\".to_string()\n        );\n\n        let create_vk_msg = HandleMsg::CreateViewingKey {\n            entropy: \"34\".to_string(),\n            padding: None,\n        };\n        let handle_response = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), create_vk_msg).unwrap();\n        let vk = match from_binary(\u0026handle_response.data.unwrap()).unwrap() {\n            HandleAnswer::CreateViewingKey { key } =\u003e key,\n            _ =\u003e panic!(\"Unexpected result from handle\"),\n        };\n\n        let query_balance_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: vk.0,\n        };\n\n        let query_response = query(\u0026deps, query_balance_msg).unwrap();\n        let balance = match from_binary(\u0026query_response).unwrap() {\n            QueryAnswer::Balance { amount } =\u003e amount,\n            _ =\u003e panic!(\"Unexpected result from query\"),\n        };\n        assert_eq!(balance, Uint128(5000));\n\n        let wrong_vk_query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"giannis\".to_string()),\n            key: \"wrong_vk\".to_string(),\n        };\n        let query_result = query(\u0026deps, wrong_vk_query_msg);\n        let error = extract_error_msg(query_result);\n        assert_eq!(\n            error,\n            \"Wrong viewing key for this address or viewing key not set\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_query_token_info() {\n        let init_name = \"sec-sec\".to_string();\n        let init_admin = HumanAddr(\"admin\".to_string());\n        let init_symbol = \"SECSEC\".to_string();\n        let init_decimals = 8;\n        let init_config: InitConfig = from_binary(\u0026Binary::from(\n            r#\"{ \"public_total_supply\": true }\"#.as_bytes(),\n        ))\n        .unwrap();\n        let init_supply = Uint128(5000);\n\n        let mut deps = mock_dependencies(20, \u0026[]);\n        let env = mock_env(\"instantiator\", \u0026[]);\n        let init_msg = InitMsg {\n            name: init_name.clone(),\n            admin: Some(init_admin.clone()),\n            symbol: init_symbol.clone(),\n            decimals: init_decimals.clone(),\n            initial_balances: Some(vec![InitialBalance {\n                address: HumanAddr(\"giannis\".to_string()),\n                amount: init_supply,\n            }]),\n            prng_seed: Binary::from(\"lolz fun yay\".as_bytes()),\n            config: Some(init_config),\n        };\n        let init_result = init(\u0026mut deps, env, init_msg);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let query_msg = QueryMsg::TokenInfo {};\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Init failed: {}\",\n            query_result.err().unwrap()\n        );\n        let query_answer: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        match query_answer {\n            QueryAnswer::TokenInfo {\n                name,\n                symbol,\n                decimals,\n                total_supply,\n            } =\u003e {\n                assert_eq!(name, init_name);\n                assert_eq!(symbol, init_symbol);\n                assert_eq!(decimals, init_decimals);\n                assert_eq!(total_supply, Some(Uint128(5000)));\n            }\n            _ =\u003e panic!(\"unexpected\"),\n        }\n    }\n\n    #[test]\n    fn test_query_allowance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"giannis\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::IncreaseAllowance {\n            spender: HumanAddr(\"lebron\".to_string()),\n            amount: Uint128(2000),\n            padding: None,\n            expiration: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), handle_msg);\n        assert!(\n            handle_result.is_ok(),\n            \"handle() failed: {}\",\n            handle_result.err().unwrap()\n        );\n\n        let vk1 = ViewingKey(\"key1\".to_string());\n        let vk2 = ViewingKey(\"key2\".to_string());\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk1.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        assert!(\n            query_result.is_ok(),\n            \"Query failed: {}\",\n            query_result.err().unwrap()\n        );\n        let error = extract_error_msg(query_result);\n        assert!(error.contains(\"Wrong viewing key\"));\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: vk1.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"lebron\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: vk2.0.clone(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"giannis\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk1.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(2000));\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"giannis\".to_string()),\n            spender: HumanAddr(\"lebron\".to_string()),\n            key: vk2.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(2000));\n\n        let query_msg = QueryMsg::Allowance {\n            owner: HumanAddr(\"lebron\".to_string()),\n            spender: HumanAddr(\"giannis\".to_string()),\n            key: vk2.0.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let allowance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Allowance { allowance, .. } =\u003e allowance,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(allowance, Uint128(0));\n    }\n\n    #[test]\n    fn test_query_balance() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"key\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let unwrapped_result: HandleAnswer =\n            from_binary(\u0026handle_result.unwrap().data.unwrap()).unwrap();\n        assert_eq!(\n            to_binary(\u0026unwrapped_result).unwrap(),\n            to_binary(\u0026HandleAnswer::SetViewingKey {\n                status: ResponseStatus::Success\n            })\n            .unwrap(),\n        );\n\n        let query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"wrong_key\".to_string(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let error = extract_error_msg(query_result);\n        assert!(error.contains(\"Wrong viewing key\"));\n\n        let query_msg = QueryMsg::Balance {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let balance = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::Balance { amount } =\u003e amount,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(balance, Uint128(5000));\n    }\n\n    #[test]\n    fn test_query_transfer_history() {\n        let (init_result, mut deps) = init_helper(vec![InitialBalance {\n            address: HumanAddr(\"bob\".to_string()),\n            amount: Uint128(5000),\n        }]);\n        assert!(\n            init_result.is_ok(),\n            \"Init failed: {}\",\n            init_result.err().unwrap()\n        );\n\n        let handle_msg = HandleMsg::SetViewingKey {\n            key: \"key\".to_string(),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        assert!(ensure_success(handle_result.unwrap()));\n\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"alice\".to_string()),\n            amount: Uint128(1000),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"banana\".to_string()),\n            amount: Uint128(500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n        let handle_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"mango\".to_string()),\n            amount: Uint128(2500),\n            padding: None,\n        };\n        let handle_result = handle(\u0026mut deps, mock_env(\"bob\", \u0026[]), handle_msg);\n        let result = handle_result.unwrap();\n        assert!(ensure_success(result));\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 0,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        // let a: QueryAnswer = from_binary(\u0026query_result.unwrap()).unwrap();\n        // println!(\"{:?}\", a);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert!(transfers.is_empty());\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 10,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(transfers.len(), 3);\n\n        let query_msg = QueryMsg::TransferHistory {\n            address: HumanAddr(\"bob\".to_string()),\n            key: \"key\".to_string(),\n            page: None,\n            page_size: 2,\n        };\n        let query_result = query(\u0026deps, query_msg);\n        let transfers = match from_binary(\u0026query_result.unwrap()).unwrap() {\n            QueryAnswer::TransferHistory { txs } =\u003e txs,\n            _ =\u003e panic!(\"Unexpected\"),\n        };\n        assert_eq!(transfers.len(), 2);\n    }\n}\n","traces":[{"line":25,"address":[6208704,6212420],"length":1,"stats":{"Line":2},"fn_name":"init\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":30,"address":[6208773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[6208907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[6208939],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[6208954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[6209200,6209009,6210245],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[6209418,6209594,6212727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[6209553,6209856],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[6209888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[6210046,6209908],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[6210078],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[6210015,6210121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[6210273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[6210331,6210405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[6210457,6210370],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[6210482,6210537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[6210521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[6210579,6210729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[6210626,6210779,6213376,6213401],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":66,"address":[6210787],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[6210859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[6211506,6211028,6211269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[6210874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[6210905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[6210937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[6210960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[6210967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[6211007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[6211531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[6211562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[6212683,6211593,6211784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[6211774,6212038],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[1814864],"length":1,"stats":{"Line":1},"fn_name":"pad_response"},{"line":85,"address":[1815056,1815169,1814878],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":86,"address":[1815074,1815016,1814928],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":87,"address":[1814947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1814978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[1815149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[6218814,6214032],"length":1,"stats":{"Line":1},"fn_name":"handle\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":99,"address":[6218782,6214096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[6214546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[6214487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[6214556,6221845,6214612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[6214711,6214565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[6214761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[6216682,6216604,6215211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[6214511,6215229,6221855],"length":1,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[6215389,6221860],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[6221865,6215504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[6215664,6221870],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[6215824,6221875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[6221880,6215984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[6221885,6216200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[6218763,6216344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[6216531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[6216609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[6216703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[6218744,6216775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[6216906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[6217010,6218711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[6217174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[6218692,6217278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[6217449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[6217579,6218659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[6221890,6217775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[6221895,6217929],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[6218083,6221900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[6218237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[6221905,6218337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[6214945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[6215057,6221850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[6218481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[6222869,6222640],"length":1,"stats":{"Line":1},"fn_name":"query\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":152,"address":[6222675,6222820,6222934],"length":1,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[6222936,6222832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[6222849,6222938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[6222932,6222746],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[6222976,6225412],"length":1,"stats":{"Line":1},"fn_name":"authenticated_queries\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":163,"address":[6223014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[6223385,6224602,6223181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[6223419,6223582,6225809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[6223832,6223551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[6223848,6223968,6224118],"length":1,"stats":{"Line":3},"fn_name":null},{"line":173,"address":[6223871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[6225348,6223898,6223973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[6224073,6224166,6225329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[6224245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[6224277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[6224297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[6225310,6224311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[6224402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[6226068,6224466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[6224123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[6224634,6224855,6225081,6224742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[6224607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1815399,1815232],"length":1,"stats":{"Line":0},"fn_name":"query_exchange_rate"},{"line":200,"address":[1815297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1815249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1815267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[6226720,6227577],"length":1,"stats":{"Line":1},"fn_name":"query_token_info\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":207,"address":[6226745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[6226768,6226887,6227657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[6227187,6226868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[6227152,6227199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[6227175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[6227351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[6227264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[6227290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[6227319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[6227327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[6228546,6227840],"length":1,"stats":{"Line":1},"fn_name":"query_transactions\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":230,"address":[6227902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[6228207,6228588,6227962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[6228109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[6228197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[6229164,6228688],"length":1,"stats":{"Line":1},"fn_name":"query_balance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":241,"address":[6228726,6228848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[6228962,6229140,6228841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[6229031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[6229079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[6229463,6229248],"length":1,"stats":{"Line":0},"fn_name":"query_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":249,"address":[6229272,6229453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[6229331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[6229401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[6229568,6231743],"length":1,"stats":{"Line":1},"fn_name":"change_admin\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":260,"address":[6229605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[6229638,6229726,6231916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[6229716,6230284,6229976,6231911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[6230231,6231758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[6231906,6231861,6230546,6230595],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[6231035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[6230585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[6230862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[6231216,6230869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[6234860,6232320],"length":1,"stats":{"Line":1},"fn_name":"try_mint\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":281,"address":[6232402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[6232425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[6232440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[6232516,6232590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[6232642,6232547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[6232666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[6232863,6232725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[6232895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[6232950,6232832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[6232911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[6233177,6234877,6233008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[6233167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[6233442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[6233637,6233501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":309,"address":[6233669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[6233732,6233606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[6233685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[6233782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[6233797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[6234234,6233804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[6234069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[6236529,6235184],"length":1,"stats":{"Line":1},"fn_name":"try_set_key\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":336,"address":[6235218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[6235255,6236546,6235405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[6235395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[6235857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[6235669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[6235684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[6235691,6236039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[6236816,6239214],"length":1,"stats":{"Line":1},"fn_name":"try_create_key\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":353,"address":[6239686,6236859,6239179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[6237451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[6237491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":358,"address":[6239600,6237786,6237624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[6237776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[6238314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[6238053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[6238068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[6238075,6238499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[6240272,6241471],"length":1,"stats":{"Line":1},"fn_name":"set_contract_status\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":373,"address":[6240323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[6240334,6240424,6241488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[6240403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[6240864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[6240676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[6240691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[6240768,6241276,6241042,6240698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":388,"address":[6241712,6243340],"length":1,"stats":{"Line":1},"fn_name":"try_check_allowance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":393,"address":[6241929,6241752,6243359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[6242310,6241903,6243357,6242186],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[6242300,6243355,6242576,6242930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[6242744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[6242776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[6242920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[6243616,6246053],"length":1,"stats":{"Line":1},"fn_name":"try_transfer_impl\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":413,"address":[6243674,6246215,6243843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[6244238,6246210,6243817,6244105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":420,"address":[6244203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[6244859,6246076,6244587,6246200,6245986],"length":1,"stats":{"Line":3},"fn_name":null},{"line":430,"address":[6245459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[6245469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[6245610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[6247626,6246544],"length":1,"stats":{"Line":1},"fn_name":"try_transfer\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":443,"address":[6246626,6246739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[6246724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[6246843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[6246850,6247273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[6247203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[6247744,6249897],"length":1,"stats":{"Line":1},"fn_name":"try_add_receiver_api_callback\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":462,"address":[6247864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[6247972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[6248476,6250167,6248102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[6248341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[6249850,6250088,6248727,6249431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[6249277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[6249703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[6252462,6250464],"length":1,"stats":{"Line":1},"fn_name":"try_send\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":480,"address":[6250570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[6250795,6250655,6252617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[6250785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[6251064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[6251116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[6251143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[6251349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[6252044,6251605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[6251958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[6252992,6254005],"length":1,"stats":{"Line":1},"fn_name":"try_register_receive\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":508,"address":[6253041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[6253082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[6254022,6253099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[6253866,6253226,6253291,6253632],"length":1,"stats":{"Line":2},"fn_name":null},{"line":516,"address":[6253555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[1815440],"length":1,"stats":{"Line":1},"fn_name":"insufficient_allowance"},{"line":520,"address":[1815477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[6259045,6254528],"length":1,"stats":{"Line":1},"fn_name":"try_transfer_from_impl\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":533,"address":[6259230,6254797,6254622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[6254771,6255059,6259225,6255183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":535,"address":[6255445,6259220,6255157,6255571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":536,"address":[6255832,6255533],"length":1,"stats":{"Line":2},"fn_name":null},{"line":538,"address":[6255872,6256036,6259215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[6256286,6255988,6259680,6259693],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":541,"address":[6256340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[6256364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[6256572,6256836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[6256445,6256955,6256874],"length":1,"stats":{"Line":3},"fn_name":null},{"line":552,"address":[6256987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[6256919,6257079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":561,"address":[6257003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[6257776,6259068,6258961,6259195,6257504],"length":1,"stats":{"Line":3},"fn_name":null},{"line":577,"address":[6258376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":578,"address":[6258392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[6258541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":584,"address":[6259712,6260826],"length":1,"stats":{"Line":1},"fn_name":"try_transfer_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":591,"address":[6259815,6259939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[6259924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[6260043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[6260050,6260473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":598,"address":[6260403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[6263028,6260944],"length":1,"stats":{"Line":1},"fn_name":"try_send_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":609,"address":[6261071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[6261315,6263205,6261164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":[6261305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":618,"address":[6261589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[6261628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[6261681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[6261896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":627,"address":[6262152,6262591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[6262505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[6268311,6263584],"length":1,"stats":{"Line":1},"fn_name":"try_burn_from\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":638,"address":[6263669,6263842,6268336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[6268334,6263816,6264239,6264107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":640,"address":[6264512,6264195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":642,"address":[6264722,6264552,6268332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[6268717,6264671,6264978,6268704],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":645,"address":[6265041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[6265065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[6265274,6265570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[6265636,6265726,6265136],"length":1,"stats":{"Line":3},"fn_name":null},{"line":656,"address":[6265758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":658,"address":[6265671,6265853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":665,"address":[6265774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[6265958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[6266233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":672,"address":[6266294,6266532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":673,"address":[6266564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[6266647,6266437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[6266580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[6266924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[6266939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":685,"address":[6267142,6266988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":686,"address":[6267174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[6267229,6267111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[6267190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[6267279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[6267294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[6267731,6267301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":700,"address":[6267566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":703,"address":[6268736,6271924],"length":1,"stats":{"Line":1},"fn_name":"try_increase_allowance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":710,"address":[6272380,6268818,6269017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":711,"address":[6272375,6269406,6268991,6269279],"length":1,"stats":{"Line":2},"fn_name":null},{"line":713,"address":[6269817,6269396,6269668,6272370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":714,"address":[6269756,6270188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":715,"address":[6270212,6270267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":716,"address":[6270235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":718,"address":[6270276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":723,"address":[6270317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":727,"address":[6270443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":728,"address":[6270707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":729,"address":[6271193,6270813,6271427,6270983],"length":1,"stats":{"Line":2},"fn_name":null},{"line":735,"address":[6271457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":738,"address":[6273104,6276287],"length":1,"stats":{"Line":1},"fn_name":"try_decrease_allowance\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":745,"address":[6276743,6273186,6273385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":746,"address":[6273774,6273359,6273647,6276738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":748,"address":[6274185,6273764,6274036,6276733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":749,"address":[6274124,6274551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":750,"address":[6274630,6274575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":751,"address":[6274598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[6274639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[6274680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[6274806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":763,"address":[6275070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[6275176,6275346,6275790,6275556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":770,"address":[6275820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":773,"address":[6277456,6279013],"length":1,"stats":{"Line":1},"fn_name":"add_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":778,"address":[6277493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":780,"address":[6277526,6277657,6279061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":782,"address":[6277956,6277595,6279059,6277907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":784,"address":[6278383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[6277946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[6278210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":787,"address":[6278561,6278217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":791,"address":[6279360,6280917],"length":1,"stats":{"Line":1},"fn_name":"remove_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":796,"address":[6279397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":798,"address":[6279430,6280965,6279561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":800,"address":[6279860,6279499,6280963,6279811],"length":1,"stats":{"Line":2},"fn_name":null},{"line":802,"address":[6280287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":803,"address":[6279850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[6280114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":805,"address":[6280121,6280465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":809,"address":[6281264,6282821],"length":1,"stats":{"Line":1},"fn_name":"set_minters\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":814,"address":[6281301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":816,"address":[6281465,6282869,6281334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[6281403,6281715,6282867,6281764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":820,"address":[6282191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":821,"address":[6281754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":822,"address":[6282018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":823,"address":[6282025,6282369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":832,"address":[6285752,6283168],"length":1,"stats":{"Line":1},"fn_name":"try_burn\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":837,"address":[6283406,6283231,6285769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":838,"address":[6283679,6283362],"length":1,"stats":{"Line":2},"fn_name":null},{"line":840,"address":[6283703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[6283726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":843,"address":[6283787,6284025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":844,"address":[6284057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":846,"address":[6284140,6283930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[6284073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[6284417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[6284432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":856,"address":[6284481,6284635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":857,"address":[6284667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":859,"address":[6284604,6284722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[6284683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[6284772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":867,"address":[6284787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":868,"address":[6285224,6284794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":871,"address":[6285059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":874,"address":[6287400,6286016],"length":1,"stats":{"Line":1},"fn_name":"perform_transfer\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":880,"address":[6286095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":882,"address":[6286124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":883,"address":[6286185,6286431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":884,"address":[6286463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":886,"address":[6286328,6286538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":891,"address":[6286479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":893,"address":[6286796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":894,"address":[6287319,6287082,6286845,6287000,6287472],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":895,"address":[6287484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[6287048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":899,"address":[6287336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":902,"address":[6288028,6287520],"length":1,"stats":{"Line":1},"fn_name":"is_admin\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":903,"address":[6287849,6287550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":904,"address":[6287810,6287953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":905,"address":[6287964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":911,"address":[6288080],"length":1,"stats":{"Line":1},"fn_name":"check_if_admin\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":912,"address":[6288112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":913,"address":[6288270,6288315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":918,"address":[6288302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":921,"address":[1815760],"length":1,"stats":{"Line":2},"fn_name":"is_valid_name"},{"line":922,"address":[1815774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":923,"address":[1815792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":926,"address":[1815840],"length":1,"stats":{"Line":2},"fn_name":"is_valid_symbol"},{"line":927,"address":[1815864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":928,"address":[1815884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":930,"address":[1816016,1815919,1816036,1815974],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}"},{"line":952,"address":[1983728,1984710],"length":1,"stats":{"Line":2},"fn_name":"init_helper"},{"line":958,"address":[1983750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":959,"address":[1983805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":962,"address":[1983852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":963,"address":[1983879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":964,"address":[1983970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":966,"address":[1984002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":967,"address":[1984148],"length":1,"stats":{"Line":2},"fn_name":null},{"line":971,"address":[1984343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":974,"address":[1984928,1986268,1985648,1986368,1987030,1985541],"length":1,"stats":{"Line":3},"fn_name":"extract_error_msg\u003ccosmwasm_std::encoding::Binary\u003e"},{"line":975,"address":[1986447,1985007,1985727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[1985670,1986390,1984950,1986454,1985014,1985734],"length":1,"stats":{"Line":4},"fn_name":null},{"line":977,"address":[1986499,1985761,1985032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":980,"address":[1986586,1985848,1985119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":981,"address":[1985153,1985202,1986675,1985931,1985882,1986623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":982,"address":[1986637,1985164,1985893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":985,"address":[1984965,1985685,1986405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":986,"address":[1985334,1986819,1986063,1984987,1985707,1986427],"length":1,"stats":{"Line":4},"fn_name":null},{"line":987,"address":[1986025,1986781,1985296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[1987136,1987717],"length":1,"stats":{"Line":1},"fn_name":"ensure_success"},{"line":993,"address":[1987701,1987148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":995,"address":[1987519,1987483,1987555,1987375,1987420,1987537,1987435,1987573,1987501,1987390,1987450,1987465,1987405,1987627,1987591,1987609],"length":1,"stats":{"Line":8},"fn_name":null},{"line":996,"address":[1987578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1012,"address":[1987335,1987632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1014,"address":[1987302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1021,"address":[1987941,1987968,1990675,1987936],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1022,"address":[1988068,1990717,1987975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1023,"address":[1988009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1026,"address":[1990634,1988331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1028,"address":[1988700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1029,"address":[1988723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1030,"address":[1988768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[1989013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1032,"address":[1990592,1989234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[1990576,1989454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1034,"address":[1990560,1989710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1035,"address":[1989922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1036,"address":[1990075,1990176,1990544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1038,"address":[1990088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1040,"address":[1990343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1044,"address":[1992779,1991040,1991013,1991008],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1045,"address":[1991047,1992860,1991188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1046,"address":[1991089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1047,"address":[1991164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1049,"address":[1991680,1992750,1991466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1050,"address":[1991449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1052,"address":[1991474,1991642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1055,"address":[1992079,1992735,1991596,1992821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1056,"address":[1991900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1057,"address":[1991828,1991612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1058,"address":[1991876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1060,"address":[1992023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1061,"address":[1991964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1065,"address":[1992343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1066,"address":[1992478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1075,"address":[1993136,1993104,1993109,1996254],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1076,"address":[1993252,1993143,1996356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1077,"address":[1993193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1080,"address":[1996225,1993749,1993546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[1993523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1083,"address":[1993711,1993554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1087,"address":[1993903,1993681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1088,"address":[1993935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1091,"address":[1994083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1092,"address":[1994297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1093,"address":[1994423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1094,"address":[1994569,1994646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1096,"address":[1994582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1098,"address":[1994722,1994799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1100,"address":[1994735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1102,"address":[1994891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1103,"address":[1994914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1104,"address":[1995139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1107,"address":[1995348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[1995407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1111,"address":[1995555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1112,"address":[1995769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1113,"address":[1995896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[1996672,1996704,1999924,1996677],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1118,"address":[1996711,1996836,2000079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1119,"address":[1996777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1122,"address":[1999892,1997112,1997306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1123,"address":[1997095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1125,"address":[1997268,1997120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[1997238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1132,"address":[1997546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1133,"address":[1997760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1134,"address":[1997886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1137,"address":[1998032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1138,"address":[1998091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1140,"address":[1998127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1142,"address":[1998360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1143,"address":[1998574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1144,"address":[1998716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1145,"address":[1999342,1999768,1998797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1146,"address":[1998840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1147,"address":[1998899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1148,"address":[1999173,1999276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1149,"address":[1998926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1150,"address":[1998993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1151,"address":[1999060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1152,"address":[1999084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1156,"address":[1999313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1161,"address":[2000448,2000453,2000480,2002300],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1162,"address":[2000487,2000588,2002366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1163,"address":[2000529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1166,"address":[2000861,2002271,2001052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1167,"address":[2000844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1169,"address":[2001014,2000869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1173,"address":[2000984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1176,"address":[2001292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1177,"address":[2001506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1178,"address":[2001632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1180,"address":[2001791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1183,"address":[2002225,2001957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1187,"address":[2002592,2002624,2004977,2002597],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1188,"address":[2005342,2002631,2002748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1189,"address":[2002689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1192,"address":[2003217,2003024,2004945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1193,"address":[2003007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1195,"address":[2003179,2003032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1199,"address":[2003150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1202,"address":[2003457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1203,"address":[2004020,2004926,2003704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1204,"address":[2003687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1206,"address":[2003715,2003982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1208,"address":[2005037,2004992,2003845,2005218,2005124,2004907,2004168],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1211,"address":[2004346,2005014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1212,"address":[2004313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[2004495,2004418],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1216,"address":[2004431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1218,"address":[2004595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1219,"address":[2004632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1223,"address":[2005765,2009115,2005760,2005792],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1224,"address":[2005908,2009524,2005799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1225,"address":[2005849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1228,"address":[2006399,2006196,2009083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1229,"address":[2006179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1231,"address":[2006204,2006361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1236,"address":[2006331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1239,"address":[2006639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1240,"address":[2006853,2009175,2009064,2009130,2009387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1242,"address":[2007206,2009018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1243,"address":[2007116,2009165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1244,"address":[2007146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1251,"address":[2009002,2007392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1253,"address":[2007536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1256,"address":[2007655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1257,"address":[2009253,2007869,2008968,2009205],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1259,"address":[2008922,2008222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1260,"address":[2009243,2008132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1261,"address":[2008162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1263,"address":[2008408,2008485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1265,"address":[2008421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1267,"address":[2008585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1268,"address":[2008622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1272,"address":[2010208,2018070,2010176,2010181],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1273,"address":[2018364,2010378,2010221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1274,"address":[2010319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1277,"address":[2018038,2010672,2010875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1278,"address":[2010649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1280,"address":[2010680,2010837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1285,"address":[2010807,2011035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1286,"address":[2011067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1287,"address":[2011126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1290,"address":[2011306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1291,"address":[2011520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1292,"address":[2011647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1296,"address":[2011768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1297,"address":[2011827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1299,"address":[2011863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1301,"address":[2012031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1302,"address":[2012487,2017984,2012284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1303,"address":[2012261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1305,"address":[2012292,2012449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1308,"address":[2012647,2012419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1309,"address":[2012679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1310,"address":[2012738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1313,"address":[2012918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1314,"address":[2013132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1315,"address":[2013259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1319,"address":[2013380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1320,"address":[2013439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1321,"address":[2013498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1326,"address":[2014050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1327,"address":[2013705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1330,"address":[2013678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1332,"address":[2013839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1333,"address":[2013761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1334,"address":[2013820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1336,"address":[2013934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1337,"address":[2013903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1339,"address":[2013966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1340,"address":[2014024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1342,"address":[2014242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1344,"address":[2014417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1345,"address":[2014544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1349,"address":[2014665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1350,"address":[2014724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1351,"address":[2014783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1354,"address":[2014963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1355,"address":[2017803,2015216,2015435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1356,"address":[2015193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1358,"address":[2015224,2015397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1360,"address":[2015351,2015635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1362,"address":[2015367,2015603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1364,"address":[2015794,2015711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1366,"address":[2015727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1368,"address":[2015886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1369,"address":[2015966,2017722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1370,"address":[2015989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1371,"address":[2016069,2017707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1372,"address":[2016084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1373,"address":[2016248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1374,"address":[2016420,2017692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1375,"address":[2016507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1379,"address":[2016663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1380,"address":[2016722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1381,"address":[2016781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1384,"address":[2016961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1385,"address":[2017175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1386,"address":[2017302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1390,"address":[2019296,2019264,2027905,2019269],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1391,"address":[2028386,2019522,2019309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1392,"address":[2019463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1395,"address":[2027873,2019816,2020019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1396,"address":[2019793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1398,"address":[2019824,2019981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1403,"address":[2020179,2019951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1404,"address":[2020211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1405,"address":[2020270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1409,"address":[2020494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1410,"address":[2020708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1411,"address":[2020835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1415,"address":[2020956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1416,"address":[2021015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1420,"address":[2021207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1421,"address":[2021460,2021663,2027819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1422,"address":[2021437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1424,"address":[2021468,2021625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1427,"address":[2021595,2021823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1428,"address":[2021855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1429,"address":[2021914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1433,"address":[2022138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1434,"address":[2022352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1435,"address":[2022479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1439,"address":[2022600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1442,"address":[2022719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1443,"address":[2023229,2027762,2022972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1444,"address":[2022949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1446,"address":[2022980,2023191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1448,"address":[2023405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1450,"address":[2023432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1451,"address":[2023499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1452,"address":[2023566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1453,"address":[2023606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1456,"address":[2023740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1457,"address":[2023799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1458,"address":[2023858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1459,"address":[2023882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1462,"address":[2024142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1463,"address":[2027705,2024711,2024395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1464,"address":[2024372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1466,"address":[2024406,2024673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1468,"address":[2024536,2024879,2027674,2025271],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1469,"address":[2024940,2025146,2025217],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1470,"address":[2025052,2025201,2027953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1473,"address":[2025463,2025380],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1475,"address":[2025396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1477,"address":[2025539,2025616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1479,"address":[2025552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1481,"address":[2025708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1482,"address":[2025788,2027593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1483,"address":[2025811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1484,"address":[2025891,2027578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1485,"address":[2025906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1486,"address":[2026070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1487,"address":[2027563,2026242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1488,"address":[2026329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1492,"address":[2026485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1493,"address":[2026544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1494,"address":[2026603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1498,"address":[2026827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1499,"address":[2027041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1500,"address":[2027168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1504,"address":[2029392,2029360,2034863,2029365],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1505,"address":[2029405,2029554,2035124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1506,"address":[2029495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1509,"address":[2029848,2030051,2034831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1510,"address":[2029825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1512,"address":[2030013,2029856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1517,"address":[2029983,2030211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1518,"address":[2030243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1521,"address":[2030391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1522,"address":[2030605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1523,"address":[2030732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1527,"address":[2030853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1528,"address":[2030912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1532,"address":[2031104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1533,"address":[2031357,2031560,2034793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1534,"address":[2031334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1536,"address":[2031365,2031522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1539,"address":[2031720,2031492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1540,"address":[2031752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1543,"address":[2031900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1544,"address":[2032114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1545,"address":[2032241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1549,"address":[2032356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1550,"address":[2032415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1553,"address":[2032563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1554,"address":[2034755,2032810,2033026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1555,"address":[2032793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1557,"address":[2032818,2032988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1559,"address":[2032945,2033211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1561,"address":[2032958,2033179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1563,"address":[2033303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1564,"address":[2034704,2033383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1565,"address":[2033398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1566,"address":[2033570,2034689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1567,"address":[2033657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1571,"address":[2033813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1572,"address":[2033872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1575,"address":[2034020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1576,"address":[2034234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1577,"address":[2034361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1581,"address":[2040020,2035680,2035653,2035648],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1582,"address":[2035834,2035693,2040242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1583,"address":[2035775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1586,"address":[2039988,2036331,2036128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1587,"address":[2036105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1589,"address":[2036136,2036293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1593,"address":[2036263,2036491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1594,"address":[2036523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1598,"address":[2036715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1599,"address":[2036968,2037184,2039969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1600,"address":[2036945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1602,"address":[2037146,2036976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1605,"address":[2037369,2037103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1607,"address":[2037116,2037337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1609,"address":[2037445,2037522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1611,"address":[2037458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1614,"address":[2037630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1615,"address":[2037675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1624,"address":[2037822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1625,"address":[2037881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1629,"address":[2038073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1630,"address":[2038320,2039882,2038523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1631,"address":[2038303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1633,"address":[2038328,2038485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1637,"address":[2038671,2038455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1638,"address":[2038703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1642,"address":[2038895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1643,"address":[2039142,2039863,2039357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1644,"address":[2039125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1646,"address":[2039319,2039150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1649,"address":[2039505,2039309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1650,"address":[2039543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1660,"address":[2040693,2044153,2040688,2040720],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1661,"address":[2044321,2040727,2040852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1662,"address":[2040793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1665,"address":[2041146,2041349,2044121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1666,"address":[2041123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1668,"address":[2041154,2041311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1672,"address":[2041281,2041503],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1673,"address":[2041535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1677,"address":[2041727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1678,"address":[2044105,2041974,2042190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1679,"address":[2041957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1681,"address":[2042152,2041982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1684,"address":[2042375,2042109],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1686,"address":[2042122,2042343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1688,"address":[2042528,2042451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1690,"address":[2042464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1693,"address":[2042636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1694,"address":[2042681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1703,"address":[2042828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1704,"address":[2042887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1708,"address":[2043079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1709,"address":[2044018,2043326,2043541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1710,"address":[2043309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1712,"address":[2043334,2043503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1715,"address":[2043689,2043493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1716,"address":[2043727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1726,"address":[2044688,2046721,2044693,2044720],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1727,"address":[2046925,2044727,2044836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1728,"address":[2044777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1731,"address":[2045306,2046689,2045112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1732,"address":[2045095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1734,"address":[2045120,2045268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1738,"address":[2045238,2045454],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1741,"address":[2045578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1742,"address":[2046024,2046670,2045825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1743,"address":[2045808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1745,"address":[2045986,2045833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1748,"address":[2045976,2046188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1751,"address":[2046652,2046257,2046620,2046744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1752,"address":[2046604,2046279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1756,"address":[2047280,2047285,2047312,2048955],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1757,"address":[2047428,2049048,2047319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1758,"address":[2047369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1761,"address":[2048926,2047701,2047986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1762,"address":[2047684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1764,"address":[2047948,2047709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1771,"address":[2048134,2047906],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1772,"address":[2048342,2048910,2048541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1773,"address":[2048325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1775,"address":[2048350,2048503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1778,"address":[2048697,2048493,2048895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1779,"address":[2048739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1783,"address":[2051343,2049269,2049264,2049296],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1784,"address":[2049303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1785,"address":[2049460,2051436,2049361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1786,"address":[2049377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1787,"address":[2049436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1789,"address":[2049946,2049750,2051314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1790,"address":[2049733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1792,"address":[2049908,2049758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1795,"address":[2049898,2050102,2051299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1796,"address":[2050166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1798,"address":[2050190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1801,"address":[2050306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1802,"address":[2051283,2050553,2050752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1803,"address":[2050536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1805,"address":[2050714,2050561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1808,"address":[2051268,2050704,2050908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1809,"address":[2050982,2051650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1813,"address":[2053882,2051712,2051744,2051717],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1814,"address":[2051751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1815,"address":[2053975,2051908,2051809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1816,"address":[2051825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1817,"address":[2051884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1819,"address":[2053853,2052394,2052198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1820,"address":[2052181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1822,"address":[2052206,2052356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1825,"address":[2052346,2053838,2052550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1826,"address":[2052614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1828,"address":[2052638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1829,"address":[2052697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1832,"address":[2052845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1833,"address":[2053092,2053822,2053291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1834,"address":[2053075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1836,"address":[2053100,2053253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1839,"address":[2053807,2053447,2053243],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1840,"address":[2053521,2054189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1844,"address":[2054256,2054288,2059104,2054261],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1845,"address":[2054301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1847,"address":[2059371,2054384,2054459],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1848,"address":[2054400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1851,"address":[2055071,2054774,2059058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1852,"address":[2054751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1854,"address":[2054782,2055033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1861,"address":[2055231,2054991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1862,"address":[2055406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1863,"address":[2055533,2059025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1866,"address":[2059287,2055753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1869,"address":[2055979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1870,"address":[2056193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1871,"address":[2056320,2058992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1874,"address":[2059236,2056540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1877,"address":[2056766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1878,"address":[2056980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1879,"address":[2057107,2058959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1882,"address":[2059185,2057291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1885,"address":[2057517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1886,"address":[2057731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1887,"address":[2057858,2058926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1890,"address":[2058032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1893,"address":[2058183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1894,"address":[2058397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1895,"address":[2058893,2058524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1899,"address":[2059973,2059968,2060000,2063051],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1900,"address":[2060007,2060132,2063210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1901,"address":[2060073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1904,"address":[2060411,2063019,2060702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1905,"address":[2060394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1907,"address":[2060419,2060664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1915,"address":[2060622,2060850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1916,"address":[2063003,2061058,2061261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1917,"address":[2061041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1919,"address":[2061066,2061223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1923,"address":[2061193,2061409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1924,"address":[2061441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1927,"address":[2061589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1928,"address":[2061803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1929,"address":[2061957,2062973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1931,"address":[2061922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1935,"address":[2062124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1939,"address":[2062284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1940,"address":[2062498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1941,"address":[2062943,2062652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1943,"address":[2062617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1948,"address":[2063557,2063552,2063584,2067077],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1949,"address":[2067278,2063597,2063722],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1950,"address":[2063663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1953,"address":[2064218,2067045,2063998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1954,"address":[2063981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1956,"address":[2064006,2064180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1960,"address":[2064366,2064134,2067230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1963,"address":[2064549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1964,"address":[2064763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1965,"address":[2064890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1968,"address":[2067179,2065003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1971,"address":[2065229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1972,"address":[2065443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1975,"address":[2065635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1976,"address":[2065694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1979,"address":[2065842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1980,"address":[2066056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1983,"address":[2066248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1984,"address":[2066307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1987,"address":[2066455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1988,"address":[2066669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1989,"address":[2066796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1993,"address":[2067605,2067632,2071040,2067600],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1994,"address":[2067770,2071241,2067645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1995,"address":[2067711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1998,"address":[2068254,2071008,2068040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1999,"address":[2068023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2001,"address":[2068216,2068048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2005,"address":[2068402,2068170,2071193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2008,"address":[2068585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2009,"address":[2068799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2010,"address":[2068926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2013,"address":[2069039,2071142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2016,"address":[2069265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2017,"address":[2069479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2020,"address":[2069671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2021,"address":[2069730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2024,"address":[2069878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2025,"address":[2070092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2028,"address":[2070284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2029,"address":[2070343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2032,"address":[2070491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2033,"address":[2070705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2037,"address":[2071568,2071536,2071541,2077244],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2038,"address":[2071581,2077565,2071730],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2039,"address":[2071671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2042,"address":[2072253,2072024,2077212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2043,"address":[2072001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2045,"address":[2072032,2072215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2049,"address":[2072169,2072407,2077514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2052,"address":[2072590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2053,"address":[2072804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2054,"address":[2072931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2057,"address":[2077463,2073044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2060,"address":[2073270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2061,"address":[2073484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2064,"address":[2073676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2065,"address":[2073735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2068,"address":[2073883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2069,"address":[2074097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2070,"address":[2074224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2073,"address":[2074327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2074,"address":[2074386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2077,"address":[2074534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2078,"address":[2074748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2079,"address":[2074875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2083,"address":[2077352,2074988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2086,"address":[2075214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2087,"address":[2075428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2090,"address":[2075620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2091,"address":[2075679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2094,"address":[2075827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2095,"address":[2076041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2096,"address":[2076168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2099,"address":[2076271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2100,"address":[2076330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2103,"address":[2076478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2104,"address":[2076692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2105,"address":[2076819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2111,"address":[2078096,2078064,2081590,2078069],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2112,"address":[2078103,2081831,2078212],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2113,"address":[2078153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2116,"address":[2078491,2078688,2081558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2117,"address":[2078474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2119,"address":[2078499,2078650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2123,"address":[2078620,2078836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2124,"address":[2078868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2126,"address":[2078970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2127,"address":[2079081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2128,"address":[2081512,2079235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2130,"address":[2079200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2134,"address":[2079402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2137,"address":[2079521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2138,"address":[2079765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2139,"address":[2079880,2079927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2140,"address":[2079894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2144,"address":[2080054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2145,"address":[2080113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2148,"address":[2080228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2149,"address":[2080385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2150,"address":[2080422,2080469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2151,"address":[2080436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2153,"address":[2080540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2156,"address":[2080687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2157,"address":[2080746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2159,"address":[2080848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2160,"address":[2080959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2161,"address":[2081383,2081113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2163,"address":[2081078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2168,"address":[2082341,2082368,2086002,2082336],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2169,"address":[2082375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2170,"address":[2082440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2171,"address":[2082499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2172,"address":[2082526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2173,"address":[2082629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2177,"address":[2082735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2179,"address":[2082759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2180,"address":[2082793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2182,"address":[2082840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2183,"address":[2082883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2184,"address":[2082922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2185,"address":[2082957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2186,"address":[2083074,2082983,2086219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2190,"address":[2083320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2191,"address":[2083353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2193,"address":[2083541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2194,"address":[2083793,2084091,2085852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2195,"address":[2083770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2197,"address":[2083801,2084053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2200,"address":[2083928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2201,"address":[2083939,2084239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2202,"address":[2084272,2085833,2084588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2203,"address":[2084255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2205,"address":[2084283,2084550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2207,"address":[2084752,2085814,2084413],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2209,"address":[2084871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2215,"address":[2085021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2216,"address":[2085177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2217,"address":[2085325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2218,"address":[2085484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2220,"address":[2084838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2225,"address":[2086757,2086784,2094365,2086752],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2226,"address":[2086797,2094870,2086930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2227,"address":[2086871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2230,"address":[2094333,2087427,2087224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2231,"address":[2087201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2233,"address":[2087232,2087389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2237,"address":[2087587,2087359],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2238,"address":[2087619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2242,"address":[2087811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2243,"address":[2094314,2088064,2088267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2244,"address":[2088041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2246,"address":[2088229,2088072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2249,"address":[2088427,2088199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2250,"address":[2088459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2253,"address":[2088518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2254,"address":[2088577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2255,"address":[2088636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2257,"address":[2088770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2258,"address":[2094236,2088920,2089229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2259,"address":[2088897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2261,"address":[2088931,2089191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2263,"address":[2089061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2264,"address":[2089397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2267,"address":[2089506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2270,"address":[2089625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2271,"address":[2094198,2089839,2094380,2094428,2094640],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2273,"address":[2090192,2094152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2274,"address":[2090102,2094418],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2275,"address":[2090132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2282,"address":[2090378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2285,"address":[2090497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2286,"address":[2090711,2094506,2094133,2094458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2288,"address":[2094087,2091064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2289,"address":[2090974,2094496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2290,"address":[2091004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2297,"address":[2091250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2298,"address":[2091309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2299,"address":[2091368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2301,"address":[2091502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2302,"address":[2091613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2303,"address":[2091792,2091839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2304,"address":[2091806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2306,"address":[2091929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2309,"address":[2092076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2310,"address":[2092135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2311,"address":[2092194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2313,"address":[2092328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2314,"address":[2092439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2315,"address":[2092665,2092618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2316,"address":[2092632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2318,"address":[2092755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2321,"address":[2092902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2322,"address":[2092961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2323,"address":[2093020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2325,"address":[2093154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2326,"address":[2093265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2327,"address":[2093444,2093491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2328,"address":[2093458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2330,"address":[2093581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2334,"address":[2099053,2095952,2095984,2095957],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2335,"address":[2095991,2096092,2099277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2336,"address":[2096033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2339,"address":[2096371,2096568,2099021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2340,"address":[2096354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2342,"address":[2096379,2096530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2346,"address":[2096500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2349,"address":[2096808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2350,"address":[2097022,2099002,2099113,2099068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2352,"address":[2098956,2097375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2353,"address":[2097285,2099103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2354,"address":[2097315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2361,"address":[2097561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2362,"address":[2097620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2364,"address":[2097722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2365,"address":[2097833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2366,"address":[2097960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2369,"address":[2098063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2370,"address":[2098122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2372,"address":[2098224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2373,"address":[2098335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2374,"address":[2098561,2098514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2375,"address":[2098528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2377,"address":[2098651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2381,"address":[2099760,2099733,2105911,2099728],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":2382,"address":[2099773,2099898,2106181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2383,"address":[2099839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2386,"address":[2100368,2100174,2105879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2387,"address":[2100157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2389,"address":[2100182,2100330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2393,"address":[2100300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2396,"address":[2100608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2397,"address":[2100822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2400,"address":[2101014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2401,"address":[2101073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2404,"address":[2101221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2405,"address":[2101435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2406,"address":[2101561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2408,"address":[2101707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2409,"address":[2101766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2412,"address":[2101914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2413,"address":[2102128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2414,"address":[2102254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2416,"address":[2102400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2417,"address":[2102459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2420,"address":[2102607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2421,"address":[2102821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2422,"address":[2102947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2425,"address":[2103093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2426,"address":[2103152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2430,"address":[2103304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2433,"address":[2103415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2434,"address":[2103594,2103641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2435,"address":[2103608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2437,"address":[2103768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2440,"address":[2103826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2441,"address":[2103885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2445,"address":[2104037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2446,"address":[2104148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2447,"address":[2104374,2104327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2448,"address":[2104341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2450,"address":[2104501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2453,"address":[2104679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2454,"address":[2104738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2458,"address":[2104890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2459,"address":[2105001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2460,"address":[2105180,2105227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2461,"address":[2105194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2463,"address":[2105354],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1054,"coverable":1148},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\nmod rand;\npub mod receiver;\npub mod state;\nmod utils;\nmod viewing_key;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Binary, HumanAddr, StdError, StdResult, Uint128};\n\nuse crate::state::Tx;\nuse crate::viewing_key::ViewingKey;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct InitialBalance {\n    pub address: HumanAddr,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema)]\npub struct InitMsg {\n    pub name: String,\n    pub admin: Option\u003cHumanAddr\u003e,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Option\u003cVec\u003cInitialBalance\u003e\u003e,\n    pub prng_seed: Binary,\n    pub config: Option\u003cInitConfig\u003e,\n}\n\nimpl InitMsg {\n    pub fn config(\u0026self) -\u003e InitConfig {\n        self.config.clone().unwrap_or_default()\n    }\n}\n\n/// This type represents optional configuration values which can be overridden.\n/// All values are optional and have defaults which are more private by default,\n/// but can be overridden if necessary\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Default, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct InitConfig {\n    /// Indicates whether the total supply is public or should be kept secret.\n    /// default: False\n    public_total_supply: Option\u003cbool\u003e,\n}\n\nimpl InitConfig {\n    pub fn public_total_supply(\u0026self) -\u003e bool {\n        self.public_total_supply.unwrap_or(false)\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    // Native coin interactions\n    Redeem {\n        amount: Uint128,\n        denom: Option\u003cString\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    Deposit {\n        padding: Option\u003cString\u003e,\n    },\n\n    // Base ERC-20 stuff\n    Transfer {\n        recipient: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    Send {\n        recipient: HumanAddr,\n        amount: Uint128,\n        msg: Option\u003cBinary\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    Burn {\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    RegisterReceive {\n        code_hash: String,\n        padding: Option\u003cString\u003e,\n    },\n    CreateViewingKey {\n        entropy: String,\n        padding: Option\u003cString\u003e,\n    },\n    SetViewingKey {\n        key: String,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Allowance\n    IncreaseAllowance {\n        spender: HumanAddr,\n        amount: Uint128,\n        expiration: Option\u003cu64\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    DecreaseAllowance {\n        spender: HumanAddr,\n        amount: Uint128,\n        expiration: Option\u003cu64\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    TransferFrom {\n        owner: HumanAddr,\n        recipient: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    SendFrom {\n        owner: HumanAddr,\n        recipient: HumanAddr,\n        amount: Uint128,\n        msg: Option\u003cBinary\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    BurnFrom {\n        owner: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Mint\n    Mint {\n        recipient: HumanAddr,\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n    AddMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    RemoveMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n    SetMinters {\n        minters: Vec\u003cHumanAddr\u003e,\n        padding: Option\u003cString\u003e,\n    },\n\n    // Admin\n    ChangeAdmin {\n        address: HumanAddr,\n        padding: Option\u003cString\u003e,\n    },\n    SetContractStatus {\n        level: ContractStatusLevel,\n        padding: Option\u003cString\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleAnswer {\n    // Native\n    Deposit {\n        status: ResponseStatus,\n    },\n    Redeem {\n        status: ResponseStatus,\n    },\n\n    // Base\n    Transfer {\n        status: ResponseStatus,\n    },\n    Send {\n        status: ResponseStatus,\n    },\n    Burn {\n        status: ResponseStatus,\n    },\n    RegisterReceive {\n        status: ResponseStatus,\n    },\n    CreateViewingKey {\n        key: ViewingKey,\n    },\n    SetViewingKey {\n        status: ResponseStatus,\n    },\n\n    // Allowance\n    IncreaseAllowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n    },\n    DecreaseAllowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n    },\n    TransferFrom {\n        status: ResponseStatus,\n    },\n    SendFrom {\n        status: ResponseStatus,\n    },\n    BurnFrom {\n        status: ResponseStatus,\n    },\n\n    // Mint\n    Mint {\n        status: ResponseStatus,\n    },\n    AddMinters {\n        status: ResponseStatus,\n    },\n    RemoveMinters {\n        status: ResponseStatus,\n    },\n    SetMinters {\n        status: ResponseStatus,\n    },\n\n    // Other\n    ChangeAdmin {\n        status: ResponseStatus,\n    },\n    SetContractStatus {\n        status: ResponseStatus,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    TokenInfo {},\n    ExchangeRate {},\n    Allowance {\n        owner: HumanAddr,\n        spender: HumanAddr,\n        key: String,\n    },\n    Balance {\n        address: HumanAddr,\n        key: String,\n    },\n    TransferHistory {\n        address: HumanAddr,\n        key: String,\n        page: Option\u003cu32\u003e,\n        page_size: u32,\n    },\n    Minters {},\n}\n\nimpl QueryMsg {\n    pub fn get_validation_params(\u0026self) -\u003e (Vec\u003c\u0026HumanAddr\u003e, ViewingKey) {\n        match self {\n            Self::Balance { address, key } =\u003e (vec![address], ViewingKey(key.clone())),\n            Self::TransferHistory { address, key, .. } =\u003e (vec![address], ViewingKey(key.clone())),\n            Self::Allowance {\n                owner,\n                spender,\n                key,\n                ..\n            } =\u003e (vec![owner, spender], ViewingKey(key.clone())),\n            _ =\u003e panic!(\"This query type does not require authentication\"),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryAnswer {\n    TokenInfo {\n        name: String,\n        symbol: String,\n        decimals: u8,\n        total_supply: Option\u003cUint128\u003e,\n    },\n    ExchangeRate {\n        rate: Uint128,\n        denom: String,\n    },\n    Allowance {\n        spender: HumanAddr,\n        owner: HumanAddr,\n        allowance: Uint128,\n        expiration: Option\u003cu64\u003e,\n    },\n    Balance {\n        amount: Uint128,\n    },\n    TransferHistory {\n        txs: Vec\u003cTx\u003e,\n    },\n\n    ViewingKeyError {\n        msg: String,\n    },\n    Minters {\n        minters: Vec\u003cHumanAddr\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct CreateViewingKeyResponse {\n    pub key: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ResponseStatus {\n    Success,\n    Failure,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ContractStatusLevel {\n    NormalRun,\n    StopAll,\n}\n\npub fn status_level_to_u8(status_level: ContractStatusLevel) -\u003e u8 {\n    match status_level {\n        ContractStatusLevel::NormalRun =\u003e 0,\n        ContractStatusLevel::StopAll =\u003e 2,\n    }\n}\n\npub fn u8_to_status_level(status_level: u8) -\u003e StdResult\u003cContractStatusLevel\u003e {\n    match status_level {\n        0 =\u003e Ok(ContractStatusLevel::NormalRun),\n        2 =\u003e Ok(ContractStatusLevel::StopAll),\n        _ =\u003e Err(StdError::generic_err(\"Invalid state level\")),\n    }\n}\n\n// Take a Vec\u003cu8\u003e and pad it up to a multiple of `block_size`, using spaces at the end.\npub fn space_pad(block_size: usize, message: \u0026mut Vec\u003cu8\u003e) -\u003e \u0026mut Vec\u003cu8\u003e {\n    let len = message.len();\n    let surplus = len % block_size;\n    if surplus == 0 {\n        return message;\n    }\n\n    let missing = block_size - surplus;\n    message.reserve(missing);\n    message.extend(std::iter::repeat(b' ').take(missing));\n    message\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::{from_slice, StdResult};\n\n    #[derive(Serialize, Deserialize, JsonSchema, Debug, PartialEq)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum Something {\n        Var { padding: Option\u003cString\u003e },\n    }\n\n    #[test]\n    fn test_deserialization_of_missing_option_fields() -\u003e StdResult\u003c()\u003e {\n        let input = b\"{ \\\"var\\\": {} }\";\n        let obj: Something = from_slice(input)?;\n        assert_eq!(\n            obj,\n            Something::Var { padding: None },\n            \"unexpected value: {:?}\",\n            obj\n        );\n        Ok(())\n    }\n}\n","traces":[{"line":27,"address":[1834544],"length":1,"stats":{"Line":2},"fn_name":"config"},{"line":28,"address":[5876569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[1834617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[1834656,1835543],"length":1,"stats":{"Line":1},"fn_name":"get_validation_params"},{"line":253,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[1835632],"length":1,"stats":{"Line":2},"fn_name":"status_level_to_u8"},{"line":321,"address":[1835659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[1835663,1835644],"length":1,"stats":{"Line":4},"fn_name":null},{"line":323,"address":[1835654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[1835680],"length":1,"stats":{"Line":1},"fn_name":"u8_to_status_level"},{"line":328,"address":[1835769,1835756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[1835704,1835749],"length":1,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[1835762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[1835775,1835720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[1835824],"length":1,"stats":{"Line":1},"fn_name":"space_pad"},{"line":337,"address":[1835861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[1836075,1835882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[1835922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[1835933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[1835950,1836105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[1835984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[1835990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[1836060],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[1805488,1805497,1805536,1806139],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":362,"address":[1805553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[1805568,1805763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[1805979,1805685,1805867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":370,"address":[1805947],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":30,"coverable":38},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","src","rand.rs"],"content":"use rand_chacha::ChaChaRng;\nuse rand_core::{RngCore, SeedableRng};\n\nuse sha2::{Digest, Sha256};\n\npub fn sha_256(data: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    let hash = hasher.finalize();\n\n    let mut result = [0u8; 32];\n    result.copy_from_slice(hash.as_slice());\n    result\n}\n\npub struct Prng {\n    rng: ChaChaRng,\n}\n\nimpl Prng {\n    pub fn new(seed: \u0026[u8], entropy: \u0026[u8]) -\u003e Self {\n        let mut hasher = Sha256::new();\n\n        // write input message\n        hasher.update(\u0026seed);\n        hasher.update(\u0026entropy);\n        let hash = hasher.finalize();\n\n        let mut hash_bytes = [0u8; 32];\n        hash_bytes.copy_from_slice(hash.as_slice());\n\n        let rng: ChaChaRng = ChaChaRng::from_seed(hash_bytes);\n\n        Self { rng }\n    }\n\n    pub fn rand_bytes(\u0026mut self) -\u003e [u8; 32] {\n        let mut bytes = [0u8; 32];\n        self.rng.fill_bytes(\u0026mut bytes);\n\n        bytes\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// This test checks that the rng is stateful and generates\n    /// different random bytes every time it is called.\n    #[test]\n    fn test_rng() {\n        let mut rng = Prng::new(b\"foo\", b\"bar!\");\n        let r1: [u8; 32] = [\n            155, 11, 21, 97, 252, 65, 160, 190, 100, 126, 85, 251, 47, 73, 160, 49, 216, 182, 93,\n            30, 185, 67, 166, 22, 34, 10, 213, 112, 21, 136, 49, 214,\n        ];\n        let r2: [u8; 32] = [\n            46, 135, 19, 242, 111, 125, 59, 215, 114, 130, 122, 155, 202, 23, 36, 118, 83, 11, 6,\n            180, 97, 165, 218, 136, 134, 243, 191, 191, 149, 178, 7, 149,\n        ];\n        let r3: [u8; 32] = [\n            9, 2, 131, 50, 199, 170, 6, 68, 168, 28, 242, 182, 35, 114, 15, 163, 65, 139, 101, 221,\n            207, 147, 119, 110, 81, 195, 6, 134, 14, 253, 245, 244,\n        ];\n        let r4: [u8; 32] = [\n            68, 196, 114, 205, 225, 64, 201, 179, 18, 77, 216, 197, 211, 13, 21, 196, 11, 102, 106,\n            195, 138, 250, 29, 185, 51, 38, 183, 0, 5, 169, 65, 190,\n        ];\n        assert_eq!(r1, rng.rand_bytes());\n        assert_eq!(r2, rng.rand_bytes());\n        assert_eq!(r3, rng.rand_bytes());\n        assert_eq!(r4, rng.rand_bytes());\n    }\n}\n","traces":[{"line":6,"address":[1825376],"length":1,"stats":{"Line":2},"fn_name":"sha_256"},{"line":7,"address":[1825419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[6463999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[1825451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[6464058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[1825522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[6464144],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1825648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1825709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[1825792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1806224,1806192,1806197],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":53,"address":[1806231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[1806266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[1806522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1806778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1807034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1807290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1807457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1807624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1807791],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":28},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","src","receiver.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{to_binary, Binary, CosmosMsg, HumanAddr, StdResult, Uint128, WasmMsg};\n\nuse crate::{contract::RESPONSE_BLOCK_SIZE, msg::space_pad};\n\n/// Snip20ReceiveMsg should be de/serialized under `Receive()` variant in a HandleMsg\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct Snip20ReceiveMsg {\n    pub sender: HumanAddr,\n    pub from: HumanAddr,\n    pub amount: Uint128,\n    pub msg: Option\u003cBinary\u003e,\n}\n\nimpl Snip20ReceiveMsg {\n    pub fn new(sender: HumanAddr, from: HumanAddr, amount: Uint128, msg: Option\u003cBinary\u003e) -\u003e Self {\n        Self {\n            sender,\n            from,\n            amount,\n            msg,\n        }\n    }\n\n    /// serializes the message, and pads it to 256 bytes\n    pub fn into_binary(self) -\u003e StdResult\u003cBinary\u003e {\n        let msg = ReceiverHandleMsg::Receive(self);\n        let mut data = to_binary(\u0026msg)?;\n        space_pad(RESPONSE_BLOCK_SIZE, \u0026mut data.0);\n        Ok(data)\n    }\n\n    /// creates a cosmos_msg sending this struct to the named contract\n    pub fn into_cosmos_msg(\n        self,\n        callback_code_hash: String,\n        contract_addr: HumanAddr,\n    ) -\u003e StdResult\u003cCosmosMsg\u003e {\n        let msg = self.into_binary()?;\n        let execute = WasmMsg::Execute {\n            msg,\n            callback_code_hash,\n            contract_addr,\n            send: vec![],\n        };\n        Ok(execute.into())\n    }\n}\n\n// This is just a helper to properly serialize the above message\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\nenum ReceiverHandleMsg {\n    Receive(Snip20ReceiveMsg),\n}\n","traces":[{"line":19,"address":[1793920],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2245344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","src","state.rs"],"content":"use std::any::type_name;\nuse std::convert::TryFrom;\n\nuse cosmwasm_std::{\n    Api, CanonicalAddr, Coin, HumanAddr, ReadonlyStorage, StdError, StdResult, Storage, Uint128,\n};\nuse cosmwasm_storage::{PrefixedStorage, ReadonlyPrefixedStorage};\n\nuse secret_toolkit::storage::{AppendStore, AppendStoreMut, TypedStore, TypedStoreMut};\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::msg::{status_level_to_u8, u8_to_status_level, ContractStatusLevel};\nuse crate::viewing_key::ViewingKey;\nuse serde::de::DeserializeOwned;\n\npub static CONFIG_KEY: \u0026[u8] = b\"config\";\npub const PREFIX_TXS: \u0026[u8] = b\"transfers\";\n\npub const KEY_CONSTANTS: \u0026[u8] = b\"constants\";\npub const KEY_TOTAL_SUPPLY: \u0026[u8] = b\"total_supply\";\npub const KEY_CONTRACT_STATUS: \u0026[u8] = b\"contract_status\";\npub const KEY_MINTERS: \u0026[u8] = b\"minters\";\npub const KEY_TX_COUNT: \u0026[u8] = b\"tx-count\";\n\npub const PREFIX_CONFIG: \u0026[u8] = b\"config\";\npub const PREFIX_BALANCES: \u0026[u8] = b\"balances\";\npub const PREFIX_ALLOWANCES: \u0026[u8] = b\"allowances\";\npub const PREFIX_VIEW_KEY: \u0026[u8] = b\"viewingkey\";\npub const PREFIX_RECEIVERS: \u0026[u8] = b\"receivers\";\n\n// Note that id is a globally incrementing counter.\n// Since it's 64 bits long, even at 50 tx/s it would take\n// over 11 billion years for it to rollback. I'm pretty sure\n// we'll have bigger issues by then.\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\npub struct Tx {\n    pub id: u64,\n    pub from: HumanAddr,\n    pub sender: HumanAddr,\n    pub receiver: HumanAddr,\n    pub coins: Coin,\n}\n\nimpl Tx {\n    pub fn into_stored\u003cA: Api\u003e(self, api: \u0026A) -\u003e StdResult\u003cStoredTx\u003e {\n        let tx = StoredTx {\n            id: self.id,\n            from: api.canonical_address(\u0026self.from)?,\n            sender: api.canonical_address(\u0026self.sender)?,\n            receiver: api.canonical_address(\u0026self.receiver)?,\n            coins: self.coins,\n        };\n        Ok(tx)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct StoredTx {\n    pub id: u64,\n    pub from: CanonicalAddr,\n    pub sender: CanonicalAddr,\n    pub receiver: CanonicalAddr,\n    pub coins: Coin,\n}\n\nimpl StoredTx {\n    pub fn into_humanized\u003cA: Api\u003e(self, api: \u0026A) -\u003e StdResult\u003cTx\u003e {\n        let tx = Tx {\n            id: self.id,\n            from: api.human_address(\u0026self.from)?,\n            sender: api.human_address(\u0026self.sender)?,\n            receiver: api.human_address(\u0026self.receiver)?,\n            coins: self.coins,\n        };\n        Ok(tx)\n    }\n}\n\npub fn store_transfer\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    owner: \u0026CanonicalAddr,\n    sender: \u0026CanonicalAddr,\n    receiver: \u0026CanonicalAddr,\n    amount: Uint128,\n    denom: String,\n) -\u003e StdResult\u003c()\u003e {\n    let mut config = Config::from_storage(store);\n    let id = config.tx_count() + 1;\n    config.set_tx_count(id)?;\n\n    let coins = Coin { denom, amount };\n    let tx = StoredTx {\n        id,\n        from: owner.clone(),\n        sender: sender.clone(),\n        receiver: receiver.clone(),\n        coins,\n    };\n\n    if owner != sender {\n        append_tx(store, tx.clone(), \u0026owner)?;\n    }\n    append_tx(store, tx.clone(), \u0026sender)?;\n    append_tx(store, tx, \u0026receiver)?;\n\n    Ok(())\n}\n\nfn append_tx\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    tx: StoredTx,\n    for_address: \u0026CanonicalAddr,\n) -\u003e StdResult\u003c()\u003e {\n    let mut store = PrefixedStorage::multilevel(\u0026[PREFIX_TXS, for_address.as_slice()], store);\n    let mut store = AppendStoreMut::attach_or_create(\u0026mut store)?;\n    store.push(\u0026tx)\n}\n\npub fn get_transfers\u003cA: Api, S: ReadonlyStorage\u003e(\n    api: \u0026A,\n    storage: \u0026S,\n    for_address: \u0026CanonicalAddr,\n    page: u32,\n    page_size: u32,\n) -\u003e StdResult\u003cVec\u003cTx\u003e\u003e {\n    let store = ReadonlyPrefixedStorage::multilevel(\u0026[PREFIX_TXS, for_address.as_slice()], storage);\n\n    // Try to access the storage of txs for the account.\n    // If it doesn't exist yet, return an empty list of transfers.\n    let store = if let Some(result) = AppendStore::\u003cStoredTx, _\u003e::attach(\u0026store) {\n        result?\n    } else {\n        return Ok(vec![]);\n    };\n\n    // Take `page_size` txs starting from the latest tx, potentially skipping `page * page_size`\n    // txs from the start.\n    let tx_iter = store\n        .iter()\n        .rev()\n        .skip((page * page_size) as _)\n        .take(page_size as _);\n    // The `and_then` here flattens the `StdResult\u003cStdResult\u003cTx\u003e\u003e` to an `StdResult\u003cTx\u003e`\n    let txs: StdResult\u003cVec\u003cTx\u003e\u003e = tx_iter\n        .map(|tx| tx.map(|tx| tx.into_humanized(api)).and_then(|x| x))\n        .collect();\n    txs\n}\n\n// Config\n\n#[derive(Serialize, Debug, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct Constants {\n    pub name: String,\n    pub admin: HumanAddr,\n    pub symbol: String,\n    pub decimals: u8,\n    pub prng_seed: Vec\u003cu8\u003e,\n    // privacy configuration\n    pub total_supply_is_public: bool,\n}\n\npub struct ReadonlyConfig\u003c'a, S: ReadonlyStorage\u003e {\n    storage: ReadonlyPrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyConfig\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a S) -\u003e Self {\n        Self {\n            storage: ReadonlyPrefixedStorage::new(PREFIX_CONFIG, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyConfigImpl\u003cReadonlyPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyConfigImpl(\u0026self.storage)\n    }\n\n    pub fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        self.as_readonly().constants()\n    }\n\n    pub fn total_supply(\u0026self) -\u003e u128 {\n        self.as_readonly().total_supply()\n    }\n\n    pub fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        self.as_readonly().contract_status()\n    }\n\n    pub fn minters(\u0026self) -\u003e Vec\u003cHumanAddr\u003e {\n        self.as_readonly().minters()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        self.as_readonly().tx_count()\n    }\n}\n\nfn set_bin_data\u003cT: Serialize, S: Storage\u003e(storage: \u0026mut S, key: \u0026[u8], data: \u0026T) -\u003e StdResult\u003c()\u003e {\n    let bin_data =\n        bincode2::serialize(\u0026data).map_err(|e| StdError::serialize_err(type_name::\u003cT\u003e(), e))?;\n\n    storage.set(key, \u0026bin_data);\n    Ok(())\n}\n\nfn get_bin_data\u003cT: DeserializeOwned, S: ReadonlyStorage\u003e(storage: \u0026S, key: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n    let bin_data = storage.get(key);\n\n    match bin_data {\n        None =\u003e Err(StdError::not_found(\"Key not found in storage\")),\n        Some(bin_data) =\u003e Ok(bincode2::deserialize::\u003cT\u003e(\u0026bin_data)\n            .map_err(|e| StdError::serialize_err(type_name::\u003cT\u003e(), e))?),\n    }\n}\n\npub struct Config\u003c'a, S: Storage\u003e {\n    storage: PrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: Storage\u003e Config\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a mut S) -\u003e Self {\n        Self {\n            storage: PrefixedStorage::new(PREFIX_CONFIG, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyConfigImpl\u003cPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyConfigImpl(\u0026self.storage)\n    }\n\n    pub fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        self.as_readonly().constants()\n    }\n\n    pub fn set_constants(\u0026mut self, constants: \u0026Constants) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_CONSTANTS, constants)\n    }\n\n    pub fn total_supply(\u0026self) -\u003e u128 {\n        self.as_readonly().total_supply()\n    }\n\n    pub fn set_total_supply(\u0026mut self, supply: u128) {\n        self.storage.set(KEY_TOTAL_SUPPLY, \u0026supply.to_be_bytes());\n    }\n\n    pub fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        self.as_readonly().contract_status()\n    }\n\n    pub fn set_contract_status(\u0026mut self, status: ContractStatusLevel) {\n        let status_u8 = status_level_to_u8(status);\n        self.storage\n            .set(KEY_CONTRACT_STATUS, \u0026status_u8.to_be_bytes());\n    }\n\n    pub fn set_minters(\u0026mut self, minters_to_set: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_MINTERS, \u0026minters_to_set)\n    }\n\n    pub fn add_minters(\u0026mut self, minters_to_add: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        let mut minters = self.minters();\n        minters.extend(minters_to_add);\n\n        self.set_minters(minters)\n    }\n\n    pub fn remove_minters(\u0026mut self, minters_to_remove: Vec\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n        let mut minters = self.minters();\n\n        for minter in minters_to_remove {\n            minters.retain(|x| x != \u0026minter);\n        }\n\n        self.set_minters(minters)\n    }\n\n    pub fn minters(\u0026mut self) -\u003e Vec\u003cHumanAddr\u003e {\n        self.as_readonly().minters()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        self.as_readonly().tx_count()\n    }\n\n    pub fn set_tx_count(\u0026mut self, count: u64) -\u003e StdResult\u003c()\u003e {\n        set_bin_data(\u0026mut self.storage, KEY_TX_COUNT, \u0026count)\n    }\n}\n\n/// This struct refactors out the readonly methods that we need for `Config` and `ReadonlyConfig`\n/// in a way that is generic over their mutability.\n///\n/// This was the only way to prevent code duplication of these methods because of the way\n/// that `ReadonlyPrefixedStorage` and `PrefixedStorage` are implemented in `cosmwasm-std`\nstruct ReadonlyConfigImpl\u003c'a, S: ReadonlyStorage\u003e(\u0026'a S);\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyConfigImpl\u003c'a, S\u003e {\n    fn constants(\u0026self) -\u003e StdResult\u003cConstants\u003e {\n        let consts_bytes = self\n            .0\n            .get(KEY_CONSTANTS)\n            .ok_or_else(|| StdError::generic_err(\"no constants stored in configuration\"))?;\n        bincode2::deserialize::\u003cConstants\u003e(\u0026consts_bytes)\n            .map_err(|e| StdError::serialize_err(type_name::\u003cConstants\u003e(), e))\n    }\n\n    fn total_supply(\u0026self) -\u003e u128 {\n        let supply_bytes = self\n            .0\n            .get(KEY_TOTAL_SUPPLY)\n            .expect(\"no total supply stored in config\");\n        // This unwrap is ok because we know we stored things correctly\n        slice_to_u128(\u0026supply_bytes).unwrap()\n    }\n\n    fn contract_status(\u0026self) -\u003e ContractStatusLevel {\n        let supply_bytes = self\n            .0\n            .get(KEY_CONTRACT_STATUS)\n            .expect(\"no contract status stored in config\");\n\n        // These unwraps are ok because we know we stored things correctly\n        let status = slice_to_u8(\u0026supply_bytes).unwrap();\n        u8_to_status_level(status).unwrap()\n    }\n\n    fn minters(\u0026self) -\u003e Vec\u003cHumanAddr\u003e {\n        get_bin_data(self.0, KEY_MINTERS).unwrap()\n    }\n\n    pub fn tx_count(\u0026self) -\u003e u64 {\n        get_bin_data(self.0, KEY_TX_COUNT).unwrap_or_default()\n    }\n}\n\n// Balances\n\npub struct ReadonlyBalances\u003c'a, S: ReadonlyStorage\u003e {\n    storage: ReadonlyPrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyBalances\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a S) -\u003e Self {\n        Self {\n            storage: ReadonlyPrefixedStorage::new(PREFIX_BALANCES, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyBalancesImpl\u003cReadonlyPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyBalancesImpl(\u0026self.storage)\n    }\n\n    pub fn account_amount(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        self.as_readonly().account_amount(account)\n    }\n}\n\npub struct Balances\u003c'a, S: Storage\u003e {\n    storage: PrefixedStorage\u003c'a, S\u003e,\n}\n\nimpl\u003c'a, S: Storage\u003e Balances\u003c'a, S\u003e {\n    pub fn from_storage(storage: \u0026'a mut S) -\u003e Self {\n        Self {\n            storage: PrefixedStorage::new(PREFIX_BALANCES, storage),\n        }\n    }\n\n    fn as_readonly(\u0026self) -\u003e ReadonlyBalancesImpl\u003cPrefixedStorage\u003cS\u003e\u003e {\n        ReadonlyBalancesImpl(\u0026self.storage)\n    }\n\n    pub fn balance(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        self.as_readonly().account_amount(account)\n    }\n\n    pub fn set_account_balance(\u0026mut self, account: \u0026CanonicalAddr, amount: u128) {\n        self.storage.set(account.as_slice(), \u0026amount.to_be_bytes())\n    }\n}\n\n/// This struct refactors out the readonly methods that we need for `Balances` and `ReadonlyBalances`\n/// in a way that is generic over their mutability.\n///\n/// This was the only way to prevent code duplication of these methods because of the way\n/// that `ReadonlyPrefixedStorage` and `PrefixedStorage` are implemented in `cosmwasm-std`\nstruct ReadonlyBalancesImpl\u003c'a, S: ReadonlyStorage\u003e(\u0026'a S);\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyBalancesImpl\u003c'a, S\u003e {\n    pub fn account_amount(\u0026self, account: \u0026CanonicalAddr) -\u003e u128 {\n        let account_bytes = account.as_slice();\n        let result = self.0.get(account_bytes);\n        match result {\n            // This unwrap is ok because we know we stored things correctly\n            Some(balance_bytes) =\u003e slice_to_u128(\u0026balance_bytes).unwrap(),\n            None =\u003e 0,\n        }\n    }\n}\n\n// Allowances\n\n#[derive(Serialize, Debug, Deserialize, Clone, PartialEq, Default, JsonSchema)]\npub struct Allowance {\n    pub amount: u128,\n    pub expiration: Option\u003cu64\u003e,\n}\n\npub fn read_allowance\u003cS: Storage\u003e(\n    store: \u0026S,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n) -\u003e StdResult\u003cAllowance\u003e {\n    let owner_store =\n        ReadonlyPrefixedStorage::multilevel(\u0026[PREFIX_ALLOWANCES, owner.as_slice()], store);\n    let owner_store = TypedStore::attach(\u0026owner_store);\n    let allowance = owner_store.may_load(spender.as_slice());\n    allowance.map(Option::unwrap_or_default)\n}\n\npub fn write_allowance\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n    allowance: Allowance,\n) -\u003e StdResult\u003c()\u003e {\n    let mut owner_store =\n        PrefixedStorage::multilevel(\u0026[PREFIX_ALLOWANCES, owner.as_slice()], store);\n    let mut owner_store = TypedStoreMut::attach(\u0026mut owner_store);\n\n    owner_store.store(spender.as_slice(), \u0026allowance)\n}\n\n// Viewing Keys\n\npub fn write_viewing_key\u003cS: Storage\u003e(store: \u0026mut S, owner: \u0026CanonicalAddr, key: \u0026ViewingKey) {\n    let mut balance_store = PrefixedStorage::new(PREFIX_VIEW_KEY, store);\n    balance_store.set(owner.as_slice(), \u0026key.to_hashed());\n}\n\npub fn read_viewing_key\u003cS: Storage\u003e(store: \u0026S, owner: \u0026CanonicalAddr) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n    let balance_store = ReadonlyPrefixedStorage::new(PREFIX_VIEW_KEY, store);\n    balance_store.get(owner.as_slice())\n}\n\n// Receiver Interface\n\npub fn get_receiver_hash\u003cS: ReadonlyStorage\u003e(\n    store: \u0026S,\n    account: \u0026HumanAddr,\n) -\u003e Option\u003cStdResult\u003cString\u003e\u003e {\n    let store = ReadonlyPrefixedStorage::new(PREFIX_RECEIVERS, store);\n    store.get(account.as_str().as_bytes()).map(|data| {\n        String::from_utf8(data)\n            .map_err(|_err| StdError::invalid_utf8(\"stored code hash was not a valid String\"))\n    })\n}\n\npub fn set_receiver_hash\u003cS: Storage\u003e(store: \u0026mut S, account: \u0026HumanAddr, code_hash: String) {\n    let mut store = PrefixedStorage::new(PREFIX_RECEIVERS, store);\n    store.set(account.as_str().as_bytes(), code_hash.as_bytes());\n}\n\n// Helpers\n\n/// Converts 16 bytes value into u128\n/// Errors if data found that is not 16 bytes\nfn slice_to_u128(data: \u0026[u8]) -\u003e StdResult\u003cu128\u003e {\n    match \u003c[u8; 16]\u003e::try_from(data) {\n        Ok(bytes) =\u003e Ok(u128::from_be_bytes(bytes)),\n        Err(_) =\u003e Err(StdError::generic_err(\n            \"Corrupted data found. 16 byte expected.\",\n        )),\n    }\n}\n\n/// Converts 1 byte value into u8\n/// Errors if data found that is not 1 byte\nfn slice_to_u8(data: \u0026[u8]) -\u003e StdResult\u003cu8\u003e {\n    if data.len() == 1 {\n        Ok(data[0])\n    } else {\n        Err(StdError::generic_err(\n            \"Corrupted data found. 1 byte expected.\",\n        ))\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[532864,535118],"length":1,"stats":{"Line":1},"fn_name":"store_transfer\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":89,"address":[532972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[535323,533021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[533087,535240,533266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[533156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[533243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[533512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[533532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[533829,533914,533783],"length":1,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[533822,533919,535180,533839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[534181,534443,535178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[534779,534276,534705,535176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[534741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[536172,535568],"length":1,"stats":{"Line":1},"fn_name":"append_tx\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":116,"address":[535624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[535732,535852,536187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[535842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[537449,536256],"length":1,"stats":{"Line":1},"fn_name":"get_transfers\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":128,"address":[536338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[536513,536447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[536617,536832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[536503,537083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[537234,537147,537203,536822],"length":1,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[537646,537162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[537214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[537302,537241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[537294,537680,537776,537788,537808,537849,537723],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}\u003ccosmwasm_std::mock::MockApi,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":149,"address":[537361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[539216,539607,538784,538352,539175,538743],"length":1,"stats":{"Line":5},"fn_name":"set_bin_data\u003cu64,cosmwasm_storage::prefixed_storage::PrefixedStorage\u003ccosmwasm_std::storage::MemoryStorage\u003e\u003e"},{"line":202,"address":[539666,539792,539432,539648,539810,538413,539936,538568,539277,539954,539000,538845],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}\u003csnip20_sienna::state::Constants,cosmwasm_storage::prefixed_storage::PrefixedStorage\u003ccosmwasm_std::storage::MemoryStorage\u003e\u003e"},{"line":205,"address":[539121,538969,538537,539401,539553,538689],"length":1,"stats":{"Line":10},"fn_name":null},{"line":206,"address":[539133,539565,538701],"length":1,"stats":{"Line":5},"fn_name":null},{"line":209,"address":[540080,541632,541569,540832,540760,542369],"length":1,"stats":{"Line":2},"fn_name":"get_bin_data\u003cu64,cosmwasm_storage::prefixed_storage::PrefixedStorage\u003ccosmwasm_std::storage::MemoryStorage\u003e\u003e"},{"line":210,"address":[540121,540873,541673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[540210,540270,541761,541821,541021,540961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[540963,540131,540883,540212,541683,541763],"length":1,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[541513,540704,540149,541121,542079,541043,541843,541701,540424,541279,540285,540470,541921,542313,540901],"length":1,"stats":{"Line":6},"fn_name":null},{"line":215,"address":[542432,542060,540472,541096,542081,542594,542320,542576,540711,541896,542367,542720,542738,541260,541567,541281,542450,540740,540451,542349,540402,541520,541549,540758],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003cu64,cosmwasm_storage::prefixed_storage::PrefixedStorage\u003ccosmwasm_std::storage::MemoryStorage\u003e\u003e"},{"line":224,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[548400,548802],"length":1,"stats":{"Line":1},"fn_name":"read_allowance\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":418,"address":[548464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[548560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[548593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[548658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[549139,548848],"length":1,"stats":{"Line":1},"fn_name":"write_allowance\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":431,"address":[548917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[549013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[549046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[549184,549372],"length":1,"stats":{"Line":1},"fn_name":"write_viewing_key\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":441,"address":[549222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[549249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[549424,549565],"length":1,"stats":{"Line":1},"fn_name":"read_viewing_key\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":446,"address":[549456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[549483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[549600,549837],"length":1,"stats":{"Line":1},"fn_name":"get_receiver_hash\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":456,"address":[549638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[549665,549780,549984],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":458,"address":[549998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[549888,549904],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":463,"address":[550064,550353],"length":1,"stats":{"Line":1},"fn_name":"set_receiver_hash\u003ccosmwasm_std::storage::MemoryStorage\u003e"},{"line":464,"address":[550097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[550126,550246],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[1773552],"length":1,"stats":{"Line":1},"fn_name":"slice_to_u128"},{"line":473,"address":[1773709,1773585,1773632],"length":1,"stats":{"Line":3},"fn_name":null},{"line":474,"address":[1773596,1773634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":475,"address":[1773716,1773607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[1773760],"length":1,"stats":{"Line":1},"fn_name":"slice_to_u8"},{"line":484,"address":[1773903,1773819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[1773955,1773846,1773895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":487,"address":[1773860,1773910],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":150,"coverable":174},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","src","utils.rs"],"content":"use crate::viewing_key::VIEWING_KEY_SIZE;\nuse sha2::{Digest, Sha256};\nuse std::convert::TryInto;\nuse subtle::ConstantTimeEq;\n\npub fn ct_slice_compare(s1: \u0026[u8], s2: \u0026[u8]) -\u003e bool {\n    bool::from(s1.ct_eq(s2))\n}\n\npub fn create_hashed_password(s1: \u0026str) -\u003e [u8; VIEWING_KEY_SIZE] {\n    Sha256::digest(s1.as_bytes())\n        .as_slice()\n        .try_into()\n        .expect(\"Wrong password length\")\n}\n","traces":[{"line":6,"address":[1816080],"length":1,"stats":{"Line":1},"fn_name":"ct_slice_compare"},{"line":7,"address":[1816104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[1816144],"length":1,"stats":{"Line":1},"fn_name":"create_hashed_password"},{"line":11,"address":[1816242],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","src","viewing_key.rs"],"content":"use std::fmt;\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::Env;\n\nuse crate::rand::{sha_256, Prng};\nuse crate::utils::{create_hashed_password, ct_slice_compare};\n\npub const VIEWING_KEY_SIZE: usize = 32;\npub const VIEWING_KEY_PREFIX: \u0026str = \"api_key_\";\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug)]\npub struct ViewingKey(pub String);\n\nimpl ViewingKey {\n    pub fn check_viewing_key(\u0026self, hashed_pw: \u0026[u8]) -\u003e bool {\n        let mine_hashed = create_hashed_password(\u0026self.0);\n\n        ct_slice_compare(\u0026mine_hashed, hashed_pw)\n    }\n\n    pub fn new(env: \u0026Env, seed: \u0026[u8], entropy: \u0026[u8]) -\u003e Self {\n        // 16 here represents the lengths in bytes of the block height and time.\n        let entropy_len = 16 + env.message.sender.len() + entropy.len();\n        let mut rng_entropy = Vec::with_capacity(entropy_len);\n        rng_entropy.extend_from_slice(\u0026env.block.height.to_be_bytes());\n        rng_entropy.extend_from_slice(\u0026env.block.time.to_be_bytes());\n        rng_entropy.extend_from_slice(\u0026env.message.sender.0.as_bytes());\n        rng_entropy.extend_from_slice(entropy);\n\n        let mut rng = Prng::new(seed, \u0026rng_entropy);\n\n        let rand_slice = rng.rand_bytes();\n\n        let key = sha_256(\u0026rand_slice);\n\n        Self(VIEWING_KEY_PREFIX.to_string() + \u0026base64::encode(key))\n    }\n\n    pub fn to_hashed(\u0026self) -\u003e [u8; VIEWING_KEY_SIZE] {\n        create_hashed_password(\u0026self.0)\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        self.0.as_bytes()\n    }\n}\n\nimpl fmt::Display for ViewingKey {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[1745613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1745658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1745696,1746649],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":26,"address":[1797788,1796896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1745909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1797032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1746195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1746864],"length":1,"stats":{"Line":1},"fn_name":"to_hashed"},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":20},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","tests","example-receiver","src","contract.rs"],"content":"use cosmwasm_std::{\n    from_binary, to_binary, Api, BankMsg, Binary, Coin, Context, CosmosMsg, Env, Extern,\n    HandleResponse, HumanAddr, InitResponse, Querier, StdError, StdResult, Storage, Uint128,\n    WasmMsg,\n};\n\nuse crate::msg::{CountResponse, HandleMsg, InitMsg, QueryMsg, Snip20Msg};\nuse crate::state::{config, config_read, State};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let state = State {\n        count: msg.count,\n        owner: deps.api.canonical_address(\u0026env.message.sender)?,\n        known_snip_20: vec![],\n    };\n\n    config(\u0026mut deps.storage).save(\u0026state)?;\n\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Increment {} =\u003e try_increment(deps, env),\n        HandleMsg::Reset { count } =\u003e try_reset(deps, env, count),\n        HandleMsg::Register { reg_addr, reg_hash } =\u003e try_register(deps, env, reg_addr, reg_hash),\n        HandleMsg::Receive {\n            sender,\n            from,\n            amount,\n            msg,\n        } =\u003e try_receive(deps, env, sender, from, amount, msg),\n        HandleMsg::Redeem {\n            addr,\n            hash,\n            to,\n            amount,\n        } =\u003e try_redeem(deps, env, addr, hash, to, amount),\n        HandleMsg::Fail {} =\u003e try_fail(),\n    }\n}\n\npub fn try_increment\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut count = 0;\n    config(\u0026mut deps.storage).update(|mut state| {\n        state.count += 1;\n        count = state.count;\n        Ok(state)\n    })?;\n\n    let mut context = Context::new();\n    context.add_log(\"count\", count.to_string());\n\n    Ok(context.into())\n}\n\npub fn try_reset\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    count: i32,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender_address_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n    config(\u0026mut deps.storage).update(|mut state| {\n        if sender_address_raw != state.owner {\n            return Err(StdError::Unauthorized { backtrace: None });\n        }\n        state.count = count;\n        Ok(state)\n    })?;\n    Ok(HandleResponse::default())\n}\n\npub fn try_register\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    reg_addr: HumanAddr,\n    reg_hash: String,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut conf = config(\u0026mut deps.storage);\n    let mut state = conf.load()?;\n    if !state.known_snip_20.contains(\u0026reg_addr) {\n        state.known_snip_20.push(reg_addr.clone());\n    }\n    conf.save(\u0026state)?;\n\n    let msg = to_binary(\u0026Snip20Msg::register_receive(env.contract_code_hash))?;\n    let message = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: reg_addr,\n        callback_code_hash: reg_hash,\n        msg,\n        send: vec![],\n    });\n\n    Ok(HandleResponse {\n        messages: vec![message],\n        log: vec![],\n        data: None,\n    })\n}\n\npub fn try_receive\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    _sender: HumanAddr,\n    _from: HumanAddr,\n    _amount: Uint128,\n    msg: Binary,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let msg: HandleMsg = from_binary(\u0026msg)?;\n\n    if matches!(msg, HandleMsg::Receive { .. }) {\n        return Err(StdError::generic_err(\n            \"Recursive call to receive() is not allowed\",\n        ));\n    }\n\n    let state = config_read(\u0026deps.storage).load()?;\n    if !state.known_snip_20.contains(\u0026env.message.sender) {\n        return Err(StdError::generic_err(format!(\n            \"{} is not a known SNIP-20 coin that this contract registered to\",\n            env.message.sender\n        )));\n    }\n\n    /* use sender \u0026 amount */\n    handle(deps, env, msg)\n}\n\nfn try_redeem\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    addr: HumanAddr,\n    hash: String,\n    to: HumanAddr,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let state = config_read(\u0026deps.storage).load()?;\n    if !state.known_snip_20.contains(\u0026addr) {\n        return Err(StdError::generic_err(format!(\n            \"{} is not a known SNIP-20 coin that this contract registered to\",\n            addr\n        )));\n    }\n\n    let msg = to_binary(\u0026Snip20Msg::redeem(amount))?;\n    let secret_redeem = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: addr,\n        callback_code_hash: hash,\n        msg,\n        send: vec![],\n    });\n    let redeem = CosmosMsg::Bank(BankMsg::Send {\n        amount: vec![Coin::new(amount.u128(), \"uscrt\")],\n        from_address: env.contract.address,\n        to_address: to,\n    });\n\n    Ok(HandleResponse {\n        messages: vec![secret_redeem, redeem],\n        log: vec![],\n        data: None,\n    })\n}\n\nfn try_fail() -\u003e StdResult\u003cHandleResponse\u003e {\n    Err(StdError::generic_err(\"intentional failure\"))\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::GetCount {} =\u003e to_binary(\u0026query_count(deps)?),\n    }\n}\n\nfn query_count\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cCountResponse\u003e {\n    let state = config_read(\u0026deps.storage).load()?;\n    Ok(CountResponse { count: state.count })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","tests","example-receiver","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\npub mod state;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","tests","example-receiver","src","msg.rs"],"content":"use cosmwasm_std::{Binary, HumanAddr, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n    pub count: i32,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    Increment {},\n    Reset {\n        count: i32,\n    },\n    Register {\n        reg_addr: HumanAddr,\n        reg_hash: String,\n    },\n    Receive {\n        sender: HumanAddr,\n        from: HumanAddr,\n        amount: Uint128,\n        msg: Binary,\n    },\n    Redeem {\n        addr: HumanAddr,\n        hash: String,\n        to: HumanAddr,\n        amount: Uint128,\n    },\n    Fail {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    // GetCount returns the current count as a json-encoded number\n    GetCount {},\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct CountResponse {\n    pub count: i32,\n}\n\n// Messages sent to SNIP-20 contracts\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum Snip20Msg {\n    RegisterReceive {\n        code_hash: String,\n        padding: Option\u003cString\u003e,\n    },\n    Redeem {\n        amount: Uint128,\n        padding: Option\u003cString\u003e,\n    },\n}\n\nimpl Snip20Msg {\n    pub fn register_receive(code_hash: String) -\u003e Self {\n        Snip20Msg::RegisterReceive {\n            code_hash,\n            padding: None, // TODO add padding calculation\n        }\n    }\n\n    pub fn redeem(amount: Uint128) -\u003e Self {\n        Snip20Msg::Redeem {\n            amount,\n            padding: None, // TODO add padding calculation\n        }\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","tests","example-receiver","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{CanonicalAddr, HumanAddr, Storage};\nuse cosmwasm_storage::{singleton, singleton_read, ReadonlySingleton, Singleton};\n\npub static CONFIG_KEY: \u0026[u8] = b\"config\";\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct State {\n    pub count: i32,\n    pub owner: CanonicalAddr,\n    pub known_snip_20: Vec\u003cHumanAddr\u003e,\n}\n\npub fn config\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, State\u003e {\n    singleton(storage, CONFIG_KEY)\n}\n\npub fn config_read\u003cS: Storage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, State\u003e {\n    singleton_read(storage, CONFIG_KEY)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","contracts","snip20-sienna","tests","integration.rs"],"content":"#[test]\n#[ignore]\nfn empty_test() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","amm-shared","src","data.rs"],"content":"use cosmwasm_std::{HumanAddr, StdResult, Uint128, CosmosMsg, WasmMsg, BankMsg, Coin, to_binary};\nuse crate::token_type::TokenType;\nuse schemars::JsonSchema;\nuse secret_toolkit::snip20;\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, JsonSchema)]\npub struct Pagination {\n    pub start: u64,\n    pub limit: u8\n}\n\npub fn create_send_msg (\n    token:     \u0026TokenType\u003cHumanAddr\u003e,\n    sender:    HumanAddr,\n    recipient: HumanAddr,\n    amount:    Uint128\n) -\u003e StdResult\u003cCosmosMsg\u003e {\n    let msg = match token {\n        TokenType::CustomToken { contract_addr, token_code_hash } =\u003e {\n            CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract_addr.clone(),\n                callback_code_hash: token_code_hash.to_string(),\n                msg: to_binary(\u0026snip20::HandleMsg::Send {\n                    recipient,\n                    amount,\n                    padding: None,\n                    msg: None,\n                })?,\n                send: vec![]\n            })\n        },\n        TokenType::NativeToken { denom } =\u003e {            \n            CosmosMsg::Bank(BankMsg::Send {\n                from_address: sender,\n                to_address: recipient,\n                amount: vec![Coin {\n                    denom: denom.to_string(),\n                    amount: amount\n                }],\n            })\n        }\n    };\n\n    Ok(msg)\n}\n","traces":[{"line":13,"address":[1057629,1055808],"length":1,"stats":{"Line":0},"fn_name":"create_send_msg"},{"line":19,"address":[693026,694176,693215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[1582514,1582678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[1583361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[1582717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[1056128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[1582813,1583008,1583320,1583094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[1056150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[1582789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[693345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[1583072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[1582543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[1057162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[693104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[693135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[694191,694812,693176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[693205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[694494],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":18},{"path":["/","home","runner","work","sienna","sienna","libraries","amm-shared","src","display.rs"],"content":"use std::fmt::{Display, Formatter, Result};\nuse crate::{TokenType, TokenTypeAmount, TokenPair, TokenPairAmount};\n\nimpl\u003cA: Display\u003e Display for TokenType\u003cA\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result {\n        match self {\n            TokenType::NativeToken { denom } =\u003e write!(f, \"{}\", denom),\n            TokenType::CustomToken { contract_addr, .. } =\u003e write!(f, \"{}\", contract_addr),\n        }\n    }\n}\n\nimpl\u003cA: Display\u003e Display for TokenTypeAmount\u003cA\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result {\n        write!(f, \"Token type: {} \\n Amount: {}\", self.token, self.amount)\n    }\n}\n\nimpl\u003cA: Display\u003e Display for TokenPair\u003cA\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result {\n        write!(f, \"Token 1: {} \\n Token 2: {}\", self.0, self.1)\n    }\n}\n\nimpl\u003cA: Display + Clone\u003e Display for TokenPairAmount\u003cA\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result {\n        write!(\n            f, \"Token 1: {} {} \\n Token 2: {} {}\",\n            self.pair.0, self.amount_0, self.pair.1, self.amount_1\n        )\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":12},{"path":["/","home","runner","work","sienna","sienna","libraries","amm-shared","src","exchange.rs"],"content":"use cosmwasm_std::{HumanAddr, StdResult, Api, CanonicalAddr};\nuse crate::token_pair::TokenPair;\nuse fadroma_scrt_addr::{Humanize, Canonize};\nuse schemars::JsonSchema;\nuse serde::{Serialize, Deserialize};\n\n/// Represents the address of an exchange and the pair that it manages\n#[derive(Serialize, Deserialize, JsonSchema, Clone, PartialEq, Debug)]\npub struct Exchange\u003cA: Clone\u003e {\n    /// The pair that the contract manages.\n    pub pair:    TokenPair\u003cA\u003e,\n    /// Address of the contract that manages the exchange.\n    pub address: A\n}\n\nimpl Canonize\u003cExchange\u003cCanonicalAddr\u003e\u003e for Exchange\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cExchange\u003cCanonicalAddr\u003e\u003e {\n        Ok(Exchange {\n            pair:    self.pair.canonize(api)?,\n            address: self.address.canonize(api)?\n        })\n    }\n}\n\nimpl Humanize\u003cExchange\u003cHumanAddr\u003e\u003e for Exchange\u003cCanonicalAddr\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cExchange\u003cHumanAddr\u003e\u003e {\n        Ok(Exchange {\n            pair:    self.pair.humanize(api)?,\n            address: api.human_address(\u0026self.address)?\n        })\n    }\n}\n\n#[deprecated(note=\"please use Exchange\u003cCanonicalAddr\u003e instead\")]\npub type ExchangeStored = Exchange\u003cCanonicalAddr\u003e;\n\n#[derive(Serialize, Deserialize, JsonSchema, PartialEq, Debug, Clone)]\npub struct ExchangeSettings\u003cA\u003e {\n    pub swap_fee:      Fee,\n    pub sienna_fee:    Fee,\n    pub sienna_burner: Option\u003cA\u003e\n}\n\n#[deprecated(note=\"please use ExchangeSettings\u003cCanonicalAddr\u003e instead\")]\npub type ExchangeSettingsStored = ExchangeSettings\u003cCanonicalAddr\u003e;\n\nimpl ExchangeSettings\u003cHumanAddr\u003e {\n    pub fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cExchangeSettings\u003cCanonicalAddr\u003e\u003e {\n        Ok(ExchangeSettings {\n            swap_fee:   self.swap_fee,\n            sienna_fee: self.sienna_fee,\n            sienna_burner: if let Some(info) = \u0026self.sienna_burner { \n                Some(info.canonize(api)?) \n            } else {\n                None\n            }\n        })\n    }\n}\n\nimpl ExchangeSettings\u003cCanonicalAddr\u003e {\n    pub fn humanize (self, api: \u0026impl Api) -\u003e StdResult\u003cExchangeSettings\u003cHumanAddr\u003e\u003e {\n        Ok(ExchangeSettings {\n            swap_fee:   self.swap_fee,\n            sienna_fee: self.sienna_fee,\n            sienna_burner: if let Some(info) = self.sienna_burner { \n                Some(info.humanize(api)?)\n            } else {\n                None\n            }\n        })\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, PartialEq, Clone, Copy, Debug)]\npub struct Fee {\n    pub nom: u8,\n    pub denom: u16\n}\n\nimpl Fee {\n    pub fn new(nom: u8, denom: u16) -\u003e Self {\n        Self {\n            nom,\n            denom\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[885248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[884699,885006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[885360,885125,884987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[884592,883584],"length":1,"stats":{"Line":1},"fn_name":"humanize\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":27,"address":[884180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[883627,883938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[884057,884292,883915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[865558,864946],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[864962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":21,"coverable":23},{"path":["/","home","runner","work","sienna","sienna","libraries","amm-shared","src","lib.rs"],"content":"// Modules re-export\npub use secret_toolkit::snip20;\npub use composable_admin as admin;\npub use composable_snip20 as snip20_impl;\n\npub mod fadroma {\n    pub use fadroma_scrt_callback as callback;\n    pub use fadroma_scrt_addr as address;\n    pub use fadroma_scrt_migrate as migrate;\n    pub use fadroma_scrt_storage as storage;\n    pub use cosmwasm_utils as utils;\n}\n\n\npub use data::*;\npub use token_pair::*;\npub use token_pair_amount::*;\npub use token_type::*;\npub use token_type_amount::*;\npub use exchange::*;\npub use display::*;\n\npub mod msg;\n\nmod data;\nmod token_pair;\nmod token_pair_amount;\nmod token_type;\nmod token_type_amount;\nmod exchange;\nmod display;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","amm-shared","src","msg.rs"],"content":"pub use crate::snip20_impl::msg as snip20;\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse cosmwasm_std::{HumanAddr, Binary, Uint128, Decimal};\nuse fadroma_scrt_callback::{ContractInstantiationInfo, ContractInstance, Callback};\nuse fadroma_scrt_migrate::types::ContractStatusLevel;\n\nuse crate::{TokenPair, TokenType, TokenTypeAmount, TokenPairAmount};\n\npub mod factory {\n    use super::*;\n    use super::ido::TokenSaleConfig;\n    use crate::{Pagination, Exchange, ExchangeSettings};\n    use composable_admin::admin::{AdminHandleMsg, AdminQueryMsg};\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n    pub struct InitMsg {\n        pub snip20_contract:   ContractInstantiationInfo,\n        pub lp_token_contract: ContractInstantiationInfo,\n        pub pair_contract:     ContractInstantiationInfo,\n        pub ido_contract:      ContractInstantiationInfo,\n        pub exchange_settings: ExchangeSettings\u003cHumanAddr\u003e,\n        pub admin: Option\u003cHumanAddr\u003e\n    }\n\n    #[derive(Serialize, Deserialize, JsonSchema)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum HandleMsg {\n        /// Set pause/migration status\n        SetStatus {\n            level: ContractStatusLevel,\n            reason: String,\n            new_address: Option\u003cHumanAddr\u003e\n        },\n        /// Set contract templates and exchange settings. Admin only command.\n        SetConfig {\n            snip20_contract:   Option\u003cContractInstantiationInfo\u003e,\n            lp_token_contract: Option\u003cContractInstantiationInfo\u003e,\n            pair_contract:     Option\u003cContractInstantiationInfo\u003e,\n            ido_contract:      Option\u003cContractInstantiationInfo\u003e,\n            exchange_settings: Option\u003cExchangeSettings\u003cHumanAddr\u003e\u003e\n        },\n        /// Instantiates an exchange pair contract\n        CreateExchange {\n            pair: TokenPair\u003cHumanAddr\u003e\n        },\n        /// Instantiates an IDO contract\n        CreateIdo {\n            info: TokenSaleConfig\n        },\n        /// Used by a newly instantiated exchange contract to register\n        /// itself with the factory\n        RegisterExchange {\n            pair: TokenPair\u003cHumanAddr\u003e,\n            signature: Binary\n        },\n        /// Used by a newly instantiated IDO contract to register\n        /// itself with the factory\n        RegisterIdo {\n            signature: Binary\n        },\n        /// Adds already created exchanges to the registry. Admin only command.\n        AddExchanges {\n            exchanges: Vec\u003cExchange\u003cHumanAddr\u003e\u003e\n        },\n        /// Adds already created IDO addresses to the registry. Admin only command.\n        AddIdos {\n            idos: Vec\u003cHumanAddr\u003e\n        },\n        Admin(AdminHandleMsg)\n    }\n\n    #[derive(Serialize, Deserialize, JsonSchema)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum QueryMsg {\n        /// Get pause/migration status\n        Status,\n        /// Get configuration (contract templates and exchange settings)\n        GetConfig {},\n        GetExchangeAddress { pair: TokenPair\u003cHumanAddr\u003e },\n        ListIdos { pagination: Pagination },\n        ListExchanges { pagination: Pagination },\n        GetExchangeSettings,\n\n        Admin(AdminQueryMsg)\n    }\n\n    #[derive(Serialize, Deserialize, Debug, JsonSchema, PartialEq)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum QueryResponse {\n        GetExchangeAddress {\n            address: HumanAddr\n        },\n        ListIdos {\n            idos: Vec\u003cHumanAddr\u003e\n        },\n        ListExchanges {\n            exchanges: Vec\u003cExchange\u003cHumanAddr\u003e\u003e\n        },\n        GetExchangeSettings {\n            settings: ExchangeSettings\u003cHumanAddr\u003e\n        },\n        Config {\n            snip20_contract:   ContractInstantiationInfo,\n            lp_token_contract: ContractInstantiationInfo,\n            pair_contract:     ContractInstantiationInfo,\n            ido_contract:      ContractInstantiationInfo,\n            exchange_settings: ExchangeSettings\u003cHumanAddr\u003e\n        }\n    }\n}\n\npub mod exchange {\n    use super::*;\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n    pub struct InitMsg {\n        /// The tokens that will be managed by the exchange\n        pub pair: TokenPair\u003cHumanAddr\u003e,\n        /// LP token instantiation info\n        pub lp_token_contract: ContractInstantiationInfo,\n        /// Used by the exchange contract to\n        /// send back its address to the factory on init\n        pub factory_info: ContractInstance\u003cHumanAddr\u003e,\n        pub callback: Callback\u003cHumanAddr\u003e\n    }\n\n    #[derive(Serialize, Deserialize, JsonSchema)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum HandleMsg {\n        /// Set pause/migration status\n        SetStatus {\n            level: ContractStatusLevel,\n            reason: String,\n            new_address: Option\u003cHumanAddr\u003e\n        },\n        AddLiquidity {\n            deposit: TokenPairAmount\u003cHumanAddr\u003e,\n            /// The amount the price moves in a trading pair between when a transaction is submitted and when it is executed.\n            /// Transactions that exceed this threshold will be rejected.\n            slippage_tolerance: Option\u003cDecimal\u003e\n        },\n        RemoveLiquidity {\n            /// The amount of LP tokens burned.\n            amount: Uint128,\n            /// The account to refund the tokens to.\n            recipient: HumanAddr\n        },\n        Swap {\n            /// The token type to swap from.\n            offer: TokenTypeAmount\u003cHumanAddr\u003e,\n            expected_return: Option\u003cUint128\u003e,\n        },\n        /// Sent by the LP token contract so that we can record its address.\n        OnLpTokenInit\n    }\n\n    #[derive(Serialize, Deserialize, JsonSchema)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum QueryMsg {\n        /// Get pause/migration status\n        Status,\n        PairInfo,\n        Version,\n        SwapSimulation {\n            /// The token type to swap from.\n            offer: TokenTypeAmount\u003cHumanAddr\u003e\n        }\n    }\n\n    #[derive(Serialize, Deserialize, JsonSchema)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum QueryMsgResponse {\n        PairInfo {\n            liquidity_token: ContractInstance\u003cHumanAddr\u003e,\n            factory:         ContractInstance\u003cHumanAddr\u003e,\n            pair:            TokenPair\u003cHumanAddr\u003e,\n            amount_0:        Uint128,\n            amount_1:        Uint128,\n            total_liquidity: Uint128\n        },\n        Version { version: u32 }\n    }\n\n    #[derive(Serialize, Deserialize, JsonSchema)]\n    pub struct SwapSimulationResponse {\n        pub return_amount: Uint128,\n        pub spread_amount: Uint128,\n        pub commission_amount: Uint128,\n    }\n}\n\npub mod ido {\n    use super::*;\n    use composable_admin::admin::{AdminHandleMsg, AdminQueryMsg};\n\n    #[derive(Serialize, Deserialize, JsonSchema)]\n    pub struct InitMsg {\n        pub info: TokenSaleConfig,\n        /// Should be the address of the original sender, since this is initiated by the factory.\n        pub admin: HumanAddr,\n        /// Used by the IDO to register itself with the factory.\n        pub callback: Callback\u003cHumanAddr\u003e\n    }\n    \n    #[derive(Serialize, Deserialize, JsonSchema)]\n    pub struct TokenSaleConfig {\n        /// The token that will be used to buy the SNIP20.\n        pub input_token: TokenType\u003cHumanAddr\u003e,\n        /// The price for a single token.\n        pub rate: Uint128,\n        // The address of the SNIP20 token beind sold.\n        pub sold_token: ContractInstance\u003cHumanAddr\u003e,\n        /// The addresses that are eligible to participate in the sale.\n        pub whitelist: Vec\u003cHumanAddr\u003e,\n        /// The maximum number of participants allowed.\n        pub max_seats: u32,\n        /// The total amount that each participant is allowed to buy.\n        pub max_allocation: Uint128,\n        /// The minimum amount that each participant is allowed to buy.\n        pub min_allocation: Uint128\n    }\n\n    #[derive(Serialize, Deserialize, JsonSchema)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum HandleMsg {\n        Swap {\n            amount: Uint128\n        },\n        Admin(AdminHandleMsg)\n    }\n\n    #[derive(Serialize, Deserialize, JsonSchema)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum QueryMsg {\n        GetRate,\n        Admin(AdminQueryMsg)\n    }\n\n    #[derive(Serialize, Deserialize, JsonSchema)]\n    #[serde(rename_all = \"snake_case\")]\n    pub enum QueryResponse {\n        GetRate { \n            rate: Uint128 \n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","amm-shared","src","token_pair.rs"],"content":"use cosmwasm_std::{Api, StdResult, Querier, HumanAddr, Uint128, CanonicalAddr};\nuse crate::token_type::TokenType;\nuse fadroma_scrt_addr::{Canonize, Humanize};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize, Deserializer, Serializer};\n\n#[derive(Clone, Debug, JsonSchema)]\npub struct TokenPair\u003cA\u003e(pub TokenType\u003cA\u003e, pub TokenType\u003cA\u003e);\n\nimpl Canonize\u003cTokenPair\u003cCanonicalAddr\u003e\u003e for TokenPair\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cTokenPair\u003cCanonicalAddr\u003e\u003e {\n        Ok(TokenPair(self.0.canonize(api)?, self.1.canonize(api)?))\n    }\n}\n\nimpl Humanize\u003cTokenPair\u003cHumanAddr\u003e\u003e for TokenPair\u003cCanonicalAddr\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cTokenPair\u003cHumanAddr\u003e\u003e {\n        Ok(TokenPair(self.0.humanize(api)?, self.1.humanize(api)?))\n    }\n}\n\n#[deprecated(note=\"please use TokenPair\u003cCanonicalAddr\u003e instead\")]\npub type TokenPairStored = TokenPair\u003cCanonicalAddr\u003e;\n\npub struct TokenPairIterator\u003c'a, A\u003e {\n    pair: \u0026'a TokenPair\u003cA\u003e,\n    index: u8\n}\n\nimpl\u003cA: Clone + PartialEq\u003e TokenPair\u003cA\u003e {\n    /// Returns `true` if one of the token types in the pair is the same as the argument.\n    pub fn contains(\u0026self, token: \u0026TokenType\u003cA\u003e) -\u003e bool {\n        self.0 == *token || self.1 == *token\n    }\n\n    /// Returns the index of the stored token type (0 or 1) that matches the argument.\n    /// Returns `None` if there are no matches.\n    pub fn get_token_index(\u0026self, token: \u0026TokenType\u003cA\u003e) -\u003e Option\u003cusize\u003e {\n        if self.0 == *token {\n            return Some(0);\n        } else if self.1 == *token {\n            return Some(1);\n        }\n\n        None\n    }\n\n    pub fn get_token(\u0026self, index: usize) -\u003e Option\u003c\u0026TokenType\u003cA\u003e\u003e {\n        match index {\n            0 =\u003e Some(\u0026self.0),\n            1 =\u003e Some(\u0026self.1),\n            _ =\u003e None\n        }\n    }\n}\n\nimpl TokenPair\u003cHumanAddr\u003e {\n    /// Returns the balance for each token in the pair. The order of the balances in returned array\n    /// correspond to the token order in the pair i.e `[ self.0 balance, self.1 balance ]`.\n    pub fn query_balances(\n        \u0026self,\n        querier: \u0026impl Querier,\n        exchange_addr: HumanAddr,\n        viewing_key: String\n    ) -\u003e StdResult\u003c[Uint128; 2]\u003e {\n        let amount_0 = self.0.query_balance(querier, exchange_addr.clone(), viewing_key.clone())?;\n        let amount_1 = self.1.query_balance(querier, exchange_addr, viewing_key)?;\n\n        // order is important\n        Ok([amount_0, amount_1])\n    }\n}\n\nimpl\u003cA: PartialEq\u003e PartialEq for TokenPair\u003cA\u003e {\n    fn eq(\u0026self, other: \u0026TokenPair\u003cA\u003e) -\u003e bool {\n        (self.0 == other.0 || self.0 == other.1) \u0026\u0026 (self.1 == other.0 || self.1 == other.1)\n    }\n}\n\nimpl\u003c'a, A: Clone\u003e IntoIterator for \u0026'a TokenPair\u003cA\u003e {\n    type Item = \u0026'a TokenType\u003cA\u003e;\n    type IntoIter = TokenPairIterator\u003c'a, A\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        TokenPairIterator { pair: self, index: 0 }\n    }\n}\n\nimpl\u003c'a, A: Clone\u003e Iterator for TokenPairIterator\u003c'a, A\u003e {\n    type Item = \u0026'a TokenType\u003cA\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let result = match self.index {\n            0 =\u003e Some(\u0026self.pair.0),\n            1 =\u003e Some(\u0026self.pair.1),\n            _ =\u003e None\n        };\n\n        self.index += 1;\n\n        result\n    }\n}\n\n// These are only used for serde, because it doesn't work with struct tuples.\n#[derive(Serialize, Deserialize)]\npub struct TokenPairSerde\u003cA: Clone\u003e {\n    token_0: TokenType\u003cA\u003e,\n    token_1: TokenType\u003cA\u003e,\n}\n\n#[deprecated(note=\"please use TokenPairStoredSerde\u003cCanonicalAddr\u003e instead\")]\npub type TokenPairStoredSerde = TokenPairSerde\u003cCanonicalAddr\u003e;\n\nimpl\u003cA: Clone + Serialize\u003e Serialize for TokenPair\u003cA\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        TokenPairSerde { token_0: self.0.clone(), token_1: self.1.clone() }.serialize(serializer)\n    }\n}\n\nimpl\u003c'de, A: Deserialize\u003c'de\u003e + Clone\u003e Deserialize\u003c'de\u003e for TokenPair\u003cA\u003e {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Deserialize::deserialize(deserializer)\n            .map(|TokenPairSerde { token_0, token_1 }| TokenPair(token_0, token_1))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn token_pair_equality() {\n        let pair: TokenPair\u003cHumanAddr\u003e = TokenPair(\n            TokenType::CustomToken {\n                contract_addr: \"address\".into(),\n                token_code_hash: \"hash\".into()\n            },\n            TokenType::NativeToken {\n                denom: \"denom\".into()\n            }\n        );\n\n        let pair2 = TokenPair(pair.1.clone(), pair.0.clone());\n\n        assert_eq!(pair, pair.clone());\n        assert_eq!(pair2, pair2.clone());\n        assert_eq!(pair, pair2);\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[709901,709056],"length":1,"stats":{"Line":2},"fn_name":"humanize\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[711088,711376],"length":1,"stats":{"Line":4},"fn_name":"serialize\u003ccosmwasm_std::addresses::CanonicalAddr,\u0026mut serde_json_wasm::ser::Serializer\u003e"},{"line":119,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[711552,711472],"length":1,"stats":{"Line":3},"fn_name":"deserialize\u003ccosmwasm_std::addresses::CanonicalAddr,serde::__private::de::missing_field::MissingFieldDeserializer\u003cserde_json_wasm::de::errors::Error\u003e\u003e"},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":138,"address":[686944,686912,686917,688113],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":140,"address":[687007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[686951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[686976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[687114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[687083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[688059,687293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[687461,688031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[688016,687652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[687835],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":21,"coverable":46},{"path":["/","home","runner","work","sienna","sienna","libraries","amm-shared","src","token_pair_amount.rs"],"content":"use cosmwasm_std::{Uint128, Env, StdResult};\nuse crate::{token_type::TokenType, token_pair::TokenPair};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct TokenPairAmount\u003cA: Clone\u003e {\n    pub pair:     TokenPair\u003cA\u003e,\n    pub amount_0: Uint128,\n    pub amount_1: Uint128\n}\n\nimpl\u003cA: Clone\u003e TokenPairAmount\u003cA\u003e {\n    pub fn assert_sent_native_token_balance(\u0026self, env: \u0026Env) -\u003e StdResult\u003c()\u003e {\n        self.pair.0.assert_sent_native_token_balance(env, self.amount_0)?;\n        self.pair.1.assert_sent_native_token_balance(env, self.amount_1)?;\n\n        Ok(())\n    }\n}\n\nimpl\u003c'a, A: Clone\u003e IntoIterator for \u0026'a TokenPairAmount\u003cA\u003e {\n    type Item = (Uint128, \u0026'a TokenType\u003cA\u003e);\n    type IntoIter = TokenPairAmountIterator\u003c'a, A\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        TokenPairAmountIterator {\n            pair: self,\n            index: 0\n        }\n    }\n}\n\npub struct TokenPairAmountIterator\u003c'a, A: Clone\u003e {\n    pair: \u0026'a TokenPairAmount\u003cA\u003e,\n    index: u8\n}\n\nimpl\u003c'a, A: Clone\u003e Iterator for TokenPairAmountIterator\u003c'a, A\u003e {\n    type Item = (Uint128, \u0026'a TokenType\u003cA\u003e);\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let result = match self.index {\n            0 =\u003e Some((self.pair.amount_0, \u0026self.pair.pair.0)),\n            1 =\u003e Some((self.pair.amount_1, \u0026self.pair.pair.1)),\n            _ =\u003e None\n        };\n        self.index += 1;\n        result\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","home","runner","work","sienna","sienna","libraries","amm-shared","src","token_type.rs"],"content":"use cosmwasm_std::{HumanAddr, CanonicalAddr, Api, StdResult, Querier, Uint128, StdError, Env};\nuse fadroma_scrt_addr::{Canonize, Humanize};\nuse schemars::JsonSchema;\nuse secret_toolkit::snip20;\nuse serde::{Deserialize, Serialize};\n\nconst BLOCK_SIZE: usize = 256;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum TokenType\u003cA\u003e {\n    CustomToken {\n        contract_addr: A,\n        token_code_hash: String,\n        //viewing_key: String,\n    },\n    NativeToken {\n        denom: String,\n    },\n}\nimpl Canonize\u003cTokenType\u003cCanonicalAddr\u003e\u003e for TokenType\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cTokenType\u003cCanonicalAddr\u003e\u003e {\n        Ok(match self {\n            Self::CustomToken { contract_addr, token_code_hash } =\u003e TokenType::CustomToken {\n                contract_addr: contract_addr.canonize(api)?,\n                token_code_hash: token_code_hash.clone()\n            },\n            Self::NativeToken { denom } =\u003e TokenType::NativeToken {\n                denom: denom.clone()\n            }\n        })\n    }\n}\nimpl Humanize\u003cTokenType\u003cHumanAddr\u003e\u003e for TokenType\u003cCanonicalAddr\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cTokenType\u003cHumanAddr\u003e\u003e {\n        Ok(match self {\n            Self::CustomToken { contract_addr, token_code_hash } =\u003e TokenType::CustomToken {\n                contract_addr: contract_addr.humanize(api)?,\n                token_code_hash: token_code_hash.clone()\n            },\n            Self::NativeToken { denom } =\u003e TokenType::NativeToken {\n                denom: denom.clone()\n            }\n        })\n    }\n}\n\n#[deprecated(note=\"please use TokenType\u003cCanonicalAddr\u003e instead\")]\npub type TokenTypeStored = TokenType\u003cCanonicalAddr\u003e;\n\nimpl\u003cA: Clone\u003e TokenType\u003cA\u003e {\n    pub fn is_native_token(\u0026self) -\u003e bool {\n        match self {\n            TokenType::NativeToken { .. } =\u003e true,\n            TokenType::CustomToken { .. } =\u003e false,\n        }\n    }\n    pub fn is_custom_token(\u0026self) -\u003e bool {\n        match self {\n            TokenType::NativeToken { .. } =\u003e false,\n            TokenType::CustomToken { .. } =\u003e true,\n        }\n    }\n    pub fn assert_sent_native_token_balance(\u0026self, env: \u0026Env, amount: Uint128) -\u003e StdResult\u003c()\u003e {\n        if let TokenType::NativeToken { denom } = \u0026self {\n            return match env.message.sent_funds.iter().find(|x| x.denom == *denom) {\n                Some(coin) =\u003e {\n                    if amount == coin.amount {\n                        Ok(())\n                    } else {\n                        Err(StdError::generic_err(\"Native token balance missmatch between the argument and the transferred\"))\n                    }\n                }\n                None =\u003e {\n                    if amount.is_zero() {\n                        Ok(())\n                    } else {\n                        Err(StdError::generic_err(\"Native token balance missmatch between the argument and the transferred\"))\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n\nimpl TokenType\u003cHumanAddr\u003e {\n    pub fn query_balance(\n        \u0026self,\n        querier: \u0026impl Querier,\n        exchange_addr: HumanAddr,\n        viewing_key: String\n    ) -\u003e StdResult\u003cUint128\u003e {\n        match self {\n            TokenType::NativeToken { denom } =\u003e {\n                let result = querier.query_balance(exchange_addr, denom)?;\n                Ok(result.amount)\n            },\n            TokenType::CustomToken { contract_addr, token_code_hash } =\u003e {\n                let result = snip20::balance_query(\n                    querier,\n                    exchange_addr.clone(),\n                    viewing_key,\n                    BLOCK_SIZE,\n                    token_code_hash.clone(),\n                    contract_addr.clone()\n                )?;\n                Ok(result.amount)\n            }\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":47},{"path":["/","home","runner","work","sienna","sienna","libraries","amm-shared","src","token_type_amount.rs"],"content":"use cosmwasm_std::{Uint128, Env, StdResult};\nuse crate::token_type::TokenType;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct TokenTypeAmount\u003cA\u003e {\n    pub token: TokenType\u003cA\u003e,\n    pub amount: Uint128\n}\n\nimpl\u003cA: Clone\u003e TokenTypeAmount\u003cA\u003e {\n    pub fn assert_sent_native_token_balance(\u0026self, env: \u0026Env) -\u003e StdResult\u003c()\u003e {\n        self.token.assert_sent_native_token_balance(env, self.amount)\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-addr","lib.rs"],"content":"//! `HumanAddr`\u003c-\u003e`CanonicalAddr` conversion\n\nuse cosmwasm_std::{Api, CanonicalAddr, HumanAddr, StdResult};\n\npub trait Humanize\u003cT\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cT\u003e;\n}\n\npub trait Canonize\u003cT\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cT\u003e;\n}\n\n/// Attempting to canonicalize an empty address will fail. \n/// This function skips calling `canonical_address` if the input is empty\n/// and returns `CanonicalAddr::default()` instead.\npub fn canonize_maybe_empty(api: \u0026impl Api, addr: \u0026HumanAddr) -\u003e StdResult\u003cCanonicalAddr\u003e {\n    Ok(\n        if *addr == HumanAddr::default() {\n            CanonicalAddr::default()\n        } else {\n            api.canonical_address(addr)?\n        }\n    )\n}\n\n/// Attempting to humanize an empty address will fail. \n/// This function skips calling `human_address` if the input is empty\n/// and returns `HumanAddr::default()` instead.\npub fn humanize_maybe_empty(api: \u0026impl Api, addr: \u0026CanonicalAddr) -\u003e StdResult\u003cHumanAddr\u003e {\n    Ok(\n        if *addr == CanonicalAddr::default() {\n            HumanAddr::default()\n        } else {\n            api.human_address(addr)?\n        }\n    )\n}\n\nimpl Humanize\u003cHumanAddr\u003e for CanonicalAddr {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cHumanAddr\u003e {\n        humanize_maybe_empty(api, self)\n    }\n}\n\nimpl\u003cT: Humanize\u003cU\u003e, U\u003e Humanize\u003cVec\u003cU\u003e\u003e for Vec\u003cT\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cVec\u003cU\u003e\u003e {\n        self.iter().map(|x|x.humanize(api)).collect()\n    }\n}\n\nimpl Canonize\u003cCanonicalAddr\u003e for HumanAddr {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cCanonicalAddr\u003e {\n        canonize_maybe_empty(api, self)\n    }\n}\n\nimpl\u003cT: Canonize\u003cU\u003e, U\u003e Canonize\u003cVec\u003cU\u003e\u003e for Vec\u003cT\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cVec\u003cU\u003e\u003e {\n        self.iter().map(|x|x.canonize(api)).collect()\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-admin","composable-admin","src","admin.rs"],"content":"use cosmwasm_std::{\n    HumanAddr, CanonicalAddr, StdResult, Extern, Env,\n    Api, Querier, Storage, StdError, HandleResponse,\n    Binary, to_binary\n};\nuse schemars::JsonSchema;\nuse serde::{Serialize, Deserialize};\n\nconst ADMIN_KEY: \u0026[u8] = b\"ltp5P6sFZT\";\n\npub fn admin_handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: AdminHandleMsg,\n    handle: impl AdminHandle,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        AdminHandleMsg::ChangeAdmin { address } =\u003e handle.change_admin(deps, env, address)\n    }\n}\n\npub fn admin_query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: AdminQueryMsg,\n    query: impl AdminQuery,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        AdminQueryMsg::Admin =\u003e query.query_admin(deps)\n    }\n}\n\npub trait AdminHandle {\n    fn change_admin\u003cS: Storage, A: Api, Q: Querier\u003e(\n        \u0026self,\n        deps: \u0026mut Extern\u003cS, A, Q\u003e,\n        env: Env,\n        address: HumanAddr,\n    ) -\u003e StdResult\u003cHandleResponse\u003e {\n        assert_admin(deps, \u0026env)?;\n        save_admin(deps, \u0026address)?;\n    \n        Ok(HandleResponse::default())\n    }\n}\n\npub trait AdminQuery {\n    fn query_admin\u003cS: Storage, A: Api, Q: Querier\u003e(\n        \u0026self,\n        deps: \u0026Extern\u003cS, A, Q\u003e\n    )-\u003e StdResult\u003cBinary\u003e {\n        let address = load_admin(deps)?;\n    \n        to_binary(\u0026AdminQueryResponse { \n            address\n        })\n    }\n}\n\npub struct DefaultHandleImpl;\n\nimpl AdminHandle for DefaultHandleImpl { }\n\npub struct DefaultQueryImpl;\n\nimpl AdminQuery for DefaultQueryImpl { }\n\n#[derive(JsonSchema, Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum AdminHandleMsg {\n    ChangeAdmin {\n        address: HumanAddr\n    }\n}\n\n#[derive(JsonSchema, Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum AdminQueryMsg {\n    Admin\n}\n\n#[derive(JsonSchema, Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub struct AdminQueryResponse {\n    pub address: HumanAddr\n}\n\npub fn load_admin\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e\n) -\u003e StdResult\u003cHumanAddr\u003e {\n    let result = deps.storage.get(ADMIN_KEY);\n\n    if let Some(bytes) = result {\n        let admin = CanonicalAddr::from(bytes);\n\n        deps.api.human_address(\u0026admin)\n    } else {\n        Ok(HumanAddr::default())\n    }\n}\n\npub fn save_admin\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    address: \u0026HumanAddr\n) -\u003e StdResult\u003c()\u003e {\n    let admin = deps.api.canonical_address(address)?;\n    deps.storage.set(ADMIN_KEY, \u0026admin.as_slice());\n\n    Ok(())\n}\n\npub fn assert_admin\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    env: \u0026Env\n) -\u003e StdResult\u003c()\u003e {\n    let admin = load_admin(deps)?;\n\n    if admin == env.message.sender {\n        return Ok(());\n    }\n\n    Err(StdError::unauthorized())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::from_binary;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env};\n\n    #[test]\n    fn test_handle() {\n        let ref mut deps = mock_dependencies(10, \u0026[]);\n\n        let admin = HumanAddr::from(\"admin\");\n        save_admin(deps, \u0026admin).unwrap();\n\n        let msg = AdminHandleMsg::ChangeAdmin { \n            address: HumanAddr::from(\"will fail\")\n        };\n\n        let result = admin_handle(\n            deps,\n            mock_env(\"unauthorized\", \u0026[]),\n            msg,\n            DefaultHandleImpl\n        ).unwrap_err();\n        \n        match result {\n            StdError::Unauthorized { .. } =\u003e { },\n            _ =\u003e panic!(\"Expected \\\"StdError::Unauthorized\\\"\")\n        };\n\n        let new_admin = HumanAddr::from(\"new_admin\");\n\n        let msg = AdminHandleMsg::ChangeAdmin { \n            address: new_admin.clone()\n        };\n\n        admin_handle(\n            deps,\n            mock_env(admin, \u0026[]),\n            msg,\n            DefaultHandleImpl\n        ).unwrap();\n\n        assert!(load_admin(deps).unwrap() == new_admin);\n    }\n\n    #[test]\n    fn test_query() {\n        let ref mut deps = mock_dependencies(10, \u0026[]);\n\n        let result = admin_query(deps, AdminQueryMsg::Admin, DefaultQueryImpl).unwrap();\n\n        let response: AdminQueryResponse = from_binary(\u0026result).unwrap();\n        assert!(response.address == HumanAddr::default());\n\n        let admin = HumanAddr::from(\"admin\");\n        save_admin(deps, \u0026admin).unwrap();\n\n        let result = admin_query(deps, AdminQueryMsg::Admin, DefaultQueryImpl).unwrap();\n\n        let response: AdminQueryResponse = from_binary(\u0026result).unwrap();\n        assert!(response.address == admin);\n    }\n}\n","traces":[{"line":11,"address":[544208,544368],"length":1,"stats":{"Line":1},"fn_name":"admin_handle\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e,composable_admin::admin::DefaultHandleImpl\u003e"},{"line":18,"address":[544249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[544416,544462],"length":1,"stats":{"Line":1},"fn_name":"admin_query\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e,composable_admin::admin::DefaultQueryImpl\u003e"},{"line":28,"address":[544441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[546162,545856],"length":1,"stats":{"Line":1},"fn_name":"load_admin\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":90,"address":[545885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[545924,545962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[545990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[546040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[546081,545955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[546320,546715],"length":1,"stats":{"Line":1},"fn_name":"save_admin\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":105,"address":[546358,546501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[546469,546612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[546673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[546752,547123],"length":1,"stats":{"Line":1},"fn_name":"assert_admin\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":115,"address":[546914,546790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[547015,546892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[547026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[547046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[565093,566115,565120,565088],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":132,"address":[565127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[565191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[565222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[565280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[565351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[565390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[565496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[565507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[565540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[565587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[565634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[565706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[565840,566059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[566389,566416,566384,567145],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":171,"address":[566423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[566471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[566524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[566582,567094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[566688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[566740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[566782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[566835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[566888],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":50,"coverable":51},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-admin","composable-admin","src","lib.rs"],"content":"pub use require_admin::require_admin;\n\npub mod multi_admin;\npub mod admin;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-admin","composable-admin","src","multi_admin.rs"],"content":"use cosmwasm_std::{\n    HumanAddr, CanonicalAddr, StdResult, Extern, Env,\n    Api, Querier, Storage, to_vec, StdError, HandleResponse,\n    Binary, to_binary, from_slice, ReadonlyStorage\n};\nuse schemars::JsonSchema;\nuse serde::{Serialize, Deserialize};\nuse serde::de::DeserializeOwned;\n\nconst ADMINS_KEY: \u0026[u8] = b\"i801onL3kf\";\n\npub fn multi_admin_handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: MultiAdminHandleMsg,\n    handle: impl MultiAdminHandle,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        MultiAdminHandleMsg::AddAdmins { addresses } =\u003e handle.add_admins(deps, env, addresses)\n    }\n}\n\npub fn multi_admin_query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: MultiAdminQueryMsg,\n    query: impl MultiAdminQuery,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        MultiAdminQueryMsg::Admins =\u003e query.query_admins(deps)\n    }\n}\n\npub trait MultiAdminHandle {\n    fn add_admins\u003cS: Storage, A: Api, Q: Querier\u003e(\n        \u0026self,\n        deps: \u0026mut Extern\u003cS, A, Q\u003e,\n        env: Env,\n        addresses: Vec\u003cHumanAddr\u003e,\n    ) -\u003e StdResult\u003cHandleResponse\u003e {\n        assert_admin(deps, \u0026env)?;\n        save_admins(deps, \u0026addresses)?;\n    \n        Ok(HandleResponse::default())\n    }\n}\n\npub trait MultiAdminQuery {\n    fn query_admins\u003cS: Storage, A: Api, Q: Querier\u003e(\n        \u0026self,\n        deps: \u0026Extern\u003cS, A, Q\u003e\n    )-\u003e StdResult\u003cBinary\u003e {\n        let addresses = load_admins(deps)?;\n    \n        to_binary(\u0026MultiAdminQueryResponse { \n            addresses\n        })\n    }\n}\n\npub struct DefaultHandleImpl;\n\nimpl MultiAdminHandle for DefaultHandleImpl { }\n\npub struct DefaultQueryImpl;\n\nimpl MultiAdminQuery for DefaultQueryImpl { }\n\n#[derive(JsonSchema, Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum MultiAdminHandleMsg {\n    AddAdmins {\n        addresses: Vec\u003cHumanAddr\u003e,\n    }\n}\n\n#[derive(JsonSchema, Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum MultiAdminQueryMsg {\n    Admins\n}\n\n#[derive(JsonSchema, Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub struct MultiAdminQueryResponse {\n    pub addresses: Vec\u003cHumanAddr\u003e\n}\n\npub fn save_admins\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    addresses: \u0026Vec\u003cHumanAddr\u003e\n) -\u003e StdResult\u003c()\u003e {\n    let mut admins: Vec\u003cCanonicalAddr\u003e = \n        load(\u0026deps.storage, ADMINS_KEY).unwrap_or(vec![]);\n    \n    for address in addresses {\n        let canonical = deps.api.canonical_address(address)?;\n        admins.push(canonical);\n    }\n\n    deps.storage.set(ADMINS_KEY, \u0026to_vec(\u0026admins)?);\n\n    Ok(())\n}\n\npub fn load_admins\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e\n) -\u003e StdResult\u003cVec\u003cHumanAddr\u003e\u003e {\n    let admins: Vec\u003cCanonicalAddr\u003e =\n        load(\u0026deps.storage, ADMINS_KEY).unwrap_or(vec![]);\n    \n    let mut result = Vec::with_capacity(admins.len());\n\n    for admin in admins {\n        result.push(deps.api.human_address(\u0026admin)?)\n    }\n\n    Ok(result)\n}\n\npub fn assert_admin\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    env: \u0026Env,\n) -\u003e StdResult\u003c()\u003e {\n    let admins = load_admins(deps)?;\n\n    if admins.contains(\u0026env.message.sender) {\n        return Ok(());\n    }\n\n    Err(StdError::unauthorized())\n}\n\nfn load\u003cT: DeserializeOwned, S: ReadonlyStorage\u003e(storage: \u0026S, key: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n    let result = storage.get(key).ok_or_else(||\n        StdError::SerializeErr { \n            source: \"load\".into(),\n            msg: \"key not found\".into(),\n            backtrace: None\n        }\n    )?;\n    \n    from_slice(\u0026result)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::from_binary;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env};\n\n    #[test]\n    fn test_handle() {\n        const ADMIN: \u0026str = \"goshu\";\n\n        fn run_msg\u003cS: Storage, A: Api, Q: Querier\u003e(\n            deps: \u0026mut Extern\u003cS, A, Q\u003e,\n            addresses: Vec\u003cHumanAddr\u003e,\n            assert_len: usize\n        ) {\n            let msg = MultiAdminHandleMsg::AddAdmins {\n                addresses\n            };\n    \n            let result = multi_admin_handle(\n                deps,\n                mock_env(HumanAddr::from(ADMIN), \u0026[]),\n                msg,\n                DefaultHandleImpl\n            );\n    \n            assert!(result.is_ok());\n    \n            let admins = load_admins(deps).unwrap();\n            assert!(\n                admins.len() == assert_len,\n                \"Assert admins.len() failed: Expected: {}, Got: {}\", admins.len(), assert_len\n            );\n        }\n\n        let ref mut deps = mock_dependencies(10, \u0026[]);\n\n        let admin = HumanAddr::from(\"goshu\");\n        save_admins(deps, \u0026vec![ admin.clone() ]).unwrap();\n\n        let msg = MultiAdminHandleMsg::AddAdmins {\n            addresses: vec![ HumanAddr::from(\"will fail\") ]\n        };\n\n        let result = multi_admin_handle(\n            deps,\n            mock_env(HumanAddr::from(\"unauthorized\"), \u0026[]),\n            msg,\n            DefaultHandleImpl\n        )\n        .unwrap_err();\n\n        match result {\n            StdError::Unauthorized { .. } =\u003e { },\n            _ =\u003e panic!(\"Expected \\\"StdError::Unauthorized\\\"\")\n        };\n\n        run_msg(deps, vec![], 1);\n\n        run_msg(\n            deps,\n            vec![\n                HumanAddr::from(\"archer\"),\n                HumanAddr::from(\"lana\")\n            ],\n            3\n        );\n\n        run_msg(\n            deps,\n            vec![\n                HumanAddr::from(\"pam\"),\n            ],\n            4\n        );\n    }\n\n    #[test]\n    fn test_query() {\n        let ref mut deps = mock_dependencies(10, \u0026[]);\n\n        let result = multi_admin_query(deps, MultiAdminQueryMsg::Admins, DefaultQueryImpl).unwrap();\n\n        let response: MultiAdminQueryResponse = from_binary(\u0026result).unwrap();\n        assert!(response.addresses.len() == 0);\n\n        let admins = vec![\n            HumanAddr::from(\"archer\"),\n            HumanAddr::from(\"lana\")\n        ];\n\n        save_admins(deps, \u0026admins).unwrap();\n\n        let result = multi_admin_query(deps, MultiAdminQueryMsg::Admins, DefaultQueryImpl).unwrap();\n\n        let response: MultiAdminQueryResponse = from_binary(\u0026result).unwrap();\n        assert!(response.addresses == admins);\n    }\n}\n","traces":[{"line":12,"address":[515136,514976],"length":1,"stats":{"Line":1},"fn_name":"multi_admin_handle\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e,composable_admin::multi_admin::DefaultHandleImpl\u003e"},{"line":19,"address":[515017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[515230,515184],"length":1,"stats":{"Line":1},"fn_name":"multi_admin_query\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e,composable_admin::multi_admin::DefaultQueryImpl\u003e"},{"line":29,"address":[515209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[517918,516624],"length":1,"stats":{"Line":1},"fn_name":"save_admins\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":92,"address":[516667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[516774,516915,517417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[517987,516954,517155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[517092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[517422,517957,517892,516905,517826],"length":1,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[517938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[519357,518160],"length":1,"stats":{"Line":1},"fn_name":"load_admins\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":108,"address":[518190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[518313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[518541,518348,519143],"length":1,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[518692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[519153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[519600,520001],"length":1,"stats":{"Line":1},"fn_name":"assert_admin\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":124,"address":[519763,519638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[519875,519740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[519907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[519926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[520393,520048],"length":1,"stats":{"Line":1},"fn_name":"load\u003calloc::vec::Vec\u003ccosmwasm_std::addresses::CanonicalAddr, alloc::alloc::Global\u003e,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":134,"address":[520240,520157,520432,520089,520322,520627],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}\u003calloc::vec::Vec\u003ccosmwasm_std::addresses::CanonicalAddr, alloc::alloc::Global\u003e,cosmwasm_std::storage::MemoryStorage\u003e"},{"line":135,"address":[520514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[520445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[520468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[520505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[520209,520351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[473456,472309,472304,472336],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":155,"address":[474581,473808],"length":1,"stats":{"Line":1},"fn_name":"run_msg\u003ccosmwasm_std::storage::MemoryStorage,cosmwasm_std::mock::MockApi,cosmwasm_std::mock::MockQuerier\u003ccosmwasm_std::types::Empty\u003e\u003e"},{"line":166,"address":[473898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[473966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[474039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[474110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[474253,474183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[474155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[474199,474237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[472343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[472387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[472428,473421,473543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[472599,473528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[472745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[472808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[472912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[472923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[472964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[473389,473082,473004,473486],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[473020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[473051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[473471,473198,473245],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[473214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[474704,474709,474736,475551],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":224,"address":[474743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[474791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[474844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[474889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[475045,475498,474967,475566],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[474983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[475014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[475149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[475191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[475244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[475297],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":70,"coverable":72},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-admin","require-admin","src","lib.rs"],"content":"use proc_macro::TokenStream;\nuse syn::{FnArg, ItemFn, PathArguments, Stmt, Type, parse_macro_input, parse_quote, Pat, PatIdent};\nuse syn::punctuated::Punctuated;\nuse syn::token::Comma;\nuse quote::quote;\n\n#[proc_macro_attribute]\npub fn require_admin(_attr: TokenStream, func: TokenStream) -\u003e TokenStream {\n    let mut ast = parse_macro_input!(func as ItemFn);\n\n    let (deps, env) = find_extern_arg(\u0026ast.sig.inputs);\n\n    let stmt = create_require_admin_stmt(deps, env);\n    ast.block.stmts.insert(0, stmt);\n\n    let result = quote! {\n        #ast\n    };\n\n    TokenStream::from(result)\n}\n\nfn find_extern_arg(args: \u0026Punctuated\u003cFnArg, Comma\u003e) -\u003e (PatIdent, PatIdent) {\n    let mut deps: Option\u003cPatIdent\u003e = None;\n    let mut env: Option\u003cPatIdent\u003e = None;\n\n    for arg in args {\n        match arg {\n            FnArg::Typed(item) =\u003e {\n                match item.ty.as_ref() {\n                    Type::Reference(reference) =\u003e {\n                        match reference.elem.as_ref() {\n                            Type::Path(type_path) =\u003e {\n                                let result = type_path.path.segments.iter()\n                                    .find(|i| {\n                                        if let PathArguments::AngleBracketed(_) = i.arguments {\n                                            if i.ident.to_string() == \"Extern\" {\n                                                return true\n                                            }\n                                        }\n\n                                        false\n                                    });\n\n                                if let Some(_) = result {\n                                    if let Pat::Ident(ident) = item.pat.as_ref() {\n                                        deps = Some(ident.clone())\n                                    }\n                                }\n                            },\n                            _ =\u003e continue\n                        }\n                    },\n                    Type::Path(type_path) =\u003e {\n                        let result = type_path.path.segments.iter()\n                            .find(|i| {\n                                if i.ident.to_string() == \"Env\" {\n                                    return true\n                                }\n                    \n                                false\n                            });\n                \n                        if let Some(_) = result {\n                            if let Pat::Ident(ident) = item.pat.as_ref() {\n                                env = Some(ident.clone())\n                            }\n                        }\n                    }\n                    _ =\u003e continue\n                }\n            },\n            _ =\u003e continue\n        }\n    }\n    \n    return (\n        deps.unwrap_or_else(|| panic!(\"Couldn't find argument of type \\\"Extern\u003cStorage, Api, Querier\u003e\\\"\")),\n        env.unwrap_or_else(|| panic!(\"Couldn't find arguments of type \\\"Env\\\"\"))\n    );\n}\n\nfn create_require_admin_stmt(deps: PatIdent, env: PatIdent) -\u003e Stmt {\n    let code = quote! {\n        assert_admin(#deps, \u0026#env)?;\n    };\n\n    parse_quote!(#code)\n}\n","traces":[{"line":8,"address":[273055,271904],"length":1,"stats":{"Line":0},"fn_name":"require_admin"},{"line":9,"address":[271935,273114,272150,273028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[272127,272219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[272427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[272666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[272735,272989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[272826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[273264,274849],"length":1,"stats":{"Line":0},"fn_name":"find_extern_arg"},{"line":24,"address":[273308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[273343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[273508,273362,274420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[273547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[273582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[273610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[273666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[273694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[273726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[275383,275248],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":36,"address":[275351,275267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[275372,275284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[275344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[275353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[273838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[274934,273874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[274864,273930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[274068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[274083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[275424,275535],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":57,"address":[275438,275524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[275498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[275505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[274195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[275012,274231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[274287,274939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[274687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[275569,274425,275568],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":79,"address":[275600,275601,274552],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":83,"address":[275632,276215],"length":1,"stats":{"Line":0},"fn_name":"create_require_admin_stmt"},{"line":84,"address":[275661,276169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[275953,276142],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":40},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-auth","composable-auth","src","lib.rs"],"content":"pub use cosmwasm_utils::viewing_key::{ViewingKey, VIEWING_KEY_SIZE};\n\nuse cosmwasm_std::{\n    StdResult, Extern, Env, Api, Querier, Storage,\n    StdError, HandleResponse, to_binary\n};\nuse schemars::JsonSchema;\nuse serde::{Serialize, Deserialize};\nuse cosmwasm_utils::storage::{ns_save, ns_load};\n\nconst VIEWING_KEYS: \u0026[u8] = b\"XXzo7ZXRJ2\";\n\npub fn auth_handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: AuthHandleMsg,\n    handle: impl AuthHandle,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        AuthHandleMsg::CreateViewingKey { entropy, .. } =\u003e\n            handle.create_viewing_key(deps, env, entropy),\n        AuthHandleMsg::SetViewingKey { key, .. } =\u003e \n            handle.set_viewing_key(deps, env, key)\n    }\n}\n\npub trait AuthHandle {\n    fn create_viewing_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n        \u0026self,\n        deps: \u0026mut Extern\u003cS, A, Q\u003e,\n        env: Env,\n        entropy: String\n    ) -\u003e StdResult\u003cHandleResponse\u003e {\n        let prng_seed = [ \n            env.block.time.to_be_bytes(),\n            env.block.height.to_be_bytes() \n        ].concat();\n\n        let key = ViewingKey::new(\u0026env, \u0026prng_seed, \u0026(entropy).as_ref());\n        let address = deps.api.canonical_address(\u0026env.message.sender)?;\n        save_viewing_key(deps, address.as_slice(), \u0026key)?;\n\n        Ok(HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: Some(to_binary(\u0026CreateViewingKeyData {\n                key: key.0\n            })?)\n        })\n    }\n\n    fn set_viewing_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n        \u0026self,\n        deps: \u0026mut Extern\u003cS, A, Q\u003e,\n        env: Env,\n        key: String\n    ) -\u003e StdResult\u003cHandleResponse\u003e {\n        let key = ViewingKey(key);\n        let address = deps.api.canonical_address(\u0026env.message.sender)?;\n        save_viewing_key(deps, address.as_slice(), \u0026key)?;\n\n        Ok(HandleResponse::default())\n    }\n}\n\n#[derive(JsonSchema, Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum AuthHandleMsg {\n    CreateViewingKey {\n        entropy: String,\n        padding: Option\u003cString\u003e,\n    },\n    SetViewingKey {\n        key: String,\n        padding: Option\u003cString\u003e,\n    }\n}\n\n#[derive(JsonSchema, Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub struct CreateViewingKeyData {\n    pub key: String\n}\n\npub struct DefaultHandleImpl;\n\nimpl AuthHandle for DefaultHandleImpl { }\n\n#[inline]\npub fn save_viewing_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    key: \u0026[u8],\n    viewing_key: \u0026ViewingKey\n) -\u003e StdResult\u003c()\u003e {\n    ns_save(\u0026mut deps.storage, VIEWING_KEYS, key, \u0026viewing_key)\n}\n\n#[inline]\npub fn load_viewing_key\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    key: \u0026[u8],\n) -\u003e StdResult\u003cOption\u003cViewingKey\u003e\u003e {\n    ns_load(\u0026deps.storage, VIEWING_KEYS, key)\n}\n\npub fn authenticate(\n    storage: \u0026impl Storage,\n    provided_key: \u0026ViewingKey,\n    storage_key: \u0026[u8]\n) -\u003e StdResult\u003c()\u003e {\n    let stored_vk: Option\u003cViewingKey\u003e = ns_load(storage, VIEWING_KEYS, storage_key)?;\n\n    if let Some(key) = stored_vk {\n        if provided_key.check_viewing_key(\u0026key.to_hashed()) {\n            return Ok(());\n        }\n    }\n\n    provided_key.check_viewing_key(\u0026[0u8; VIEWING_KEY_SIZE]);\n\n    return Err(StdError::unauthorized());\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::{from_binary, HumanAddr};\n    use cosmwasm_std::testing::{mock_dependencies, mock_env};\n\n    #[test]\n    fn test_handle() {\n        let ref mut deps = mock_dependencies(10, \u0026[]);\n\n        let sender = HumanAddr(\"sender\".into());\n        let sender_canonical = deps.api.canonical_address(\u0026sender).unwrap();\n        let env = mock_env(sender, \u0026[]);\n\n        let result = auth_handle(\n            deps,\n            env.clone(),\n            AuthHandleMsg::CreateViewingKey { entropy: \"123\".into(), padding: None },\n            DefaultHandleImpl\n        ).unwrap();\n\n        let created_vk: CreateViewingKeyData = from_binary(\u0026result.data.unwrap()).unwrap();\n        let created_vk = ViewingKey(created_vk.key);\n        \n        assert_eq!(created_vk, load_viewing_key(deps, sender_canonical.as_slice()).unwrap().unwrap());\n\n        let auth_result = authenticate(\u0026deps.storage, \u0026ViewingKey(\"invalid\".into()), sender_canonical.as_slice());\n        assert_eq!(auth_result.unwrap_err(), StdError::unauthorized());\n\n        let auth_result = authenticate(\u0026deps.storage, \u0026created_vk, sender_canonical.as_slice());\n        assert!(auth_result.is_ok());\n\n        let new_key = String::from(\"new_key\");\n\n        auth_handle(\n            deps,\n            env.clone(),\n            AuthHandleMsg::SetViewingKey { key: new_key.clone(), padding: None },\n            DefaultHandleImpl\n        ).unwrap();\n\n        assert_eq!(ViewingKey(new_key.clone()), load_viewing_key(deps, sender_canonical.as_slice()).unwrap().unwrap());\n\n        let auth_result = authenticate(\u0026deps.storage, \u0026ViewingKey(new_key), sender_canonical.as_slice());\n        assert!(auth_result.is_ok());\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":20},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-callback","lib.rs"],"content":"use cosmwasm_std::{HumanAddr, CanonicalAddr, StdResult, Api, Binary};\nuse fadroma_scrt_addr::{Humanize, Canonize};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n/// Info needed to instantiate a contract.\n#[derive(Serialize, Deserialize, JsonSchema, Clone, PartialEq, Debug)]\npub struct ContractInstantiationInfo {\n    pub code_hash: String,\n    pub id: u64\n}\n\n/// Info needed to talk to a contract instance.\n#[derive(Default, Serialize, Deserialize, JsonSchema, Clone, PartialEq, Debug)]\npub struct ContractInstance\u003cA\u003e {\n    pub address: A,\n    pub code_hash: String\n}\nimpl Canonize\u003cContractInstance\u003cCanonicalAddr\u003e\u003e for ContractInstance\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cContractInstance\u003cCanonicalAddr\u003e\u003e {\n        Ok(ContractInstance {\n            address:   self.address.canonize(api)?,\n            code_hash: self.code_hash.clone()\n        })\n    }\n}\nimpl Humanize\u003cContractInstance\u003cHumanAddr\u003e\u003e for ContractInstance\u003cCanonicalAddr\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cContractInstance\u003cHumanAddr\u003e\u003e {\n        Ok(ContractInstance {\n            address:   self.address.humanize(api)?,\n            code_hash: self.code_hash.clone()\n        })\n    }\n}\n\n#[deprecated(note=\"Please use ContractInstance\u003cHumanAddr\u003e instead.\")]\npub type ContractInfo = ContractInstance\u003cHumanAddr\u003e;\n\n#[deprecated(note=\"Please use ContractInstance\u003cCanonicalAddr\u003e instead.\")]\npub type ContractInfoStored = ContractInstance\u003cCanonicalAddr\u003e;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n/// Info needed to have the other contract respond.\npub struct Callback\u003cA\u003e {\n    /// The message to call.\n    pub msg: Binary,\n    /// Info about the contract requesting the callback.\n    pub contract: ContractInstance\u003cA\u003e\n}\nimpl Canonize\u003cCallback\u003cCanonicalAddr\u003e\u003e for Callback\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cCallback\u003cCanonicalAddr\u003e\u003e {\n        Ok(Callback { msg: self.msg.clone(), contract: self.contract.canonize(api)? })\n    }\n}\nimpl Humanize\u003cCallback\u003cHumanAddr\u003e\u003e for Callback\u003cCanonicalAddr\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cCallback\u003cHumanAddr\u003e\u003e {\n        Ok(Callback { msg: self.msg.clone(), contract: self.contract.humanize(api)? })\n    }\n}\n\n#[deprecated(note=\"Please use Callback\u003cCanonicalAddr\u003e instead.\")]\npub type CallbackStored = Callback\u003cCanonicalAddr\u003e;\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-contract","lib.rs"],"content":"//! # Fadroma\n\n/// Import commonly used definitions that need to be available everywhere in the contract\n#[macro_export] macro_rules! prelude {\n    () =\u003e { use cosmwasm_std::{\n        Storage, Api, Querier, Extern, Env,\n        HumanAddr, CanonicalAddr, Coin, Uint128,\n        StdResult, StdError,\n        InitResponse, HandleResponse, LogAttribute, Binary,\n        CosmosMsg, BankMsg, WasmMsg, to_binary,\n        log\n    }; };\n}\n\n/// Define an enum that implements the necessary traits\n/// (de/serialization, schema generation, cloning, debug printing, equality comparison)\n#[macro_export] macro_rules! message {\n    ( $Msg:ident { $( $(#[$meta:meta])* $field:ident : $type:ty ),* } ) =\u003e {\n        #[derive(serde::Serialize,serde::Deserialize,Clone,Debug,PartialEq,schemars::JsonSchema)]\n        #[serde(rename_all = \"snake_case\")]\n        pub struct $Msg { $( $(#[$meta])* pub $field: $type ),* } } }\n\n/// Define an enum with variants that implement the necessary traits\n#[macro_export] macro_rules! messages {\n    ( $( $Enum:ident { $( $(#[$meta:meta])* $Msg:ident { $( $field:ident : $type:ty ),* } )* } )*\n    ) =\u003e { $(\n        #[derive(serde::Serialize,serde::Deserialize,Clone,Debug,PartialEq,schemars::JsonSchema)]\n        #[serde(rename_all = \"snake_case\")]\n        pub enum $Enum { $( $(#[$meta])* $Msg { $($field : $type),* } ),* } )* } }\n\n/// Define the state singleton.\n// TODO: Support other shapes of state\n#[macro_export] macro_rules! define_state_singleton {\n    (\n        $State:ident\n        { $( $(#[$meta:meta])* $state_field:ident : $state_field_type:ty ),* }\n    ) =\u003e {\n        /// State singleton\n        message!($State { $($(#[$meta])* $state_field:$state_field_type),* });\n        use cosmwasm_storage::{Singleton, singleton, ReadonlySingleton, singleton_read};\n        pub static CONFIG_KEY: \u0026[u8] = b\"fadroma_root_state\";\n        pub fn get_store_rw\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, $State\u003e {\n            singleton(storage, CONFIG_KEY)\n        }\n        pub fn get_store_ro\u003cS: Storage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, $State\u003e {\n            singleton_read(storage, CONFIG_KEY)\n        }\n    }\n}\n\n/// Instantiation interface.\n#[macro_export] macro_rules! define_init_message {\n    // if imported:\n    ($_:ident, $Import:ident) =\u003e { pub use super::$Import; };\n    // if defined in place:\n    ($Name:ident, { $(\n        $(#[$meta:meta])* $arg:ident : $type:ty\n    ),* }) =\u003e {\n        message!($Name { $($arg: $type),* });\n    }\n}\n\n/// Query interface.\n#[macro_export] macro_rules! define_q_messages {\n    // if imported:\n    ($_1:tt, $Import:ident, { $($_2:tt)* }) =\u003e { pub use super::$Import; };\n    // if defined in place:\n    ($Name:ident, { $(\n        $(#[$meta:meta])* $Variant:ident ( $($arg:ident : $type:ty),* )\n    )* }) =\u003e {\n        messages!($Name { $( $(#[$meta])* $Variant {$($arg: $type),*} )* });\n    };\n}\n\n/// Transaction interface.\n#[macro_export] macro_rules! define_tx_messages {\n    // if imported:\n    ($_1:tt, $Import:ident, { $($_2:tt)* }) =\u003e { pub use super::$Import; };\n    // if defined in place:\n    ($Name:ident, { $(\n        $(#[$meta:meta])* $Variant:ident ( $($arg:ident : $type:ty),* )\n    )* }) =\u003e {\n        messages!($Name { $( $(#[$meta])* $Variant {$($arg: $type),*} )* });\n    };\n}\n\n/// Instatiation. Either defines or imports an `InitMsg`, and hooks up your init logic to it.\n/// Function body must return the initial value of `State`.\n#[macro_export] macro_rules! implement_init {\n    // define the InitMsg in place:\n    (\n        $(#[$InitMeta:meta])* [$Init:ident]\n        ($deps:ident, $env:ident, $msg:ident :{ $($field:ident : $type:ty),* }) $body:block\n    ) =\u003e {\n        use msg::$Init;\n        $(#[$InitMeta])*\n        pub fn init \u003cS: Storage, A: Api, Q: Querier\u003e(\n            $deps: \u0026mut Extern\u003cS, A, Q\u003e, $env: Env, $msg: $Init\n        ) -\u003e StdResult\u003cInitResponse\u003e {\n            $(let $field : $type = $msg.$field;)*\n            get_store_rw(\u0026mut $deps.storage).save(\u0026$body)?;\n            Ok(InitResponse::default())\n        }\n    };\n    // or import it from an external module:\n    (\n        $(#[$InitMeta:meta])* [$_:ident]\n        ($deps:ident, $env:ident, $msg:ident : $InitExt:ty ) $body:block\n    ) =\u003e {\n        $(#[$InitMeta])*\n        pub fn init \u003cS: Storage, A: Api, Q: Querier\u003e(\n            $deps: \u0026mut Extern\u003cS, A, Q\u003e, $env: Env, $msg: $InitExt\n        ) -\u003e StdResult\u003cInitResponse\u003e {\n            // no auto-destructuring\n            get_store_rw(\u0026mut $deps.storage).save(\u0026$body)?;\n            Ok(InitResponse::default())\n        }\n    };\n}\n\n/// Query implementations.\n#[macro_export] macro_rules! implement_queries {\n    // for external query message type, ignore the name in the brackets\n    // and pass through to the next macro variantb\n    (\n        $State:ident, $EnumExt:ident, $_:ident\n        ( $deps:ident, $state:ident, $msg:ident ) -\u003e $Response:ident { $($bodies:tt)* }\n    ) =\u003e {\n        implement_queries!($State, $EnumExt ( $deps, $state, $msg ) -\u003e $Response { $($bodies)* });\n    };\n\n    // implement queries defined in $body\n    (\n        $State:ident, $Enum:ident\n        ( $deps:ident, $state:ident, $msg:ident ) -\u003e $Response:ident { $(\n            $(#[$meta:meta])* $Variant:ident ( $($field:ident : $type:ty),*)\n            $body:tt\n        )* }\n    ) =\u003e {\n        /// Query dispatcher.\n        pub fn query \u003cS: Storage, A: Api, Q: Querier\u003e (\n            $deps: \u0026Extern\u003cS, A, Q\u003e, $msg: msg::$Enum\n        ) -\u003e StdResult\u003cBinary\u003e {\n            let state = get_store_ro(\u0026$deps.storage).load()?; // get snapshot of contract state\n            let result = match $msg { $( // find the matching handler\n                msg::$Enum::$Variant {..} =\u003e self::queries::$Variant($deps, state, $msg),\n            )* };\n            Ok(cosmwasm_std::to_binary(\u0026result?)?) // return handler result\n        }\n        /// Query handlers.\n        mod queries {\n            prelude!();\n            use super::{*, msg::Response};\n            // for every query message variant, define a handler \n            $(\n                $(#[$meta])*\n                #[allow(non_snake_case)]\n                pub fn $Variant \u003cS: Storage, A: Api, Q: Querier\u003e(\n                    $deps: \u0026Extern\u003cS, A, Q\u003e, $state: $State, $msg: msg::$Enum,\n                ) -\u003e StdResult\u003c$Response\u003e {\n                    if let super::msg::$Enum::$Variant {$($field),*} = $msg { // destructure the message\n                        $body // perform user-specified actions\n                    } else { unreachable!() }\n                }\n            )*\n        }\n\n    }\n}\n\n/// Transaction implementations\n#[macro_export] macro_rules! implement_transactions {\n    (   $State:ident, $Enum:ident, $_:ident\n        ($deps:ident, $env:ident, $state:ident, $msg:ident) -\u003e $Response:ident { $($bodies:tt)* }\n    ) =\u003e {\n        implement_transactions!($State, $Enum ($deps, $env, $state, $msg) -\u003e $Response { $($bodies)* });\n    };\n    (   $State:ident, $Enum:ident\n        ($deps:ident, $env:ident, $state:ident, $msg:ident) -\u003e $Response:ident {\n            $($(#[$meta:meta])* $Variant:ident ( $($arg:ident $(: $type:ty)?),* ) $body:block)*\n        }\n    ) =\u003e {\n        /// Transaction dispatcher\n        pub fn handle \u003cS: Storage, A: Api, Q: Querier\u003e (\n            $deps: \u0026mut Extern\u003cS, A, Q\u003e, $env: Env, $msg: msg::$Enum,\n        ) -\u003e StdResult\u003cHandleResponse\u003e {\n            // pick the handler that matches the message and call it:\n            match $msg { $(\n                msg::$Enum::$Variant {..} =\u003e self::handle::$Variant($deps, $env, $msg),\n            )* }\n        }\n        /// Transaction handlers\n        mod handle {\n            prelude!();\n            use super::*;\n            // shorthand for saving state\n            // define a handler for every tx message variant\n            $(#[allow(non_snake_case)] pub fn $Variant \u003cS: Storage, A: Api, Q: Querier\u003e(\n                $deps: \u0026mut Extern\u003cS, A, Q\u003e,\n                $env:  Env,\n                $msg:  msg::$Enum,\n            ) -\u003e StdResult\u003cHandleResponse\u003e {\n                // get mutable snapshot of current state:\n                let mut $state = get_store_rw(\u0026mut $deps.storage).load()?;\n                macro_rules! save_state {\n                    () =\u003e { get_store_rw(\u0026mut $deps.storage).save(\u0026$state)?; }\n                };\n                if let super::msg::$Enum::$Variant {$($arg),*} = $msg {\n                    // perform user-specified actions\n                    $body\n                } else {\n                    unreachable!()\n                }\n            })*\n        }\n    };\n}\n\n/// Define a smart contract\n#[macro_export] macro_rules! contract {\n\n    // This pattern matching is ugly!\n    (\n        // passed to `define_state_singleton!`\n        [$State:ident]\n        { $( $(#[$meta:meta])* $state_field:ident : $state_field_type:ty ),* }\n\n        // Define the signature of the init message, how it's handled.\n        //\n        $(#[$InitMeta:meta])*\n        [$Init:ident]\n        ( $init_deps:ident, $init_env:ident, $init_msg:ident : $($init_msg_definition:tt)+\n        ) $init_body:block\n\n        // Define query messages and how they're handled:\n        [$Q:ident]\n        ( $q_deps:ident, $q_state:ident, $q_msg:ident $( : $ExtQ:ident)? )\n        -\u003e $QResponse:ident { $(\n            $(#[$QVariantMeta:meta])* $QVariant:ident\n            ($($q_arg:ident $(: $q_arg_type:ty)?),*) $q_body:tt\n        )* }\n\n        // Define possible responses:\n        [$Response:ident] {\n        $( $(#[$response_meta:meta])* $ResponseMsg:ident { $($resp_field:ident : $resp_field_type:ty),* } )* }\n\n        // Define transaction messages and how they're handled:\n        [$TX:ident]\n        ( $tx_deps:ident, $tx_env:ident, $tx_state:ident, $tx_msg:ident $( : $ExtTX:ident)? )\n        -\u003e $TXResponse:ident { $(\n            $(#[$TXVariantMeta:meta])* $TXVariant:ident\n            ($($tx_arg:ident $(: $tx_arg_type:ty)?),*) $tx_body:tt\n        )* }\n\n    ) =\u003e {\n\n        prelude!();\n\n        /// WASM entry points.\n        // Similar in spirit to [`create_entry_points`](https://docs.rs/cosmwasm-std/0.10.1/src/cosmwasm_std/entry_points.rs.html#49),\n        // but doesn't need the implementation to be in a sibling module (the `super::contract` on L65)\n        // TODO custom `migrate` for SecretNetwork\n        #[cfg(target_arch = \"wasm32\")]\n        mod wasm {\n            //use super::contract;\n            use cosmwasm_std::{\n                ExternalStorage as Storage, ExternalApi as Api, ExternalQuerier as Querier,\n                do_init, do_handle, do_query\n            };\n            #[no_mangle] extern \"C\" fn init (env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n                do_init(\u0026super::init::\u003cStorage, Api, Querier\u003e, env_ptr, msg_ptr)\n            }\n            #[no_mangle] extern \"C\" fn handle (env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n                do_handle(\u0026super::handle::\u003cStorage, Api, Querier\u003e, env_ptr, msg_ptr)\n            }\n            #[no_mangle] extern \"C\" fn query (msg_ptr: u32) -\u003e u32 {\n                do_query(\u0026super::query::\u003cStorage, Api, Querier\u003e, msg_ptr,)\n            }\n            // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n            // automatically because we `use cosmwasm_std`.\n        }\n\n        /// This contract's on-chain API.\n        pub mod msg {\n            // The argument sets of the {Init,Query,Handle}Msg handlers\n            // are used to automatically generate the corresponding\n            // protocol messages.\n            // * This is why the @Q/@TX/@Response sub-sections are not just passed in as opaque `tt`s\n            // * Only responses can't be inferred and need to be pre-defined.\n            // * Although, with some more macro trickery, they could be defined in place\n            //   (e.g. the return types of $Q handlers could be defined as\n            //   `-\u003e Foo { field: type }` and then populated with `return Self { field: value }`\n            // * Let's revisit this once some we have some more examples of custom responses\n            //\n            prelude!();\n\n            use super::*;\n\n            define_init_message!($Init, $($init_msg_definition)+);\n\n            define_q_messages!($Q, $($ExtQ,)? {\n                $( $(#[$QVariantMeta])* $QVariant ($($q_arg $(: $q_arg_type)?),*))*\n            });\n\n            define_tx_messages!($TX, $($ExtTX,)? {\n                $( $(#[$TXVariantMeta])* $TXVariant ($( $tx_arg $(: $tx_arg_type)?),*))*\n            });\n\n            messages!($Response { $(\n                $(#[$response_meta])* $ResponseMsg {$($resp_field: $resp_field_type),*}\n            )* });\n        }\n\n        /// Implementations\n        //use msg::{$Init,$Q,$TX,$Response};\n\n        define_state_singleton! {\n            $State { $( $(#[$meta])* $state_field : $state_field_type ),* }\n        }\n\n        implement_init! {\n            $(#[$InitMeta])* [$Init]\n            ($init_deps, $init_env, $init_msg : $($init_msg_definition)+) $init_body\n        }\n\n        implement_queries! {\n            $State, $($ExtQ,)? $Q ($q_deps, $q_state, $q_msg) -\u003e $QResponse { $(\n                $(#[$QVariantMeta])* $QVariant\n                ($($q_arg $(: $q_arg_type)?),*) $q_body\n            )* }\n        }\n\n        implement_transactions! {\n            $State, $($ExtTX,)? $TX ($tx_deps, $tx_env, $tx_state, $tx_msg) -\u003e $TXResponse { $(\n                $(#[$TXVariantMeta])* $TXVariant\n                ($( $tx_arg $(: $tx_arg_type)?),*) $tx_body\n            )* }\n        }\n\n    };\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-migrate","checks.rs"],"content":"use cosmwasm_std::{StdResult, StdError, HumanAddr};\nuse crate::types::{ContractStatus, ContractStatusLevel};\n\nmacro_rules! migration_message {\n    (paused: $reason:expr) =\u003e { format!(\n         \"This contract has been paused. Reason: {}\",\n         \u0026$reason\n    ) };\n    (migration: $reason:expr, $new_address:expr) =\u003e { format!(\n         \"This contract is being migrated to {}, please use that address instead. Reason: {}\",\n         \u0026$new_address.unwrap_or(HumanAddr::default()),\n         \u0026$reason\n    ) };\n}\n\npub fn is_operational (status: \u0026ContractStatus\u003cHumanAddr\u003e) -\u003e StdResult\u003c()\u003e {\n    let ContractStatus { level, reason, new_address } = status;\n    match level {\n        ContractStatusLevel::Operational =\u003e Ok(()),\n        ContractStatusLevel::Paused =\u003e Err(StdError::GenericErr {\n            backtrace: None,\n            msg: migration_message!(paused: reason)\n        }),\n        ContractStatusLevel::Migrating =\u003e Err(StdError::GenericErr {\n            backtrace: None,\n            msg: migration_message!(migration: reason, new_address.clone())\n        }),\n    }\n}\n\npub fn can_set_status (\n    status:           \u0026ContractStatus\u003cHumanAddr\u003e,\n    new_status_level: \u0026ContractStatusLevel\n) -\u003e StdResult\u003c()\u003e {\n    let ContractStatus { level, reason, new_address } = status;\n    match level {\n        ContractStatusLevel::Operational =\u003e Ok(()),\n        ContractStatusLevel::Paused =\u003e Ok(()),\n        ContractStatusLevel::Migrating =\u003e match new_status_level {\n            // if already migrating, allow message and new_address to be updated\n            ContractStatusLevel::Migrating =\u003e Ok(()),\n            // but prevent reverting from migration status\n            _ =\u003e Err(StdError::GenericErr {\n                backtrace: None,\n                msg: migration_message!(migration: reason, new_address.clone())\n            })\n        }\n    }\n}\n","traces":[{"line":16,"address":[446275,445072],"length":1,"stats":{"Line":0},"fn_name":"is_operational"},{"line":17,"address":[445097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[445227,445604,445213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[445145,445220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[445468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[445232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[445249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[446060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[445179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[446215,445191,445609,446290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[447309,446448],"length":1,"stats":{"Line":0},"fn_name":"can_set_status"},{"line":35,"address":[446486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[446593,446579,446610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[446586,446534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[446603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[446663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[446656,446568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[447119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[446620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[447324,446668,446632,447265],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":20},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-migrate","lib.rs"],"content":"pub mod types;\nmod storage;\nmod checks;\n\nuse cosmwasm_std::{Extern, Storage, Api, Querier, Env, HumanAddr, StdResult};\nuse composable_admin::{require_admin, admin::assert_admin};\nuse fadroma_scrt_addr::{Humanize, Canonize};\n\n/// Return the current contract status. Defaults to operational if nothing was stored.\npub fn get_status \u003cS: Storage, A: Api, Q: Querier\u003e (\n    deps: \u0026Extern\u003cS, A, Q\u003e\n) -\u003e StdResult\u003ctypes::ContractStatus\u003cHumanAddr\u003e\u003e {\n    storage::load(\u0026deps.storage)?.humanize(\u0026deps.api)\n}\n\n/// Fail if the current contract status level is other than `Operational`.\npub fn is_operational \u003cS: Storage, A: Api, Q: Querier\u003e (\n    deps: \u0026Extern\u003cS, A, Q\u003e\n) -\u003e StdResult\u003c()\u003e {\n    checks::is_operational(\u0026get_status(deps)?)\n}\n\n/// Fail if trying to return from `Migrating` status.\npub fn can_set_status \u003cS: Storage, A: Api, Q: Querier\u003e  (\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    to_level: \u0026types::ContractStatusLevel\n) -\u003e StdResult\u003c()\u003e {\n    checks::can_set_status(\u0026get_status(deps)?, to_level)\n}\n\n/// Store a new contract status.\n#[require_admin]\npub fn set_status \u003cS: Storage, A: Api, Q: Querier\u003e (\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    level: types::ContractStatusLevel,\n    reason: String,\n    new_address: Option\u003cHumanAddr\u003e\n) -\u003e StdResult\u003c()\u003e {\n    storage::save(\u0026mut deps.storage, \u0026types::ContractStatus { level, reason, new_address: match new_address {\n        Some(new_address) =\u003e Some(new_address.canonize(\u0026deps.api)?),\n        None =\u003e None\n    } })\n}\n\n/// Wrap status levels around the `match` statement that does your handle dispatch.\n#[macro_export] macro_rules! with_status {\n    // by default, assumes the handle msg enum is called `HandleMsg` and imported\n    ($deps:ident, $env:ident, match $msg:ident { $($rest:tt)* }) =\u003e {\n        with_status!(HandleMsg, $deps, $env, match $msg { $($rest)* })\n    };\n    // but an alternative name can be passed\n    ($HandleMsg:ty, $deps:ident, $env:ident, match $msg:ident { $($rest:tt)* }) =\u003e {\n        if let HandleMsg::SetStatus { level, reason, new_address } = $msg {\n            fadroma_scrt_migrate::can_set_status(\u0026$deps, \u0026level)?;\n            fadroma_scrt_migrate::set_status($deps, $env, level, reason, new_address)?;\n            Ok(HandleResponse::default())\n        } else {\n            fadroma_scrt_migrate::is_operational(\u0026$deps)?;\n            match $msg {\n                HandleMsg::SetStatus { .. } =\u003e unreachable!(),\n                $($rest)*\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-migrate","storage.rs"],"content":"use cosmwasm_std::{StdResult, CanonicalAddr, Storage};\nuse crate::types::ContractStatus;\n\npub const PREFIX: \u0026[u8] = b\"fadroma_migration_state\";\n\npub fn load (storage: \u0026impl Storage) -\u003e StdResult\u003cContractStatus\u003cCanonicalAddr\u003e\u003e {\n    match cosmwasm_utils::storage::load(storage, PREFIX)? {\n        Some(status) =\u003e status,\n        None =\u003e Ok(ContractStatus::default())\n    }\n}\npub fn save (storage: \u0026mut impl Storage, status: \u0026ContractStatus\u003cCanonicalAddr\u003e) -\u003e StdResult\u003c()\u003e {\n    cosmwasm_utils::storage::save(storage, PREFIX, status)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-migrate","test.rs"],"content":"// TODO\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-migrate","types.rs"],"content":"use cosmwasm_std::{HumanAddr, CanonicalAddr, StdResult, Api};\nuse serde::{Serialize, Deserialize};\nuse schemars::JsonSchema;\nuse fadroma_scrt_addr::{Humanize, Canonize};\n\n/// Possible states of a contract.\n#[derive(Serialize, Deserialize, JsonSchema, PartialEq, Debug, Clone)]\npub enum ContractStatusLevel {\n    /// Live\n    Operational,\n    /// Temporarily disabled\n    Paused,\n    /// Permanently disabled\n    Migrating,\n}\n\n// TODO once serde-json-wasm finally supports serializing Rusty enums,\n// this structure can be merged with `ContractStatusLevel`, with\n// `reason` and `new_address` becoming propeties of `Migrating`\n/// Current state of a contract w/ optional description and pointer to new version\n#[derive(Serialize, Deserialize, JsonSchema, PartialEq, Debug, Clone)]\npub struct ContractStatus\u003cA\u003e {\n    pub level:       ContractStatusLevel,\n    pub reason:      String,\n    pub new_address: Option\u003cA\u003e\n}\nimpl\u003cA\u003e Default for ContractStatus\u003cA\u003e {\n    fn default () -\u003e Self { Self {\n        level:       ContractStatusLevel::Operational,\n        reason:      String::new(),\n        new_address: None\n    } }\n}\nimpl Humanize\u003cContractStatus\u003cHumanAddr\u003e\u003e for ContractStatus\u003cCanonicalAddr\u003e {\n    fn humanize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cContractStatus\u003cHumanAddr\u003e\u003e {\n        Ok(ContractStatus {\n            level: self.level.clone(),\n            reason: self.reason.clone(),\n            new_address: match \u0026self.new_address {\n                Some(canon_addr) =\u003e Some(api.human_address(\u0026canon_addr)?),\n                None =\u003e None\n            }\n        })\n    }\n}\nimpl Canonize\u003cContractStatus\u003cCanonicalAddr\u003e\u003e for ContractStatus\u003cHumanAddr\u003e {\n    fn canonize (\u0026self, api: \u0026impl Api) -\u003e StdResult\u003cContractStatus\u003cCanonicalAddr\u003e\u003e {\n        Ok(ContractStatus {\n            level: self.level.clone(),\n            reason: self.reason.clone(),\n            new_address: match \u0026self.new_address {\n                Some(human_addr) =\u003e Some(api.canonical_address(\u0026human_addr)?),\n                None =\u003e None\n            }\n        })\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":15},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-storage","lib.rs"],"content":"use serde::Serialize;\nuse serde::de::DeserializeOwned;\nuse cosmwasm_std::{ReadonlyStorage, StdResult, Storage, from_slice, to_vec};\n\npub fn save\u003cT: Serialize, S: Storage\u003e(storage: \u0026mut S, key: \u0026[u8], value: \u0026T) -\u003e StdResult\u003c()\u003e {\n    storage.set(key, \u0026to_vec(value)?);\n    Ok(())\n}\n\npub fn remove\u003cS: Storage\u003e(storage: \u0026mut S, key: \u0026[u8]) {\n    storage.remove(key);\n}\n\npub fn load\u003cT: DeserializeOwned, S: ReadonlyStorage\u003e(storage: \u0026S, key: \u0026[u8]) -\u003e StdResult\u003cOption\u003cT\u003e\u003e {\n    let result = storage.get(key);\n\n    if let Some(data) = result {\n        from_slice(\u0026data)\n    } else {\n        Ok(None)\n    }\n}\n\npub fn ns_save\u003cT: Serialize, S: Storage\u003e(storage: \u0026mut S, namespace: \u0026[u8], key: \u0026[u8], value: \u0026T) -\u003e StdResult\u003c()\u003e {\n    let key = concat(namespace, key);\n    storage.set(\u0026key, \u0026to_vec(value)?);\n\n    Ok(())\n}\n\npub fn ns_remove\u003cS: Storage\u003e(storage: \u0026mut S, namespace: \u0026[u8], key: \u0026[u8]) {\n    let key = concat(namespace, key);\n    storage.remove(\u0026key);\n}\n\npub fn ns_load\u003cT: DeserializeOwned, S: ReadonlyStorage\u003e(storage: \u0026S, namespace: \u0026[u8], key: \u0026[u8]) -\u003e StdResult\u003cOption\u003cT\u003e\u003e {\n    let key = concat(namespace, key);\n\n    load(storage, \u0026key)\n}\n\n#[inline]\nfn concat(namespace: \u0026[u8], key: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n    let mut k = namespace.to_vec();\n    k.extend_from_slice(key);\n\n    k\n}\n\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-utils","src","convert.rs"],"content":"use cosmwasm_std::{StdResult, StdError};\nuse crate::u256_math;\nuse crate::u256_math::U256;\n\n/// Convert between tokens with different decimals.\n///\n/// # Arguments\n///\n/// * `amount` - the amount of the input token to convert\n/// * `rate` - corresponds to the output token decimals. E.g: If we want 1:1 rate and the output token has 6 decimals, then rate = 1_000_000\n/// * `input_decimals` - the number of decimals of the input token\n/// * `output_decimals` - the number of decimals of the output token\npub fn convert_token(\n    amount: u128,\n    rate: u128,\n    input_decimals: u8,\n    output_decimals: u8\n) -\u003e StdResult\u003cu128\u003e {\n    let err_msg = \"u128 overflow detected.\";\n\n    // result = amount * rate / one whole output token\n \n    let amount = Some(U256::from(amount));\n    let rate = Some(U256::from(rate));\n\n    let mut result = u256_math::mul(amount, rate).ok_or_else(|| \n        StdError::generic_err(err_msg)\n    )?;\n\n    // But, if tokens have different number of decimals, we need to compensate either by \n    // dividing or multiplying (depending on which token has more decimals) the difference\n    if input_decimals \u003c output_decimals {\n        let compensation = get_whole_token_representation(\n            output_decimals - input_decimals\n        );\n        let compensation = Some(U256::from(compensation));\n\n        result = u256_math::mul(Some(result), compensation).ok_or_else(|| \n            StdError::generic_err(err_msg) \n        )?;\n    } else if output_decimals \u003c input_decimals {\n        let compensation = get_whole_token_representation(\n            input_decimals - output_decimals\n        );\n        let compensation = Some(U256::from(compensation));\n\n        result = u256_math::div(Some(result), compensation).ok_or_else(|| \n            StdError::generic_err(err_msg) \n        )?;\n    }\n\n    let whole_token = Some(U256::from(\n        get_whole_token_representation(output_decimals)\n    ));\n\n    let result = u256_math::div(Some(result), whole_token).ok_or_else(||\n        StdError::generic_err(err_msg)\n    )?;\n\n    // Check if resulting u128 would overflow\n    if result.0[3] \u003e 0 {\n        return Err(StdError::generic_err(err_msg));\n    }\n\n    Ok(result.low_u128())\n}\n\n/// Get the amount needed to represent 1 whole token given its decimals.\n/// Ex. Given token A that has 3 decimals, 1 A == 1000\npub fn get_whole_token_representation(decimals: u8) -\u003e u128 {\n    let mut whole_token = 1u128;\n\n    for _ in 0..decimals {\n        whole_token *= 10;\n    };\n\n    whole_token\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_convert_token() {\n        // Assuming the user friendly (in the UI) exchange rate has been set to\n        // 1 swapped_token (9 decimals) == 1.5 input_token (9 decimals):\n        // the rate would be 1 / 1.5 = 0.(6) or 666666666 (0.(6) ** 10 * 9)\n        // meaning the price for 1 whole swapped_token is\n        // 1500000000 (1.5 * 10 ** 9 decimals) of input_token.\n\n        // If we want to get 2 of swapped_token, we need to send 3 input_token\n        // i.e. amount = 3000000000 (3 * 10 ** 9 decimals)\n\n        let rate = 666_666_666;\n        let amount = 3_000_000_000;\n\n        let result = convert_token(amount, rate, 9, 9).unwrap();\n        assert_eq!(result, 1_999_999_998);\n\n        // Should work the same even if input_token has less decimals (ex. 6)\n        // Here amount has 3 zeroes less because input_token now has 6 decimals, so\n        // 1 input_token = 3000000 (3 * 10 ** 6)\n\n        let rate = 666_666_666;\n        let amount = 3_000_000;\n\n        let result = convert_token(amount, rate, 6, 9).unwrap();\n        assert_eq!(result, 1_999_999_998);\n\n        // And the other way around - when swap_token has 6 decimals.\n        // Here the rate and result have 3 less digits - to account for the less decimals\n\n        let rate = 666_666;\n        let amount = 3_000_000_000;\n\n        let result = convert_token(amount, rate, 9, 6).unwrap();\n        assert_eq!(result, 1_999_998);\n    }\n}\n","traces":[{"line":13,"address":[489456],"length":1,"stats":{"Line":1},"fn_name":"convert_token"},{"line":19,"address":[489542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[489569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[489672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[490077,492576,489765,489940,490162],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":27,"address":[492596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[490848,490068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[490188,492502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[490282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[490375,490656,490853,492624,490938],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":39,"address":[492644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[491608,490983,490215],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[490964,492532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[491042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[491695,492672,491416,491135,491610],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":48,"address":[492692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[491745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[491717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[492720,492119,492348,491838,492263],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":57,"address":[492740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[492247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[492363,492424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[492395,492474],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[492768],"length":1,"stats":{"Line":1},"fn_name":"get_whole_token_representation"},{"line":71,"address":[492779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[493004,492797,492898],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[493009,492912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[499701,499728,499696],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":95,"address":[499735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[499764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[499784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[499859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[500012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[500036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[500060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[500150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[500303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[500332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[500352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[500442],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":35,"coverable":40},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-utils","src","crypto.rs"],"content":"use rand_chacha::ChaChaRng;\nuse rand_core::{RngCore, SeedableRng};\nuse subtle::ConstantTimeEq;\nuse sha2::{Digest, Sha256};\n\npub struct Prng {\n    rng: ChaChaRng,\n}\n\npub fn sha_256(data: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    let hash = hasher.finalize();\n\n    let mut result = [0u8; 32];\n    result.copy_from_slice(hash.as_slice());\n    \n    result\n}\n\npub fn compare_slice_ct_time(s1: \u0026[u8], s2: \u0026[u8]) -\u003e bool {\n    bool::from(s1.ct_eq(s2))\n}\n\nimpl Prng {\n    pub fn new(seed: \u0026[u8], entropy: \u0026[u8]) -\u003e Self {\n        let mut hasher = Sha256::new();\n\n        // write input message\n        hasher.update(\u0026seed);\n        hasher.update(\u0026entropy);\n        let hash = hasher.finalize();\n\n        let mut hash_bytes = [0u8; 32];\n        hash_bytes.copy_from_slice(hash.as_slice());\n\n        let rng: ChaChaRng = ChaChaRng::from_seed(hash_bytes);\n\n        Self { rng }\n    }\n\n    pub fn rand_bytes(\u0026mut self) -\u003e [u8; 32] {\n        let mut bytes = [0u8; 32];\n        self.rng.fill_bytes(\u0026mut bytes);\n\n        bytes\n    }\n}","traces":[{"line":10,"address":[484544],"length":1,"stats":{"Line":0},"fn_name":"sha_256"},{"line":11,"address":[484587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[484607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[484617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[484666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[484687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[484752],"length":1,"stats":{"Line":0},"fn_name":"compare_slice_ct_time"},{"line":22,"address":[484776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[484816],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":20},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-utils","src","lib.rs"],"content":"pub mod viewing_key;\npub mod storage;\npub mod crypto;\npub mod convert;\npub mod u256_math;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-utils","src","storage.rs"],"content":"#![deprecated(note=\"Please use fadroma_scrt_storage instead\")]\npub use fadroma_scrt_storage::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-utils","src","u256_math.rs"],"content":"// Copied from https://github.com/enigmampc/SecretSwap/blob/master/contracts/secretswap_pair/src/u256_math.rs\n\npub use primitive_types::U256;\n\n/// U256 sqrt ported from here: https://ethereum.stackexchange.com/a/87713/12112\n///\n/// function sqrt(uint y) internal pure returns (uint z) {\n///     if (y \u003e 3) {\n///         z = y;\n///         uint x = y / 2 + 1;\n///         while (x \u003c z) {\n///             z = x;\n///             x = (y / x + x) / 2;\n///         }\n///     } else if (y != 0) {\n///         z = 1;\n///     }\n/// }\n///\n/// Tested it here: https://github.com/enigmampc/u256-sqrt-test/blob/aa7693/src/main.rs\npub fn sqrt(y: U256) -\u003e Option\u003cU256\u003e {\n    let mut z = U256::from(0);\n    if y.gt(\u0026U256::from(3)) {\n        z = y.clone();\n        let mut x = y.checked_div(U256::from(2))?.checked_add(U256::from(1))?;\n        while x.lt(\u0026z) {\n            z = x.clone();\n            x = y\n                .checked_div(x)?\n                .checked_add(x)?\n                .checked_div(U256::from(2))?;\n        }\n    } else if !y.is_zero() {\n        z = U256::from(1);\n    }\n\n    return Some(z);\n}\n\npub fn sub(a: Option\u003cU256\u003e, b: Option\u003cU256\u003e) -\u003e Option\u003cU256\u003e {\n    match b {\n        Some(b) =\u003e a.and_then(checked_sub(b)),\n        None =\u003e None,\n    }\n}\n\npub fn div(nom: Option\u003cU256\u003e, denom: Option\u003cU256\u003e) -\u003e Option\u003cU256\u003e {\n    match denom {\n        Some(denom) =\u003e nom.and_then(checked_div(denom)),\n        None =\u003e None,\n    }\n}\n\npub fn add(a: Option\u003cU256\u003e, b: Option\u003cU256\u003e) -\u003e Option\u003cU256\u003e {\n    match b {\n        Some(b) =\u003e a.and_then(checked_add(b)),\n        None =\u003e None,\n    }\n}\n\npub fn mul(a: Option\u003cU256\u003e, b: Option\u003cU256\u003e) -\u003e Option\u003cU256\u003e {\n    match b {\n        Some(b) =\u003e a.and_then(checked_mul(b)),\n        None =\u003e None,\n    }\n}\n\nfn checked_sub(b: U256) -\u003e impl Fn(U256) -\u003e Option\u003cU256\u003e {\n    move |a: U256| a.checked_sub(b)\n}\n\nfn checked_div(denom: U256) -\u003e impl Fn(U256) -\u003e Option\u003cU256\u003e {\n    move |nom: U256| nom.checked_div(denom)\n}\n\nfn checked_add(b: U256) -\u003e impl Fn(U256) -\u003e Option\u003cU256\u003e {\n    move |a: U256| a.checked_add(b)\n}\n\nfn checked_mul(b: U256) -\u003e impl Fn(U256) -\u003e Option\u003cU256\u003e {\n    move |a: U256| a.checked_mul(b)\n}\n","traces":[{"line":21,"address":[494912],"length":1,"stats":{"Line":0},"fn_name":"sqrt"},{"line":22,"address":[494934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[494947,495640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[494998,495034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[495074,495584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[496628,495607,495582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[495645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[496193,495905,496436,495723,495834,496633,496646,496097,496355,496342,496142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[495770,496131,495885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[496344,496033,496173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[496321,496416,496635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[496689,496660,495015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[496668,496691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[496748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[496880],"length":1,"stats":{"Line":0},"fn_name":"sub"},{"line":41,"address":[496930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[496906,496946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[496923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[497104],"length":1,"stats":{"Line":1},"fn_name":"div"},{"line":48,"address":[497154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[497130,497170],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[497147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[497328],"length":1,"stats":{"Line":0},"fn_name":"add"},{"line":55,"address":[497378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[497394,497354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[497371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[497552],"length":1,"stats":{"Line":1},"fn_name":"mul"},{"line":62,"address":[497602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[497618,497578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[497595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[497776],"length":1,"stats":{"Line":0},"fn_name":"checked_sub"},{"line":69,"address":[497841,497779,497824],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":72,"address":[497952],"length":1,"stats":{"Line":1},"fn_name":"checked_div"},{"line":73,"address":[497955,498000,498017],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":76,"address":[498128],"length":1,"stats":{"Line":0},"fn_name":"checked_add"},{"line":77,"address":[498131,498176,498193],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":80,"address":[498304],"length":1,"stats":{"Line":1},"fn_name":"checked_mul"},{"line":81,"address":[498352,498307,498369],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"}],"covered":8,"coverable":38},{"path":["/","home","runner","work","sienna","sienna","libraries","fadroma-21.06.1","scrt-utils","src","viewing_key.rs"],"content":"//Copied from https://github.com/enigmampc/snip20-reference-impl/blob/master/src/viewing_key.rs\n\nuse std::fmt;\n\nuse cosmwasm_std::{Env, Binary};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::crypto::{sha_256, Prng, compare_slice_ct_time};\n\npub const VIEWING_KEY_SIZE: usize = 32;\nconst VIEWING_KEY_PREFIX: \u0026str = \"api_key_\";\n\n#[derive(Serialize, Deserialize, JsonSchema, Clone, Debug, PartialEq)]\npub struct ViewingKey(pub String);\n\npub fn create_hashed_password(s1: \u0026str) -\u003e [u8; VIEWING_KEY_SIZE] {\n    sha_256(s1.as_bytes())\n}\n\nimpl ViewingKey {\n    ///A good source for the `seed` and `entropy` values is https://www.random.org/strings/\n    pub fn new(env: \u0026Env, seed: \u0026[u8], entropy: \u0026[u8]) -\u003e Self {\n        // 16 here represents the lengths in bytes of the block height and time.\n        let entropy_len = 16 + env.message.sender.len() + entropy.len();\n        let mut rng_entropy = Vec::with_capacity(entropy_len);\n        rng_entropy.extend_from_slice(\u0026env.block.height.to_be_bytes());\n        rng_entropy.extend_from_slice(\u0026env.block.time.to_be_bytes());\n        rng_entropy.extend_from_slice(\u0026env.message.sender.0.as_bytes());\n        rng_entropy.extend_from_slice(entropy);\n\n        let mut rng = Prng::new(seed, \u0026rng_entropy);\n\n        let rand_slice = rng.rand_bytes();\n\n        let key = sha_256(\u0026rand_slice);\n\n        Self(VIEWING_KEY_PREFIX.to_string() + \u0026Binary::from(\u0026key).to_base64())\n    }\n\n    pub fn to_hashed(\u0026self) -\u003e [u8; VIEWING_KEY_SIZE] {\n        create_hashed_password(\u0026self.0)\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        self.0.as_bytes()\n    }\n\n    pub fn check_viewing_key(\u0026self, hashed_pw: \u0026[u8]) -\u003e bool {\n        let mine_hashed = create_hashed_password(\u0026self.0);\n\n        compare_slice_ct_time(\u0026mine_hashed, hashed_pw)\n    }\n}\n\nimpl fmt::Display for ViewingKey {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n","traces":[{"line":17,"address":[480368],"length":1,"stats":{"Line":0},"fn_name":"create_hashed_password"},{"line":18,"address":[480447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[480464,481471],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":25,"address":[480560,481520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[480677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[480696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[480780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[480865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","home","runner","work","sienna","sienna","libraries","kukumba","src","lib.rs"],"content":"#[macro_export]\n\nmacro_rules! kukumba {\n\n    (\n        $(\n            #[$unit:ident]\n            $( $($op:ident $desc:literal)+ { $($stmt:stmt)* } )*\n        )*\n    ) =\u003e {\n        $(#[test] fn $unit () {\n            $(\n                $(print!(\"\\n  {} {}\", stringify!($op), $desc);)+\n                print!(\": \");\n                $($stmt;)*\n            )*\n        })*\n    };\n\n}\n","traces":[{"line":11,"address":[656003,578880,595205,577357,610245,578853,610240,593636,562661,632656,679280,562656,546432,610272,632661,632688,658736,608950,595232,562688,630420,658704,561161,578848,595200,546400,658709,546405],"length":1,"stats":{"Line":57},"fn_name":"{{closure}}"},{"line":13,"address":[564435,562701,632701,548278,610285,595796,658749,618453,585547,640877,671845,595245,596971,553206,579444,578893,563260,672377,645805,666917,646395,569363,580619,646025,547103,623601,623381,601899,546445],"length":1,"stats":{"Line":81},"fn_name":null},{"line":14,"address":[623913,623543,646337,563572,569837,546824,586021,645967,579756,611011,646707,672319,672689,595616,563080,579264,602685,553680,547415,596108,633435,659475],"length":1,"stats":{"Line":60},"fn_name":null},{"line":17,"address":[655886,654302,561120,577330,593580,655332,630379,629979,595215,679163,608388,577301,559966,608699,593651,560528,630108,593391,679295,658719,656987,562671,655933,546415,577106,630350,578863,678968,610255,608894,629563,630435,577254,576738,560915,592947,608923,656018,673697,678820,655962,561044,592385,608965,680078,576176,561091,561176,593609,655691,608847,624862,679210,679239,678404,630303,577372,631218,632671,593533,603693,655563,654954],"length":1,"stats":{"Line":63},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","sienna","sienna","libraries","lend-experimental","src","core_library.rs"],"content":"use super::uint256::Uint256;\nuse crate::wad_ray_math::{self, WadRayMathU256};\nuse bigint::U256;\nuse cosmwasm_std::{Env, StdError, StdResult, Uint128};\nuse lazy_static::lazy_static;\nuse serde::{Deserialize, Serialize};\nuse std::ops::{Add, Div, Sub};\npub enum InterestRateMode {\n    Stable,\n    Varible,\n    None,\n}\nlazy_static! {\n    static ref SECODNS_PER_YEAR: U256 = U256::from(31_536_000);\n}\n\n#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub struct UserReserveData {\n    //principal amount borrowed by the user.\n    principal_borrow_balance: Uint256,\n    //cumulated variable borrow index for the user. Expressed in ray\n    last_variable_borrow_cumulative_index: Uint256,\n    //origination fee cumulated by the user\n    origination_fee: Uint256,\n    // stable borrow rate at which the user has borrowed. Expressed in ray\n    stable_borrow_rate: Uint256,\n    last_update_timestamp: u64,\n\n    //defines if a specific deposit should or not be used as a collateral in borrows\n    use_as_collateral: bool,\n}\n#[derive(Debug, Default, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct ReserveData {\n    //the liquidity index. Expressed in ray\n    last_liquidity_cumulate_index: Uint256,\n    //the current supply rate. Expressed in ray\n    current_liquidity_rate: Uint256,\n    //the total borrows of the reserve at a stable rate. Expressed in the currency decimals\n    total_borrow_stable: Uint256,\n    //the total borrows of the reserve at a variable rate. Expressed in the currency decimals\n    total_borrows_variable: Uint256,\n    //the current variable borrow rate. Expressed in ray\n    current_variable_borrow_rate: Uint256,\n    //the current stable borrow rate. Expressed in ray\n    current_stable_borrow_rate: Uint256,\n    //the current average stable borrow rate (weighted average of all the different stable rate loans). Expressed in ray\n    current_average_stable_borrow_rate: Uint256,\n    //variable borrow index. Expressed in ray\n    last_variable_borrow_cumulative_index: Uint256,\n    //the ltv of the reserve. Expressed in percentage (0-100)\n    base_ltv_as_collateral: Uint256,\n    //the liquidation threshold of the reserve. Expressed in percentage (0-100)\n    liquidation_threshold: Uint256,\n    //the liquidation bonus of the reserve. Expressed in percentage\n    liquidation_bonus: Uint256,\n    //the decimals of the reserve asset\n    decimals: Uint256,\n\n    /*\n    address of the aToken representing the asset\n     */\n    a_token_address: String,\n\n    /*\n    address of the interest rate strategy contract\n     */\n    interest_rate_strategy_address: String,\n    last_update_timestamp: u64,\n    // borrowingEnabled = true means users can borrow from this reserve\n    borrowing_enabled: bool,\n    // usageAsCollateralEnabled = true means users can use this reserve as collateral\n    usage_as_collateral_enabled: bool,\n    // isStableBorrowRateEnabled = true means users can borrow at a stable rate\n    is_stable_borrow_rate_enabled: bool,\n    // isActive = true means the reserve has been activated and properly configured\n    is_active: bool,\n    // isFreezed = true means the reserve only allows repays and redeems, but not deposits, new borrowings or rate swap\n    is_freezed: bool,\n}\n\nimpl ReserveData {\n    /**\n     * @dev returns the ongoing normalized income for the reserve.\n     * a value of 1e27 means there is no income. As time passes, the income is accrued.\n     * A value of 2*1e27 means that the income of the reserve is double the initial amount.\n     * @param _reserve the reserve object\n     * @return the normalized income. expressed in ray\n     **/\n    pub fn get_normolized_income(\u0026self, env: \u0026Env) -\u003e U256 {\n        calculate_linear_interest(\n            self.current_liquidity_rate.0,\n            self.last_update_timestamp,\n            env,\n        )\n        .ray_mul(self.last_liquidity_cumulate_index.0)\n    }\n    /**\n     * @dev Updates the liquidity cumulative index Ci and variable borrow cumulative index Bvc. Refer to the whitepaper for\n     * a formal specification.\n     * @param _self the reserve object\n     **/\n    pub fn update_cumulative_indexes(\u0026mut self, env: \u0026Env) {\n        let total_borrows = _get_total_borrows(\u0026self);\n        if total_borrows \u003e U256::from(0) {\n            let camulated_liquidity_interest = calculate_linear_interest(\n                self.current_liquidity_rate.0,\n                self.last_update_timestamp,\n                env,\n            );\n            self.last_variable_borrow_cumulative_index = Uint256::from(\n                camulated_liquidity_interest.ray_mul(self.last_variable_borrow_cumulative_index.0),\n            );\n            let cumulated_varible_borrow_interest = calculate_compouned_interest(\n                self.current_variable_borrow_rate,\n                self.last_update_timestamp,\n                env,\n            );\n            self.last_variable_borrow_cumulative_index = Uint256::from(\n                cumulated_varible_borrow_interest\n                    .ray_mul(self.last_variable_borrow_cumulative_index.0),\n            );\n        }\n    }\n\n    /**\n     * @dev accumulates a predefined amount of asset to the reserve as a fixed, one time income. Used for example to accumulate\n     * the flashloan fee to the reserve, and spread it through the depositors.\n     * @param _self the reserve object\n     * @param _totalLiquidity the total liquidity available in the reserve\n     * @param _amount the amount to accomulate\n     **/\n    pub fn cumulated_to_liquidity_index(\u0026mut self, _total_liquidity: U256, _amount: U256) {\n        let amount_to_liquidity_ratio = _amount.wad_to_ray().ray_div(_total_liquidity.wad_to_ray());\n\n        let cumulated_liquidity = amount_to_liquidity_ratio.add(wad_ray_math::ray_256());\n\n        self.last_liquidity_cumulate_index =\n            Uint256::from(cumulated_liquidity.ray_mul(self.last_liquidity_cumulate_index.0));\n    }\n\n    /**\n     * @dev initializes a reserve\n     * @param _self the reserve object\n     * @param _aTokenAddress the address of the overlying atoken contract\n     * @param _decimals the number of decimals of the underlying asset\n     * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n     **/\n    pub fn init(\n        \u0026mut self,\n        _a_token_address: String,\n        _decimals: Uint256,\n        _interested_rate_strategy_address: String,\n    ) -\u003e StdResult\u003c()\u003e {\n        if !self.a_token_address.is_empty() {\n            return Err(StdError::generic_err(\n                \"Reserve has already been initialized\",\n            ));\n        }\n\n        if self.last_liquidity_cumulate_index.0 == U256::from(0) {\n            self.last_liquidity_cumulate_index = wad_ray_math::ray_256().into();\n        }\n\n        if self.last_variable_borrow_cumulative_index == U256::from(0).into() {\n            self.last_variable_borrow_cumulative_index = Uint256::from(wad_ray_math::ray_256());\n        }\n        self.a_token_address = _a_token_address;\n        self.decimals = _decimals;\n\n        self.interest_rate_strategy_address = _interested_rate_strategy_address;\n        self.is_active = true;\n        self.is_freezed = false;\n\n        Ok(())\n    }\n\n    pub fn get_total_borrows(\u0026self) -\u003e U256 {\n        _get_total_borrows(self)\n    }\n\n    /**\n     * @dev enables borrowing on a reserve\n     * @param _self the reserve object\n     * @param _stableBorrowRateEnabled true if the stable borrow rate must be enabled by default, false otherwise\n     **/\n\n    pub fn enable_borrowing(\u0026mut self, _stable_borrow_rate_enable: bool) -\u003e StdResult\u003c()\u003e {\n        if self.borrowing_enabled == true {\n            return Err(StdError::generic_err(\"Reserve is already enabled\"));\n        }\n        self.borrowing_enabled = true;\n        self.is_stable_borrow_rate_enabled = _stable_borrow_rate_enable;\n        Ok(())\n    }\n\n    /**\n     * @dev disables borrowing on a reserve\n     * @param _self the reserve object\n     **/\n\n    pub fn disable_borrowing(\u0026mut self) {\n        self.borrowing_enabled = false;\n    }\n\n    /**\n     * @dev enables a reserve to be used as collateral\n     * @param _self the reserve object\n     * @param _baseLTVasCollateral the loan to value of the asset when used as collateral\n     * @param _liquidationThreshold the threshold at which loans using this asset as collateral will be considered undercollateralized\n     * @param _liquidationBonus the bonus liquidators receive to liquidate this asset\n     **/\n\n    pub fn enable_as_collateral(\n        \u0026mut self,\n        _base_ltv_as_collateral: Uint256,\n        _liqudation_threshold: Uint256,\n        _liqudation_bouns: Uint256,\n    ) -\u003e StdResult\u003c()\u003e {\n        if self.borrowing_enabled == true {\n            return Err(StdError::generic_err(\n                \"Reserve is already enabled as collateral\",\n            ));\n        }\n        self.usage_as_collateral_enabled = true;\n        self.base_ltv_as_collateral = _base_ltv_as_collateral;\n        self.liquidation_threshold = _liqudation_threshold;\n        self.liquidation_bonus = _liqudation_bouns;\n\n        if self.last_liquidity_cumulate_index == U256::from(0).into() {\n            self.last_liquidity_cumulate_index = wad_ray_math::ray_256().into();\n        }\n        Ok(())\n    }\n\n    /**\n     * @dev disables a reserve as collateral\n     * @param _self the reserve object\n     **/\n\n    pub fn disable_as_collateral(\u0026mut self) {\n        self.usage_as_collateral_enabled = false;\n    }\n\n    pub fn increase_total_borrows_stable_and_update_averege_rate(\n        \u0026mut self,\n        _amount: Uint256,\n        _rate: Uint256,\n    ) {\n        let previus_total_borrow_stable = self.total_borrow_stable;\n        //updating reserve borrows stable\n        self.total_borrow_stable = self.total_borrow_stable.add(_amount);\n\n        //update the average stable rate\n        //weighted average of all the borrows\n        let weighted_last_borrows = _amount.0.wad_to_ray().ray_mul(_rate.0);\n        let _weighted_previous_total_borrows = previus_total_borrow_stable\n            .0\n            .wad_to_ray()\n            .ray_mul(self.current_average_stable_borrow_rate.0);\n        self.current_average_stable_borrow_rate = Uint256::from(\n            weighted_last_borrows\n                .add(weighted_last_borrows)\n                .ray_div(self.total_borrow_stable.0.wad_to_ray()),\n        );\n    }\n    /**\n     * @dev decreases the total borrows at a stable rate on a specific reserve and updates the\n     * average stable rate consequently\n     * @param _reserve the reserve object\n     * @param _amount the amount to substract to the total borrows stable\n     * @param _rate the rate at which the amount has been repaid\n     **/\n    pub fn decrease_total_borrows_stable_and_update_average_rate(\n        \u0026mut self,\n        _amount: Uint256,\n        _rate: Uint256,\n    ) -\u003e StdResult\u003c()\u003e {\n        if self.total_borrow_stable \u003c _amount {\n            return Err(StdError::generic_err(\"Invalid amount to decrease\"));\n        }\n\n        let previus_total_borrow_stable = self.total_borrow_stable;\n\n        //updating reserve borrows stable\n        self.total_borrow_stable = self.total_borrow_stable.sub(_amount);\n        if self.total_borrow_stable == U256::from(0).into() {\n            self.current_average_stable_borrow_rate = U256::from(0).into();\n            return Ok(());\n        }\n\n        //update the average stable rate\n        //weighted average of all the borrows\n        let weighted_last_borrow = _amount.0.wad_to_ray().ray_mul(_rate.0);\n        let weighted_previous_total_borrows = previus_total_borrow_stable\n            .0\n            .wad_to_ray()\n            .ray_mul(self.current_average_stable_borrow_rate.0);\n        if weighted_previous_total_borrows \u003c weighted_last_borrow {\n            return Err(StdError::generic_err(\"The amounts to subtract don't match\"));\n        }\n\n        self.current_average_stable_borrow_rate = Uint256::from(\n            weighted_previous_total_borrows\n                .sub(weighted_last_borrow)\n                .ray_div(self.total_borrow_stable.0.wad_to_ray()),\n        );\n\n        Ok(())\n    }\n\n    /**\n     * @dev increases the total borrows at a variable rate\n     * @param _reserve the reserve object\n     * @param _amount the amount to add to the total borrows variable\n     **/\n    pub fn increase_total_borrows_variable(\u0026mut self, _amount: Uint256) {\n        self.total_borrows_variable = self.total_borrows_variable.add(_amount);\n    }\n\n    /**\n     * @dev decreases the total borrows at a variable rate\n     * @param _reserve the reserve object\n     * @param _amount the amount to substract to the total borrows variable\n     **/\n\n    pub fn decrease_total_borrows_varible(\u0026mut self, _amount: Uint256) -\u003e StdResult\u003c()\u003e {\n        if self.total_borrows_variable \u003c _amount {\n            return Err(StdError::generic_err(\n                \"The amount that is being subtracted from the variable total borrows is incorrect\",\n            ));\n        }\n        Ok(())\n    }\n}\n\nimpl UserReserveData {\n    /**\n     * @dev calculates the compounded borrow balance of a user\n     * @param _self the userReserve object\n     * @param _reserve the reserve object\n     * @return the user compounded borrow balance\n     **/\n    pub fn get_compounded_borrow_balance(\u0026self, _reserve: \u0026ReserveData, env: \u0026Env) -\u003e U256 {\n        if self.principal_borrow_balance.0 == U256::from(0) {\n            return U256::from(0);\n        }\n\n        let principal_borrow_balance_ray = self.principal_borrow_balance.0.wad_to_ray();\n        let mut compounded_balance = U256::from(0);\n        let mut cumulated_interest = U256::from(0);\n\n        if self.stable_borrow_rate \u003e Uint256::from(0_u64) {\n            cumulated_interest = calculate_compouned_interest(\n                self.stable_borrow_rate,\n                self.last_update_timestamp,\n                env,\n            );\n        } else {\n            //variable interest\n            cumulated_interest = calculate_compouned_interest(\n                _reserve.current_variable_borrow_rate,\n                _reserve.last_update_timestamp,\n                env,\n            )\n            .ray_mul(_reserve.last_variable_borrow_cumulative_index.0)\n            .ray_div(self.last_variable_borrow_cumulative_index.0);\n        }\n\n        compounded_balance = principal_borrow_balance_ray\n            .ray_mul(cumulated_interest)\n            .ray_to_wad();\n        if compounded_balance == self.principal_borrow_balance.0 {\n            //solium-disable-next-line\n            if self.last_update_timestamp != env.block.time {\n                //no interest cumulation because of the rounding - we add 1 wei\n                //as symbolic cumulated interest to avoid interest free loans.\n\n                return self.principal_borrow_balance.0.add(U256::from(1));\n            }\n        }\n        compounded_balance\n    }\n}\n/**\n * @dev Updates the liquidity cumulative index Ci and variable borrow cumulative index Bvc. Refer to the whitepaper for\n * a formal specification.\n * @param _self the reserve object\n**/\n\n//pub fn\n\npub fn calculate_linear_interest(_rate: U256, _last_update_timestamp: u64, env: \u0026Env) -\u003e U256 {\n    //solim-disable-next-line\n    let time_defference = U256::from(env.block.time.sub(_last_update_timestamp));\n\n    let time_delta = time_defference\n        .wad_to_ray()\n        .ray_div(SECODNS_PER_YEAR.wad_to_ray());\n\n    _rate.ray_mul(time_delta).add(wad_ray_math::ray_256())\n}\n\npub fn calculate_compouned_interest(\n    _rate: Uint256,\n    _last_update_timestamp: u64,\n    env: \u0026Env,\n) -\u003e U256 {\n    let time_defference = U256::from(env.block.time.sub(_last_update_timestamp));\n\n    let rate_pre_second = _rate.0.div(*SECODNS_PER_YEAR);\n\n    rate_pre_second\n        .add(wad_ray_math::ray_256())\n        .ray_pow(time_defference)\n}\n/**\n * @dev returns the total borrows on the reserve\n * @param _reserve the reserve object\n * @return the total borrows (stable + variable)\n **/\n\nfn _get_total_borrows(_reserve: \u0026ReserveData) -\u003e U256 {\n    _reserve\n        .total_borrow_stable\n        .0\n        .add(_reserve.total_borrows_variable.0)\n}\n\n#[cfg(test)]\nmod core_lib_tests {\n    use cosmwasm_std::{\n        testing::MOCK_CONTRACT_ADDR, BlockInfo, ContractInfo, HumanAddr, MessageInfo,\n    };\n\n    use super::*;\n\n    #[test]\n    fn inti_test() {\n        let mut data = ReserveData::default();\n        data.init(\n            \"deafult_address\".to_string(),\n            U256::from(1000).into(),\n            \"test_rate_strategy_address\".to_string(),\n        )\n        .unwrap();\n    }\n\n    #[test]\n    fn double_init_test() {\n        let mut data = ReserveData::default();\n        data.init(\n            \"a_token_address\".to_string(),\n            U256::from(10).into(),\n            \"interested_rate_strategy_address\".to_string(),\n        )\n        .unwrap();\n        let res = data.init(\n            \"a_token_address\".to_string(),\n            U256::from(10).into(),\n            \"interested_rate_strategy_address\".to_string(),\n        );\n        let want = Err(StdError::generic_err(\n            \"Reserve has already been initialized\",\n        ));\n\n        assert_eq!(want, res);\n    }\n\n    #[test]\n    fn get_normolize_test() {\n        let reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(2).pow(U256::from(1)).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(10).pow(U256::from(27)).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_520,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        let normolze = reserve_data.get_normolized_income(\u0026Env {\n            block: BlockInfo {\n                height: 100,\n                time: 1_571_800_620,\n                chain_id: \"cosmos-testnet-14002\".to_string(),\n            },\n            message: MessageInfo {\n                sender: HumanAddr(\"bob\".to_string()),\n                sent_funds: vec![],\n            },\n            contract: ContractInfo {\n                address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            },\n            contract_key: Some(\"\".to_string()),\n            contract_code_hash: \"\".to_string(),\n        });\n\n        assert_eq!(50, normolze.as_u32());\n    }\n\n    #[test]\n    fn calculate_compouned_interest_test() {\n        let env = Env {\n            block: BlockInfo {\n                height: 100,\n                time: 1_571_800_420,\n                chain_id: \"cosmos-testnet-14002\".to_string(),\n            },\n            message: MessageInfo {\n                sender: HumanAddr(\"bob\".to_string()),\n                sent_funds: vec![],\n            },\n            contract: ContractInfo {\n                address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            },\n            contract_key: Some(\"\".to_string()),\n            contract_code_hash: \"\".to_string(),\n        };\n\n        let res = calculate_compouned_interest(Uint256::from(10_u64), 1_571_800_320, \u0026env);\n        assert_eq!(U256::from(10).pow(U256::from(27)), res);\n    }\n\n    #[test]\n    fn calculate_linear_interest_test() {\n        let env = Env {\n            block: BlockInfo {\n                height: 100,\n                time: 1_571_800_420,\n                chain_id: \"cosmos-testnet-14002\".to_string(),\n            },\n            message: MessageInfo {\n                sender: HumanAddr(\"bob\".to_string()),\n                sent_funds: vec![],\n            },\n            contract: ContractInfo {\n                address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            },\n            contract_key: Some(\"\".to_string()),\n            contract_code_hash: \"\".to_string(),\n        };\n        let res = calculate_linear_interest(U256::from(10), 1_571_800_320, \u0026env);\n        assert_eq!(U256::from(10).pow(U256::from(27)), res);\n    }\n\n    #[test]\n    fn get_compounded_borrow_balance_test() {\n        let user_data = UserReserveData {\n            principal_borrow_balance: Uint256::from(10000u64), //U256::from(10000),\n            last_variable_borrow_cumulative_index: Uint256::from(10_u64),\n            origination_fee: Uint256::from(5_u64),\n            stable_borrow_rate: Uint256::from(50_u64),\n            last_update_timestamp: 1_571_800_320,\n            use_as_collateral: true,\n        };\n        let reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: true,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(70).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(7).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n        let env = Env {\n            block: BlockInfo {\n                height: 100,\n                time: 1_571_800_420,\n                chain_id: \"cosmos-testnet-14002\".to_string(),\n            },\n            message: MessageInfo {\n                sender: HumanAddr(\"bob\".to_string()),\n                sent_funds: vec![],\n            },\n            contract: ContractInfo {\n                address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            },\n            contract_key: Some(\"\".to_string()),\n            contract_code_hash: \"\".to_string(),\n        };\n        let res = user_data.get_compounded_borrow_balance(\u0026reserve_data, \u0026env);\n        assert_eq!(U256::from(10001), res);\n    }\n\n    #[test]\n    fn update_cumulative_indexes_test() {\n        let env = Env {\n            block: BlockInfo {\n                height: 100,\n                time: 1_571_800_420,\n                chain_id: \"cosmos-testnet-14002\".to_string(),\n            },\n            message: MessageInfo {\n                sender: HumanAddr(\"bob\".to_string()),\n                sent_funds: vec![],\n            },\n            contract: ContractInfo {\n                address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            },\n            contract_key: Some(\"\".to_string()),\n            contract_code_hash: \"\".to_string(),\n        };\n\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: true,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(70).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        reserve_data.update_cumulative_indexes(\u0026env);\n\n        assert_eq!(\n            Uint256::from(70u64),\n            reserve_data.last_variable_borrow_cumulative_index\n        );\n    }\n\n    #[test]\n    fn get_total_borrows_test() {\n        let reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: true,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(70).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n        let res = reserve_data.get_total_borrows();\n        assert_eq!(170, res.as_u64());\n    }\n\n    #[test]\n    fn enable_borrowing_test_1() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: true,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(70).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        let res = reserve_data.enable_borrowing(true);\n        let want = Err(StdError::generic_err(\"Reserve is already enabled\"));\n        assert_eq!(want, res);\n    }\n\n    #[test]\n    fn enable_borrowing_test_2() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(70).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        reserve_data.enable_borrowing(true).unwrap();\n        assert_eq!(true, reserve_data.borrowing_enabled);\n    }\n\n    #[test]\n    fn disable_borrowing_test() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: true,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(70).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        reserve_data.disable_borrowing();\n        assert_eq!(false, reserve_data.borrowing_enabled);\n    }\n\n    #[test]\n    fn enable_as_cllateral_test_1() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: true,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(70).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        let res = reserve_data.enable_as_collateral(\n            U256::from(77).into(),\n            U256::from(14).into(),\n            U256::from(80).into(),\n        );\n        let want = Err(StdError::generic_err(\n            \"Reserve is already enabled as collateral\",\n        ));\n        assert_eq!(want, res);\n    }\n\n    #[test]\n    fn enable_as_cllateral_test_2() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(70).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        reserve_data\n            .enable_as_collateral(\n                U256::from(77).into(),\n                U256::from(14).into(),\n                U256::from(80).into(),\n            )\n            .unwrap();\n        let want = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(77).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(70).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(14).into(),\n            liquidation_bonus: U256::from(80).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        assert_eq!(want, reserve_data);\n    }\n\n    #[test]\n    fn disable_as_collateral_test() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(70).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n        reserve_data.disable_as_collateral();\n        assert_eq!(false, reserve_data.usage_as_collateral_enabled);\n    }\n\n    #[test]\n    fn increase_total_borrows_stable_and_update_averege_rate_test() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(0).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n        let ten = U256::from(10);\n        let amount = ten.pow(U256::from(27)).into();\n        reserve_data.increase_total_borrows_stable_and_update_averege_rate(\n            amount,\n            U256::from(80000_u64).into(),\n        );\n        let want: Uint256 = U256::from(160000).into();\n        assert_eq!(amount, reserve_data.total_borrow_stable);\n        assert_eq!(want, reserve_data.current_average_stable_borrow_rate);\n    }\n\n    #[test]\n    fn descrees_total_borrows_stable_and_update_average_rate_test_1() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(20).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        let want = Err(StdError::generic_err(\"Invalid amount to decrease\"));\n        let res = reserve_data.decrease_total_borrows_stable_and_update_average_rate(\n            U256::from(40).into(),\n            U256::from(70).into(),\n        );\n\n        assert_eq!(want, res);\n    }\n\n    #[test]\n    fn descrees_total_borrows_stable_and_update_average_rate_test_2() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(140).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        reserve_data\n            .decrease_total_borrows_stable_and_update_average_rate(\n                U256::from(70).into(),\n                U256::from(70).into(),\n            )\n            .unwrap();\n        assert_eq!(Uint256::from(70u64), reserve_data.total_borrow_stable);\n        assert_eq!(\n            Uint256::zero(),\n            reserve_data.current_average_stable_borrow_rate\n        );\n    }\n\n    #[test]\n    fn descrees_total_borrows_stable_and_update_average_rate_test_3() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(100).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(140).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        reserve_data\n            .decrease_total_borrows_stable_and_update_average_rate(\n                U256::from(140).into(),\n                U256::from(70).into(),\n            )\n            .unwrap();\n        assert_eq!(Uint256::zero(), reserve_data.total_borrow_stable);\n        assert_eq!(\n            Uint256::zero(),\n            reserve_data.current_average_stable_borrow_rate\n        );\n    }\n\n    #[test]\n    fn descrees_total_borrows_stable_and_update_average_rate_test_4() {\n        //let total_borrow_stabl\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(2).pow(U256::from(1)).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(10).pow(U256::from(27)).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        let res = reserve_data.decrease_total_borrows_stable_and_update_average_rate(\n            U256::from(10).pow(U256::from(26)).into(),\n            U256::from(70).into(),\n        );\n        let want = Err(StdError::generic_err(\"The amounts to subtract don't match\"));\n        assert_eq!(want, res);\n    }\n\n    #[test]\n    fn increase_total_borrows_variable_test() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(2).pow(U256::from(1)).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(10).pow(U256::from(27)).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        reserve_data.increase_total_borrows_variable(U256::from(100).into());\n\n        assert_eq!(Uint256::from(200_u64), reserve_data.total_borrows_variable);\n    }\n\n    #[test]\n    fn decrease_total_borrows_varible_test_1() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(2).pow(U256::from(1)).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(10).pow(U256::from(27)).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n        let res = reserve_data.decrease_total_borrows_varible(U256::from(200).into());\n        let want = Err(StdError::generic_err(\n            \"The amount that is being subtracted from the variable total borrows is incorrect\",\n        ));\n        assert_eq!(want, res);\n    }\n\n    #[test]\n    fn decrease_total_borrows_varible_test_2() {\n        let mut reserve_data = ReserveData {\n            a_token_address: \"tokena_addrr\".to_string(),\n            base_ltv_as_collateral: U256::from(50).into(),\n            borrowing_enabled: false,\n            current_average_stable_borrow_rate: U256::from(2).pow(U256::from(1)).into(),\n            current_liquidity_rate: U256::from(400).into(),\n            last_liquidity_cumulate_index: U256::from(50).into(),\n            total_borrow_stable: U256::from(10).pow(U256::from(27)).into(),\n            total_borrows_variable: U256::from(100).into(),\n            current_variable_borrow_rate: Uint256::from(70_u64),\n            current_stable_borrow_rate: U256::from(78).into(),\n            last_variable_borrow_cumulative_index: U256::from(70).into(),\n            liquidation_threshold: U256::from(7).into(),\n            liquidation_bonus: U256::from(45).into(),\n            decimals: U256::from(10).into(),\n            interest_rate_strategy_address: \"test_rate_strategy_addr\".to_string(),\n            last_update_timestamp: 1_571_800_320,\n            usage_as_collateral_enabled: true,\n            is_stable_borrow_rate_enabled: true,\n            is_active: true,\n            is_freezed: false,\n        };\n\n        reserve_data\n            .decrease_total_borrows_stable_and_update_average_rate(\n                U256::from(50).into(),\n                U256::from(50).into(),\n            )\n            .unwrap();\n        let want: Uint256 = Uint256::from(10_u64).0.pow(U256::from(27)).into();\n        assert_eq!(\n            want - Uint256::from(50_u64),\n            reserve_data.total_borrow_stable\n        );\n        assert_eq!(\n            Uint256::from(2u64),\n            reserve_data.current_average_stable_borrow_rate\n        );\n    }\n}\n","traces":[{"line":14,"address":[553035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[599632],"length":1,"stats":{"Line":1},"fn_name":"calculate_linear_interest"},{"line":394,"address":[599683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[599763,599713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[599728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[599791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[599920],"length":1,"stats":{"Line":1},"fn_name":"calculate_compouned_interest"},{"line":408,"address":[599971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[600006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[600143,600295,600208],"length":1,"stats":{"Line":3},"fn_name":null},{"line":413,"address":[600195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[600243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[600336],"length":1,"stats":{"Line":1},"fn_name":"_get_total_borrows"},{"line":423,"address":[600357,600429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[600393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[504085,504356,504080,504112],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":439,"address":[504119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[504246,504306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":441,"address":[504137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[504172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[504219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[504448,505240,504453,504480],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":450,"address":[504487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[504682,504622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[504513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[504548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[504595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[504813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[504704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[504739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[504786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[504873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[505008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[505440,505445,507593,505472],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":472,"address":[505479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[505504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[505551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[505657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[505704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[505751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[505857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[505917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[505924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[505971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[506018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[506065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[506112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[506159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[507040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[506695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[506668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[506829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[506751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[506810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[506924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[506893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[506956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[507014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[507287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[507808,507813,507840,508784],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":517,"address":[507872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[508006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[508101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[508133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[508191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[508401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[508441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[508949,508944,509924,508976],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":540,"address":[509008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":545,"address":[509142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[509237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[509269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[509327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[509524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[509581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[512473,510101,510096,510128],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":562,"address":[510135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[510153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[510171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[510189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[510447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[510472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":573,"address":[510519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[510566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[510613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[510660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[510707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":578,"address":[510767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[510774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":580,"address":[510821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[510868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":582,"address":[510915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":583,"address":[510962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":584,"address":[511009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":592,"address":[511563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":597,"address":[511697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[511792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[511824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[511882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[512129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[512136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":[512688,512720,514703,512693],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":614,"address":[512752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[512886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":623,"address":[512981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[513013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":627,"address":[513071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":631,"address":[513268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[513295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":634,"address":[513342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":635,"address":[513389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":636,"address":[513436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[513483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[513530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[513590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[513597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[513644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":642,"address":[513691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":643,"address":[513738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[513785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[513832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":653,"address":[514372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[514399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":656,"address":[514392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":662,"address":[516271,514917,514912,514944],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":664,"address":[514951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":665,"address":[514976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":667,"address":[515023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[515070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[515117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[515164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":671,"address":[515211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":672,"address":[515271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":673,"address":[515278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[515325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[515372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[515419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":677,"address":[515466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[515513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":685,"address":[516035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[516050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":690,"address":[516341,516368,517854,516336],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":692,"address":[516375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[516400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[516447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[516494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[516541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":698,"address":[516588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":699,"address":[516635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":700,"address":[516695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":701,"address":[516702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":702,"address":[516749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":703,"address":[516796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":704,"address":[516843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":705,"address":[516890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[516937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":714,"address":[517464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":715,"address":[517471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[517606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[517968,517973,518000,519307],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":722,"address":[518007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":723,"address":[518032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[518079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[518126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":727,"address":[518173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":728,"address":[518220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":729,"address":[518267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[518327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[518334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[518381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[518428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":734,"address":[518475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":735,"address":[518522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":736,"address":[518569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":744,"address":[519093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":745,"address":[519122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[519408,519381,519376,520680],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":751,"address":[519415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[519440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[519487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":755,"address":[519534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":756,"address":[519581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":757,"address":[519628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[519675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[519735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[519742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":761,"address":[519789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[519836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":763,"address":[519883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[519930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":765,"address":[519977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":773,"address":[520488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":774,"address":[520495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[520752,522430,520757,520784],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":780,"address":[520791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":781,"address":[520816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":783,"address":[520863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":784,"address":[520910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[520957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[521004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":787,"address":[521051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":788,"address":[521111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":789,"address":[521118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":790,"address":[521165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":791,"address":[521212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":792,"address":[521259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[521306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":794,"address":[521353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":802,"address":[522040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":803,"address":[521862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[521909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":805,"address":[521956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":807,"address":[522047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":810,"address":[522182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":814,"address":[522549,525193,522544,522576],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":816,"address":[522583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[522608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":819,"address":[522655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[522702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":821,"address":[522749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":822,"address":[522796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":823,"address":[522843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[522903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":825,"address":[522910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":826,"address":[522957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":827,"address":[523004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":828,"address":[523051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":829,"address":[523098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[523145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":838,"address":[523832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":840,"address":[523654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[523701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":842,"address":[523748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":846,"address":[523861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":847,"address":[523888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[523935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":850,"address":[523982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":851,"address":[524029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[524076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":853,"address":[524123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[524183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[524190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":856,"address":[524237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[524284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":858,"address":[524331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":859,"address":[524378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":860,"address":[524425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":868,"address":[524960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":872,"address":[526616,525312,525317,525344],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":874,"address":[525351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":875,"address":[525376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":877,"address":[525423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":878,"address":[525470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":879,"address":[525517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":880,"address":[525564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":881,"address":[525611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":882,"address":[525671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":883,"address":[525678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":884,"address":[525725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":885,"address":[525772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":886,"address":[525819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":887,"address":[525866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":888,"address":[525913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":895,"address":[526424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":896,"address":[526431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":900,"address":[528438,526688,526693,526720],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":902,"address":[526727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":903,"address":[526752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":905,"address":[526799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":906,"address":[526846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":907,"address":[526893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":908,"address":[526940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":909,"address":[526984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":910,"address":[527044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":911,"address":[527051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":912,"address":[527098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":913,"address":[527145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":914,"address":[527192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":915,"address":[527239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[527286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":923,"address":[527798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[527822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":925,"address":[528036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":926,"address":[527936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":927,"address":[527968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":929,"address":[528043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":930,"address":[528090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":931,"address":[528243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":935,"address":[528512,528517,528544,530135],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":937,"address":[528551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":938,"address":[528576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":940,"address":[528623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":941,"address":[528670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":942,"address":[528717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[528764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":944,"address":[528811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":945,"address":[528871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":946,"address":[528878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":947,"address":[528925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":948,"address":[528972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[529019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":950,"address":[529066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":951,"address":[529113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":959,"address":[529622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":960,"address":[529872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":961,"address":[529749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":962,"address":[529796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":965,"address":[529887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":969,"address":[530288,530261,531904,530256],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":971,"address":[530295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":972,"address":[530320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":974,"address":[530367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":975,"address":[530414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[530461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":977,"address":[530508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":978,"address":[530555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":979,"address":[530615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":980,"address":[530622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":981,"address":[530669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":982,"address":[530716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[530763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":984,"address":[530810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":985,"address":[530857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":993,"address":[531492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":995,"address":[531369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":996,"address":[531416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":999,"address":[531534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1000,"address":[531709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1001,"address":[531702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1007,"address":[531973,532000,531968,533611],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1009,"address":[532007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1010,"address":[532032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1012,"address":[532079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1013,"address":[532126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1014,"address":[532173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1015,"address":[532220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1016,"address":[532267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1017,"address":[532327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1018,"address":[532334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1019,"address":[532381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1020,"address":[532428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1021,"address":[532475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1022,"address":[532522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1023,"address":[532569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[533204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[533081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1034,"address":[533128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1037,"address":[533241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1038,"address":[533416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1039,"address":[533409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1045,"address":[533685,533680,533712,535480],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1048,"address":[533719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1049,"address":[533744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1051,"address":[533791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1052,"address":[533897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1053,"address":[533944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1054,"address":[533991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1055,"address":[534097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1056,"address":[534157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1057,"address":[534164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1058,"address":[534211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1059,"address":[534258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1060,"address":[534305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1061,"address":[534352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1062,"address":[534399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":[535090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1071,"address":[534908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1072,"address":[535014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1074,"address":[535097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1075,"address":[535232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1079,"address":[537112,535600,535605,535632],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1081,"address":[535639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1082,"address":[535664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1084,"address":[535711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1085,"address":[535817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1086,"address":[535864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1087,"address":[535911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1088,"address":[536017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1089,"address":[536077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1090,"address":[536084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1091,"address":[536131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1092,"address":[536178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1093,"address":[536225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1094,"address":[536272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1095,"address":[536319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1103,"address":[536828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1105,"address":[536908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1109,"address":[537189,537184,537216,538870],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1111,"address":[537223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1112,"address":[537248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1114,"address":[537295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1115,"address":[537401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1116,"address":[537448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[537495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1118,"address":[537601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1119,"address":[537661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1120,"address":[537668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1121,"address":[537715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1122,"address":[537762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1123,"address":[537809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1124,"address":[537856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1125,"address":[537903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1132,"address":[538412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1133,"address":[538487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1136,"address":[538622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1140,"address":[540960,539024,538997,538992],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1142,"address":[539031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1143,"address":[539056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1145,"address":[539103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1146,"address":[539209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1147,"address":[539256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1148,"address":[539303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1149,"address":[539409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1150,"address":[539469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1151,"address":[539476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1152,"address":[539523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1153,"address":[539570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1154,"address":[539617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1155,"address":[539664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1156,"address":[539711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1164,"address":[540346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1166,"address":[540223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1167,"address":[540270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1170,"address":[540388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1171,"address":[540592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1172,"address":[540509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1175,"address":[540765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1176,"address":[540758],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":525,"coverable":550},{"path":["/","home","runner","work","sienna","sienna","libraries","lend-experimental","src","lib.rs"],"content":"pub mod core_library;\npub mod uint256;\npub mod wad_ray_math;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","lend-experimental","src","uint256.rs"],"content":"use schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::convert::TryFrom;\nuse std::fmt::{self, Write};\nuse std::ops;\nuse std::str::FromStr;\n\nuse bigint::U256;\nuse cosmwasm_std::{Decimal, StdError, Uint128};\n\n/// A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n/// The greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^128 - 1) / 10^18)\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Decimal256(#[schemars(with = \"String\")] pub U256);\n\nimpl Decimal256 {\n    pub const MAX: Decimal256 = Decimal256(U256::MAX);\n    pub const DECIMAL_FRACTIONAL: U256 = U256([1_000_000_000_000_000_000u64, 0, 0, 0]);\n\n    /// Create a 1.0 Decimal256\n    pub const fn one() -\u003e Decimal256 {\n        Decimal256(Decimal256::DECIMAL_FRACTIONAL)\n    }\n\n    /// Create a 0.0 Decimal256\n    pub const fn zero() -\u003e Decimal256 {\n        Decimal256(U256([0, 0, 0, 0]))\n    }\n\n    /// Convert x% into Decimal256\n    pub fn percent(x: u64) -\u003e Decimal256 {\n        Decimal256(U256::from(x) * U256::from(10_000_000_000_000_000u64))\n    }\n\n    /// Convert permille (x/1000) into Decimal256\n    pub fn permille(x: u64) -\u003e Decimal256 {\n        Decimal256(U256::from(x) * U256::from(1_000_000_000_000_000u64))\n    }\n\n    /// Returns the ratio (nominator / denominator) as a Decimal256\n    pub fn from_ratio\u003cA: Into\u003cU256\u003e, B: Into\u003cU256\u003e\u003e(nominator: A, denominator: B) -\u003e Decimal256 {\n        let nominator: U256 = nominator.into();\n        let denominator: U256 = denominator.into();\n        if denominator.is_zero() {\n            panic!(\"Denominator must not be zero\");\n        }\n\n        Decimal256(nominator * Decimal256::DECIMAL_FRACTIONAL / denominator)\n    }\n\n    pub fn from_uint256\u003cA: Into\u003cUint256\u003e\u003e(val: A) -\u003e Decimal256 {\n        let num: Uint256 = val.into();\n        Decimal256(num.0 * Decimal256::DECIMAL_FRACTIONAL)\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl From\u003cDecimal\u003e for Decimal256 {\n    fn from(val: Decimal) -\u003e Self {\n        Decimal256::from_str(\u0026val.to_string()).unwrap()\n    }\n}\n\nimpl Into\u003cDecimal\u003e for Decimal256 {\n    fn into(self) -\u003e Decimal {\n        let U256(ref arr) = self.0;\n        assert!(arr[2] == 0u64);\n        assert!(arr[3] == 0u64);\n        Decimal::from_str(\u0026self.to_string()).unwrap()\n    }\n}\n\nimpl FromStr for Decimal256 {\n    type Err = StdError;\n\n    /// Converts the decimal string to a Decimal256\n    /// Possible inputs: \"1.23\", \"1\", \"000012\", \"1.123000000\"\n    /// Disallowed: \"\", \".23\"\n    ///\n    /// This never performs any kind of rounding.\n    /// More than 18 fractional digits, even zeros, result in an error.\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let parts: Vec\u003c\u0026str\u003e = input.split('.').collect();\n        match parts.len() {\n            1 =\u003e {\n                let whole = U256::from_dec_str(parts[0])\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n\n                let whole_as_atomics = whole * Decimal256::DECIMAL_FRACTIONAL;\n                Ok(Decimal256(whole_as_atomics))\n            }\n            2 =\u003e {\n                let whole = U256::from_dec_str(parts[0])\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n                let fractional = U256::from_dec_str(parts[1])\n                    .map_err(|_| StdError::generic_err(\"Error parsing fractional\"))?;\n                let exp = (18usize.checked_sub(parts[1].len())).ok_or_else(|| {\n                    StdError::generic_err(\"Cannot parse more than 18 fractional digits\")\n                })?;\n                let fractional_factor = U256::from(10).pow(exp.into());\n\n                let whole_as_atomics = whole * Decimal256::DECIMAL_FRACTIONAL;\n                let atomics = whole_as_atomics + fractional * fractional_factor;\n                Ok(Decimal256(atomics))\n            }\n            _ =\u003e Err(StdError::generic_err(\"Unexpected number of dots\")),\n        }\n    }\n}\n\nimpl fmt::Display for Decimal256 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let whole = (self.0) / Decimal256::DECIMAL_FRACTIONAL;\n        let fractional = (self.0) % Decimal256::DECIMAL_FRACTIONAL;\n\n        if fractional.is_zero() {\n            write!(f, \"{}\", whole)\n        } else {\n            let fractional_string = fractional.to_string();\n            let fractional_string = \"0\".repeat(18 - fractional_string.len()) + \u0026fractional_string;\n\n            f.write_str(\u0026whole.to_string())?;\n            f.write_char('.')?;\n            f.write_str(fractional_string.trim_end_matches('0'))?;\n\n            Ok(())\n        }\n    }\n}\n\nimpl ops::Add for Decimal256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self {\n        Decimal256(self.0 + rhs.0)\n    }\n}\n\nimpl ops::AddAssign for Decimal256 {\n    fn add_assign(\u0026mut self, rhs: Self) {\n        self.0 = self.0 + rhs.0;\n    }\n}\n\nimpl ops::Sub for Decimal256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -\u003e Self {\n        assert!(self.0 \u003e= rhs.0);\n        Decimal256(self.0 - rhs.0)\n    }\n}\n\nimpl ops::Mul for Decimal256 {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -\u003e Self {\n        Decimal256(self.0 * rhs.0 / Decimal256::DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Div for Decimal256 {\n    type Output = Self;\n\n    fn div(self, rhs: Self) -\u003e Self {\n        assert!(!rhs.is_zero());\n\n        Decimal256(self.0 * Decimal256::DECIMAL_FRACTIONAL / rhs.0)\n    }\n}\n\n/// Serializes as a decimal string\nimpl Serialize for Decimal256 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Decimal256 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cDecimal256, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Decimal256Visitor)\n    }\n}\n\nstruct Decimal256Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Decimal256Visitor {\n    type Value = Decimal256;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded decimal\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match Decimal256::from_str(v) {\n            Ok(d) =\u003e Ok(d),\n            Err(e) =\u003e Err(E::custom(format!(\"Error parsing decimal '{}': {}\", v, e))),\n        }\n    }\n}\n\n//*** Uint256 ***/\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Uint256(#[schemars(with = \"String\")] pub U256);\n\nimpl Uint256 {\n    /// Creates a Uint256(0)\n    pub const fn zero() -\u003e Self {\n        Uint256(U256([0, 0, 0, 0]))\n    }\n\n    /// Create a 1.0 Decimal256\n    pub const fn one() -\u003e Self {\n        Uint256(U256([1, 0, 0, 0]))\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl From\u003cU256\u003e for Uint256 {\n    fn from(val: U256) -\u003e Self {\n        Uint256(val)\n    }\n}\n\n#[inline(always)]\nfn split_u128(a: u128) -\u003e (u64, u64) {\n    ((a \u003e\u003e 64) as _, (a \u0026 0xFFFFFFFFFFFFFFFF) as _)\n}\n\nimpl From\u003cUint128\u003e for Uint256 {\n    fn from(val: Uint128) -\u003e Self {\n        Uint256::from(val.u128())\n    }\n}\n\nimpl From\u003cu128\u003e for Uint256 {\n    fn from(val: u128) -\u003e Self {\n        let (hi, low) = split_u128(val);\n        Uint256(U256([low, hi, 0, 0]))\n    }\n}\n\nimpl From\u003cu64\u003e for Uint256 {\n    fn from(val: u64) -\u003e Self {\n        Uint256(val.into())\n    }\n}\n\nimpl TryFrom\u003c\u0026str\u003e for Uint256 {\n    type Error = StdError;\n\n    fn try_from(val: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match U256::from_dec_str(val) {\n            Ok(u) =\u003e Ok(Uint256(u)),\n            Err(_e) =\u003e Err(StdError::generic_err(format!(\"invalid Uint256 '{}'\", val))),\n        }\n    }\n}\n\nimpl FromStr for Uint256 {\n    type Err = StdError;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let number =\n            U256::from_dec_str(input).map_err(|_| StdError::generic_err(\"Error parsing number\"))?;\n        Ok(Uint256(number))\n    }\n}\n\nimpl Into\u003cString\u003e for Uint256 {\n    fn into(self) -\u003e String {\n        self.0.to_string()\n    }\n}\n\nimpl Into\u003cu128\u003e for Uint256 {\n    fn into(self) -\u003e u128 {\n        let U256(ref arr) = self.0;\n        assert!(arr[2] == 0u64);\n        assert!(arr[3] == 0u64);\n\n        let (hi, low) = (arr[1], arr[0]);\n        ((hi as u128) \u003c\u003c 64) + (low as u128)\n    }\n}\n\nimpl Into\u003cUint128\u003e for Uint256 {\n    fn into(self) -\u003e Uint128 {\n        Uint128(self.into())\n    }\n}\n\nimpl fmt::Display for Uint256 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl ops::Add for Uint256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self {\n        Uint256(self.0 + rhs.0)\n    }\n}\n\nimpl ops::AddAssign for Uint256 {\n    fn add_assign(\u0026mut self, other: Self) {\n        self.0 = self.0 + other.0;\n    }\n}\n\nimpl ops::Sub for Uint256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -\u003e Self::Output {\n        assert!(self.0 \u003e= rhs.0);\n        Uint256(self.0 - rhs.0)\n    }\n}\n\nimpl ops::Div for Uint256 {\n    type Output = Self;\n    fn div(self, rhs: Self) -\u003e Self::Output {\n        Uint256(self.0 / rhs.0)\n    }\n}\n\nimpl ops::Mul\u003cUint256\u003e for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Uint256) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint256::zero();\n        }\n\n        Uint256(self.0 * rhs.0)\n    }\n}\n\n/// Both d*u and u*d with d: Decimal256 and u: Uint256 returns an Uint256. There is no\n/// specific reason for this decision other than the initial use cases we have. If you\n/// need a Decimal256 result for the same calculation, use Decimal256(d*u) or Decimal256(u*d).\nimpl ops::Mul\u003cDecimal256\u003e for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Decimal256) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint256::zero();\n        }\n\n        self.multiply_ratio(rhs.0, Decimal256::DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Div\u003cDecimal256\u003e for Uint256 {\n    type Output = Self;\n\n    fn div(self, rhs: Decimal256) -\u003e Self::Output {\n        assert!(!rhs.is_zero());\n\n        if self.is_zero() {\n            return Uint256::zero();\n        }\n\n        self.multiply_ratio(Decimal256::DECIMAL_FRACTIONAL, rhs.0)\n    }\n}\n\nimpl ops::Mul\u003cUint256\u003e for Decimal256 {\n    type Output = Uint256;\n\n    fn mul(self, rhs: Uint256) -\u003e Self::Output {\n        rhs * self\n    }\n}\n\nimpl Uint256 {\n    /// returns self * nom / denom\n    pub fn multiply_ratio\u003cA: Into\u003cU256\u003e, B: Into\u003cU256\u003e\u003e(\u0026self, nom: A, denom: B) -\u003e Uint256 {\n        let nominator: U256 = nom.into();\n        let denominator: U256 = denom.into();\n        if denominator.is_zero() {\n            panic!(\"Denominator must not be zero\");\n        }\n\n        // TODO: minimize rounding that takes place (using gcd algorithm)\n        let val = self.0 * nominator / denominator;\n        Uint256::from(val)\n    }\n}\n\n/// Serializes as a base64 string\nimpl Serialize for Uint256 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Uint256 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cUint256, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Uint256Visitor)\n    }\n}\n\nstruct Uint256Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Uint256Visitor {\n    type Value = Uint256;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded integer\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match U256::from_dec_str(v) {\n            Ok(u) =\u003e Ok(Uint256(u)),\n            Err(_e) =\u003e Err(E::custom(format!(\"invalid Uint256 '{}'\", v))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::{from_slice, to_vec, StdResult};\n    use std::{\n        convert::TryInto,\n        ops::{Div, Mul},\n    };\n\n    #[test]\n    fn decimal_one() {\n        let value = Decimal256::one();\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL);\n    }\n\n    #[test]\n    fn decimal_zero() {\n        let value = Decimal256::zero();\n        assert_eq!(value.0, U256::zero());\n    }\n\n    #[test]\n    fn decimal_percent() {\n        let value = Decimal256::percent(50);\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL / 2.into());\n    }\n\n    #[test]\n    fn decimal_permille() {\n        let value = Decimal256::permille(125);\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL / 8.into());\n    }\n    #[test]\n    fn decimal_from_ratio_works() {\n        // 1.0\n        assert_eq!(Decimal256::from_ratio(1, 1), Decimal256::one());\n        assert_eq!(Decimal256::from_ratio(53, 53), Decimal256::one());\n        assert_eq!(Decimal256::from_ratio(125, 125), Decimal256::one());\n\n        // 1.5\n        assert_eq!(Decimal256::from_ratio(3, 2), Decimal256::percent(150));\n        assert_eq!(Decimal256::from_ratio(150, 100), Decimal256::percent(150));\n        assert_eq!(Decimal256::from_ratio(333, 222), Decimal256::percent(150));\n\n        // 0.125\n        assert_eq!(Decimal256::from_ratio(1, 8), Decimal256::permille(125));\n        assert_eq!(Decimal256::from_ratio(125, 1000), Decimal256::permille(125));\n\n        // 1/3 (result floored)\n        assert_eq!(\n            Decimal256::from_ratio(1, 3),\n            Decimal256(0_333_333_333_333_333_333u64.into())\n        );\n\n        // 2/3 (result floored)\n        assert_eq!(\n            Decimal256::from_ratio(2, 3),\n            Decimal256(0_666_666_666_666_666_666u64.into())\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn decimal_from_ratio_panics_for_zero_denominator() {\n        Decimal256::from_ratio(1, 0);\n    }\n\n    #[test]\n    fn decimal_from_str_works() {\n        // Integers\n        assert_eq!(Decimal256::from_str(\"\").unwrap(), Decimal256::percent(0));\n        assert_eq!(Decimal256::from_str(\"0\").unwrap(), Decimal256::percent(0));\n        assert_eq!(Decimal256::from_str(\"1\").unwrap(), Decimal256::percent(100));\n        assert_eq!(Decimal256::from_str(\"5\").unwrap(), Decimal256::percent(500));\n        assert_eq!(\n            Decimal256::from_str(\"42\").unwrap(),\n            Decimal256::percent(4200)\n        );\n        assert_eq!(Decimal256::from_str(\"000\").unwrap(), Decimal256::percent(0));\n        assert_eq!(\n            Decimal256::from_str(\"001\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"005\").unwrap(),\n            Decimal256::percent(500)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0042\").unwrap(),\n            Decimal256::percent(4200)\n        );\n\n        // Decimal256s\n        assert_eq!(\n            Decimal256::from_str(\"1.\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"1.0\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"1.5\").unwrap(),\n            Decimal256::percent(150)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0.5\").unwrap(),\n            Decimal256::percent(50)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0.123\").unwrap(),\n            Decimal256::permille(123)\n        );\n\n        assert_eq!(\n            Decimal256::from_str(\"40.00\").unwrap(),\n            Decimal256::percent(4000)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"04.00\").unwrap(),\n            Decimal256::percent(0400)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"00.40\").unwrap(),\n            Decimal256::percent(0040)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"00.04\").unwrap(),\n            Decimal256::percent(0004)\n        );\n\n        // Can handle 18 fractional digits\n        assert_eq!(\n            Decimal256::from_str(\"7.123456789012345678\").unwrap(),\n            Decimal256(7123456789012345678u64.into())\n        );\n        assert_eq!(\n            Decimal256::from_str(\"7.999999999999999999\").unwrap(),\n            Decimal256(7999999999999999999u64.into())\n        );\n\n        // Works for documented max value\n        assert_eq!(\n            Decimal256::from_str(\n                \"115792089237316195423570985008687907853269984665640564039457.584007913129639935\"\n            )\n            .unwrap(),\n            Decimal256::MAX\n        );\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_whole_part() {\n        match Decimal256::from_str(\" \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"-1\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_fractinal_part() {\n        match Decimal256::from_str(\"1. \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.e\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.2e3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_more_than_18_fractional_digits() {\n        match Decimal256::from_str(\"7.1234567890123456789\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        // No special rules for trailing zeros. This could be changed but adds gas cost for the happy path.\n        match Decimal256::from_str(\"7.1230000000000000000\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_invalid_number_of_dots() {\n        match Decimal256::from_str(\"1.2.3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.2.3.4\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_integer_part() {\n        let _ =\n            Decimal256::from_str(\"115792089237316195423570985008687907853269984665640564039458\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_integer_part_with_decimal() {\n        let _ =\n            Decimal256::from_str(\"115792089237316195423570985008687907853269984665640564039458.0\");\n    }\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_decimal_part() {\n        let _ = Decimal256::from_str(\n            \"115792089237316195423570985008687907853269984665640564039457.584007913129639936\",\n        );\n    }\n\n    #[test]\n    fn decimal_is_zero_works() {\n        assert_eq!(Decimal256::zero().is_zero(), true);\n        assert_eq!(Decimal256::percent(0).is_zero(), true);\n        assert_eq!(Decimal256::permille(0).is_zero(), true);\n\n        assert_eq!(Decimal256::one().is_zero(), false);\n        assert_eq!(Decimal256::percent(123).is_zero(), false);\n        assert_eq!(Decimal256::permille(1234).is_zero(), false);\n    }\n\n    #[test]\n    fn decimal_add() {\n        let value = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(\n            value.0,\n            Decimal256::DECIMAL_FRACTIONAL * U256::from(3) / U256::from(2)\n        );\n    }\n\n    #[test]\n    fn decimal_sub() {\n        assert_eq!(\n            Decimal256::percent(50),\n            Decimal256::one() - Decimal256::percent(50)\n        );\n    }\n\n    #[test]\n    fn decimal_mul() {\n        assert_eq!(\n            Decimal256::percent(25),\n            Decimal256::percent(50) * Decimal256::percent(50)\n        );\n    }\n\n    #[test]\n    fn decimal_div() {\n        assert_eq!(\n            Decimal256::one() + Decimal256::one(),\n            Decimal256::percent(50) / Decimal256::percent(25)\n        );\n    }\n\n    #[test]\n    fn decimal_to_string() {\n        // Integers\n        assert_eq!(Decimal256::zero().to_string(), \"0\");\n        assert_eq!(Decimal256::one().to_string(), \"1\");\n        assert_eq!(Decimal256::percent(500).to_string(), \"5\");\n\n        // Decimal256s\n        assert_eq!(Decimal256::percent(125).to_string(), \"1.25\");\n        assert_eq!(Decimal256::percent(42638).to_string(), \"426.38\");\n        assert_eq!(Decimal256::percent(1).to_string(), \"0.01\");\n        assert_eq!(Decimal256::permille(987).to_string(), \"0.987\");\n\n        assert_eq!(Decimal256(1u64.into()).to_string(), \"0.000000000000000001\");\n        assert_eq!(Decimal256(10u64.into()).to_string(), \"0.00000000000000001\");\n        assert_eq!(Decimal256(100u64.into()).to_string(), \"0.0000000000000001\");\n        assert_eq!(Decimal256(1000u64.into()).to_string(), \"0.000000000000001\");\n        assert_eq!(Decimal256(10000u64.into()).to_string(), \"0.00000000000001\");\n        assert_eq!(Decimal256(100000u64.into()).to_string(), \"0.0000000000001\");\n        assert_eq!(Decimal256(1000000u64.into()).to_string(), \"0.000000000001\");\n        assert_eq!(Decimal256(10000000u64.into()).to_string(), \"0.00000000001\");\n        assert_eq!(Decimal256(100000000u64.into()).to_string(), \"0.0000000001\");\n        assert_eq!(Decimal256(1000000000u64.into()).to_string(), \"0.000000001\");\n        assert_eq!(Decimal256(10000000000u64.into()).to_string(), \"0.00000001\");\n        assert_eq!(Decimal256(100000000000u64.into()).to_string(), \"0.0000001\");\n        assert_eq!(Decimal256(10000000000000u64.into()).to_string(), \"0.00001\");\n        assert_eq!(Decimal256(100000000000000u64.into()).to_string(), \"0.0001\");\n        assert_eq!(Decimal256(1000000000000000u64.into()).to_string(), \"0.001\");\n        assert_eq!(Decimal256(10000000000000000u64.into()).to_string(), \"0.01\");\n        assert_eq!(Decimal256(100000000000000000u64.into()).to_string(), \"0.1\");\n    }\n\n    #[test]\n    fn decimal_serialize() {\n        assert_eq!(to_vec(\u0026Decimal256::zero()).unwrap(), br#\"\"0\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::one()).unwrap(), br#\"\"1\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(8)).unwrap(), br#\"\"0.08\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(87)).unwrap(), br#\"\"0.87\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(876)).unwrap(), br#\"\"8.76\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(8765)).unwrap(), br#\"\"87.65\"\"#);\n    }\n\n    #[test]\n    fn decimal_deserialize() {\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0\"\"#).unwrap(),\n            Decimal256::zero()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"1\"\"#).unwrap(),\n            Decimal256::one()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"000\"\"#).unwrap(),\n            Decimal256::zero()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"001\"\"#).unwrap(),\n            Decimal256::one()\n        );\n\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0.08\"\"#).unwrap(),\n            Decimal256::percent(8)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0.87\"\"#).unwrap(),\n            Decimal256::percent(87)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"8.76\"\"#).unwrap(),\n            Decimal256::percent(876)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"87.65\"\"#).unwrap(),\n            Decimal256::percent(8765)\n        );\n    }\n\n    #[test]\n    fn div_test() {\n        let a: Uint256 = 100u64.into();\n        let b: Uint256 = 2u64.into();\n        let c = a.div(b);\n        assert_eq!(c, 50u64.into());\n    }\n    #[test]\n    fn to_and_from_uint256() {\n        let a: Uint256 = 12345u64.into();\n        assert_eq!(U256::from(12345), a.0);\n        assert_eq!(\"12345\", a.to_string());\n\n        let a: Uint256 = \"34567\".try_into().unwrap();\n        assert_eq!(U256::from(34567), a.0);\n        assert_eq!(\"34567\", a.to_string());\n\n        let a: StdResult\u003cUint256\u003e = \"1.23\".try_into();\n        assert!(a.is_err());\n    }\n\n    #[test]\n    fn uint256_is_zero_works() {\n        assert_eq!(Uint256::zero().is_zero(), true);\n        assert_eq!(Uint256::from(0u64).is_zero(), true);\n\n        assert_eq!(Uint256::from(1u64).is_zero(), false);\n        assert_eq!(Uint256::from(123u64).is_zero(), false);\n    }\n\n    #[test]\n    fn uint256_json() {\n        let orig = Uint256::from(1234567890987654321u64);\n        let serialized = to_vec(\u0026orig).unwrap();\n        assert_eq!(serialized.as_slice(), b\"\\\"1234567890987654321\\\"\");\n        let parsed: Uint256 = from_slice(\u0026serialized).unwrap();\n        assert_eq!(parsed, orig);\n    }\n\n    #[test]\n    fn uint256_compare() {\n        let a = Uint256::from(12345u64);\n        let b = Uint256::from(23456u64);\n\n        assert!(a \u003c b);\n        assert!(b \u003e a);\n        assert_eq!(a, Uint256::from(12345u64));\n    }\n\n    #[test]\n    fn uint256_math() {\n        let a = Uint256::from(12345u64);\n        let b = Uint256::from(23456u64);\n\n        // test + and - for valid values\n        assert_eq!(a + b, Uint256::from(35801u64));\n        assert_eq!(b - a, Uint256::from(11111u64));\n\n        // test +=\n        let mut c = Uint256::from(300000u64);\n        c += b;\n        assert_eq!(c, Uint256::from(323456u64));\n    }\n    #[test]\n    #[should_panic]\n    fn uint256_math_sub_underflow() {\n        let _ = Uint256::from(12345u64) - Uint256::from(23456u64);\n    }\n\n    #[test]\n    #[should_panic]\n    fn uint256_math_overflow_panics() {\n        // almost_max is 2^256 - 10\n        let almost_max = Uint256::from(U256([\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n        ]));\n        let _ = almost_max + Uint256::from(12u64);\n    }\n\n    #[test]\n    // in this test the Decimal256 is on the right\n    fn uint256_decimal_multiply() {\n        // a*b\n        let left = Uint256::from(300u64);\n        let right = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(left * right, Uint256::from(450u64));\n\n        // a*0\n        let left = Uint256::from(300u64);\n        let right = Decimal256::zero();\n        assert_eq!(left * right, Uint256::from(0u64));\n\n        // 0*a\n        let left = Uint256::zero();\n        let right = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(left * right, Uint256::zero());\n    }\n\n    #[test]\n    fn u256_multiply_ratio_works() {\n        let base = Uint256::from(500u64);\n\n        // factor 1/1\n        assert_eq!(base.multiply_ratio(1, 1), Uint256::from(500u64));\n        assert_eq!(base.multiply_ratio(3, 3), Uint256::from(500u64));\n        assert_eq!(base.multiply_ratio(654321, 654321), Uint256::from(500u64));\n\n        // factor 3/2\n        assert_eq!(base.multiply_ratio(3, 2), Uint256::from(750u64));\n        assert_eq!(base.multiply_ratio(333333, 222222), Uint256::from(750u64));\n\n        // factor 2/3 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(2, 3), Uint256::from(333u64));\n        assert_eq!(base.multiply_ratio(222222, 333333), Uint256::from(333u64));\n\n        // factor 5/6 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(5, 6), Uint256::from(416u64));\n        assert_eq!(base.multiply_ratio(100, 120), Uint256::from(416u64));\n    }\n\n    #[test]\n    fn u256_from_u128() {\n        assert_eq!(Uint256::from(100u64), Uint256::from(100u128));\n        let num = Uint256::from(1_000_000_000_000_000_000_000_000u128);\n        assert_eq!(num.to_string(), \"1000000000000000000000000\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn u256_multiply_ratio_panics_for_zero_denominator() {\n        Uint256::from(500u64).multiply_ratio(1, 0);\n    }\n\n    #[test]\n    fn u256_zero_one() {\n        assert_eq!(Uint256::zero().0, U256::zero());\n        assert_eq!(Uint256::one().0, U256::one());\n    }\n\n    #[test]\n    fn u256_into_u128() {\n        let val: u128 = Uint256::from(1234556700000000000999u128).into();\n        assert_eq!(val, 1234556700000000000999u128);\n    }\n\n    #[test]\n    #[should_panic]\n    fn u256_into_u128_panics_for_overflow() {\n        let _: u128 = Uint256::from_str(\"2134982317498312749832174923184732198471983247\")\n            .unwrap()\n            .into();\n    }\n\n    #[test]\n    // in this test the Decimal256 is on the left\n    fn decimal_uint256_multiply() {\n        // a*b\n        let left = Decimal256::one() + Decimal256::percent(50); // 1.5\n        let right = Uint256::from(300u64);\n        assert_eq!(left * right, Uint256::from(450u64));\n\n        // 0*a\n        let left = Decimal256::zero();\n        let right = Uint256::from(300u64);\n        assert_eq!(left * right, Uint256::from(0u64));\n\n        // a*0\n        let left = Decimal256::one() + Decimal256::percent(50); // 1.5\n        let right = Uint256::from(0u64);\n        assert_eq!(left * right, Uint256::from(0u64));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[583998,583840],"length":1,"stats":{"Line":1},"fn_name":"serialize\u003c\u0026mut serde_json_wasm::ser::Serializer\u003e"},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[584064],"length":1,"stats":{"Line":1},"fn_name":"deserialize\u003c\u0026mut serde_json_wasm::de::Deserializer\u003e"},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[584935,584160],"length":1,"stats":{"Line":1},"fn_name":"visit_str\u003cserde_json_wasm::de::errors::Error\u003e"},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[590110,589952],"length":1,"stats":{"Line":1},"fn_name":"serialize\u003c\u0026mut serde_json_wasm::ser::Serializer\u003e"},{"line":419,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[590176],"length":1,"stats":{"Line":1},"fn_name":"deserialize\u003c\u0026mut serde_json_wasm::de::Deserializer\u003e"},{"line":429,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[590272],"length":1,"stats":{"Line":1},"fn_name":"visit_str\u003cserde_json_wasm::de::errors::Error\u003e"},{"line":446,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[464480,464512,464485],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":464,"address":[464519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[464529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[464704,464677,464672],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":470,"address":[464711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[464721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[464885,464912,464880],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":476,"address":[464919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[464934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[465216,465189,465184],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":482,"address":[465223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[465238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[465488,465520,465493],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":488,"address":[465527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[465727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[465927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[466127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[466335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[466543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[466733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[466923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[467223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[467113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[467136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[467482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[467372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[467395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[467653,467648,467680],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":521,"address":[467744,467717,467712],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":523,"address":[467757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[467993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[468230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[468468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[468777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[468706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[468759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[468944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[469252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[469181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[469234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[469490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[469419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[469472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[469728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[469657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[469710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":546,"address":[469966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[469895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[469948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[470204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":551,"address":[470133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[470186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[470442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[470371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[470424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[470680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[470609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[470662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[470918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[470847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[470900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[471156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[471085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[471138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[471394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":572,"address":[471323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":573,"address":[471376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[471632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[471561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[471614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[471852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":580,"address":[471781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[471834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[472141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[472001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[472054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[472430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[472290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":591,"address":[472343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[472632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[472579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[472805,472832,474012,472800],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":606,"address":[472839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[473085,473993,472913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":608,"address":[473312,473974,472925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[473396,474043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":612,"address":[473616,473432,473955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":613,"address":[473852,473447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[474480,476288,474485,474512],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":619,"address":[474519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[476269,474601,474779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[474613,475012,476250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[476319,475096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":625,"address":[475132,475316,476231],"length":1,"stats":{"Line":2},"fn_name":null},{"line":626,"address":[475147,476212,475552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[475636,476395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":630,"address":[476193,475856,475672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":631,"address":[475687,476090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[477024,476992,476997,478204],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":637,"address":[477031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[477105,477277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":639,"address":[477311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[478166,477504,477117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[477588,478235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":646,"address":[477808,477624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":647,"address":[477848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":649,"address":[477639,478044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[479884,478704,478672,478677],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":655,"address":[478711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":656,"address":[478785,478957,479865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":657,"address":[479846,478797,479184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[479268,479915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":661,"address":[479827,479488,479304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":662,"address":[479724,479319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[480384,480352,480357],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":675,"address":[480437,480464,480432],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":681,"address":[480544,480517,480512],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":688,"address":[480592,480597,480624],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":689,"address":[480631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":690,"address":[480785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":691,"address":[480961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[481137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":694,"address":[481311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[481490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":699,"address":[481680,481712,481685],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":700,"address":[481719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":701,"address":[481937,481764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":703,"address":[481774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[482101,482128,482096],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":709,"address":[482201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":710,"address":[482135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":711,"address":[482150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[482357,482384,482352],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":717,"address":[482462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":718,"address":[482391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":719,"address":[482406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":724,"address":[482608,482613,482640],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":725,"address":[482752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[482647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":727,"address":[482687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[482928,482896,482901,489823],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":734,"address":[482941,489809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":735,"address":[483162,489793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":736,"address":[489777,483383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":739,"address":[483609,489761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[483835,489745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":741,"address":[484061,489729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[484287,489713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":744,"address":[489697,484513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":745,"address":[484803,489681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":746,"address":[485093,489662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[485383,489643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[489624,485673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[489605,485963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[486253,489586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":751,"address":[486543,489567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[486833,489548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":753,"address":[489529,487123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[489510,487413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":755,"address":[487708,489491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":756,"address":[489472,488003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":757,"address":[489453,488280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[488557,489434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[489415,488834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[489396,489111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[492013,490448,490480,490453],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":765,"address":[491999,490487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":766,"address":[490736,491983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[491967,490967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[491951,491203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":769,"address":[491935,491439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":770,"address":[491675,491919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":774,"address":[492181,492176,492208],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":775,"address":[492281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":776,"address":[492215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[492268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":779,"address":[492514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":780,"address":[492448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":781,"address":[492501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":783,"address":[492747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":784,"address":[492681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[492734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":787,"address":[492980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":788,"address":[492914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":789,"address":[492967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":792,"address":[493200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[493129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":794,"address":[493182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":796,"address":[493420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":797,"address":[493349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":798,"address":[493402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":800,"address":[493640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":801,"address":[493569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":802,"address":[493622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[493860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":805,"address":[493789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":806,"address":[493842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":811,"address":[494037,494064,494032],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":812,"address":[494071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":813,"address":[494086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":814,"address":[494101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":815,"address":[494231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[494416,495387,494448,494421],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":819,"address":[494455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[494470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":821,"address":[494635,495373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":823,"address":[494822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[494875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":825,"address":[495357,495043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":827,"address":[495233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":828,"address":[495266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":832,"address":[495477,495504,495472],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":833,"address":[495511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":834,"address":[495659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":836,"address":[495835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":837,"address":[496014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[496240,496213,496788,496208],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":842,"address":[496247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":843,"address":[496267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[496310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":845,"address":[496523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":846,"address":[496618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":850,"address":[496837,496864,496832],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":851,"address":[496871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[496886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[496901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[496962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":856,"address":[497023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":860,"address":[497189,497216,497184],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":861,"address":[497223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":862,"address":[497238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[497253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[497559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":869,"address":[497865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":870,"address":[497883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":871,"address":[497962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":875,"address":[498144,498149,498176],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":876,"address":[498180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":881,"address":[498272,498240,498245],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":883,"address":[498279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[498370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":894,"address":[498512,498485,498480],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":896,"address":[498519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":897,"address":[498534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":898,"address":[498591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":901,"address":[498897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":902,"address":[498915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":903,"address":[498928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":906,"address":[499251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":907,"address":[499264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":908,"address":[499324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":912,"address":[499696,499669,499664],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":913,"address":[499703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[499721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":917,"address":[499934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":918,"address":[500147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":921,"address":[500360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":922,"address":[500576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":925,"address":[500774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":926,"address":[500972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":929,"address":[501170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":930,"address":[501368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":934,"address":[501616,501589,502023,501584],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":935,"address":[501623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":936,"address":[501811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":937,"address":[502009,501816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":942,"address":[502064,502069,502096],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":947,"address":[502149,502144,502176],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":948,"address":[502183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[502344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":953,"address":[502549,502544,502576],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":954,"address":[502603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":955,"address":[502633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":960,"address":[502816,502789,502784],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":968,"address":[502896,502901,502928],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":970,"address":[502935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":971,"address":[502986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":972,"address":[503004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":975,"address":[503316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[503329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":977,"address":[503347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":980,"address":[503670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":981,"address":[503730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":982,"address":[503747],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":396,"coverable":441},{"path":["/","home","runner","work","sienna","sienna","libraries","lend-experimental","src","wad_ray_math.rs"],"content":"use crate::uint256::Uint256;\nuse bigint::U256;\nuse lazy_static::lazy_static;\nuse std::ops::{Add, Div, Mul};\nconst WAD: u128 = 1 * 10_u128.pow(18);\nconst halfWAD: u128 = WAD / 2;\n\nconst RAY: u128 = 1 * 10_u128.pow(27);\n\nconst halfRAY: u128 = RAY / 2;\n\nconst WAD_RAY_RATIO: u128 = 1 * 10_u128.pow(9);\n\n// U256 Constss\n\nlazy_static! {\n    static ref WAD_256: U256 = {\n        let ten = U256::from(10);\n        let wad_256 = ten.pow(U256::from(18));\n        wad_256\n    };\n    static ref HALF_WAD_256: U256 = {\n        let ten = U256::from(10);\n        let wad_256 = ten.pow(U256::from(18));\n        wad_256 / U256::from(2)\n    };\n    static ref RAY_256: U256 = {\n        let ten = U256::from(10);\n        let ray = ten.pow(U256::from(27));\n        ray\n    };\n    static ref HALF_RAY_256: U256 = {\n        let ten = U256::from(10);\n        let ray = ten.pow(U256::from(27));\n        ray / U256::from(2)\n    };\n    static ref WAD_RAY_RATIO_256: U256 = {\n        let ten = U256::from(10);\n        let wad_ray_ratio = ten.pow(U256::from(9));\n        wad_ray_ratio\n    };\n}\n\npub fn ray_256() -\u003e U256 {\n    *RAY_256\n}\n\npub fn wad_256() -\u003e U256 {\n    *WAD_256\n}\n\npub fn half_ray_256() -\u003e U256 {\n    *HALF_RAY_256\n}\npub fn half_wad_256() -\u003e U256 {\n    *HALF_WAD_256\n}\n// 128\npub fn ray() -\u003e u128 {\n    RAY\n}\n\npub fn wad() -\u003e u128 {\n    WAD\n}\n\npub fn half_ray() -\u003e u128 {\n    halfRAY\n}\n\npub fn half_wad() -\u003e u128 {\n    halfWAD\n}\nfn _ray_mul(a: u128, b: u128) -\u003e u128 {\n    halfRAY.add(a.mul(b)).div(RAY)\n}\nfn _ray_mul_256(a: U256, b: U256) -\u003e U256 {\n    HALF_RAY_256.add(a.mul(b)).div(*RAY_256)\n}\n\npub trait WadRayMathU256 {\n    fn wad_mul(\u0026self, b: U256) -\u003e U256;\n    fn wad_div(\u0026self, b: U256) -\u003e U256;\n    fn ray_mul(\u0026self, b: U256) -\u003e U256;\n    fn ray_div(\u0026self, b: U256) -\u003e U256;\n    fn ray_to_wad(\u0026self) -\u003e U256;\n    fn wad_to_ray(\u0026self) -\u003e U256;\n    fn ray_pow(\u0026mut self, n: U256) -\u003e U256;\n}\nimpl WadRayMathU256 for U256 {\n    fn wad_mul(\u0026self, b: U256) -\u003e U256 {\n        HALF_WAD_256.add(self.mul(b)).div(*WAD_256)\n    }\n    fn wad_div(\u0026self, b: U256) -\u003e U256 {\n        let half_b = b / U256::from(2);\n        half_b.add(self.mul(*WAD_256)).div(b)\n    }\n    fn ray_mul(\u0026self, b: U256) -\u003e U256 {\n        HALF_RAY_256.add(self.mul(b)).div(*RAY_256)\n    }\n\n    fn ray_div(\u0026self, b: U256) -\u003e U256 {\n        let half_b = b / U256::from(2);\n        half_b.add(self.mul(*RAY_256)).div(b)\n    }\n\n    fn ray_to_wad(\u0026self) -\u003e U256 {\n        let half_ratio = *WAD_RAY_RATIO_256 / U256::from(2);\n        half_ratio.add(*self).div(*WAD_RAY_RATIO_256)\n    }\n\n    fn wad_to_ray(\u0026self) -\u003e U256 {\n        self.mul(*WAD_RAY_RATIO_256)\n    }\n\n    fn ray_pow(\u0026mut self, mut n: U256) -\u003e U256 {\n        let mut z = if n % U256::from(2) != U256::from(0) {\n            *self\n        } else {\n            *RAY_256\n        };\n        n = n / U256::from(2);\n        while n != U256::from(0) {\n            *self = _ray_mul_256(*self, *self);\n            if n % U256::from(2) != U256::from(0) {\n                z = _ray_mul_256(z, *self);\n            }\n            n = n / U256::from(2);\n        }\n        z\n    }\n}\npub trait WadRayMath {\n    fn wad_mul(\u0026self, b: u128) -\u003e u128;\n\n    fn wad_div(\u0026self, b: u128) -\u003e u128;\n\n    fn ray_mul(\u0026self, b: u128) -\u003e u128;\n\n    fn ray_div(\u0026self, b: u128) -\u003e u128;\n\n    fn ray_to_wad(\u0026self) -\u003e u128;\n\n    fn wad_to_ray(\u0026self) -\u003e u128;\n\n    fn ray_pow(\u0026mut self, n: u128) -\u003e u128;\n}\n\nimpl WadRayMath for u128 {\n    fn wad_mul(\u0026self, b: u128) -\u003e u128 {\n        halfWAD.add(self.mul(b)).div(WAD)\n    }\n\n    fn wad_div(\u0026self, b: u128) -\u003e u128 {\n        let half_b = b / 2;\n        half_b.add(self.mul(WAD)).div(b)\n    }\n\n    fn ray_mul(\u0026self, b: u128) -\u003e u128 {\n        halfRAY.add(self.mul(b)).div(RAY)\n    }\n\n    fn ray_div(\u0026self, b: u128) -\u003e u128 {\n        let half_b = b / 2;\n        half_b.add(self.mul(RAY)).div(b)\n    }\n\n    fn ray_to_wad(\u0026self) -\u003e u128 {\n        let half_ratio = WAD_RAY_RATIO / 2;\n        half_ratio.add(self).div(WAD_RAY_RATIO)\n    }\n\n    fn wad_to_ray(\u0026self) -\u003e u128 {\n        self.mul(WAD_RAY_RATIO)\n    }\n\n    fn ray_pow(\u0026mut self, mut n: u128) -\u003e u128 {\n        let mut z = if n % 2 != 0 { *self } else { RAY };\n\n        n = n / 2;\n        while n != 0 {\n            *self = _ray_mul(*self, *self);\n            if n % 2 != 0 {\n                z = _ray_mul(z, *self);\n            }\n            n = n / 2;\n        }\n        z\n    }\n}\n\n#[cfg(test)]\nmod wad_ray_tests {\n    use super::*;\n    use bigint::U256;\n\n    #[test]\n    fn wad_mul_test() {\n        let res = 10_u128.pow(18).wad_mul(5);\n        assert_eq!(5, res);\n    }\n\n    #[test]\n    fn wad_div_test() {\n        let res = 10_u128.pow(18).wad_div(5);\n        assert_eq!(2 * 10_u128.pow(35), res);\n    }\n\n    #[test]\n    fn ray_mul_test() {\n        let res = 10_u128.pow(27).ray_mul(5);\n        assert_eq!(5, res);\n    }\n\n    #[test]\n    fn ray_div_test() {\n        let res = 10_u128.pow(5).ray_div(5);\n        assert_eq!(2 * 10_u128.pow(31), res);\n    }\n\n    #[test]\n    fn ray_to_wad_test() {\n        let res = 10_u128.pow(9).ray_to_wad();\n        assert_eq!(1, res);\n    }\n\n    #[test]\n    fn wad_to_ray_test() {\n        let res = 10_u128.pow(18).ray_pow(1_000_000_000_000);\n        assert_eq!(0, res);\n    }\n\n    #[test]\n    fn wad_mul_test_256() {\n        let ten = U256::from(10);\n        let res = ten.pow(U256::from(18)).wad_mul(U256::from(5));\n        assert_eq!(U256::from(5), res);\n    }\n\n    #[test]\n    fn wad_div_test_256() {\n        let ten = U256::from(10);\n        let res = ten.pow(U256::from(18)).wad_div(U256::from(5));\n        assert_eq!(U256::from(2) * ten.pow(U256::from(35)), res);\n    }\n\n    #[test]\n    fn ray_mul_test_256() {\n        let ten = U256::from(10);\n        let res = ten.pow(U256::from(27)).ray_mul(U256::from(5));\n        assert_eq!(U256::from(5), res);\n    }\n\n    #[test]\n    fn ray_div_test_256() {\n        let ten = U256::from(10);\n        let res = 10_u128.pow(5).ray_div(5);\n        assert_eq!(2 * 10_u128.pow(31), res);\n    }\n\n    #[test]\n    fn ray_to_wad_test_256() {\n        let ten = U256::from(10);\n        let res = ten.pow(U256::from(9)).ray_to_wad();\n        assert_eq!(U256::from(1), res);\n    }\n\n    #[test]\n    fn wad_to_ray_test_256() {\n        let ten = U256::from(10);\n        let res = ten\n            .pow(U256::from(18))\n            .ray_pow(U256::from(1000000000000_u64));\n        assert_eq!(U256::from(0), res);\n    }\n}\n","traces":[{"line":18,"address":[553825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[553841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[558289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[558305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[558391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[553073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[553089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[555313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[555329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[555415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[554017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[554033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[620272],"length":1,"stats":{"Line":1},"fn_name":"ray_256"},{"line":45,"address":[620285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[620352],"length":1,"stats":{"Line":0},"fn_name":"wad_256"},{"line":49,"address":[620365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[620432],"length":1,"stats":{"Line":0},"fn_name":"half_ray_256"},{"line":53,"address":[620445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[620512],"length":1,"stats":{"Line":0},"fn_name":"half_wad_256"},{"line":56,"address":[620525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[620592],"length":1,"stats":{"Line":0},"fn_name":"ray"},{"line":63,"address":[620608],"length":1,"stats":{"Line":0},"fn_name":"wad"},{"line":67,"address":[620624],"length":1,"stats":{"Line":0},"fn_name":"half_ray"},{"line":71,"address":[620640],"length":1,"stats":{"Line":0},"fn_name":"half_wad"},{"line":74,"address":[620656],"length":1,"stats":{"Line":1},"fn_name":"_ray_mul"},{"line":75,"address":[620680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[620800],"length":1,"stats":{"Line":1},"fn_name":"_ray_mul_256"},{"line":78,"address":[620827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[541029,541024,541056],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":199,"address":[541077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[541121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[541296,541264,541269],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":205,"address":[541317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[541375,541584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[541648,541616,541621],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":211,"address":[541669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[541713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[541856,541861,541888],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":217,"address":[541909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[541967,542176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[542208,542213,542240],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":223,"address":[542261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[542296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[542464,542432,542437],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":229,"address":[542485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[542534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[542704,542677,542672],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":235,"address":[542711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[542727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[542867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[543040,543045,543072],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":242,"address":[543079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[543095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[543235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[543552,543584,543557],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":249,"address":[543591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[543607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[543747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[543920,543925,543952],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":256,"address":[543959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[543989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[544047,544274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[544309,544336,544304],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":263,"address":[544343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[544359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[544472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[544661,544656,544688],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":270,"address":[544695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[544782,544711,544833],"length":1,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[544763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[544809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[544856],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":107,"coverable":122},{"path":["/","home","runner","work","sienna","sienna","libraries","linear-map","lib","lib.rs"],"content":"//! Minimal KV store that passes `serde_json_wasm` serialization\n\nuse std::mem::replace;\nuse cosmwasm_std::{StdResult, Api, HumanAddr, CanonicalAddr};\n\n/// Just a wrapped `Vec` with `get` and `insert` methods.\n///\n/// Acts as a KV map but serializes as an array of [K,V] pairs:\n/// * new keys are appended to the end, existing keys are updated in place\n/// * there is no check for keys being unique during deserialization\n/// * in case of duplicate keys, it's the 1st instance of a given key that \"counts\".\n///\n/// It's like this because `serde_json_wasm` doesn't serialize maps (`HashMap`, `BTreeMap`).\n/// This is true even in versions more recent than the default for SecretNetwork:\n/// the `serialize_map` method contains a single `unreachable!()` panic. It's not immediately\n/// obvious why this remains the case the case; perhaps iterating over of those is somehow more\n/// expensive on a blockchain? In any case, in the absence of gas benchmarks it's pointless\n/// to risk altering the default execution environment (of which `serde_json_wasm` is part),\n/// even though there's no obvious reason why that wouldn't work.\n#[derive(serde::Serialize,serde::Deserialize,Clone,Debug,PartialEq,schemars::JsonSchema)]\npub struct LinearMap\u003cK, V\u003e(pub Vec\u003c(K, V)\u003e);\n\nimpl \u003cK, V\u003e Default for LinearMap\u003cK, V\u003e {\n    fn default () -\u003e Self { Self(Vec::new()) }\n}\n\nimpl \u003cK: PartialEq, V\u003e LinearMap\u003cK, V\u003e {\n    pub fn new () -\u003e Self { Self(Vec::new()) }\n    pub fn get (\u0026self, key: \u0026K) -\u003e Option\u003c\u0026V\u003e {\n        for (k, v) in self.0.iter() {\n            if key == k {\n                return Some(v)\n            }\n        }\n        None\n    }\n    pub fn insert (\u0026mut self, key: K, value: V) -\u003e Option\u003cV\u003e {\n        let mut found = None;\n        for (i, (k, _)) in self.0.iter_mut().enumerate() {\n            if key == *k {\n                found = Some(i);\n                break\n            }\n        }\n        if let Some(index) = found {\n            Some(replace(\u0026mut self.0[index], (key, value)).1)\n        } else {\n            self.0.push((key, value));\n            None\n        }\n    }\n}\n\nimpl \u003cV: Copy\u003e LinearMap\u003cHumanAddr, V\u003e {\n    pub fn canonize \u003cA: Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cLinearMap\u003cCanonicalAddr, V\u003e\u003e {\n        let canonized: Result\u003cVec\u003c_\u003e,_\u003e = self.0.iter().map(\n            |(human, value)| match api.canonical_address(human) {\n                Ok(canon) =\u003e Ok((canon, *value)),\n                Err(e)    =\u003e Err(e)\n            }).collect();\n        Ok(LinearMap(canonized?))\n    }\n}\n\nimpl \u003cV: Copy\u003e LinearMap\u003cCanonicalAddr, V\u003e {\n    pub fn humanize \u003cA: Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cLinearMap\u003cHumanAddr, V\u003e\u003e {\n        let humanized: Result\u003cVec\u003c_\u003e,_\u003e = self.0.iter().map(\n            |(canon, value)| match api.human_address(canon) {\n                Ok(human) =\u003e Ok((human, *value)),\n                Err(e)    =\u003e Err(e)\n            }).collect();\n        Ok(LinearMap(humanized?))\n    }\n}\n","traces":[{"line":24,"address":[773456,773469],"length":1,"stats":{"Line":14},"fn_name":"default\u003ccosmwasm_std::addresses::HumanAddr,cosmwasm_std::math::Uint128\u003e"},{"line":29,"address":[1505728],"length":1,"stats":{"Line":2},"fn_name":"get\u003ccosmwasm_std::addresses::CanonicalAddr,cosmwasm_std::math::Uint128\u003e"},{"line":30,"address":[1505745,1505880,1505970],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[1505928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[1505963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[655417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[754372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[754573,754431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[754589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[754462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[754793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":30},{"path":["/","home","runner","work","sienna","sienna","libraries","migrate","lib","lib.rs"],"content":"use cosmwasm_std::{StdResult, StdError, HumanAddr};\nuse serde::{Serialize, Deserialize};\nuse schemars::JsonSchema;\n\n#[derive(Serialize, Deserialize, JsonSchema, PartialEq, Debug, Clone)]\npub enum ContractStatusLevel {\n    Operational,\n    Paused,\n    Migrating,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, PartialEq, Debug, Clone)]\npub struct ContractStatus {\n    pub level:       ContractStatusLevel,\n    pub reason:      String,\n    pub new_address: Option\u003cHumanAddr\u003e\n}\n\nimpl Default for ContractStatus {\n    fn default () -\u003e Self {\n        Self {\n            level:       ContractStatusLevel::Operational,\n            reason:      String::new(),\n            new_address: None\n        }\n    }\n}\n\nmacro_rules! migration_message {\n    (paused: $reason:expr) =\u003e { format!(\n         \"This contract has been paused. Reason: {}\",\n         \u0026$reason\n    ) };\n    (migration: $reason:expr, $new_address:expr) =\u003e { format!(\n         \"This contract is being migrated to {}, please use that address instead. Reason: {}\",\n         \u0026$new_address.unwrap_or(HumanAddr::default()),\n         \u0026$reason\n    ) };\n}\n\npub fn is_operational (status: \u0026ContractStatus) -\u003e StdResult\u003c()\u003e {\n    let ContractStatus { level, reason, new_address } = status;\n    match level {\n        ContractStatusLevel::Operational =\u003e Ok(()),\n        ContractStatusLevel::Paused =\u003e Err(StdError::GenericErr {\n            backtrace: None,\n            msg: migration_message!(paused: reason)\n        }),\n        ContractStatusLevel::Migrating =\u003e Err(StdError::GenericErr {\n            backtrace: None,\n            msg: migration_message!(migration: reason, new_address.clone())\n        }),\n    }\n}\n\npub fn can_set_status (\n    status:           \u0026ContractStatus,\n    new_status_level: \u0026ContractStatusLevel\n) -\u003e StdResult\u003c()\u003e {\n    let ContractStatus { level, reason, new_address } = status;\n    match level {\n        ContractStatusLevel::Operational =\u003e Ok(()),\n        ContractStatusLevel::Paused =\u003e Ok(()),\n        ContractStatusLevel::Migrating =\u003e match new_status_level {\n            // if already migrating, allow message and new_address to be updated\n            ContractStatusLevel::Migrating =\u003e Ok(()),\n            // but prevent reverting from migration status\n            _ =\u003e Err(StdError::GenericErr {\n                backtrace: None,\n                msg: migration_message!(migration: reason, new_address.clone())\n            })\n        }\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[1045422],"length":1,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[1045520,1046727],"length":1,"stats":{"Line":6},"fn_name":"is_operational"},{"line":42,"address":[1045545],"length":1,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[442324,441947,441933],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[1045668,1045593],"length":1,"stats":{"Line":12},"fn_name":null},{"line":45,"address":[442188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[441952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[441969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[442780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1045627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1045639,1046057,1046667,1046742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[443168,444029],"length":1,"stats":{"Line":0},"fn_name":"can_set_status"},{"line":60,"address":[443206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[443299,443313,443330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[443254,443306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[443323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[443383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[443288,443376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[443839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[443340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[443388,443352,443985,444044],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":22},{"path":["/","home","runner","work","sienna","sienna","libraries","schedule","bin","cli.rs"],"content":"use serde::Deserialize;\nuse sienna_schedule::{*, vesting::*, validate::*};\n\nuse std::{path::Path, fs::read_to_string};\nuse serde_json_wasm::from_str;\n\nuse clap::{App, Arg};\n\nfn main () -\u003e Result\u003c(), std::io::Error\u003e {\n    let mut app = App::new(\"sienna_schedule\")\n        .version(\"1.0\")\n        .author(\"Adam A. \u003cadam@hack.bg\u003e\")\n        .about(\"Converts a schedule from JSON to Markdown, materializing all portions\")\n        .arg(Arg::new(\"PATH\")\n            .default_value(\"../../settings/schedule.json\"));\n\n    let matches = \u0026app.clone().get_matches();\n    match matches.value_of(\"PATH\") {\n        Some(path) =\u003e {\n            println!(\"\\n# Schedule\");\n            println!(\"\\n(Generated from schedule.json)\\n\");\n            let schedule = get_schedule(path).unwrap();\n            println!(\"Internal representation:\\n```\\n{:#?}\\n```\", \u0026schedule);\n            schedule.validate().unwrap();\n            for pool in schedule.pools.iter() {\n                println!(\"\\n## Pool: *{}*\", \u0026pool.name);\n                for account in pool.accounts.iter() {\n                    println!(\"\\n### Account: *{}*\\n\", \u0026account.name);\n                    println!(\"* Amount: **{} attoSIENNA**\", \u0026account.amount);\n                    println!(\"* Cliff: **{} attoSIENNA**\", \u0026account.cliff);\n                    println!(\"* Portion size: **{} attoSIENNA**\", \u0026account.portion_size());\n                    println!(\"* Portion count: **{}**\\n\", \u0026account.portion_count());\n                    let mut portion = if account.cliff \u003e cosmwasm_std::Uint128::zero() { -1 } else { 0 };\n                    let mut balance = 0u128;\n                    println!(\"|portion #|day|unlocked amount (attoSIENNA)|\");\n                    println!(\"|:-:|:-:|--:|\");\n                    for t in account.start_at..account.end()+1 {\n                        let new_balance = account.unlocked(t, \u0026account.address);\n                        if new_balance != balance {\n                            portion += 1;\n                            balance = new_balance;\n                            println!(\"|{:\u003e7}|{:\u003e7}|{:\u003e26}|\",\n                                if portion == 0 { \"cliff\".to_string() } else { portion.to_string() },\n                                t / 86400,\n                                balance\n                            );\n                        }\n                    }\n                }\n            }\n        },\n        None =\u003e {\n            \u0026app.print_long_help();\n        }\n    };\n\n    Ok(())\n\n}\n\nfn get_schedule (path: \u0026str) -\u003e Result\u003cSchedule\u003cHumanAddr\u003e, serde_json_wasm::de::Error\u003e {\n    from_str(\u0026read_to_string(Path::new(path)).unwrap())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","libraries","schedule","lib","canon.rs"],"content":"//! `HumanAddr`\u003c-\u003e`CanonicalAddr` conversion for `Schedule`, `Pool`, and `Account`.\n\nuse crate::{Schedule, Pool, Account};\nuse cosmwasm_std::{Api, CanonicalAddr, HumanAddr, StdResult};\n\npub trait Humanize\u003cT\u003e {\n    fn humanize \u003cA: Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cT\u003e;\n}\nimpl\u003cT: Humanize\u003cU\u003e, U\u003e Humanize\u003cVec\u003cU\u003e\u003e for Vec\u003cT\u003e {\n    fn humanize \u003cA: Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cVec\u003cU\u003e\u003e {\n        self.iter().map(|x|x.humanize(api)).collect()\n    }\n}\n\npub trait Canonize\u003cT\u003e {\n    fn canonize \u003cA: Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cT\u003e;\n}\nimpl\u003cT: Canonize\u003cU\u003e, U\u003e Canonize\u003cVec\u003cU\u003e\u003e for Vec\u003cT\u003e {\n    fn canonize \u003cA: Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cVec\u003cU\u003e\u003e {\n        self.iter().map(|x|x.canonize(api)).collect()\n    }\n}\n\nimpl Humanize\u003cSchedule\u003cHumanAddr\u003e\u003e for Schedule\u003cCanonicalAddr\u003e {\n    fn humanize \u003cA:Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cSchedule\u003cHumanAddr\u003e\u003e {\n        Ok(Schedule { total: self.total, pools: self.pools.humanize(api) ? })\n    }\n}\nimpl Humanize\u003cPool\u003cHumanAddr\u003e\u003e for Pool\u003cCanonicalAddr\u003e {\n    fn humanize \u003cA:Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cPool\u003cHumanAddr\u003e\u003e {\n        let accounts = self.accounts.humanize(api)?;\n        let \u0026Pool { total, partial, .. } = self;\n        Ok(Pool { name: self.name.clone(), total, partial, accounts })\n    }\n}\nimpl Humanize\u003cAccount\u003cHumanAddr\u003e\u003e for Account\u003cCanonicalAddr\u003e {\n    fn humanize \u003cA:Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cAccount\u003cHumanAddr\u003e\u003e {\n        let address = api.human_address(\u0026self.address)?;\n        let \u0026Account { amount, cliff, start_at, interval, duration, .. } = self;\n        let name = self.name.clone();\n        Ok(Account { name, amount, cliff, start_at, interval, duration, address })\n    }\n}\n\nimpl Canonize\u003cSchedule\u003cCanonicalAddr\u003e\u003e for Schedule\u003cHumanAddr\u003e {\n    fn canonize \u003cA:Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cSchedule\u003cCanonicalAddr\u003e\u003e {\n        Ok(Schedule { total: self.total, pools: self.pools.canonize(api)? })\n    }\n}\nimpl Canonize\u003cPool\u003cCanonicalAddr\u003e\u003e for Pool\u003cHumanAddr\u003e {\n    fn canonize \u003cA:Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cPool\u003cCanonicalAddr\u003e\u003e {\n        let accounts = self.accounts.canonize(api)?;\n        let \u0026Pool { total, partial, .. } = self;\n        Ok(Pool { name: self.name.clone(), total, partial, accounts })\n    }\n}\nimpl Canonize\u003cAccount\u003cCanonicalAddr\u003e\u003e for Account\u003cHumanAddr\u003e {\n    fn canonize \u003cA: Api\u003e (\u0026self, api: \u0026A) -\u003e StdResult\u003cAccount\u003cCanonicalAddr\u003e\u003e {\n        let address = api.canonical_address(\u0026self.address)?;\n        let \u0026Account { amount, cliff, start_at, interval, duration, .. } = self;\n        let name = self.name.clone();\n        Ok(Account { name, amount, cliff, start_at, interval, duration, address })\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":11,"address":[833856,833827,833792,833891],"length":1,"stats":{"Line":14},"fn_name":"{{closure}}\u003csienna_schedule::Account\u003ccosmwasm_std::addresses::CanonicalAddr\u003e,sienna_schedule::Account\u003ccosmwasm_std::addresses::HumanAddr\u003e,cosmwasm_std::mock::MockApi\u003e"},{"line":19,"address":[902368,902224],"length":1,"stats":{"Line":11},"fn_name":"canonize\u003csienna_schedule::Account\u003ccosmwasm_std::addresses::HumanAddr\u003e,sienna_schedule::Account\u003ccosmwasm_std::addresses::CanonicalAddr\u003e,cosmwasm_std::mock::MockApi\u003e"},{"line":20,"address":[833763,833728,833699,833664],"length":1,"stats":{"Line":23},"fn_name":"{{closure}}\u003csienna_schedule::Pool\u003ccosmwasm_std::addresses::HumanAddr\u003e,sienna_schedule::Pool\u003ccosmwasm_std::addresses::CanonicalAddr\u003e,cosmwasm_std::mock::MockApi\u003e"},{"line":25,"address":[740448],"length":1,"stats":{"Line":2},"fn_name":"humanize\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":26,"address":[740693,740481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[738406,737888],"length":1,"stats":{"Line":2},"fn_name":"humanize\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":31,"address":[738098,737926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[739294],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[739453],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[740816],"length":1,"stats":{"Line":7},"fn_name":"canonize\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":47,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":51,"address":[738966,738448],"length":1,"stats":{"Line":4},"fn_name":"canonize\u003ccosmwasm_std::mock::MockApi\u003e"},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","home","runner","work","sienna","sienna","libraries","schedule","lib","errors.rs"],"content":"//! Error definitions\n\n/// Create an error result\n#[macro_export] macro_rules! Error {\n    ($msg:expr) =\u003e {\n        Err(cosmwasm_std::StdError::GenericErr {\n            msg: $msg.to_string(),\n            backtrace: None //Some(snafu::Backtrace::generate())\n        })\n    };\n}\n\n/// `impl` error methods on one or more structs\n#[macro_export] macro_rules! define_errors {\n    ($(\n        $Struct:ident $(\u003c$G:tt$(:$GG:tt)?\u003e)? { $(\n            $name:ident\n            ($(\u0026$self:ident,)? $($arg:ident : $type:ty),*)\n            { $format:literal $(, $var:expr)* }\n        )* }\n    )*) =\u003e {\n        $( impl $(\u003c$G$(:$GG)?\u003e)? $Struct $(\u003c$G\u003e)? { $(\n            #[doc=$format]\n            pub fn $name\u003cT\u003e ($(\u0026$self,)? $($arg : $type),*) -\u003e cosmwasm_std::StdResult\u003cT\u003e {\n                Error!(format!($format $(, $var)*))\n            }\n        )* } )*\n    }\n}\n\nuse crate::{Schedule, Pool, Account};\ndefine_errors!(\n    Schedule\u003cA:Clone\u003e {\n        err_total (\u0026self,) {\n            \"schedule: pools add up to {}, expected {}\",\n            \u0026self.subtotal(), \u0026self.total\n        }\n        err_pool_not_found (\u0026self, name: \u0026str) {\n            \"schedule: pool {} not found\",\n            \u0026name\n        }\n    }\n    Pool\u003cA:Clone\u003e {\n        err_total (\u0026self,) {\n            \"pool {}: accounts add up to {}, expected {}\",\n            \u0026self.name, \u0026self.subtotal(), \u0026self.total\n        }\n        err_pool_full (\u0026self,) {\n            \"pool {}: can't add any more accounts to this pool\",\n            \u0026self.name\n        }\n        err_account_too_big (\u0026self, account: \u0026Account\u003cA\u003e) {\n            \"pool {}: account ({}) \u003e unallocated funds in pool ({})\",\n            \u0026self.name,\n            account.amount.u128(),\n            self.unallocated()\n        }\n    }\n    Account\u003cA:Clone\u003e {\n        err_empty (\u0026self,) {\n            \"account {}: amount must be \u003e0\",\n            \u0026self.name\n        }\n        err_cliff_too_big (\u0026self,) {\n            \"account {}: cliff ({}) \u003e total ({})\",\n            \u0026self.name,\n            \u0026self.cliff,\n            \u0026self.amount\n        }\n        err_does_not_add_up (\u0026self,) {\n            \"account {}: cliff + portions + remainder don't add up to amount\",\n            \u0026self.name\n        }\n    }\n);\n","traces":[{"line":24,"address":[484672,485376,483616,486528,486923,484161,488011,486484,485334,484624,485808,487579,486960,485771,487616,484208],"length":1,"stats":{"Line":9},"fn_name":"err_total\u003ccosmwasm_std::addresses::HumanAddr,()\u003e"},{"line":25,"address":[487023,485408,487648,484255,485922,483704,486560,484772],"length":1,"stats":{"Line":10},"fn_name":null},{"line":36,"address":[701334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[484242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[629478,630182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[485400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[695251,694531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[485867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[485901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[486552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[670985,670329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[486996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[487011],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[487640],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","runner","work","sienna","sienna","libraries","schedule","lib","lib.rs"],"content":"/// # SIENNA/Hack.bg Schedule v2.0\n///\n/// ## Conceptual model\n/// * `Schedule`: the root object.\n///   * Has a `total`.\n///   * Contains `Pool`s adding up to that total.\n/// * `Pool`: subdivision of schedule,\n///   * Contains `Account`s.\n///   * If `partial` is true, `Account`s can be at runtime, up to the total.\n///   * Otherwise, requires `Account`s to add up to exactly the total in order to pass validation.\n/// * `Account`: subdivision of a `Pool` (corresponds to `Channel`+`Periodic` from v1)\n\nuse schemars::JsonSchema;\nuse serde::{Serialize, Deserialize};\n//use snafu::GenerateBacktrace;\npub use cosmwasm_std::{Uint128, HumanAddr, StdResult, StdError};\n\npub mod errors; pub use errors::*;\npub mod canon; pub use canon::*;\npub mod validate;\npub mod vesting;\npub mod mutate;\n\n/// Unit of time\npub type Seconds = u64;\n\n/// Unit of account\npub const ONE_SIENNA: u128 = 1000000000000000000u128;\n\n/// The most basic return type that may contain an error\npub type UsuallyOk = StdResult\u003c()\u003e;\n\n/// Contains `Pool`s that must add up to `total`.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Schedule\u003cA:Clone\u003e {\n    pub total:   Uint128,\n    pub pools:   Vec\u003cPool\u003cA\u003e\u003e,\n}\nimpl\u003cA:Clone\u003e Schedule\u003cA\u003e {\n    pub fn new (pools: \u0026[Pool\u003cA\u003e]) -\u003e Self {\n        let mut s = Schedule { total: Uint128::zero(), pools: pools.to_vec() };\n        s.total = Uint128::from(s.subtotal());\n        s\n    }\n    /// Sum of all contained pools (expected to equal `self.total`)\n    pub fn subtotal (\u0026self) -\u003e u128 {\n        self.pools.iter().fold(0, |total, pool| total + pool.total.u128())\n    }\n}\n\n/// Subdivision of `Schedule`, contains `Account`s, may be `partial`.\n/// If `partial == false`, they must add up to `total`.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Pool\u003cA\u003e {\n    /// if `true`, adding new `Account`s is allowed at runtime, up to `total`.\n    /// otherwise, accounts must add up to `total` at creation.\n    pub partial:  bool,\n    pub name:     String,\n    pub total:    Uint128,\n    pub accounts: Vec\u003cAccount\u003cA\u003e\u003e,\n}\nimpl\u003cA:Clone\u003e Pool\u003cA\u003e {\n    pub fn partial (name: \u0026str, total: u128, accounts: \u0026[Account\u003cA\u003e]) -\u003e Self {\n        let accounts = accounts.to_vec();\n        Pool { partial: true, name: name.into(), total: total.into(), accounts }\n    }\n    pub fn full (name: \u0026str, accounts: \u0026[Account\u003cA\u003e]) -\u003e Self {\n        let accounts = accounts.to_vec();\n        let mut total = Uint128::zero();\n        for \u0026Account{amount,..} in accounts.iter() { total += amount }\n        Pool { partial: false, name: name.into(), total, accounts }\n    }\n    /// Sum of all contained accounts - expected to equal total\n    pub fn subtotal (\u0026self) -\u003e u128 {\n        self.accounts.iter().fold(0, |total, acc| total + acc.amount.u128())\n    }\n    /// Remaining unallocated funds\n    pub fn unallocated (\u0026self) -\u003e u128 {\n        self.total.u128() - self.subtotal()\n    }\n}\n\n/// Individual vesting config.\n/// Immediate release is thought of as a special case of vesting where:\n/// * `head == total`\n/// * `duration == interval == 0`,\n/// * only `head_allocations` is considered.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Account\u003cA\u003e {\n    /// Human-readable name\n    pub name:     String,\n    /// Recipient address\n    pub address:  A,\n    /// Funds that this account will release\n    pub amount:   Uint128,\n    /// If `\u003e 0`, releases this much money the first time, pushing back the regular portions\n    pub cliff:    Uint128,\n    /// How many seconds after contract launch to begin vesting\n    pub start_at: Seconds,\n    /// How many seconds to wait between portions\n    pub interval: Seconds,\n    /// If `\u003e 0`, vesting stops after this much seconds regardless of how much is left of `total`.\n    pub duration: Seconds,\n}\nimpl\u003cA:Clone\u003e Account\u003cA\u003e {\n    pub fn immediate (name: \u0026str, address: \u0026A, amount: u128) -\u003e Self {\n        Self {\n            name:     name.into(),\n            address:  address.clone(),\n            amount:   amount.into(),\n            cliff:    0u128.into(),\n            start_at: 0,\n            interval: 0,\n            duration: 0\n        }\n    }\n    pub fn periodic (\n        name: \u0026str, address: \u0026A, amount: u128,\n        cliff: u128, start_at: Seconds, interval: Seconds, duration: Seconds\n    ) -\u003e Self {\n        Self {\n            name:    name.into(),\n            address: address.clone(),\n            amount:  amount.into(),\n            cliff:   cliff.into(),\n            start_at,\n            interval,\n            duration\n        }\n    }\n}\n","traces":[{"line":41,"address":[480832,481048],"length":1,"stats":{"Line":8},"fn_name":"new\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":42,"address":[480869],"length":1,"stats":{"Line":8},"fn_name":null},{"line":43,"address":[480945],"length":1,"stats":{"Line":8},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[481088],"length":1,"stats":{"Line":10},"fn_name":"subtotal\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":48,"address":[481200,481247,481097],"length":1,"stats":{"Line":24},"fn_name":"{{closure}}\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":65,"address":[481686,481360],"length":1,"stats":{"Line":2},"fn_name":"partial\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":66,"address":[481477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[481497,481665],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[482332,481760],"length":1,"stats":{"Line":2},"fn_name":"full\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[481855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[482198,482095],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[482384],"length":1,"stats":{"Line":7},"fn_name":"subtotal\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":77,"address":[482393,482543,482496],"length":1,"stats":{"Line":21},"fn_name":"{{closure}}\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":27,"coverable":28},{"path":["/","home","runner","work","sienna","sienna","libraries","schedule","lib","mutate.rs"],"content":"//! Methods to amend the schedule at runtime\n\nuse crate::{*, validate::Validation};\n\nimpl\u003cA: Clone\u003e Schedule\u003cA\u003e {\n    pub fn add_account (\u0026mut self, pool_name: \u0026str, account: Account\u003cA\u003e) -\u003e UsuallyOk {\n        for pool in self.pools.iter_mut() {\n            if pool.name == pool_name {\n                return pool.add_account(account)\n            }\n        }\n        self.err_pool_not_found(pool_name)\n    }\n}\nimpl\u003cA: Clone\u003e Pool\u003cA\u003e {\n    pub fn add_account (\u0026mut self, account: Account\u003cA\u003e) -\u003e UsuallyOk {\n        if !self.partial {\n            return self.err_pool_full()\n        }\n        if account.amount.u128() \u003e self.unallocated() {\n            return self.err_account_too_big(\u0026account)\n        }\n        account.validate()?;\n        self.accounts.push(account);\n        if self.unallocated() == 0 {\n            self.partial = false\n        }\n        self.validate()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #![allow(non_snake_case)]\n    use cosmwasm_std::HumanAddr;\n    use crate::{Schedule, Pool, Account};\n    #[test] fn test_add_to_full () {\n        let Alice = HumanAddr::from(\"Alice\");\n        let Bob   = HumanAddr::from(\"Bob\");\n        let mut P = Pool::full(\"P\", \u0026[Account::immediate(\"A\", \u0026Alice, 100)]);\n        assert_eq!(P.add_account(Account::immediate(\"B\", \u0026Bob, 100)),\n                   P.err_pool_full());\n    }\n    #[test] fn test_add_to_partial_becomes_full () {\n        let Alice = HumanAddr::from(\"Alice\");\n        let Bob   = HumanAddr::from(\"Bob\");\n        let Carol = HumanAddr::from(\"Carol\");\n        let mut P = Pool::partial(\"P\", 200, \u0026[Account::immediate(\"A\", \u0026Alice, 100)]);\n        assert_eq!(P.add_account(Account::immediate(\"B\", \u0026Bob, 200)),\n                   P.err_account_too_big(\u0026Account::immediate(\"B\", \u0026Bob, 200)));\n        assert_eq!(P.partial,\n                   true);\n        assert_eq!(P.add_account(Account::immediate(\"B\", \u0026Bob, 100)),\n                   Ok(()));\n        assert_eq!(P.partial,\n                   false);\n        assert_eq!(P.add_account(Account::immediate(\"C\", \u0026Carol, 1)),\n                   P.err_pool_full());\n    }\n    #[test] fn test_add_to_schedule () {\n        let Alice = HumanAddr::from(\"Alice\");\n        let Bob   = HumanAddr::from(\"Bob\");\n        let Carol = HumanAddr::from(\"Carol\");\n        let mut S = Schedule::new(\u0026[\n            Pool::partial(\"P1\", 100, \u0026[]),\n            Pool::full(\"P2\", \u0026[Account::immediate(\"A\", \u0026Alice, 100)]),\n        ]);\n        assert_eq!(S.add_account(\"P1\", Account::immediate(\"B\", \u0026Bob, 50)),\n                   Ok(()));\n        let A = Account::immediate(\"B\", \u0026Bob, 100);\n        assert_eq!(S.add_account(\"P1\", A.clone()),\n                   S.pools.get(0).unwrap().err_account_too_big(\u0026A));\n        assert_eq!(S.add_account(\"P1\", Account::immediate(\"C\", \u0026Carol, 50)),\n                   Ok(()));\n        assert_eq!(S.add_account(\"P1\", A.clone()),\n                   S.pools.get(0).unwrap().err_pool_full());\n        assert_eq!(S.add_account(\"P2\", A.clone()),\n                   S.pools.get(1).unwrap().err_pool_full());\n        assert_eq!(S.add_account(\"P3\", A.clone()),\n                   S.err_pool_not_found(\"P3\"));\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":37,"address":[529696,529728,530387,529701],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":38,"address":[529735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[529758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[529786,530352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[530314,530091,529992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[530076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[530592,530565,532298,530560],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":45,"address":[530599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[530622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[530653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[530684,532246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[530909,531071,532192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[530986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[531264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[532177,531404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[531651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[531793,531899,532149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[531884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[532592,532597,535594,532624],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":61,"address":[532631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[532657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[532688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[532972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[532719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[532773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[535453,533190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[533467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[535412,533529,533726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[533579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[533922,535397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[535369,534398,534215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[534265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[535341,534592,534758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[534642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[535313,534952,535045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[535002],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":51,"coverable":51},{"path":["/","home","runner","work","sienna","sienna","libraries","schedule","lib","validate.rs"],"content":"//! # Input validation\n//!\n//! The `Schedule`, `Pool`, and `Account` structs implement the `Validation` trait, which\n//! provides a `validate` method on top of the implicit schema validation provided by Serde.\n//!\n//! Unfortunately, `rustdoc` does not allow for the `impl`s that are defined\n//! in this module to be rendered on this doc page, because they implement\n//! `struct`s defined in another file.\n//!\n//! Documentation of the methods (and errors) defined in this file\n//! can be found in the documentation for those structs.\n\nuse crate::*;\n\n/// Trait for something that undergoes validation, returning `Ok` or an error.\npub trait Validation {\n    /// Default implementation is a no-op\n    fn validate (\u0026self) -\u003e UsuallyOk { Ok(()) }\n}\nimpl\u003cA:Validation\u003e Validation for Vec\u003cA\u003e {\n    fn validate (\u0026self) -\u003e UsuallyOk {\n        for item in self.iter() {\n            item.validate()?\n        }\n        Ok(())\n    }\n}\nimpl\u003cA:Clone\u003e Validation for Schedule\u003cA\u003e {\n    /// Schedule must contain valid pools that add up to the schedule total\n    fn validate (\u0026self) -\u003e UsuallyOk {\n        self.pools.validate()?;\n        if self.subtotal() != self.total.u128() {\n            return self.err_total()\n        }\n        Ok(())\n    }\n}\nimpl\u003cA:Clone\u003e Validation for Pool\u003cA\u003e {\n    fn validate (\u0026self) -\u003e UsuallyOk {\n        self.accounts.validate()?;\n        let invalid_total = if self.partial {\n            self.subtotal() \u003e self.total.u128()\n        } else {\n            self.subtotal() != self.total.u128()\n        };\n        if invalid_total { return self.err_total() }\n        Ok(())\n    }\n}\nimpl\u003cA:Clone\u003e Validation for Account\u003cA\u003e {\n    fn validate (\u0026self) -\u003e UsuallyOk {\n        if self.amount == Uint128::zero() {\n            return self.err_empty()\n        }\n        if self.cliff \u003e self.amount {\n            return self.err_cliff_too_big()\n        }\n        if self.amount.u128() != (\n            self.cliff.u128() +\n            self.portion_size() * self.portion_count() as u128 +\n            self.remainder()\n        ) {\n            return self.err_does_not_add_up()\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #![allow(non_snake_case)]\n    use cosmwasm_std::HumanAddr;\n    use crate::{Schedule, Pool, Account, validate::Validation};\n    #[test] fn test_amount_eq_zero () {\n        let A = Account::periodic(\"A\", \u0026HumanAddr::from(\"\"), 0, 0, 0, 0, 0);\n        assert_eq!(A.validate(),\n                   A.err_empty());\n        assert_eq!(Schedule::new(\u0026[Pool::full(\"P\", \u0026[A.clone()])]).validate(),\n                   A.err_empty());\n        assert_eq!(Schedule::new(\u0026[Pool::partial(\"P\", 0, \u0026[A.clone()])]).validate(),\n                   A.err_empty());\n        assert_eq!(Schedule::new(\u0026[Pool::partial(\"P\", 1, \u0026[A.clone()])]).validate(),\n                   A.err_empty());\n    }\n    #[test] fn test_cliff_gt_amount () {\n        let A = Account::periodic(\"A\", \u0026HumanAddr::from(\"\"), 1, 2, 0, 0, 0);\n        assert_eq!(A.validate(),\n                   A.err_cliff_too_big());\n        assert_eq!(Schedule::new(\u0026[Pool::full(\"P\", \u0026[A.clone()])]).validate(),\n                   A.err_cliff_too_big());\n        assert_eq!(Schedule::new(\u0026[Pool::partial(\"P\", 0, \u0026[A.clone()])]).validate(),\n                   A.err_cliff_too_big());\n        assert_eq!(Schedule::new(\u0026[Pool::partial(\"P\", 1, \u0026[A.clone()])]).validate(),\n                   A.err_cliff_too_big());\n    }\n    #[test] fn test_account_gt_pool () {\n        let A = Account::periodic(\"A\", \u0026HumanAddr::from(\"\"), 2, 0, 0, 0, 0);\n        let P = Pool{\n            partial:  false,\n            name:     \"P\".to_string(),\n            total:    1u128.into(),\n            accounts: vec![A.clone()],\n        };\n        let S = Schedule::new(\u0026[P.clone()]);\n        assert_eq!(A.validate(),\n                   Ok(()));\n        assert_eq!(S.validate(),\n                   P.err_total());\n        assert_eq!(Schedule::new(\u0026[Pool::partial(\"P\", 1, \u0026[A.clone()])]).validate(),\n                   P.err_total());\n    }\n    #[test] fn test_pools_lt_schedule () {\n        let S: Schedule\u003cHumanAddr\u003e = Schedule {\n            total: 1u128.into(),\n            pools: vec![]\n        };\n        assert_eq!(S.validate(),\n                   S.err_total());\n    }\n    #[test] fn test_pools_gt_schedule () {\n        let A = Account::periodic(\"A\", \u0026HumanAddr::from(\"\"), 2, 0, 0, 0, 0);\n        let S = Schedule {\n            total: 1u128.into(),\n            pools: vec![Pool::partial(\"P1\", 1, \u0026[]), Pool::full(\"P2\", \u0026[A])]\n        };\n        assert_eq!(S.validate(),\n                   S.err_total());\n    }\n}\n","traces":[{"line":21,"address":[524912,524528],"length":1,"stats":{"Line":14},"fn_name":"validate\u003csienna_schedule::Pool\u003ccosmwasm_std::addresses::HumanAddr\u003e\u003e"},{"line":22,"address":[525170,524950,524786,524566,524703,525087],"length":1,"stats":{"Line":26},"fn_name":null},{"line":23,"address":[524791,525175,524734,525118],"length":1,"stats":{"Line":13},"fn_name":null},{"line":25,"address":[525075,524691],"length":1,"stats":{"Line":13},"fn_name":null},{"line":30,"address":[475488],"length":1,"stats":{"Line":5},"fn_name":"validate\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":31,"address":[475596,475518],"length":1,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[475694,475579],"length":1,"stats":{"Line":10},"fn_name":null},{"line":33,"address":[475753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[475765],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[476160],"length":1,"stats":{"Line":7},"fn_name":null},{"line":47,"address":[476192],"length":1,"stats":{"Line":8},"fn_name":null},{"line":51,"address":[476224],"length":1,"stats":{"Line":5},"fn_name":"validate\u003ccosmwasm_std::addresses::HumanAddr\u003e"},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[476357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":74,"address":[512464,512432,512437,514823],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":75,"address":[512471,514809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[514768,512654,512616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[512639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[513174,514701,512854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[513159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[514634,513413,513747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[513732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[514320,514564,513986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[514305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[517704,515344,515312,515317],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":86,"address":[515351,517690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[515497,517649,515535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[515520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[515735,517582,516055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[516040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[516294,516628,517515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[516613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[516867,517445,517201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[517186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[518192,518224,520077,518197],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":97,"address":[518231,520063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[518363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[518399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[520092,518432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[518704,520006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[519978,518850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[519043,519950,519081],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[519066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[519883,519609,519275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[519594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[520861,520480,520512,520485],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":114,"address":[520528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[520543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[520825,520641,520606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[520626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[520949,520944,522088,520976],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":121,"address":[520983,522074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[521137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[522103,521170,522044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[521756,521794,522003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[521779],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":68,"coverable":69},{"path":["/","home","runner","work","sienna","sienna","libraries","schedule","lib","vesting.rs"],"content":"//! Core vesting logic\n\nuse crate::*;\n\npub trait Vesting\u003cA\u003e {\n    /// Get total amount unlocked for address `a` at time `t`.\n    fn unlocked (\u0026self, elapsed: Seconds, address: \u0026A) -\u003e u128;\n}\nimpl\u003cA:Clone+PartialEq\u003e Vesting\u003cA\u003e for Schedule\u003cA\u003e {\n    /// Sum of unlocked amounts for this address for all pools\n    fn unlocked (\u0026self, elapsed: Seconds, address: \u0026A) -\u003e u128 {\n        u128::min(\n            self.pools.iter().fold(0, |total, pool| total + pool.unlocked(elapsed, address)),\n            self.subtotal()\n        )\n    }\n}\nimpl\u003cA:Clone+PartialEq\u003e Vesting\u003cA\u003e for Pool\u003cA\u003e {\n    /// Sum of unlocked amounts for this address for all accounts in this pool\n    fn unlocked (\u0026self, elapsed: Seconds, address: \u0026A) -\u003e u128 {\n        u128::min(\n            self.accounts.iter().fold(0, |total, account| total + account.unlocked(elapsed, address)),\n            self.subtotal()\n        )\n    }\n}\nimpl\u003cA:Clone+PartialEq\u003e Vesting\u003cA\u003e for Account\u003cA\u003e {\n    /// Unlocked sum for this account at a point in time\n    fn unlocked (\u0026self, elapsed: Seconds, address: \u0026A) -\u003e u128 {\n        if *address != self.address { // if asking about someone else\n            0\n        } else if elapsed \u003c self.start_at { // if asking about a moment before the start\n            0\n        } else if elapsed \u003e= self.end() { // at the end the full amount must've been vested\n            self.amount.u128()\n        } else {\n            u128::min(\n                match self.most_recent_portion(elapsed) {\n                    Some(n) =\u003e self.cliff.u128() + (n as u128) * self.portion_size(),\n                    None =\u003e 0\n                },\n                self.amount.u128()\n            )\n        }\n    }\n}\nimpl\u003cA\u003e Account\u003cA\u003e {\n    /// Size of regular (non-cliff) portions.\n    pub fn portion_size (\u0026self) -\u003e u128 {\n        if self.portion_count() \u003e 0 {\n            self.amount_after_cliff() / self.portion_count() as u128\n        } else {\n            0\n        }\n    }\n    /// Amount to vest after the cliff\n    pub fn amount_after_cliff (\u0026self) -\u003e u128 {\n        assert!(self.amount \u003e= self.cliff);\n        self.amount.u128() - self.cliff.u128()\n    }\n    /// Number of non-cliff portions.\n    pub fn portion_count (\u0026self) -\u003e u64 {\n        if self.interval \u003e 0 {\n            (self.duration / self.interval) as u64\n        } else {\n            0\n        }\n    }\n    /// If `(amount-cliff)` doesn't divide evenly by `portion_size`,\n    /// the remainder is added to the last portion.\n    pub fn remainder (\u0026self) -\u003e u128 {\n        self.amount_after_cliff() - self.portion_size() * self.portion_count() as u128\n    }\n    /// Timestamp of last vesting (when remainder is received)\n    pub fn end (\u0026self) -\u003e Seconds {\n        self.start_at + self.duration\n    }\n    /// Time elapsed since start\n    pub fn elapsed (\u0026self, t: Seconds) -\u003e Option\u003cSeconds\u003e {\n        if t \u003e= self.start_at {\n            Some(t - self.start_at)\n        } else {\n            None\n        }\n    }\n    /// Most recent portion vested at time `t`\n    pub fn most_recent_portion (\u0026self, t: Seconds) -\u003e Option\u003cu64\u003e {\n        self.elapsed(t).map(|elapsed| u64::min(\n            elapsed / self.interval + match self.cliff.u128() { 0 =\u003e 1, _ =\u003e 0 },\n            self.portion_count()\n        ))\n    }\n    /// Whether a portion is unlocked at the exact moment specified\n    pub fn vests_at (\u0026self, t: Seconds) -\u003e bool {\n        match self.elapsed(t) {\n            Some(elapsed) =\u003e elapsed % self.interval == 0,\n            None =\u003e false\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #![allow(non_snake_case)]\n    use cosmwasm_std::HumanAddr;\n    use crate::{Schedule, Pool, Account, vesting::Vesting};\n    #[test] fn blank () {\n        // some imaginary people:\n        let Alice = HumanAddr::from(\"Alice\");\n        let Bob   = HumanAddr::from(\"Bob\");\n        // some empty, but valid schedules\n        for S in \u0026[\n            Schedule::new(\u0026[]),\n            Schedule::new(\u0026[ Pool::full(\"\", \u0026[]) ]),\n            Schedule::new(\u0026[ Pool::full(\"\", \u0026[ Account::immediate(\"\", \u0026Alice, 0) ]) ]),\n            Schedule::new(\u0026[ Pool::partial(\"\", 1, \u0026[ Account::immediate(\"\", \u0026Alice, 0) ]) ])\n        ] {\n          assert_eq!(S.unlocked(0, \u0026Alice), 0);\n          assert_eq!(S.unlocked(1, \u0026Alice), 0);\n          assert_eq!(S.unlocked(1001, \u0026Bob), 0);\n        }\n    }\n    #[test] fn vest_immediate () {\n        // a periodic `Account`...\n        let Alice = HumanAddr::from(\"Alice\");\n        let Bob   = HumanAddr::from(\"Bob\");\n        let A = Account::immediate(\"\", \u0026Alice, 100);\n        let P = Pool::full(\"\", \u0026[A.clone()]);\n        let S = Schedule::new(\u0026[P.clone()]);\n        for (l, r) in \u0026[\n            (A.amount.u128(),        100),\n            (A.cliff.u128(),           0),\n            (A.amount_after_cliff(), 100),\n            (A.start_at.into(),        0),\n            (A.interval.into(),        0),\n            (A.duration.into(),        0),\n            (A.portion_count().into(), 0),\n            (A.portion_size(),         0),\n            (A.remainder(),          100),\n        ] {\n            assert_eq!(l, r);\n        }\n        assert_eq!(100, P.total.u128());\n        assert_eq!(100, S.total.u128());\n        for t in 0..100 {\n            assert_eq!(100, S.unlocked(t, \u0026Alice));\n            assert_eq!(  0, S.unlocked(t, \u0026Bob));\n        }\n    }\n    #[test] fn vest_immediate_as_cliff () { // different way of expressing the same thing\n        // a periodic `Account`...\n        let Alice = HumanAddr::from(\"Alice\");\n        let Bob   = HumanAddr::from(\"Bob\");\n        let A = Account::periodic(\"\", \u0026Alice, 100, 100, 0, 0, 0);\n        let P = Pool::full(\"\", \u0026[A.clone()]);\n        let S = Schedule::new(\u0026[P.clone()]);\n        for (l, r) in \u0026[\n            (A.amount.u128(),        100),\n            (A.cliff.u128(),         100),\n            (A.amount_after_cliff(),   0),\n            (A.start_at.into(),        0),\n            (A.interval.into(),        0),\n            (A.duration.into(),        0),\n            (A.portion_count().into(), 0),\n            (A.portion_size(),         0),\n            (A.remainder(),            0),\n        ] {\n            assert_eq!(l, r);\n        }\n        assert_eq!(100, P.total.u128());\n        assert_eq!(100, S.total.u128());\n        for t in 0..100 {\n            assert_eq!(100, S.unlocked(t, \u0026Alice));\n            assert_eq!(  0, S.unlocked(t, \u0026Bob));\n        }\n    }\n    #[test] fn vest_periodic_with_cliff () {\n        let Alice = HumanAddr::from(\"Alice\");\n        let Bob = HumanAddr::from(\"Bob\");\n        let A = Account::periodic(\"\", \u0026Alice, 100, 42, 7, 12, 70);\n        let P = Pool::full(\"\", \u0026[A.clone()]);\n        let S = Schedule::new(\u0026[P.clone()]);\n        assert_eq!(100, S.total.u128());\n        assert_eq!(100, P.total.u128());\n        for (l, r) in \u0026[\n            (A.amount.u128(),        100),\n            (A.cliff.u128(),          42),\n            (A.amount_after_cliff(),  58),\n            (A.start_at.into(),        7),\n            (A.interval.into(),       12),\n            (A.duration.into(),       70),\n            (A.end().into(),          77),\n            (A.portion_count().into(), 5),\n            (A.portion_size(),        11),\n            (A.remainder(),            3),\n        ] {\n            assert_eq!(l, r);\n        }\n        println!(\"\\n {:\u003c11}│ {:\u003c11} │ {:\u003c11}│ {:\u003c11}\", \"T\", \"Event\", \"Alice\", \"Bob\");\n        println!(\"{:─^52}┐\", \"\");\n        let mut a = 0;\n        let mut b = 0;\n        for t in 1..200 {\n            if t == A.start_at + A.duration + A.interval { break }\n            a = S.unlocked(t, \u0026Alice);\n            b = S.unlocked(t, \u0026Bob);\n            print!(\"{:\u003e12}│\", t);\n            println!(\"{:\u003e12}│{:\u003e12}│{:\u003e12}│\", if t \u003c A.start_at {\n                assert_eq!(a, 0);\n                assert_eq!(b, 0);\n                String::from(\"😴 pre\")\n            } else if t == A.start_at {\n                assert_eq!(a, A.cliff.u128());\n                assert_eq!(b, 0);\n                String::from(\"🚀 cliff\")\n            } else if t == A.end() \u0026\u0026 A.remainder() \u003e 0 {\n                assert_eq!(a, A.amount.u128());\n                assert_eq!(b, 0);\n                String::from(\"✨ remainder\")\n            } else if t \u003e= A.end() {\n                assert_eq!(a, A.amount.u128());\n                assert_eq!(b, 0);\n                String::from(\"✅ done\")\n            } else if A.vests_at(t) {\n                let p = A.most_recent_portion(t).unwrap() as u128;\n                assert_eq!(a, A.cliff.u128() + p * A.portion_size());\n                assert_eq!(b, 0);\n                format!(\"💸 vest #{}\", p)\n            } else {\n                String::from(\"⏳ wait\")\n            }, \u0026a, \u0026b);\n        }\n        assert_eq!(a, A.amount.u128());\n        assert_eq!(b, 0);\n    }\n    #[test] fn vest_periodic_no_cliff () {\n        let Alice = HumanAddr::from(\"Alice\");\n        let Bob = HumanAddr::from(\"Bob\");\n        let A = Account::periodic(\"\", \u0026Alice, 92, 0, 20, 11, 90);\n        let P = Pool::full(\"\", \u0026[A.clone()]);\n        let S = Schedule::new(\u0026[P.clone()]);\n        assert_eq!(92, S.total.u128());\n        assert_eq!(92, P.total.u128());\n        for (l, r) in \u0026[\n            (A.amount.u128(),         92),\n            (A.cliff.u128(),           0),\n            (A.amount_after_cliff(),  92),\n            (A.start_at.into(),       20),\n            (A.interval.into(),       11),\n            (A.duration.into(),       90),\n            (A.end().into(),         110),\n            (A.portion_count().into(), 8),\n            (A.portion_size(),        11),\n            (A.remainder(),            4),\n        ] {\n            assert_eq!(l, r);\n        }\n        println!(\"\\n {:\u003c11}│ {:\u003c11} │ {:\u003c11}│ {:\u003c11}\", \"T\", \"Event\", \"Alice\", \"Bob\");\n        println!(\"{:─^52}┐\", \"\");\n        let mut a = 0;\n        let mut b = 0;\n        for t in 1..200 {\n            if t == A.start_at + A.duration + A.interval { break }\n            a = S.unlocked(t, \u0026Alice);\n            b = S.unlocked(t, \u0026Bob);\n            print!(\"{:\u003e12}│\", t);\n            println!(\"{:\u003e12}│{:\u003e12}│{:\u003e12}│\", if t \u003c A.start_at {\n                assert_eq!(a, 0);\n                assert_eq!(b, 0);\n                String::from(\"😴 pre\")\n            } else if t == A.end() \u0026\u0026 A.remainder() \u003e 0 {\n                assert_eq!(a, A.amount.u128());\n                assert_eq!(b, 0);\n                String::from(\"✨ remainder\")\n            } else if t \u003e= A.end() {\n                assert_eq!(a, A.amount.u128());\n                assert_eq!(b, 0);\n                String::from(\"✅ done\")\n            } else if A.vests_at(t) {\n                let p = A.most_recent_portion(t).unwrap() as u128;\n                assert_eq!(a, p * A.portion_size());\n                assert_eq!(b, 0);\n                format!(\"💸 vest #{}\", p)\n            } else {\n                String::from(\"⏳ wait\")\n            }, \u0026a, \u0026b);\n        }\n        assert_eq!(a, A.amount.u128());\n        assert_eq!(b, 0);\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[477423,477476],"length":1,"stats":{"Line":5},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[477497,477527],"length":1,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[477540],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[444005,446324,444000,444032],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":109,"address":[444039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[444065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[446227,446268,446186,446132,446078,444878,445903,446024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[444096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[444122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[444263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[444564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[445267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[445485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[445703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[446736,446768,450363,446741],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":125,"address":[446775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[446801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[446832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[446892,450309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[450281,447082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[448099,448853,449073],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[447212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[447309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[447414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[447499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[447596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[447693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[447798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[447921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[448014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[448907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[449094,448809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[449282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[449509,450190,449698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[449753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[449983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[450565,454267,450592,450560],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":152,"address":[450599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[450625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[450656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[450758,454213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[454185,450948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[452719,452939,451965],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[451078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[451175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[451280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[451365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[451462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[451559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[451664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[451787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[451880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[452773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[452675,452960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[453148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[453393,453600,454094],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[453655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[453885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[454464,454469,463177,454496],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":178,"address":[454509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[454535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[454566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[463123,454668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[463095,454858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[454988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[455233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[457456,457676,456488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[455478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[455575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[455680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[455765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[455862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[455959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[456064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[456187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[456310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[456403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[457510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[457265,457721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[458126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[458306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[458330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[462602,458554,458354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[463388,458588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[458700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[458785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[458878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[463066,462136,459051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[459077,459212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[459267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[459422,463192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[459169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[459452,459554],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[459751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[459906,463197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[459936,459493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[460051,460153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[460350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[460505,463202],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[460092,460551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[460556,460648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[460845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[461000,463207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[461037,460597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[461134,461043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[461187,463448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[461723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[461886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[463212,461088],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[462104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[462607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[462837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[463568,463541,463536,471677],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":237,"address":[463581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[463607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[463638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[471623,463740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[463930,471595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[464060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[464305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[465560,466528,466748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[464550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[464647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[464752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[464837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[464934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[465031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[465136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[465259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[465382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[465475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[466582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[466793,466337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[467198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[467378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[467402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[467626,467426,471102],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[471883,467660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[467772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[467857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[467950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[468123,470636,471566],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[468302,468149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[468357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[471692,468512],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[468542,468241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[468657,468759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[468956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[471697,469111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[468698,469157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[469162,469254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":277,"address":[469451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[469606,471702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[469643,469203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[469649,469740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[471943,469793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[470223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[470386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[469694,471707],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[470604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[471107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[471337],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":200,"coverable":203},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","burner","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse burner::msg::{HandleMsg, InitMsg, MigrateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(MigrateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","burner","src","contract.rs"],"content":"use cosmwasm_std::{\n    log, Api, BankMsg, Binary, Env, Extern, HandleResponse, InitResponse, MigrateResponse, Order,\n    Querier, StdError, StdResult, Storage,\n};\n\nuse crate::msg::{HandleMsg, InitMsg, MigrateMsg, QueryMsg};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    _msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    Err(StdError::generic_err(\n        \"You can only use this contract for migrations\",\n    ))\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    _msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    Err(StdError::generic_err(\n        \"You can only use this contract for migrations\",\n    ))\n}\n\npub fn migrate\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: MigrateMsg,\n) -\u003e StdResult\u003cMigrateResponse\u003e {\n    // delete all state\n    let keys: Vec\u003c_\u003e = deps\n        .storage\n        .range(None, None, Order::Ascending)\n        .map(|(k, _)| k)\n        .collect();\n    let count = keys.len();\n    for k in keys {\n        deps.storage.remove(\u0026k);\n    }\n\n    // get balance and send all to recipient\n    let balance = deps.querier.query_all_balances(\u0026env.contract.address)?;\n    let send = BankMsg::Send {\n        from_address: env.contract.address,\n        to_address: msg.payout.clone(),\n        amount: balance,\n    };\n\n    let data_msg = format!(\"burnt {} keys\", count).into_bytes();\n\n    Ok(MigrateResponse {\n        messages: vec![send.into()],\n        log: vec![log(\"action\", \"burn\"), log(\"payout\", msg.payout)],\n        data: Some(data_msg.into()),\n    })\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026Extern\u003cS, A, Q\u003e,\n    _msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    Err(StdError::generic_err(\n        \"You can only use this contract for migrations\",\n    ))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, MOCK_CONTRACT_ADDR};\n    use cosmwasm_std::{coins, HumanAddr, ReadonlyStorage, StdError};\n\n    #[test]\n    fn init_fails() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        let msg = InitMsg {};\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        // we can just call .unwrap() to assert this was a success\n        let res = init(\u0026mut deps, env, msg);\n        match res.unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"You can only use this contract for migrations\")\n            }\n            _ =\u003e panic!(\"expected migrate error message\"),\n        }\n    }\n\n    #[test]\n    fn migrate_cleans_up_data() {\n        let mut deps = mock_dependencies(20, \u0026coins(123456, \"gold\"));\n\n        // store some sample data\n        deps.storage.set(b\"foo\", b\"bar\");\n        deps.storage.set(b\"key2\", b\"data2\");\n        deps.storage.set(b\"key3\", b\"cool stuff\");\n        let cnt = deps.storage.range(None, None, Order::Ascending).count();\n        assert_eq!(3, cnt);\n\n        // change the verifier via migrate\n        let payout = HumanAddr::from(\"someone else\");\n        let msg = MigrateMsg {\n            payout: payout.clone(),\n        };\n        let env = mock_env(\"creator\", \u0026[]);\n        let res = migrate(\u0026mut deps, env, msg).unwrap();\n        // check payout\n        assert_eq!(1, res.messages.len());\n        let msg = res.messages.get(0).expect(\"no message\");\n        assert_eq!(\n            msg,\n            \u0026BankMsg::Send {\n                from_address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n                to_address: payout,\n                amount: coins(123456, \"gold\"),\n            }\n            .into(),\n        );\n\n        // check there is no data in storage\n        let cnt = deps.storage.range(None, None, Order::Ascending).count();\n        assert_eq!(0, cnt);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","burner","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\n\n#[cfg(target_arch = \"wasm32\")]\ncosmwasm_std::create_entry_points_with_migration!(contract);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","burner","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::HumanAddr;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct MigrateMsg {\n    pub payout: HumanAddr,\n}\n\n/// InitMsg is a placeholder where we don't take any input\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {}\n\n/// HandleMsg is a placeholder where we don't take any input\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct HandleMsg {}\n\n/// QueryMsg is a placeholder where we don't take any input\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct QueryMsg {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","burner","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests.\n//! 1. First copy them over verbatum,\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n\nuse cosmwasm_std::{coins, BankMsg, HumanAddr, InitResult, MigrateResponse, Order, StdError};\nuse cosmwasm_vm::testing::{init, migrate, mock_env, mock_instance, MOCK_CONTRACT_ADDR};\nuse cosmwasm_vm::StorageIterator;\n\nuse burner::msg::{InitMsg, MigrateMsg};\nuse cosmwasm_vm::Storage;\n\n// This line will test the output of cargo wasm\nstatic WASM: \u0026[u8] = include_bytes!(\"../target/wasm32-unknown-unknown/release/burner.wasm\");\n// You can uncomment this line instead to test productionified build from rust-optimizer\n// static WASM: \u0026[u8] = include_bytes!(\"../contract.wasm\");\n\n#[test]\nfn init_fails() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let msg = InitMsg {};\n    let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n    // we can just call .unwrap() to assert this was a success\n    let res: InitResult = init(\u0026mut deps, env, msg);\n    match res.unwrap_err() {\n        StdError::GenericErr { msg, .. } =\u003e {\n            assert_eq!(msg, \"You can only use this contract for migrations\")\n        }\n        _ =\u003e panic!(\"expected migrate error message\"),\n    }\n}\n\n#[test]\nfn migrate_cleans_up_data() {\n    let mut deps = mock_instance(WASM, \u0026coins(123456, \"gold\"));\n\n    // store some sample data\n    deps.with_storage(|storage| {\n        storage.set(b\"foo\", b\"bar\").0.unwrap();\n        storage.set(b\"key2\", b\"data2\").0.unwrap();\n        storage.set(b\"key3\", b\"cool stuff\").0.unwrap();\n        let cnt = storage\n            .range(None, None, Order::Ascending)\n            .0\n            .unwrap()\n            .elements()\n            .unwrap()\n            .len();\n        assert_eq!(3, cnt);\n        Ok(())\n    })\n    .unwrap();\n\n    // change the verifier via migrate\n    let payout = HumanAddr::from(\"someone else\");\n    let msg = MigrateMsg {\n        payout: payout.clone(),\n    };\n    let env = mock_env(\"creator\", \u0026[]);\n    let res: MigrateResponse = migrate(\u0026mut deps, env, msg).unwrap();\n    // check payout\n    assert_eq!(1, res.messages.len());\n    let msg = res.messages.get(0).expect(\"no message\");\n    assert_eq!(\n        msg,\n        \u0026BankMsg::Send {\n            from_address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            to_address: payout,\n            amount: coins(123456, \"gold\"),\n        }\n        .into(),\n    );\n\n    // check there is no data in storage\n    deps.with_storage(|storage| {\n        let cnt = storage\n            .range(None, None, Order::Ascending)\n            .0\n            .unwrap()\n            .elements()\n            .unwrap()\n            .len();\n        assert_eq!(0, cnt);\n        Ok(())\n    })\n    .unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","dist","src","contract.rs"],"content":"use cosmwasm_std::{\n    log, to_binary, Api, Binary, Coin, CosmosMsg, DistQuery, Env, Extern, GovQuery, HandleResponse,\n    HumanAddr, InitResponse, InitResult, Querier, RewardsResponse, StdResult, Storage, VoteOption,\n};\n\nuse crate::msg::{HandleMsg, InitMsg};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    _msg: InitMsg,\n) -\u003e InitResult {\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Rewards { address } =\u003e try_query_rewards(deps, env, address),\n    }\n}\n\npub fn try_query_rewards\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    address: HumanAddr,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let query = DistQuery::Rewards {\n        delegator: address.clone(),\n    };\n\n    let mut query_rewards: RewardsResponse =\n        deps.querier\n            .query(\u0026query.into())\n            .unwrap_or_else(|_| RewardsResponse {\n                rewards: vec![],\n                total: vec![],\n            });\n\n    let active_proposal = query_rewards\n        .total\n        .pop()\n        .unwrap_or_else(|| Coin {\n            denom: \"stake\".to_string(),\n            amount: Default::default(),\n        })\n        .amount\n        .0 as u64;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(Binary::from(active_proposal.to_be_bytes().to_vec())),\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","dist","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        // do_query(\n        //     \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        //     msg_ptr,\n        // )\n        0\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","dist","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Binary, CosmosMsg, HumanAddr, QueryRequest};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    Rewards { address: HumanAddr },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","erc20","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse cw_erc20::contract::Constants;\nuse cw_erc20::msg::{AllowanceResponse, BalanceResponse, HandleMsg, InitMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(BalanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllowanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(Constants), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","erc20","src","contract.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::convert::TryInto;\n\nuse crate::msg::{AllowanceResponse, BalanceResponse, HandleMsg, InitMsg, QueryMsg};\nuse cosmwasm_std::{\n    log, to_binary, to_vec, Api, Binary, CanonicalAddr, Env, Extern, HandleResponse, HumanAddr,\n    InitResponse, Querier, ReadonlyStorage, StdError, StdResult, Storage, Uint128,\n};\nuse cosmwasm_storage::{PrefixedStorage, ReadonlyPrefixedStorage};\n\n#[derive(Serialize, Debug, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct Constants {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n}\n\npub const PREFIX_CONFIG: \u0026[u8] = b\"config\";\npub const PREFIX_BALANCES: \u0026[u8] = b\"balances\";\npub const PREFIX_ALLOWANCES: \u0026[u8] = b\"allowances\";\n\npub const KEY_CONSTANTS: \u0026[u8] = b\"constants\";\npub const KEY_TOTAL_SUPPLY: \u0026[u8] = b\"total_supply\";\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    let mut total_supply: u128 = 0;\n    {\n        // Initial balances\n        let mut balances_store = PrefixedStorage::new(PREFIX_BALANCES, \u0026mut deps.storage);\n        for row in msg.initial_balances {\n            let raw_address = deps.api.canonical_address(\u0026row.address)?;\n            let amount_raw = row.amount.u128();\n            balances_store.set(raw_address.as_slice(), \u0026amount_raw.to_be_bytes());\n            total_supply += amount_raw;\n        }\n    }\n\n    // Check name, symbol, decimals\n    if !is_valid_name(\u0026msg.name) {\n        return Err(StdError::generic_err(\n            \"Name is not in the expected format (3-30 UTF-8 bytes)\",\n        ));\n    }\n    if !is_valid_symbol(\u0026msg.symbol) {\n        return Err(StdError::generic_err(\n            \"Ticker symbol is not in expected format [A-Z]{3,6}\",\n        ));\n    }\n    if msg.decimals \u003e 18 {\n        return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n    }\n\n    let mut config_store = PrefixedStorage::new(PREFIX_CONFIG, \u0026mut deps.storage);\n    let constants = to_vec(\u0026Constants {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n    })?;\n    config_store.set(KEY_CONSTANTS, \u0026constants);\n    config_store.set(KEY_TOTAL_SUPPLY, \u0026total_supply.to_be_bytes());\n\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Approve { spender, amount } =\u003e try_approve(deps, env, \u0026spender, \u0026amount),\n        HandleMsg::Transfer { recipient, amount } =\u003e try_transfer(deps, env, \u0026recipient, \u0026amount),\n        HandleMsg::TransferFrom {\n            owner,\n            recipient,\n            amount,\n        } =\u003e try_transfer_from(deps, env, \u0026owner, \u0026recipient, \u0026amount),\n        HandleMsg::Burn { amount } =\u003e try_burn(deps, env, \u0026amount),\n    }\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Balance { address } =\u003e {\n            let address_key = deps.api.canonical_address(\u0026address)?;\n            let balance = read_balance(\u0026deps.storage, \u0026address_key)?;\n            let out = to_binary(\u0026BalanceResponse {\n                balance: Uint128::from(balance),\n            })?;\n            Ok(out)\n        }\n        QueryMsg::Allowance { owner, spender } =\u003e {\n            let owner_key = deps.api.canonical_address(\u0026owner)?;\n            let spender_key = deps.api.canonical_address(\u0026spender)?;\n            let allowance = read_allowance(\u0026deps.storage, \u0026owner_key, \u0026spender_key)?;\n            let out = to_binary(\u0026AllowanceResponse {\n                allowance: Uint128::from(allowance),\n            })?;\n            Ok(out)\n        }\n    }\n}\n\nfn try_transfer\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: \u0026HumanAddr,\n    amount: \u0026Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender_address_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n    let recipient_address_raw = deps.api.canonical_address(recipient)?;\n    let amount_raw = amount.u128();\n\n    perform_transfer(\n        \u0026mut deps.storage,\n        \u0026sender_address_raw,\n        \u0026recipient_address_raw,\n        amount_raw,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![\n            log(\"action\", \"transfer\"),\n            log(\"sender\", env.message.sender.as_str()),\n            log(\"recipient\", recipient.as_str()),\n        ],\n        data: None,\n    };\n    Ok(res)\n}\n\nfn try_transfer_from\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: \u0026HumanAddr,\n    recipient: \u0026HumanAddr,\n    amount: \u0026Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let spender_address_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n    let owner_address_raw = deps.api.canonical_address(owner)?;\n    let recipient_address_raw = deps.api.canonical_address(recipient)?;\n    let amount_raw = amount.u128();\n\n    let mut allowance = read_allowance(\u0026deps.storage, \u0026owner_address_raw, \u0026spender_address_raw)?;\n    if allowance \u003c amount_raw {\n        return Err(StdError::generic_err(format!(\n            \"Insufficient allowance: allowance={}, required={}\",\n            allowance, amount_raw\n        )));\n    }\n    allowance -= amount_raw;\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address_raw,\n        \u0026spender_address_raw,\n        allowance,\n    )?;\n    perform_transfer(\n        \u0026mut deps.storage,\n        \u0026owner_address_raw,\n        \u0026recipient_address_raw,\n        amount_raw,\n    )?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![\n            log(\"action\", \"transfer_from\"),\n            log(\"spender\", \u0026env.message.sender.as_str()),\n            log(\"sender\", owner.as_str()),\n            log(\"recipient\", recipient.as_str()),\n        ],\n        data: None,\n    };\n    Ok(res)\n}\n\nfn try_approve\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    spender: \u0026HumanAddr,\n    amount: \u0026Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let owner_address_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n    let spender_address_raw = deps.api.canonical_address(spender)?;\n    write_allowance(\n        \u0026mut deps.storage,\n        \u0026owner_address_raw,\n        \u0026spender_address_raw,\n        amount.u128(),\n    )?;\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![\n            log(\"action\", \"approve\"),\n            log(\"owner\", env.message.sender.as_str()),\n            log(\"spender\", spender.as_str()),\n        ],\n        data: None,\n    };\n    Ok(res)\n}\n\n/// Burn tokens\n///\n/// Remove `amount` tokens from the system irreversibly, from signer account\n///\n/// @param amount the amount of money to burn\nfn try_burn\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: \u0026Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let owner_address_raw = \u0026deps.api.canonical_address(\u0026env.message.sender)?;\n    let amount_raw = amount.u128();\n\n    let mut account_balance = read_balance(\u0026deps.storage, owner_address_raw)?;\n\n    if account_balance \u003c amount_raw {\n        return Err(StdError::generic_err(format!(\n            \"insufficient funds to burn: balance={}, required={}\",\n            account_balance, amount_raw\n        )));\n    }\n    account_balance -= amount_raw;\n\n    let mut balances_store = PrefixedStorage::new(PREFIX_BALANCES, \u0026mut deps.storage);\n    balances_store.set(owner_address_raw.as_slice(), \u0026account_balance.to_be_bytes());\n\n    let mut config_store = PrefixedStorage::new(PREFIX_CONFIG, \u0026mut deps.storage);\n    let data = config_store\n        .get(KEY_TOTAL_SUPPLY)\n        .expect(\"no total supply data stored\");\n    let mut total_supply = bytes_to_u128(\u0026data).unwrap();\n\n    total_supply -= amount_raw;\n\n    config_store.set(KEY_TOTAL_SUPPLY, \u0026total_supply.to_be_bytes());\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![\n            log(\"action\", \"burn\"),\n            log(\"account\", env.message.sender.as_str()),\n            log(\"amount\", \u0026amount.to_string()),\n        ],\n        data: None,\n    };\n\n    Ok(res)\n}\n\nfn perform_transfer\u003cT: Storage\u003e(\n    store: \u0026mut T,\n    from: \u0026CanonicalAddr,\n    to: \u0026CanonicalAddr,\n    amount: u128,\n) -\u003e StdResult\u003c()\u003e {\n    let mut balances_store = PrefixedStorage::new(PREFIX_BALANCES, store);\n\n    let mut from_balance = read_u128(\u0026balances_store, from.as_slice())?;\n    if from_balance \u003c amount {\n        return Err(StdError::generic_err(format!(\n            \"Insufficient funds: balance={}, required={}\",\n            from_balance, amount\n        )));\n    }\n    from_balance -= amount;\n    balances_store.set(from.as_slice(), \u0026from_balance.to_be_bytes());\n\n    let mut to_balance = read_u128(\u0026balances_store, to.as_slice())?;\n    to_balance += amount;\n    balances_store.set(to.as_slice(), \u0026to_balance.to_be_bytes());\n\n    Ok(())\n}\n\n// Converts 16 bytes value into u128\n// Errors if data found that is not 16 bytes\npub fn bytes_to_u128(data: \u0026[u8]) -\u003e StdResult\u003cu128\u003e {\n    match data[0..16].try_into() {\n        Ok(bytes) =\u003e Ok(u128::from_be_bytes(bytes)),\n        Err(_) =\u003e Err(StdError::generic_err(\n            \"Corrupted data found. 16 byte expected.\",\n        )),\n    }\n}\n\n// Reads 16 byte storage value into u128\n// Returns zero if key does not exist. Errors if data found that is not 16 bytes\npub fn read_u128\u003cS: ReadonlyStorage\u003e(store: \u0026S, key: \u0026[u8]) -\u003e StdResult\u003cu128\u003e {\n    let result = store.get(key);\n    match result {\n        Some(data) =\u003e bytes_to_u128(\u0026data),\n        None =\u003e Ok(0u128),\n    }\n}\n\nfn read_balance\u003cS: Storage\u003e(store: \u0026S, owner: \u0026CanonicalAddr) -\u003e StdResult\u003cu128\u003e {\n    let balance_store = ReadonlyPrefixedStorage::new(PREFIX_BALANCES, store);\n    read_u128(\u0026balance_store, owner.as_slice())\n}\n\nfn read_allowance\u003cS: Storage\u003e(\n    store: \u0026S,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n) -\u003e StdResult\u003cu128\u003e {\n    let allowances_store = ReadonlyPrefixedStorage::new(PREFIX_ALLOWANCES, store);\n    let owner_store = ReadonlyPrefixedStorage::new(owner.as_slice(), \u0026allowances_store);\n    read_u128(\u0026owner_store, spender.as_slice())\n}\n\nfn write_allowance\u003cS: Storage\u003e(\n    store: \u0026mut S,\n    owner: \u0026CanonicalAddr,\n    spender: \u0026CanonicalAddr,\n    amount: u128,\n) -\u003e StdResult\u003c()\u003e {\n    let mut allowances_store = PrefixedStorage::new(PREFIX_ALLOWANCES, store);\n    let mut owner_store = PrefixedStorage::new(owner.as_slice(), \u0026mut allowances_store);\n    owner_store.set(spender.as_slice(), \u0026amount.to_be_bytes());\n    Ok(())\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 30 {\n        return false;\n    }\n    true\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let bytes = symbol.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 6 {\n        return false;\n    }\n    for byte in bytes.iter() {\n        if *byte \u003c 65 || *byte \u003e 90 {\n            return false;\n        }\n    }\n    true\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","erc20","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(target_arch = \"wasm32\")]\ncosmwasm_std::create_entry_points!(contract);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","erc20","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{HumanAddr, Uint128};\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct InitialBalance {\n    pub address: HumanAddr,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema)]\npub struct InitMsg {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Vec\u003cInitialBalance\u003e,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    Approve {\n        spender: HumanAddr,\n        amount: Uint128,\n    },\n    Transfer {\n        recipient: HumanAddr,\n        amount: Uint128,\n    },\n    TransferFrom {\n        owner: HumanAddr,\n        recipient: HumanAddr,\n        amount: Uint128,\n    },\n    Burn {\n        amount: Uint128,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    Balance {\n        address: HumanAddr,\n    },\n    Allowance {\n        owner: HumanAddr,\n        spender: HumanAddr,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct BalanceResponse {\n    pub balance: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct AllowanceResponse {\n    pub allowance: Uint128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","erc20","src","tests.rs"],"content":"use cosmwasm_std::testing::{mock_dependencies, mock_env};\nuse cosmwasm_std::{\n    from_slice, log, Api, Env, HumanAddr, ReadonlyStorage, StdError, Storage, Uint128,\n};\nuse cosmwasm_storage::ReadonlyPrefixedStorage;\n\nuse crate::contract::{\n    bytes_to_u128, handle, init, query, read_u128, Constants, KEY_CONSTANTS, KEY_TOTAL_SUPPLY,\n    PREFIX_ALLOWANCES, PREFIX_BALANCES, PREFIX_CONFIG,\n};\nuse crate::msg::{HandleMsg, InitMsg, InitialBalance, QueryMsg};\n\nstatic CANONICAL_LENGTH: usize = 20;\n\nfn mock_env_height(signer: \u0026HumanAddr, height: u64, time: u64) -\u003e Env {\n    let mut env = mock_env(signer, \u0026[]);\n    env.block.height = height;\n    env.block.time = time;\n    env\n}\n\nfn get_constants\u003cS: Storage\u003e(storage: \u0026S) -\u003e Constants {\n    let config_storage = ReadonlyPrefixedStorage::new(PREFIX_CONFIG, storage);\n    let data = config_storage\n        .get(KEY_CONSTANTS)\n        .expect(\"no config data stored\");\n    from_slice(\u0026data).expect(\"invalid data\")\n}\n\nfn get_total_supply\u003cS: Storage\u003e(storage: \u0026S) -\u003e u128 {\n    let config_storage = ReadonlyPrefixedStorage::new(PREFIX_CONFIG, storage);\n    let data = config_storage\n        .get(KEY_TOTAL_SUPPLY)\n        .expect(\"no decimals data stored\");\n    return bytes_to_u128(\u0026data).unwrap();\n}\n\nfn get_balance\u003cS: ReadonlyStorage, A: Api\u003e(api: \u0026A, storage: \u0026S, address: \u0026HumanAddr) -\u003e u128 {\n    let address_key = api\n        .canonical_address(address)\n        .expect(\"canonical_address failed\");\n    let balances_storage = ReadonlyPrefixedStorage::new(PREFIX_BALANCES, storage);\n    return read_u128(\u0026balances_storage, address_key.as_slice()).unwrap();\n}\n\nfn get_allowance\u003cS: ReadonlyStorage, A: Api\u003e(\n    api: \u0026A,\n    storage: \u0026S,\n    owner: \u0026HumanAddr,\n    spender: \u0026HumanAddr,\n) -\u003e u128 {\n    let owner_raw_address = api\n        .canonical_address(owner)\n        .expect(\"canonical_address failed\");\n    let spender_raw_address = api\n        .canonical_address(spender)\n        .expect(\"canonical_address failed\");\n    let allowances_storage = ReadonlyPrefixedStorage::new(PREFIX_ALLOWANCES, storage);\n    let owner_storage =\n        ReadonlyPrefixedStorage::new(owner_raw_address.as_slice(), \u0026allowances_storage);\n    return read_u128(\u0026owner_storage, spender_raw_address.as_slice()).unwrap();\n}\n\nmod init {\n    use super::*;\n\n    #[test]\n    fn works() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: [InitialBalance {\n                address: HumanAddr(\"addr0000\".to_string()),\n                amount: Uint128::from(11223344u128),\n            }]\n            .to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        assert_eq!(\n            get_constants(\u0026deps.storage),\n            Constants {\n                name: \"Cash Token\".to_string(),\n                symbol: \"CASH\".to_string(),\n                decimals: 9\n            }\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11223344\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 11223344);\n    }\n\n    #[test]\n    fn works_with_empty_balance() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: [].to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        assert_eq!(get_total_supply(\u0026deps.storage), 0);\n    }\n\n    #[test]\n    fn works_with_multiple_balances() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: [\n                InitialBalance {\n                    address: HumanAddr(\"addr0000\".to_string()),\n                    amount: Uint128::from(11u128),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"addr1111\".to_string()),\n                    amount: Uint128::from(22u128),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"addrbbbb\".to_string()),\n                    amount: Uint128::from(33u128),\n                },\n            ]\n            .to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addrbbbb\".to_string())),\n            33\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 66);\n    }\n\n    #[test]\n    fn works_with_balance_larger_than_53_bit() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n\n        // This value cannot be represented precisely in JavaScript and jq. Both\n        //   node -e \"console.log(9007199254740993)\"\n        //   echo '{ \"value\": 9007199254740993 }' | jq\n        // return 9007199254740992\n        let init_msg = InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: [InitialBalance {\n                address: HumanAddr(\"addr0000\".to_string()),\n                amount: Uint128::from(9007199254740993u128),\n            }]\n            .to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            9007199254740993\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 9007199254740993);\n    }\n\n    #[test]\n    // Typical supply like 100 million tokens with 18 decimals exceeds the 64 bit range\n    fn works_with_balance_larger_than_64_bit() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n\n        let init_msg = InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: [InitialBalance {\n                address: HumanAddr(\"addr0000\".to_string()),\n                amount: Uint128::from(100000000000000000000000000u128),\n            }]\n            .to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            100000000000000000000000000\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 100000000000000000000000000);\n    }\n\n    #[test]\n    fn fails_for_large_decimals() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 42,\n            initial_balances: [].to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let result = init(\u0026mut deps, env, init_msg);\n        match result {\n            Ok(_) =\u003e panic!(\"expected error\"),\n            Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(msg, \"Decimals must not exceed 18\"),\n            Err(e) =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn fails_for_name_too_short() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = InitMsg {\n            name: \"CC\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: [].to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let result = init(\u0026mut deps, env, init_msg);\n        match result {\n            Ok(_) =\u003e panic!(\"expected error\"),\n            Err(StdError::GenericErr { msg, .. }) =\u003e {\n                assert_eq!(msg, \"Name is not in the expected format (3-30 UTF-8 bytes)\")\n            }\n            Err(e) =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn fails_for_name_too_long() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = InitMsg {\n            name: \"Cash coin. Cash coin. Cash coin. Cash coin.\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: [].to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let result = init(\u0026mut deps, env, init_msg);\n        match result {\n            Ok(_) =\u003e panic!(\"expected error\"),\n            Err(StdError::GenericErr { msg, .. }) =\u003e {\n                assert_eq!(msg, \"Name is not in the expected format (3-30 UTF-8 bytes)\")\n            }\n            Err(e) =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn fails_for_symbol_too_short() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = InitMsg {\n            name: \"De De\".to_string(),\n            symbol: \"DD\".to_string(),\n            decimals: 9,\n            initial_balances: [].to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let result = init(\u0026mut deps, env, init_msg);\n        match result {\n            Ok(_) =\u003e panic!(\"expected error\"),\n            Err(StdError::GenericErr { msg, .. }) =\u003e {\n                assert_eq!(msg, \"Ticker symbol is not in expected format [A-Z]{3,6}\")\n            }\n            Err(e) =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn fails_for_symbol_too_long() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = InitMsg {\n            name: \"Super Coin\".to_string(),\n            symbol: \"SUPERCOIN\".to_string(),\n            decimals: 9,\n            initial_balances: [].to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let result = init(\u0026mut deps, env, init_msg);\n        match result {\n            Ok(_) =\u003e panic!(\"expected error\"),\n            Err(StdError::GenericErr { msg, .. }) =\u003e {\n                assert_eq!(msg, \"Ticker symbol is not in expected format [A-Z]{3,6}\")\n            }\n            Err(e) =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn fails_for_symbol_lowercase() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CaSH\".to_string(),\n            decimals: 9,\n            initial_balances: [].to_vec(),\n        };\n        let env = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let result = init(\u0026mut deps, env, init_msg);\n        match result {\n            Ok(_) =\u003e panic!(\"expected error\"),\n            Err(StdError::GenericErr { msg, .. }) =\u003e {\n                assert_eq!(msg, \"Ticker symbol is not in expected format [A-Z]{3,6}\")\n            }\n            Err(e) =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n}\n\nmod transfer {\n    use super::*;\n\n    fn make_init_msg() -\u003e InitMsg {\n        InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![\n                InitialBalance {\n                    address: HumanAddr(\"addr0000\".to_string()),\n                    amount: Uint128::from(11u128),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"addr1111\".to_string()),\n                    amount: Uint128::from(22u128),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"addrbbbb\".to_string()),\n                    amount: Uint128::from(33u128),\n                },\n            ],\n        }\n    }\n\n    #[test]\n    fn can_send_to_existing_recipient() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // Initial state\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addrbbbb\".to_string())),\n            33\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 66);\n\n        // Transfer\n        let transfer_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"addr1111\".to_string()),\n            amount: Uint128::from(1u128),\n        };\n        let env2 = mock_env_height(\u0026HumanAddr(\"addr0000\".to_string()), 450, 550);\n        let transfer_result = handle(\u0026mut deps, env2, transfer_msg).unwrap();\n        assert_eq!(transfer_result.messages.len(), 0);\n        assert_eq!(\n            transfer_result.log,\n            vec![\n                log(\"action\", \"transfer\"),\n                log(\"sender\", \"addr0000\"),\n                log(\"recipient\", \"addr1111\"),\n            ]\n        );\n\n        // New state\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            10\n        ); // -1\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            23\n        ); // +1\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addrbbbb\".to_string())),\n            33\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 66);\n    }\n\n    #[test]\n    fn can_send_to_non_existent_recipient() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // Initial state\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addrbbbb\".to_string())),\n            33\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 66);\n\n        // Transfer\n        let transfer_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"addr2323\".to_string()),\n            amount: Uint128::from(1u128),\n        };\n        let env2 = mock_env_height(\u0026HumanAddr(\"addr0000\".to_string()), 450, 550);\n        let transfer_result = handle(\u0026mut deps, env2, transfer_msg).unwrap();\n        assert_eq!(transfer_result.messages.len(), 0);\n        assert_eq!(\n            transfer_result.log,\n            vec![\n                log(\"action\", \"transfer\"),\n                log(\"sender\", \"addr0000\"),\n                log(\"recipient\", \"addr2323\"),\n            ]\n        );\n\n        // New state\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            10\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr2323\".to_string())),\n            1\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addrbbbb\".to_string())),\n            33\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 66);\n    }\n\n    #[test]\n    fn can_send_zero_amount() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // Initial state\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addrbbbb\".to_string())),\n            33\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 66);\n\n        // Transfer\n        let transfer_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"addr1111\".to_string()),\n            amount: Uint128::from(0u128),\n        };\n        let env2 = mock_env_height(\u0026HumanAddr(\"addr0000\".to_string()), 450, 550);\n        let transfer_result = handle(\u0026mut deps, env2, transfer_msg).unwrap();\n        assert_eq!(transfer_result.messages.len(), 0);\n        assert_eq!(\n            transfer_result.log,\n            vec![\n                log(\"action\", \"transfer\"),\n                log(\"sender\", \"addr0000\"),\n                log(\"recipient\", \"addr1111\"),\n            ]\n        );\n\n        // New state (unchanged)\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addrbbbb\".to_string())),\n            33\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 66);\n    }\n\n    #[test]\n    fn can_send_to_sender() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        let sender = HumanAddr(\"addr0000\".to_string());\n\n        // Initial state\n        assert_eq!(get_balance(\u0026deps.api, \u0026deps.storage, \u0026sender), 11);\n\n        // Transfer\n        let transfer_msg = HandleMsg::Transfer {\n            recipient: sender.clone(),\n            amount: Uint128::from(3u128),\n        };\n        let env2 = mock_env_height(\u0026sender, 450, 550);\n        let transfer_result = handle(\u0026mut deps, env2, transfer_msg).unwrap();\n        assert_eq!(transfer_result.messages.len(), 0);\n        assert_eq!(\n            transfer_result.log,\n            vec![\n                log(\"action\", \"transfer\"),\n                log(\"sender\", \"addr0000\"),\n                log(\"recipient\", \"addr0000\"),\n            ]\n        );\n\n        // New state\n        assert_eq!(get_balance(\u0026deps.api, \u0026deps.storage, \u0026sender), 11);\n    }\n\n    #[test]\n    fn fails_on_insufficient_balance() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // Initial state\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addrbbbb\".to_string())),\n            33\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 66);\n\n        // Transfer\n        let transfer_msg = HandleMsg::Transfer {\n            recipient: HumanAddr(\"addr1111\".to_string()),\n            amount: Uint128::from(12u128),\n        };\n        let env2 = mock_env_height(\u0026HumanAddr(\"addr0000\".to_string()), 450, 550);\n        let transfer_result = handle(\u0026mut deps, env2, transfer_msg);\n        match transfer_result {\n            Ok(_) =\u003e panic!(\"expected error\"),\n            Err(StdError::GenericErr { msg, .. }) =\u003e {\n                assert_eq!(msg, \"Insufficient funds: balance=11, required=12\")\n            }\n            Err(e) =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n\n        // New state (unchanged)\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addrbbbb\".to_string())),\n            33\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 66);\n    }\n}\n\nmod approve {\n    use super::*;\n\n    fn make_init_msg() -\u003e InitMsg {\n        InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![\n                InitialBalance {\n                    address: HumanAddr(\"addr0000\".to_string()),\n                    amount: Uint128::from(11u128),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"addr1111\".to_string()),\n                    amount: Uint128::from(22u128),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"addrbbbb\".to_string()),\n                    amount: Uint128::from(33u128),\n                },\n            ],\n        }\n    }\n\n    fn make_spender() -\u003e HumanAddr {\n        HumanAddr(\"dadadadadadadada\".to_string())\n    }\n\n    #[test]\n    fn has_zero_allowance_by_default() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // Existing owner\n        assert_eq!(\n            get_allowance(\n                \u0026deps.api,\n                \u0026deps.storage,\n                \u0026HumanAddr(\"addr0000\".to_string()),\n                \u0026make_spender()\n            ),\n            0\n        );\n\n        // Non-existing owner\n        assert_eq!(\n            get_allowance(\n                \u0026deps.api,\n                \u0026deps.storage,\n                \u0026HumanAddr(\"addr4567\".to_string()),\n                \u0026make_spender()\n            ),\n            0\n        );\n    }\n\n    #[test]\n    fn can_set_allowance() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        assert_eq!(\n            get_allowance(\n                \u0026deps.api,\n                \u0026deps.storage,\n                \u0026HumanAddr(\"addr7654\".to_string()),\n                \u0026make_spender()\n            ),\n            0\n        );\n\n        // First approval\n        let owner = HumanAddr(\"addr7654\".to_string());\n        let spender = make_spender();\n        let approve_msg1 = HandleMsg::Approve {\n            spender: spender.clone(),\n            amount: Uint128::from(334422u128),\n        };\n        let env2 = mock_env_height(\u0026owner, 450, 550);\n        let approve_result1 = handle(\u0026mut deps, env2, approve_msg1).unwrap();\n        assert_eq!(approve_result1.messages.len(), 0);\n        assert_eq!(\n            approve_result1.log,\n            vec![\n                log(\"action\", \"approve\"),\n                log(\"owner\", owner.as_str()),\n                log(\"spender\", spender.as_str()),\n            ]\n        );\n\n        assert_eq!(\n            get_allowance(\u0026deps.api, \u0026deps.storage, \u0026owner, \u0026make_spender()),\n            334422\n        );\n\n        // Updated approval\n        let approve_msg2 = HandleMsg::Approve {\n            spender: spender.clone(),\n            amount: Uint128::from(777888u128),\n        };\n        let env3 = mock_env_height(\u0026owner, 450, 550);\n        let approve_result2 = handle(\u0026mut deps, env3, approve_msg2).unwrap();\n        assert_eq!(approve_result2.messages.len(), 0);\n        assert_eq!(\n            approve_result2.log,\n            vec![\n                log(\"action\", \"approve\"),\n                log(\"owner\", owner.as_str()),\n                log(\"spender\", spender.as_str()),\n            ]\n        );\n\n        assert_eq!(\n            get_allowance(\u0026deps.api, \u0026deps.storage, \u0026owner, \u0026spender),\n            777888\n        );\n    }\n}\n\nmod transfer_from {\n    use super::*;\n\n    fn make_init_msg() -\u003e InitMsg {\n        InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![\n                InitialBalance {\n                    address: HumanAddr(\"addr0000\".to_string()),\n                    amount: Uint128::from(11u128),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"addr1111\".to_string()),\n                    amount: Uint128::from(22u128),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"addrbbbb\".to_string()),\n                    amount: Uint128::from(33u128),\n                },\n            ],\n        }\n    }\n\n    fn make_spender() -\u003e HumanAddr {\n        HumanAddr(\"dadadadadadadada\".to_string())\n    }\n\n    #[test]\n    fn works() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        let owner = HumanAddr(\"addr0000\".to_string());\n        let spender = make_spender();\n        let recipient = HumanAddr(\"addr1212\".to_string());\n\n        // Set approval\n        let approve_msg = HandleMsg::Approve {\n            spender: spender.clone(),\n            amount: Uint128::from(4u128),\n        };\n        let env2 = mock_env_height(\u0026owner, 450, 550);\n        let approve_result = handle(\u0026mut deps, env2, approve_msg).unwrap();\n        assert_eq!(approve_result.messages.len(), 0);\n        assert_eq!(\n            approve_result.log,\n            vec![\n                log(\"action\", \"approve\"),\n                log(\"owner\", owner.as_str()),\n                log(\"spender\", spender.as_str()),\n            ]\n        );\n\n        assert_eq!(get_balance(\u0026deps.api, \u0026deps.storage, \u0026owner), 11);\n        assert_eq!(get_allowance(\u0026deps.api, \u0026deps.storage, \u0026owner, \u0026spender), 4);\n\n        // Transfer less than allowance but more than balance\n        let transfer_from_msg = HandleMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: recipient.clone(),\n            amount: Uint128::from(3u128),\n        };\n        let env3 = mock_env_height(\u0026spender, 450, 550);\n        let transfer_from_result = handle(\u0026mut deps, env3, transfer_from_msg).unwrap();\n        assert_eq!(transfer_from_result.messages.len(), 0);\n        assert_eq!(\n            transfer_from_result.log,\n            vec![\n                log(\"action\", \"transfer_from\"),\n                log(\"spender\", spender.as_str()),\n                log(\"sender\", owner.as_str()),\n                log(\"recipient\", recipient.as_str()),\n            ]\n        );\n\n        // State changed\n        assert_eq!(get_balance(\u0026deps.api, \u0026deps.storage, \u0026owner), 8);\n        assert_eq!(get_allowance(\u0026deps.api, \u0026deps.storage, \u0026owner, \u0026spender), 1);\n    }\n\n    #[test]\n    fn fails_when_allowance_too_low() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        let owner = HumanAddr(\"addr0000\".to_string());\n        let spender = make_spender();\n        let recipient = HumanAddr(\"addr1212\".to_string());\n\n        // Set approval\n        let approve_msg = HandleMsg::Approve {\n            spender: spender.clone(),\n            amount: Uint128::from(2u128),\n        };\n        let env2 = mock_env_height(\u0026owner, 450, 550);\n        let approve_result = handle(\u0026mut deps, env2, approve_msg).unwrap();\n        assert_eq!(approve_result.messages.len(), 0);\n        assert_eq!(\n            approve_result.log,\n            vec![\n                log(\"action\", \"approve\"),\n                log(\"owner\", owner.as_str()),\n                log(\"spender\", spender.as_str()),\n            ]\n        );\n\n        assert_eq!(get_balance(\u0026deps.api, \u0026deps.storage, \u0026owner), 11);\n        assert_eq!(get_allowance(\u0026deps.api, \u0026deps.storage, \u0026owner, \u0026spender), 2);\n\n        // Transfer less than allowance but more than balance\n        let fransfer_from_msg = HandleMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: recipient.clone(),\n            amount: Uint128::from(3u128),\n        };\n        let env3 = mock_env_height(\u0026spender, 450, 550);\n        let transfer_result = handle(\u0026mut deps, env3, fransfer_from_msg);\n        match transfer_result {\n            Ok(_) =\u003e panic!(\"expected error\"),\n            Err(StdError::GenericErr { msg, .. }) =\u003e {\n                assert_eq!(msg, \"Insufficient allowance: allowance=2, required=3\")\n            }\n            Err(e) =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn fails_when_allowance_is_set_but_balance_too_low() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        let owner = HumanAddr(\"addr0000\".to_string());\n        let spender = make_spender();\n        let recipient = HumanAddr(\"addr1212\".to_string());\n\n        // Set approval\n        let approve_msg = HandleMsg::Approve {\n            spender: spender.clone(),\n            amount: Uint128::from(20u128),\n        };\n        let env2 = mock_env_height(\u0026owner, 450, 550);\n        let approve_result = handle(\u0026mut deps, env2, approve_msg).unwrap();\n        assert_eq!(approve_result.messages.len(), 0);\n        assert_eq!(\n            approve_result.log,\n            vec![\n                log(\"action\", \"approve\"),\n                log(\"owner\", owner.as_str()),\n                log(\"spender\", spender.as_str()),\n            ]\n        );\n\n        assert_eq!(get_balance(\u0026deps.api, \u0026deps.storage, \u0026owner), 11);\n        assert_eq!(\n            get_allowance(\u0026deps.api, \u0026deps.storage, \u0026owner, \u0026spender),\n            20\n        );\n\n        // Transfer less than allowance but more than balance\n        let fransfer_from_msg = HandleMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: recipient.clone(),\n            amount: Uint128::from(15u128),\n        };\n        let env3 = mock_env_height(\u0026spender, 450, 550);\n        let transfer_result = handle(\u0026mut deps, env3, fransfer_from_msg);\n        match transfer_result {\n            Ok(_) =\u003e panic!(\"expected error\"),\n            Err(StdError::GenericErr { msg, .. }) =\u003e {\n                assert_eq!(msg, \"Insufficient funds: balance=11, required=15\")\n            }\n            Err(e) =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n}\n\nmod burn {\n    use super::*;\n\n    fn make_init_msg() -\u003e InitMsg {\n        InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![\n                InitialBalance {\n                    address: HumanAddr(\"addr0000\".to_string()),\n                    amount: Uint128::from(11u128),\n                },\n                InitialBalance {\n                    address: HumanAddr(\"addr1111\".to_string()),\n                    amount: Uint128::from(22u128),\n                },\n            ],\n        }\n    }\n\n    #[test]\n    fn can_burn_from_existing_account() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // Initial state\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 33);\n\n        // Burn\n        let burn_msg = HandleMsg::Burn {\n            amount: Uint128::from(1u128),\n        };\n        let env2 = mock_env_height(\u0026HumanAddr(\"addr0000\".to_string()), 450, 550);\n        let burn_result = handle(\u0026mut deps, env2, burn_msg).unwrap();\n        assert_eq!(burn_result.messages.len(), 0);\n        assert_eq!(\n            burn_result.log,\n            vec![\n                log(\"action\", \"burn\"),\n                log(\"account\", \"addr0000\"),\n                log(\"amount\", \"1\")\n            ]\n        );\n\n        // New state\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            10\n        ); // -1\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 32);\n    }\n\n    #[test]\n    fn can_burn_zero_amount() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // Initial state\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 33);\n\n        // Burn\n        let burn_msg = HandleMsg::Burn {\n            amount: Uint128::from(0u128),\n        };\n        let env2 = mock_env_height(\u0026HumanAddr(\"addr0000\".to_string()), 450, 550);\n        let burn_result = handle(\u0026mut deps, env2, burn_msg).unwrap();\n        assert_eq!(burn_result.messages.len(), 0);\n        assert_eq!(\n            burn_result.log,\n            vec![\n                log(\"action\", \"burn\"),\n                log(\"account\", \"addr0000\"),\n                log(\"amount\", \"0\"),\n            ]\n        );\n\n        // New state (unchanged)\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 33);\n    }\n\n    #[test]\n    fn fails_on_insufficient_balance() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026HumanAddr(\"creator\".to_string()), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // Initial state\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 33);\n\n        // Burn\n        let burn_msg = HandleMsg::Burn {\n            amount: Uint128::from(12u128),\n        };\n        let env2 = mock_env_height(\u0026HumanAddr(\"addr0000\".to_string()), 450, 550);\n        let burn_result = handle(\u0026mut deps, env2, burn_msg);\n        match burn_result {\n            Ok(_) =\u003e panic!(\"expected error\"),\n            Err(StdError::GenericErr { msg, .. }) =\u003e {\n                assert_eq!(msg, \"insufficient funds to burn: balance=11, required=12\")\n            }\n            Err(e) =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n\n        // New state (unchanged)\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr0000\".to_string())),\n            11\n        );\n        assert_eq!(\n            get_balance(\u0026deps.api, \u0026deps.storage, \u0026HumanAddr(\"addr1111\".to_string())),\n            22\n        );\n        assert_eq!(get_total_supply(\u0026deps.storage), 33);\n    }\n}\n\nmod query {\n    use super::*;\n\n    fn address(index: u8) -\u003e HumanAddr {\n        match index {\n            0 =\u003e HumanAddr(\"addr0000\".to_string()), // contract initializer\n            1 =\u003e HumanAddr(\"addr1111\".to_string()),\n            2 =\u003e HumanAddr(\"addr4321\".to_string()),\n            3 =\u003e HumanAddr(\"addr5432\".to_string()),\n            4 =\u003e HumanAddr(\"addr6543\".to_string()),\n            _ =\u003e panic!(\"Unsupported address index\"),\n        }\n    }\n\n    fn make_init_msg() -\u003e InitMsg {\n        InitMsg {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![\n                InitialBalance {\n                    address: address(1),\n                    amount: Uint128::from(11u128),\n                },\n                InitialBalance {\n                    address: address(2),\n                    amount: Uint128::from(22u128),\n                },\n                InitialBalance {\n                    address: address(3),\n                    amount: Uint128::from(33u128),\n                },\n            ],\n        }\n    }\n\n    #[test]\n    fn can_query_balance_of_existing_address() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026address(0), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        let query_msg = QueryMsg::Balance {\n            address: address(1),\n        };\n        let query_result = query(\u0026deps, query_msg).unwrap();\n        assert_eq!(query_result.as_slice(), b\"{\\\"balance\\\":\\\"11\\\"}\");\n    }\n\n    #[test]\n    fn can_query_balance_of_nonexisting_address() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026address(0), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        let query_msg = QueryMsg::Balance {\n            address: address(4), // only indices 1, 2, 3 are initialized\n        };\n        let query_result = query(\u0026deps, query_msg).unwrap();\n        assert_eq!(query_result.as_slice(), b\"{\\\"balance\\\":\\\"0\\\"}\");\n    }\n\n    #[test]\n    fn can_query_allowance_of_existing_addresses() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026address(0), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        let owner = address(2);\n        let spender = address(1);\n\n        let approve_msg = HandleMsg::Approve {\n            spender: spender.clone(),\n            amount: Uint128::from(42u128),\n        };\n        let env2 = mock_env_height(\u0026owner, 450, 550);\n        let action_result = handle(\u0026mut deps, env2, approve_msg).unwrap();\n        assert_eq!(action_result.messages.len(), 0);\n        assert_eq!(\n            action_result.log,\n            vec![\n                log(\"action\", \"approve\"),\n                log(\"owner\", owner.as_str()),\n                log(\"spender\", spender.as_str()),\n            ]\n        );\n\n        let query_msg = QueryMsg::Allowance {\n            owner: owner.clone(),\n            spender: spender.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg).unwrap();\n        assert_eq!(query_result.as_slice(), b\"{\\\"allowance\\\":\\\"42\\\"}\");\n    }\n\n    #[test]\n    fn can_query_allowance_of_nonexisting_owner() {\n        let mut deps = mock_dependencies(CANONICAL_LENGTH, \u0026[]);\n        let init_msg = make_init_msg();\n        let env1 = mock_env_height(\u0026address(0), 450, 550);\n        let res = init(\u0026mut deps, env1, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        let owner = address(2);\n        let spender = address(1);\n        let bob = address(3);\n\n        let approve_msg = HandleMsg::Approve {\n            spender: spender.clone(),\n            amount: Uint128::from(42u128),\n        };\n        let env2 = mock_env_height(\u0026owner, 450, 550);\n        let approve_result = handle(\u0026mut deps, env2, approve_msg).unwrap();\n        assert_eq!(approve_result.messages.len(), 0);\n        assert_eq!(\n            approve_result.log,\n            vec![\n                log(\"action\", \"approve\"),\n                log(\"owner\", owner.as_str()),\n                log(\"spender\", spender.as_str()),\n            ]\n        );\n\n        // different spender\n        let query_msg = QueryMsg::Allowance {\n            owner: owner.clone(),\n            spender: bob.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg).unwrap();\n        assert_eq!(query_result.as_slice(), b\"{\\\"allowance\\\":\\\"0\\\"}\");\n\n        // differnet owner\n        let query_msg = QueryMsg::Allowance {\n            owner: bob.clone(),\n            spender: spender.clone(),\n        };\n        let query_result = query(\u0026deps, query_msg).unwrap();\n        assert_eq!(query_result.as_slice(), b\"{\\\"allowance\\\":\\\"0\\\"}\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","erc20","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests as follows:\n//! 1. Copy them over verbatim\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, wherever you see something like:\n//!      deps.storage.get(CONFIG_KEY).0.expect(\"error getting data\").expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).0.expect(\"error getting data\").expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n\nuse cosmwasm_std::{from_slice, log, Env, HandleResponse, HumanAddr, InitResponse, Uint128};\nuse cosmwasm_storage::{to_length_prefixed, to_length_prefixed_nested};\nuse cosmwasm_vm::testing::{handle, init, mock_env, mock_instance, query};\nuse cosmwasm_vm::{Api, Storage};\n\nuse cw_erc20::contract::{\n    bytes_to_u128, Constants, KEY_CONSTANTS, KEY_TOTAL_SUPPLY, PREFIX_ALLOWANCES, PREFIX_BALANCES,\n    PREFIX_CONFIG,\n};\nuse cw_erc20::msg::{HandleMsg, InitMsg, InitialBalance, QueryMsg};\n\nstatic WASM: \u0026[u8] = include_bytes!(\"../target/wasm32-unknown-unknown/release/cw_erc20.wasm\");\n\nfn mock_env_height(signer: \u0026HumanAddr, height: u64, time: u64) -\u003e Env {\n    let mut env = mock_env(signer, \u0026[]);\n    env.block.height = height;\n    env.block.time = time;\n    env\n}\n\nfn get_constants\u003cS: Storage\u003e(storage: \u0026S) -\u003e Constants {\n    let key = [\u0026to_length_prefixed(PREFIX_CONFIG), KEY_CONSTANTS].concat();\n    let data = storage\n        .get(\u0026key)\n        .0\n        .expect(\"error getting data\")\n        .expect(\"no config data stored\");\n    from_slice(\u0026data).expect(\"invalid data\")\n}\n\nfn get_total_supply\u003cS: Storage\u003e(storage: \u0026S) -\u003e u128 {\n    let key = [\u0026to_length_prefixed(PREFIX_CONFIG), KEY_TOTAL_SUPPLY].concat();\n    let data = storage\n        .get(\u0026key)\n        .0\n        .expect(\"error getting data\")\n        .expect(\"no decimals data stored\");\n    bytes_to_u128(\u0026data).unwrap()\n}\n\nfn get_balance\u003cS: Storage, A: Api\u003e(api: \u0026A, storage: \u0026S, address: \u0026HumanAddr) -\u003e u128 {\n    let address_key = api\n        .canonical_address(address)\n        .0\n        .expect(\"canonical_address failed\");\n    let key = [\n        \u0026to_length_prefixed(\u0026PREFIX_BALANCES),\n        address_key.as_slice(),\n    ]\n    .concat();\n    read_u128(storage, \u0026key)\n}\n\nfn get_allowance\u003cS: Storage, A: Api\u003e(\n    api: \u0026A,\n    storage: \u0026S,\n    owner: \u0026HumanAddr,\n    spender: \u0026HumanAddr,\n) -\u003e u128 {\n    let owner_raw_address = api\n        .canonical_address(owner)\n        .0\n        .expect(\"canonical_address failed\");\n    let spender_raw_address = api\n        .canonical_address(spender)\n        .0\n        .expect(\"canonical_address failed\");\n    let key = [\n        \u0026to_length_prefixed_nested(\u0026[PREFIX_ALLOWANCES, owner_raw_address.as_slice()]),\n        spender_raw_address.as_slice(),\n    ]\n    .concat();\n    return read_u128(storage, \u0026key);\n}\n\n// Reads 16 byte storage value into u128\n// Returns zero if key does not exist. Errors if data found that is not 16 bytes\nfn read_u128\u003cS: Storage\u003e(store: \u0026S, key: \u0026[u8]) -\u003e u128 {\n    let result = store.get(key).0.unwrap();\n    match result {\n        Some(data) =\u003e bytes_to_u128(\u0026data).unwrap(),\n        None =\u003e 0u128,\n    }\n}\n\nfn address(index: u8) -\u003e HumanAddr {\n    match index {\n        0 =\u003e HumanAddr(\"addr0000\".to_string()), // contract initializer\n        1 =\u003e HumanAddr(\"addr1111\".to_string()),\n        2 =\u003e HumanAddr(\"addr4321\".to_string()),\n        3 =\u003e HumanAddr(\"addr5432\".to_string()),\n        _ =\u003e panic!(\"Unsupported address index\"),\n    }\n}\n\nfn init_msg() -\u003e InitMsg {\n    InitMsg {\n        decimals: 5,\n        name: \"Ash token\".to_string(),\n        symbol: \"ASH\".to_string(),\n        initial_balances: [\n            InitialBalance {\n                address: address(1),\n                amount: Uint128::from(11u128),\n            },\n            InitialBalance {\n                address: address(2),\n                amount: Uint128::from(22u128),\n            },\n            InitialBalance {\n                address: address(3),\n                amount: Uint128::from(33u128),\n            },\n        ]\n        .to_vec(),\n    }\n}\n\n#[test]\nfn init_works() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n    let init_msg = init_msg();\n    let params = mock_env_height(\u0026address(0), 876, 0);\n    let res: InitResponse = init(\u0026mut deps, params, init_msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // query the store directly\n    let api = deps.api;\n    deps.with_storage(|storage| {\n        assert_eq!(\n            get_constants(storage),\n            Constants {\n                name: \"Ash token\".to_string(),\n                symbol: \"ASH\".to_string(),\n                decimals: 5\n            }\n        );\n        assert_eq!(get_total_supply(storage), 66);\n        assert_eq!(get_balance(\u0026api, storage, \u0026address(1)), 11);\n        assert_eq!(get_balance(\u0026api, storage, \u0026address(2)), 22);\n        assert_eq!(get_balance(\u0026api, storage, \u0026address(3)), 33);\n        Ok(())\n    })\n    .unwrap();\n}\n\n#[test]\nfn transfer_works() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n    let init_msg = init_msg();\n    let env1 = mock_env_height(\u0026address(0), 876, 0);\n    let res: InitResponse = init(\u0026mut deps, env1, init_msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    let sender = address(1);\n    let recipient = address(2);\n\n    // Before\n    let api = deps.api;\n    deps.with_storage(|storage| {\n        assert_eq!(get_balance(\u0026api, storage, \u0026sender), 11);\n        assert_eq!(get_balance(\u0026api, storage, \u0026recipient), 22);\n        Ok(())\n    })\n    .unwrap();\n\n    // Transfer\n    let transfer_msg = HandleMsg::Transfer {\n        recipient: recipient.clone(),\n        amount: Uint128::from(1u128),\n    };\n    let env2 = mock_env_height(\u0026sender, 877, 0);\n    let transfer_response: HandleResponse = handle(\u0026mut deps, env2, transfer_msg).unwrap();\n    assert_eq!(transfer_response.messages.len(), 0);\n    assert_eq!(\n        transfer_response.log,\n        vec![\n            log(\"action\", \"transfer\"),\n            log(\"sender\", sender.as_str()),\n            log(\"recipient\", recipient.as_str()),\n        ]\n    );\n\n    // After\n    deps.with_storage(|storage| {\n        assert_eq!(get_balance(\u0026api, storage, \u0026sender), 10);\n        assert_eq!(get_balance(\u0026api, storage, \u0026recipient), 23);\n        Ok(())\n    })\n    .unwrap();\n}\n\n#[test]\nfn approve_works() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n    let init_msg = init_msg();\n    let env1 = mock_env_height(\u0026address(0), 876, 0);\n    let res: InitResponse = init(\u0026mut deps, env1, init_msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    let owner = address(1);\n    let spender = address(2);\n\n    // Before\n    let api = deps.api;\n    deps.with_storage(|storage| {\n        assert_eq!(get_allowance(\u0026api, storage, \u0026owner, \u0026spender), 0);\n        Ok(())\n    })\n    .unwrap();\n\n    // Approve\n    let approve_msg = HandleMsg::Approve {\n        spender: spender.clone(),\n        amount: Uint128::from(42u128),\n    };\n    let env2 = mock_env_height(\u0026owner, 877, 0);\n    let approve_response: HandleResponse = handle(\u0026mut deps, env2, approve_msg).unwrap();\n    assert_eq!(approve_response.messages.len(), 0);\n    assert_eq!(\n        approve_response.log,\n        vec![\n            log(\"action\", \"approve\"),\n            log(\"owner\", owner.as_str()),\n            log(\"spender\", spender.as_str()),\n        ]\n    );\n\n    // After\n    deps.with_storage(|storage| {\n        assert_eq!(get_allowance(\u0026api, storage, \u0026owner, \u0026spender), 42);\n        Ok(())\n    })\n    .unwrap();\n}\n\n#[test]\nfn transfer_from_works() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n    let init_msg = init_msg();\n    let env1 = mock_env_height(\u0026address(0), 876, 0);\n    let res: InitResponse = init(\u0026mut deps, env1, init_msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    let owner = address(1);\n    let spender = address(2);\n    let recipient = address(3);\n\n    // Before\n    let api = deps.api;\n    deps.with_storage(|storage| {\n        assert_eq!(get_balance(\u0026api, storage, \u0026owner), 11);\n        assert_eq!(get_balance(\u0026api, storage, \u0026recipient), 33);\n        assert_eq!(get_allowance(\u0026api, storage, \u0026owner, \u0026spender), 0);\n        Ok(())\n    })\n    .unwrap();\n\n    // Approve\n    let approve_msg = HandleMsg::Approve {\n        spender: spender.clone(),\n        amount: Uint128::from(42u128),\n    };\n    let env2 = mock_env_height(\u0026owner, 877, 0);\n    let approve_response: HandleResponse = handle(\u0026mut deps, env2, approve_msg).unwrap();\n    assert_eq!(approve_response.messages.len(), 0);\n    assert_eq!(\n        approve_response.log,\n        vec![\n            log(\"action\", \"approve\"),\n            log(\"owner\", owner.as_str()),\n            log(\"spender\", spender.as_str()),\n        ]\n    );\n\n    // Transfer from\n    let transfer_from_msg = HandleMsg::TransferFrom {\n        owner: owner.clone(),\n        recipient: recipient.clone(),\n        amount: Uint128::from(2u128),\n    };\n    let env3 = mock_env_height(\u0026spender, 878, 0);\n    let transfer_from_response: HandleResponse =\n        handle(\u0026mut deps, env3, transfer_from_msg).unwrap();\n    assert_eq!(transfer_from_response.messages.len(), 0);\n    assert_eq!(\n        transfer_from_response.log,\n        vec![\n            log(\"action\", \"transfer_from\"),\n            log(\"spender\", spender.as_str()),\n            log(\"sender\", owner.as_str()),\n            log(\"recipient\", recipient.as_str()),\n        ]\n    );\n\n    // After\n    deps.with_storage(|storage| {\n        assert_eq!(get_balance(\u0026api, storage, \u0026owner), 9);\n        assert_eq!(get_balance(\u0026api, storage, \u0026recipient), 35);\n        assert_eq!(get_allowance(\u0026api, storage, \u0026owner, \u0026spender), 40);\n        Ok(())\n    })\n    .unwrap();\n}\n\n#[test]\nfn burn_works() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n    let init_msg = init_msg();\n    let env1 = mock_env_height(\u0026address(0), 876, 0);\n    let res: InitResponse = init(\u0026mut deps, env1, init_msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    let owner = address(1);\n\n    // Before\n    let api = deps.api;\n    deps.with_storage(|storage| {\n        assert_eq!(get_balance(\u0026api, storage, \u0026owner), 11);\n        Ok(())\n    })\n    .unwrap();\n\n    // Burn\n    let burn_msg = HandleMsg::Burn {\n        amount: Uint128::from(1u128),\n    };\n    let env2 = mock_env_height(\u0026owner, 877, 0);\n    let burn_response: HandleResponse = handle(\u0026mut deps, env2, burn_msg).unwrap();\n    assert_eq!(burn_response.messages.len(), 0);\n    assert_eq!(\n        burn_response.log,\n        vec![\n            log(\"action\", \"burn\"),\n            log(\"account\", owner.as_str()),\n            log(\"amount\", \"1\")\n        ]\n    );\n\n    // After\n    deps.with_storage(|storage| {\n        assert_eq!(get_balance(\u0026api, storage, \u0026owner), 10);\n        Ok(())\n    })\n    .unwrap();\n}\n\n#[test]\nfn can_query_balance_of_existing_address() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n    let init_msg = init_msg();\n    let env1 = mock_env_height(\u0026address(0), 450, 550);\n    let res: InitResponse = init(\u0026mut deps, env1, init_msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    let query_msg = QueryMsg::Balance {\n        address: address(2),\n    };\n    let query_result = query(\u0026mut deps, query_msg).unwrap();\n    assert_eq!(query_result.as_slice(), b\"{\\\"balance\\\":\\\"22\\\"}\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","escrow","examples","schema.rs"],"content":"use cosmwasm_schema::{export_schema, remove_schemas, schema_for};\nuse std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cw_escrow::msg::{HandleMsg, InitMsg, QueryMsg};\nuse cw_escrow::state::State;\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(State), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","escrow","src","contract.rs"],"content":"use cosmwasm_std::{\n    generic_err, log, unauthorized, Api, BankMsg, Binary, CanonicalAddr, Coin, CosmosMsg, Env,\n    Extern, HandleResponse, HandleResult, InitResponse, InitResult, MigrateResponse, Querier,\n    StdResult, Storage,\n};\n\nuse crate::msg::{HandleMsg, InitMsg, MigrateMsg, QueryMsg};\nuse crate::state::{config, config_read, State};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e InitResult {\n    let state = State {\n        arbiter: deps.api.canonical_address(\u0026msg.arbiter)?,\n        recipient: deps.api.canonical_address(\u0026msg.recipient)?,\n        source: env.message.sender.clone(),\n        end_height: msg.end_height,\n        end_time: msg.end_time,\n    };\n    if state.is_expired(\u0026env) {\n        Err(generic_err(\"creating expired escrow\"))\n    } else {\n        config(\u0026mut deps.storage).save(\u0026state)?;\n        Ok(InitResponse::default())\n    }\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e HandleResult {\n    let state = config_read(\u0026deps.storage).load()?;\n    match msg {\n        HandleMsg::Approve { quantity } =\u003e try_approve(deps, env, state, quantity),\n        HandleMsg::Refund {} =\u003e try_refund(deps, env, state),\n    }\n}\n\nfn try_approve\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    state: State,\n    quantity: Option\u003cVec\u003cCoin\u003e\u003e,\n) -\u003e HandleResult {\n    if env.message.sender != state.arbiter {\n        Err(unauthorized())\n    } else if state.is_expired(\u0026env) {\n        Err(generic_err(\"escrow expired\"))\n    } else {\n        let amount = if let Some(quantity) = quantity {\n            quantity\n        } else {\n            // release everything\n\n            let contract_address_human = deps.api.human_address(\u0026env.contract.address)?;\n            // Querier guarantees to returns up-to-date data, including funds sent in this handle message\n            // https://github.com/CosmWasm/wasmd/blob/master/x/wasm/internal/keeper/keeper.go#L185-L192\n            deps.querier.query_all_balances(contract_address_human)?\n        };\n\n        send_tokens(\n            \u0026deps.api,\n            \u0026env.contract.address,\n            \u0026state.recipient,\n            amount,\n            \"approve\",\n        )\n    }\n}\n\nfn try_refund\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    state: State,\n) -\u003e HandleResult {\n    // anyone can try to refund, as long as the contract is expired\n    if !state.is_expired(\u0026env) {\n        Err(generic_err(\"escrow not yet expired\"))\n    } else {\n        let contract_address_human = deps.api.human_address(\u0026env.contract.address)?;\n        // Querier guarantees to returns up-to-date data, including funds sent in this handle message\n        // https://github.com/CosmWasm/wasmd/blob/master/x/wasm/internal/keeper/keeper.go#L185-L192\n        let balance = deps.querier.query_all_balances(contract_address_human)?;\n        send_tokens(\n            \u0026deps.api,\n            \u0026env.contract.address,\n            \u0026state.source,\n            balance,\n            \"refund\",\n        )\n    }\n}\n\n// this is a helper to move the tokens, so the business logic is easy to read\nfn send_tokens\u003cA: Api\u003e(\n    api: \u0026A,\n    from_address: \u0026CanonicalAddr,\n    to_address: \u0026CanonicalAddr,\n    amount: Vec\u003cCoin\u003e,\n    action: \u0026str,\n) -\u003e HandleResult {\n    let from_human = api.human_address(from_address)?;\n    let to_human = api.human_address(to_address)?;\n    let log = vec![log(\"action\", action), log(\"to\", to_human.as_str())];\n\n    let r = HandleResponse {\n        messages: vec![CosmosMsg::Bank(BankMsg::Send {\n            from_address: from_human,\n            to_address: to_human,\n            amount,\n        })],\n        log,\n        data: None,\n    };\n    Ok(r)\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    // this always returns error\n    match msg {}\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env};\n    use cosmwasm_std::{coins, Api, HumanAddr, StdError};\n\n    fn init_msg_expire_by_height(height: u64) -\u003e InitMsg {\n        InitMsg {\n            arbiter: HumanAddr::from(\"verifies\"),\n            recipient: HumanAddr::from(\"benefits\"),\n            end_height: Some(height),\n            end_time: None,\n        }\n    }\n\n    fn mock_env_height\u003cA: Api\u003e(\n        api: \u0026A,\n        signer: \u0026str,\n        sent: \u0026[Coin],\n        height: u64,\n        time: u64,\n    ) -\u003e Env {\n        let mut env = mock_env(api, signer, sent);\n        env.block.height = height;\n        env.block.time = time;\n        env\n    }\n\n    #[test]\n    fn proper_initialization() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        let msg = init_msg_expire_by_height(1000);\n        let env = mock_env_height(\u0026deps.api, \"creator\", \u0026coins(1000, \"earth\"), 876, 0);\n        let res = init(\u0026mut deps, env, msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // it worked, let's query the state\n        let state = config_read(\u0026mut deps.storage).load().unwrap();\n        assert_eq!(\n            state,\n            State {\n                arbiter: deps\n                    .api\n                    .canonical_address(\u0026HumanAddr::from(\"verifies\"))\n                    .unwrap(),\n                recipient: deps\n                    .api\n                    .canonical_address(\u0026HumanAddr::from(\"benefits\"))\n                    .unwrap(),\n                source: deps\n                    .api\n                    .canonical_address(\u0026HumanAddr::from(\"creator\"))\n                    .unwrap(),\n                end_height: Some(1000),\n                end_time: None,\n            }\n        );\n    }\n\n    #[test]\n    fn cannot_initialize_expired() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        let msg = init_msg_expire_by_height(1000);\n        let env = mock_env_height(\u0026deps.api, \"creator\", \u0026coins(1000, \"earth\"), 1001, 0);\n        let res = init(\u0026mut deps, env, msg);\n        match res.unwrap_err() {\n            generic_err { msg, .. } =\u003e assert_eq!(msg, \"creating expired escrow\"),\n            e =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn handle_approve() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        // initialize the store\n        let init_amount = coins(1000, \"earth\");\n        let init_env = mock_env_height(\u0026deps.api, \"creator\", \u0026init_amount, 876, 0);\n        let contract_addr = deps.api.human_address(\u0026init_env.contract.address).unwrap();\n        let msg = init_msg_expire_by_height(1000);\n        let init_res = init(\u0026mut deps, init_env, msg).unwrap();\n        assert_eq!(0, init_res.messages.len());\n\n        // balance changed in init\n        deps.querier.update_balance(\u0026contract_addr, init_amount);\n\n        // beneficiary cannot release it\n        let msg = HandleMsg::Approve { quantity: None };\n        let env = mock_env_height(\u0026deps.api, \"beneficiary\", \u0026[], 900, 0);\n        let handle_res = handle(\u0026mut deps, env, msg.clone());\n        match handle_res.unwrap_err() {\n            StdError::Unauthorized { .. } =\u003e {}\n            e =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n\n        // verifier cannot release it when expired\n        let env = mock_env_height(\u0026deps.api, \"verifies\", \u0026[], 1100, 0);\n        let handle_res = handle(\u0026mut deps, env, msg.clone());\n        match handle_res.unwrap_err() {\n            generic_err { msg, .. } =\u003e assert_eq!(msg, \"escrow expired\"),\n            e =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n\n        // complete release by verfier, before expiration\n        let env = mock_env_height(\u0026deps.api, \"verifies\", \u0026[], 999, 0);\n        let handle_res = handle(\u0026mut deps, env, msg.clone()).unwrap();\n        assert_eq!(1, handle_res.messages.len());\n        let msg = handle_res.messages.get(0).expect(\"no message\");\n        assert_eq!(\n            msg,\n            \u0026CosmosMsg::Bank(BankMsg::Send {\n                from_address: HumanAddr::from(\"cosmos2contract\"),\n                to_address: HumanAddr::from(\"benefits\"),\n                amount: coins(1000, \"earth\"),\n            })\n        );\n\n        // partial release by verfier, before expiration\n        let partial_msg = HandleMsg::Approve {\n            quantity: Some(coins(500, \"earth\")),\n        };\n        let env = mock_env_height(\u0026deps.api, \"verifies\", \u0026[], 999, 0);\n        let handle_res = handle(\u0026mut deps, env, partial_msg).unwrap();\n        assert_eq!(1, handle_res.messages.len());\n        let msg = handle_res.messages.get(0).expect(\"no message\");\n        assert_eq!(\n            msg,\n            \u0026CosmosMsg::Bank(BankMsg::Send {\n                from_address: HumanAddr::from(\"cosmos2contract\"),\n                to_address: HumanAddr::from(\"benefits\"),\n                amount: coins(500, \"earth\"),\n            })\n        );\n    }\n\n    #[test]\n    fn handle_refund() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        // initialize the store\n        let init_amount = coins(1000, \"earth\");\n        let init_env = mock_env_height(\u0026deps.api, \"creator\", \u0026init_amount, 876, 0);\n        let contract_addr = deps.api.human_address(\u0026init_env.contract.address).unwrap();\n        let msg = init_msg_expire_by_height(1000);\n        let init_res = init(\u0026mut deps, init_env, msg).unwrap();\n        assert_eq!(0, init_res.messages.len());\n\n        // balance changed in init\n        deps.querier.update_balance(\u0026contract_addr, init_amount);\n\n        // cannot release when unexpired (height \u003c end_height)\n        let msg = HandleMsg::Refund {};\n        let env = mock_env_height(\u0026deps.api, \"anybody\", \u0026[], 800, 0);\n        let handle_res = handle(\u0026mut deps, env, msg.clone());\n        match handle_res.unwrap_err() {\n            generic_err { msg, .. } =\u003e assert_eq!(msg, \"escrow not yet expired\"),\n            e =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n\n        // cannot release when unexpired (height == end_height)\n        let msg = HandleMsg::Refund {};\n        let env = mock_env_height(\u0026deps.api, \"anybody\", \u0026[], 1000, 0);\n        let handle_res = handle(\u0026mut deps, env, msg.clone());\n        match handle_res.unwrap_err() {\n            generic_err { msg, .. } =\u003e assert_eq!(msg, \"escrow not yet expired\"),\n            e =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n\n        // anyone can release after expiration\n        let env = mock_env_height(\u0026deps.api, \"anybody\", \u0026[], 1001, 0);\n        let handle_res = handle(\u0026mut deps, env, msg.clone()).unwrap();\n        assert_eq!(1, handle_res.messages.len());\n        let msg = handle_res.messages.get(0).expect(\"no message\");\n        assert_eq!(\n            msg,\n            \u0026CosmosMsg::Bank(BankMsg::Send {\n                from_address: HumanAddr::from(\"cosmos2contract\"),\n                to_address: HumanAddr::from(\"creator\"),\n                amount: coins(1000, \"earth\"),\n            })\n        );\n    }\n}\n\npub fn migrate\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    _msg: MigrateMsg,\n) -\u003e StdResult\u003cMigrateResponse\u003e {\n    Ok(MigrateResponse::default())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","escrow","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\npub mod state;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_migrate, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn migrate(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_migrate(\n            \u0026contract::migrate::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","escrow","src","msg.rs"],"content":"use cosmwasm_std::{Coin, HumanAddr};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n    pub arbiter: HumanAddr,\n    pub recipient: HumanAddr,\n    /// When end height set and block height exceeds this value, the escrow is expired.\n    /// Once an escrow is expired, it can be returned to the original funder (via \"refund\").\n    pub end_height: Option\u003cu64\u003e,\n    /// When end time (in seconds since epoch 00:00:00 UTC on 1 January 1970) is set and\n    /// block time exceeds this value, the escrow is expired.\n    /// Once an escrow is expired, it can be returned to the original funder (via \"refund\").\n    pub end_time: Option\u003cu64\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    Approve {\n        // release some coins - if quantity is None, release all coins in balance\n        quantity: Option\u003cVec\u003cCoin\u003e\u003e,\n    },\n    Refund {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum MigrateMsg {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","escrow","src","state.rs"],"content":"use cosmwasm_std::{CanonicalAddr, Env, Storage};\nuse cosmwasm_storage::{singleton, singleton_read, ReadonlySingleton, Singleton};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nstatic CONFIG_KEY: \u0026[u8] = b\"config\";\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct State {\n    pub arbiter: CanonicalAddr,\n    pub recipient: CanonicalAddr,\n    pub source: CanonicalAddr,\n    pub end_height: Option\u003cu64\u003e,\n    pub end_time: Option\u003cu64\u003e,\n}\n\nimpl State {\n    pub fn is_expired(\u0026self, env: \u0026Env) -\u003e bool {\n        if let Some(end_height) = self.end_height {\n            if env.block.height \u003e end_height {\n                return true;\n            }\n        }\n\n        if let Some(end_time) = self.end_time {\n            if env.block.time \u003e end_time {\n                return true;\n            }\n        }\n\n        false\n    }\n}\n\npub fn config\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, State\u003e {\n    singleton(storage, CONFIG_KEY)\n}\n\npub fn config_read\u003cS: Storage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, State\u003e {\n    singleton_read(storage, CONFIG_KEY)\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","escrow","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests as follows:\n//! 1. Copy them over verbatim\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n\nuse cosmwasm_std::{\n    coins, BankMsg, Coin, CosmosMsg, Env, HandleResponse, HandleResult, HumanAddr, InitResponse,\n    InitResult, StdError,\n};\nuse cosmwasm_storage::to_length_prefixed;\nuse cosmwasm_vm::testing::{handle, init, mock_env, mock_instance};\nuse cosmwasm_vm::{from_slice, Api, Storage};\n\nuse cw_escrow::msg::{HandleMsg, InitMsg};\nuse cw_escrow::state::State;\n\n// This line will test the output of cargo wasm\nstatic WASM: \u0026[u8] = include_bytes!(\"../target/wasm32-unknown-unknown/release/cw_escrow.wasm\");\n// You can uncomment this line instead to test productionified build from rust-optimizer\n// static WASM: \u0026[u8] = include_bytes!(\"../contract.wasm\");\n\nfn init_msg_expire_by_height(height: u64) -\u003e InitMsg {\n    InitMsg {\n        arbiter: HumanAddr::from(\"verifies\"),\n        recipient: HumanAddr::from(\"benefits\"),\n        end_height: Some(height),\n        end_time: None,\n    }\n}\n\nfn mock_env_height\u003cA: Api\u003e(api: \u0026A, signer: \u0026str, sent: \u0026[Coin], height: u64, time: u64) -\u003e Env {\n    let mut env = mock_env(api, signer, sent);\n    env.block.height = height;\n    env.block.time = time;\n    env\n}\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let msg = init_msg_expire_by_height(1000);\n    let env = mock_env_height(\u0026deps.api, \"creator\", \u0026coins(1000, \"earth\"), 876, 0);\n    let res: InitResponse = init(\u0026mut deps, env, msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // it worked, let's query the state\n    let api = deps.api;\n    deps.with_storage(|store| {\n        let config_key_raw = to_length_prefixed(b\"config\");\n        let state: State = from_slice(\u0026store.get(\u0026config_key_raw).unwrap().0.unwrap()).unwrap();\n        assert_eq!(\n            state,\n            State {\n                arbiter: api.canonical_address(\u0026HumanAddr::from(\"verifies\")).unwrap(),\n                recipient: api.canonical_address(\u0026HumanAddr::from(\"benefits\")).unwrap(),\n                source: api.canonical_address(\u0026HumanAddr::from(\"creator\")).unwrap(),\n                end_height: Some(1000),\n                end_time: None,\n            }\n        );\n        Ok(())\n    })\n    .unwrap();\n}\n\n#[test]\nfn cannot_initialize_expired() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let msg = init_msg_expire_by_height(1000);\n    let env = mock_env_height(\u0026deps.api, \"creator\", \u0026coins(1000, \"earth\"), 1001, 0);\n    let res: InitResult = init(\u0026mut deps, env, msg);\n    match res.unwrap_err() {\n        StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"creating expired escrow\"),\n        e =\u003e panic!(\"unexpected error: {:?}\", e),\n    }\n}\n\n#[test]\nfn handle_approve() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    // initialize the store\n    let init_amount = coins(1000, \"earth\");\n    let init_env = mock_env_height(\u0026deps.api, \"creator\", \u0026init_amount, 876, 0);\n    let contract_addr = deps.api.human_address(\u0026init_env.contract.address).unwrap();\n    let msg = init_msg_expire_by_height(1000);\n    let init_res: InitResponse = init(\u0026mut deps, init_env, msg).unwrap();\n    assert_eq!(0, init_res.messages.len());\n\n    // balance changed in init\n    deps.with_querier(|querier| {\n        querier.update_balance(\u0026contract_addr, init_amount);\n        Ok(())\n    })\n    .unwrap();\n\n    // beneficiary cannot release it\n    let msg = HandleMsg::Approve { quantity: None };\n    let env = mock_env_height(\u0026deps.api, \"beneficiary\", \u0026[], 900, 0);\n    let handle_res: HandleResult = handle(\u0026mut deps, env, msg.clone());\n    match handle_res.unwrap_err() {\n        StdError::Unauthorized { .. } =\u003e {}\n        e =\u003e panic!(\"unexpected error: {:?}\", e),\n    }\n\n    // verifier cannot release it when expired\n    let env = mock_env_height(\u0026deps.api, \"verifies\", \u0026[], 1100, 0);\n    let handle_res: HandleResult = handle(\u0026mut deps, env, msg.clone());\n    match handle_res.unwrap_err() {\n        StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"escrow expired\"),\n        e =\u003e panic!(\"unexpected error: {:?}\", e),\n    }\n\n    // complete release by verfier, before expiration\n    let env = mock_env_height(\u0026deps.api, \"verifies\", \u0026[], 999, 0);\n    let handle_res: HandleResponse = handle(\u0026mut deps, env, msg.clone()).unwrap();\n    assert_eq!(1, handle_res.messages.len());\n    let msg = handle_res.messages.get(0).expect(\"no message\");\n    assert_eq!(\n        msg,\n        \u0026CosmosMsg::Bank(BankMsg::Send {\n            from_address: HumanAddr::from(\"cosmos2contract\"),\n            to_address: HumanAddr::from(\"benefits\"),\n            amount: coins(1000, \"earth\"),\n        })\n    );\n\n    // partial release by verfier, before expiration\n    let partial_msg = HandleMsg::Approve {\n        quantity: Some(coins(500, \"earth\")),\n    };\n    let env = mock_env_height(\u0026deps.api, \"verifies\", \u0026[], 999, 0);\n    let handle_res: HandleResponse = handle(\u0026mut deps, env, partial_msg).unwrap();\n    assert_eq!(1, handle_res.messages.len());\n    let msg = handle_res.messages.get(0).expect(\"no message\");\n    assert_eq!(\n        msg,\n        \u0026CosmosMsg::Bank(BankMsg::Send {\n            from_address: HumanAddr::from(\"cosmos2contract\"),\n            to_address: HumanAddr::from(\"benefits\"),\n            amount: coins(500, \"earth\"),\n        })\n    );\n}\n\n#[test]\nfn handle_refund() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    // initialize the store\n    let init_amount = coins(1000, \"earth\");\n    let init_env = mock_env_height(\u0026deps.api, \"creator\", \u0026init_amount, 876, 0);\n    let contract_addr = deps.api.human_address(\u0026init_env.contract.address).unwrap();\n    let msg = init_msg_expire_by_height(1000);\n    let init_res: InitResponse = init(\u0026mut deps, init_env, msg).unwrap();\n    assert_eq!(0, init_res.messages.len());\n\n    deps.with_querier(|querier| {\n        querier.update_balance(\u0026contract_addr, init_amount);\n        Ok(())\n    })\n    .unwrap();\n\n    // cannot release when unexpired\n    let msg = HandleMsg::Refund {};\n    let env = mock_env_height(\u0026deps.api, \"anybody\", \u0026[], 800, 0);\n    let handle_res: HandleResult = handle(\u0026mut deps, env, msg.clone());\n    match handle_res.unwrap_err() {\n        StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"escrow not yet expired\"),\n        e =\u003e panic!(\"unexpected error: {:?}\", e),\n    }\n\n    // anyone can release after expiration\n    let env = mock_env_height(\u0026deps.api, \"anybody\", \u0026[], 1001, 0);\n    let handle_res: HandleResponse = handle(\u0026mut deps, env, msg.clone()).unwrap();\n    assert_eq!(1, handle_res.messages.len());\n    let msg = handle_res.messages.get(0).expect(\"no message\");\n    assert_eq!(\n        msg,\n        \u0026CosmosMsg::Bank(BankMsg::Send {\n            from_address: HumanAddr::from(\"cosmos2contract\"),\n            to_address: HumanAddr::from(\"creator\"),\n            amount: coins(1000, \"earth\"),\n        })\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","gov","src","contract.rs"],"content":"use cosmwasm_std::{\n    log, to_binary, Api, Binary, CosmosMsg, Env, Extern, GovMsg, GovQuery, HandleResponse,\n    HumanAddr, InitResponse, InitResult, ProposalsResponse, Querier, StdResult, Storage,\n    VoteOption,\n};\n\nuse crate::msg::{HandleMsg, InitMsg};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    _msg: InitMsg,\n) -\u003e InitResult {\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Proposals {} =\u003e try_query_proposal(deps, env),\n        HandleMsg::Vote {} =\u003e try_vote(deps, env),\n    }\n}\n\npub fn try_vote\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    Ok(HandleResponse {\n        messages: vec![CosmosMsg::Gov(GovMsg::Vote {\n            proposal: 1,\n            vote_option: VoteOption::Yes,\n        })],\n        log: vec![],\n        data: None,\n    })\n}\n\npub fn try_query_proposal\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let query = GovQuery::Proposals {};\n\n    let query_rewards: ProposalsResponse = deps\n        .querier\n        .query(\u0026query.into())\n        .unwrap_or_else(|_| ProposalsResponse { proposals: vec![] });\n\n    let active_proposal = query_rewards.proposals.len() as u64;\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(Binary::from(active_proposal.to_be_bytes().to_vec())),\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","gov","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        // do_query(\n        //     \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        //     msg_ptr,\n        // )\n        0\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","gov","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Binary, CosmosMsg, HumanAddr, QueryRequest};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    Proposals {},\n    Vote {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","hackatom","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\nuse cosmwasm_std::BalanceResponse;\n\nuse hackatom::contract::{HandleMsg, InitMsg, MigrateMsg, QueryMsg, State, VerifierResponse};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(MigrateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(State), \u0026out_dir);\n    export_schema(\u0026schema_for!(VerifierResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(BalanceResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","hackatom","src","contract.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\nuse std::convert::TryInto;\n\nuse cosmwasm_std::{\n    from_slice, to_binary, to_vec, AllBalanceResponse, Api, BankMsg, Binary, CanonicalAddr,\n    Context, Env, Extern, HandleResponse, HumanAddr, InitResponse, MigrateResponse, Querier,\n    QueryRequest, QueryResponse, StdError, StdResult, Storage, WasmQuery,\n};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n    pub verifier: HumanAddr,\n    pub beneficiary: HumanAddr,\n}\n\n/// MigrateMsg allows a priviledged contract administrator to run\n/// a migration on the contract. In this (demo) case it is just migrating\n/// from one hackatom code to the same code, but taking advantage of the\n/// migration step to set a new validator.\n///\n/// Note that the contract doesn't enforce permissions here, this is done\n/// by blockchain logic (in the future by blockchain governance)\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct MigrateMsg {\n    pub verifier: HumanAddr,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct State {\n    pub verifier: CanonicalAddr,\n    pub beneficiary: CanonicalAddr,\n    pub funder: CanonicalAddr,\n}\n\n// failure modes to help test wasmd, based on this comment\n// https://github.com/cosmwasm/wasmd/issues/8#issuecomment-576146751\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    /// Releasing all funds in the contract to the beneficiary. This is the only \"proper\" action of this demo contract.\n    Release {},\n    /// Infinite loop to burn cpu cycles (only run when metering is enabled)\n    CpuLoop {},\n    /// Infinite loop making storage calls (to test when their limit hits)\n    StorageLoop {},\n    /// Infinite loop reading and writing memory\n    MemoryLoop {},\n    /// Allocate large amounts of memory without consuming much gas\n    AllocateLargeMemory {},\n    /// Trigger a panic to ensure framework handles gracefully\n    Panic {},\n    /// Starting with CosmWasm 0.10, some API calls return user errors back to the contract.\n    /// This triggers such user errors, ensuring the transaction does not fail in the backend.\n    UserErrorsInApiCalls {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    /// returns a human-readable representation of the verifier\n    /// use to ensure query path works in integration tests\n    Verifier {},\n    /// This returns cosmwasm_std::AllBalanceResponse to demo use of the querier\n    OtherBalance { address: HumanAddr },\n    /// Recurse will execute a query into itself up to depth-times and return\n    /// Each step of the recursion may perform some extra work to test gas metering\n    /// (`work` rounds of sha256 on contract).\n    /// Contract should be the set to be the address of the original contract,\n    /// we pass it in as query doesn't have access to env.\n    Recurse {\n        depth: u32,\n        work: u32,\n        contract: HumanAddr,\n        contract_code_hash: String,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct VerifierResponse {\n    pub verifier: HumanAddr,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct RecurseResponse {\n    /// hashed is the result of running sha256 \"work+1\" times on the contract's human address\n    pub hashed: Binary,\n}\n\npub const CONFIG_KEY: \u0026[u8] = b\"config\";\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    deps.storage.set(\n        CONFIG_KEY,\n        \u0026to_vec(\u0026State {\n            verifier: deps.api.canonical_address(\u0026msg.verifier)?,\n            beneficiary: deps.api.canonical_address(\u0026msg.beneficiary)?,\n            funder: deps.api.canonical_address(\u0026env.message.sender)?,\n        })?,\n    );\n\n    // This adds some unrelated log for testing purposes\n    let mut ctx = Context::new();\n    ctx.add_log(\"Let the\", \"hacking begin\");\n    ctx.try_into()\n}\n\npub fn migrate\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    msg: MigrateMsg,\n) -\u003e StdResult\u003cMigrateResponse\u003e {\n    let data = deps\n        .storage\n        .get(CONFIG_KEY)\n        .ok_or_else(|| StdError::not_found(\"State\"))?;\n    let mut config: State = from_slice(\u0026data)?;\n    config.verifier = deps.api.canonical_address(\u0026msg.verifier)?;\n    deps.storage.set(CONFIG_KEY, \u0026to_vec(\u0026config)?);\n\n    Ok(MigrateResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Release {} =\u003e do_release(deps, env),\n        HandleMsg::CpuLoop {} =\u003e do_cpu_loop(),\n        HandleMsg::StorageLoop {} =\u003e do_storage_loop(deps),\n        HandleMsg::MemoryLoop {} =\u003e do_memory_loop(),\n        HandleMsg::AllocateLargeMemory {} =\u003e do_allocate_large_memory(),\n        HandleMsg::Panic {} =\u003e do_panic(),\n        HandleMsg::UserErrorsInApiCalls {} =\u003e do_user_errors_in_api_calls(\u0026deps.api),\n    }\n}\n\nfn do_release\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let data = deps\n        .storage\n        .get(CONFIG_KEY)\n        .ok_or_else(|| StdError::not_found(\"State\"))?;\n    let state: State = from_slice(\u0026data)?;\n\n    if deps.api.canonical_address(\u0026env.message.sender)? == state.verifier {\n        let to_addr = deps.api.human_address(\u0026state.beneficiary)?;\n        let balance = deps.querier.query_all_balances(\u0026env.contract.address)?;\n\n        let mut ctx = Context::new();\n        ctx.add_log(\"action\", \"release\");\n        ctx.add_log(\"destination\", \u0026to_addr);\n        ctx.add_message(BankMsg::Send {\n            from_address: env.contract.address,\n            to_address: to_addr,\n            amount: balance,\n        });\n        ctx.set_data(\u0026[0xF0, 0x0B, 0xAA]);\n        Ok(ctx.into())\n    } else {\n        Err(StdError::unauthorized())\n    }\n}\n\nfn do_cpu_loop() -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut counter = 0u64;\n    loop {\n        counter += 1;\n        if counter \u003e= 9_000_000_000 {\n            counter = 0;\n        }\n    }\n}\n\nfn do_storage_loop\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut test_case = 0u64;\n    loop {\n        deps.storage\n            .set(b\"test.key\", test_case.to_string().as_bytes());\n        test_case += 1;\n    }\n}\n\nfn do_memory_loop() -\u003e StdResult\u003cHandleResponse\u003e {\n    let mut data = vec![1usize];\n    loop {\n        // add one element\n        data.push((*data.last().expect(\"must not be empty\")) + 1);\n    }\n}\n\nfn do_allocate_large_memory() -\u003e StdResult\u003cHandleResponse\u003e {\n    // We create memory pages explicitely since Rust's default allocator seems to be clever enough\n    // to not grow memory for unused capacity like `Vec::\u003cu8\u003e::with_capacity(100 * 1024 * 1024)`.\n    // Even with std::alloc::alloc the memory did now grow beyond 1.5 MiB.\n\n    #[cfg(target_arch = \"wasm32\")]\n    {\n        use core::arch::wasm32;\n        let pages = 1_600; // 100 MiB\n        let ptr = wasm32::memory_grow(0, pages);\n        if ptr == usize::max_value() {\n            return Err(StdError::generic_err(\"Error in memory.grow instruction\"));\n        }\n        Ok(HandleResponse::default())\n    }\n\n    #[cfg(not(target_arch = \"wasm32\"))]\n    Err(StdError::generic_err(\"Unsupported architecture\"))\n}\n\nfn do_panic() -\u003e StdResult\u003cHandleResponse\u003e {\n    panic!(\"This page intentionally faulted\");\n}\n\nfn do_user_errors_in_api_calls\u003cA: Api\u003e(api: \u0026A) -\u003e StdResult\u003cHandleResponse\u003e {\n    // Canonicalize\n\n    let empty = HumanAddr::from(\"\");\n    match api.canonical_address(\u0026empty).unwrap_err() {\n        StdError::GenericErr { .. } =\u003e {}\n        err =\u003e {\n            return Err(StdError::generic_err(format!(\n                \"Unexpected error in do_user_errors_in_api_calls: {:?}\",\n                err\n            )))\n        }\n    }\n\n    let invalid_bech32 = HumanAddr::from(\"bn93hg934hg08q340g8u4jcau3\");\n    match api.canonical_address(\u0026invalid_bech32).unwrap_err() {\n        StdError::GenericErr { .. } =\u003e {}\n        err =\u003e {\n            return Err(StdError::generic_err(format!(\n                \"Unexpected error in do_user_errors_in_api_calls: {:?}\",\n                err\n            )))\n        }\n    }\n\n    // Humanize\n\n    let empty: CanonicalAddr = vec![].into();\n    match api.human_address(\u0026empty).unwrap_err() {\n        StdError::GenericErr { .. } =\u003e {}\n        err =\u003e {\n            return Err(StdError::generic_err(format!(\n                \"Unexpected error in do_user_errors_in_api_calls: {:?}\",\n                err\n            )))\n        }\n    }\n\n    let too_short: CanonicalAddr = vec![0xAA, 0xBB, 0xCC].into();\n    match api.human_address(\u0026too_short).unwrap_err() {\n        StdError::GenericErr { .. } =\u003e {}\n        err =\u003e {\n            return Err(StdError::generic_err(format!(\n                \"Unexpected error in do_user_errors_in_api_calls: {:?}\",\n                err\n            )))\n        }\n    }\n\n    let wrong_length: CanonicalAddr = vec![0xA6; 17].into();\n    match api.human_address(\u0026wrong_length).unwrap_err() {\n        StdError::GenericErr { .. } =\u003e {}\n        err =\u003e {\n            return Err(StdError::generic_err(format!(\n                \"Unexpected error in do_user_errors_in_api_calls: {:?}\",\n                err\n            )))\n        }\n    }\n\n    Ok(HandleResponse::default())\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cQueryResponse\u003e {\n    match msg {\n        QueryMsg::Verifier {} =\u003e to_binary(\u0026query_verifier(deps)?),\n        QueryMsg::OtherBalance { address } =\u003e to_binary(\u0026query_other_balance(deps, address)?),\n        QueryMsg::Recurse {\n            depth,\n            work,\n            contract,\n            contract_code_hash,\n        } =\u003e to_binary(\u0026query_recurse(\n            deps,\n            depth,\n            work,\n            contract,\n            contract_code_hash,\n        )?),\n    }\n}\n\nfn query_verifier\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e StdResult\u003cVerifierResponse\u003e {\n    let data = deps\n        .storage\n        .get(CONFIG_KEY)\n        .ok_or_else(|| StdError::not_found(\"State\"))?;\n    let state: State = from_slice(\u0026data)?;\n    let addr = deps.api.human_address(\u0026state.verifier)?;\n    Ok(VerifierResponse { verifier: addr })\n}\n\nfn query_other_balance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    address: HumanAddr,\n) -\u003e StdResult\u003cAllBalanceResponse\u003e {\n    let amount = deps.querier.query_all_balances(address)?;\n    Ok(AllBalanceResponse { amount })\n}\n\nfn query_recurse\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    depth: u32,\n    work: u32,\n    contract: HumanAddr,\n    contract_code_hash: String,\n) -\u003e StdResult\u003cRecurseResponse\u003e {\n    // perform all hashes as requested\n    let mut hashed: Vec\u003cu8\u003e = contract.as_str().as_bytes().to_vec();\n    for _ in 0..work {\n        hashed = Sha256::digest(\u0026hashed).to_vec()\n    }\n\n    // the last contract should return the response\n    if depth == 0 {\n        Ok(RecurseResponse {\n            hashed: hashed.into(),\n        })\n    } else {\n        // otherwise, we go one level deeper and return the response of the next level\n        let req = QueryMsg::Recurse {\n            depth: depth - 1,\n            work,\n            contract: contract.clone(),\n            contract_code_hash: contract_code_hash.clone(),\n        };\n        let query = QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: contract,\n            msg: to_binary(\u0026req)?,\n            callback_code_hash: contract_code_hash.clone(),\n        });\n        deps.querier.query(\u0026query)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::{\n        mock_dependencies, mock_dependencies_with_balances, mock_env, MOCK_CONTRACT_ADDR,\n    };\n    // import trait ReadonlyStorage to get access to read\n    use cosmwasm_std::{coins, log, ReadonlyStorage, StdError};\n\n    #[test]\n    fn proper_initialization() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        let verifier = HumanAddr(String::from(\"verifies\"));\n        let beneficiary = HumanAddr(String::from(\"benefits\"));\n        let creator = HumanAddr(String::from(\"creator\"));\n        let expected_state = State {\n            verifier: deps.api.canonical_address(\u0026verifier).unwrap(),\n            beneficiary: deps.api.canonical_address(\u0026beneficiary).unwrap(),\n            funder: deps.api.canonical_address(\u0026creator).unwrap(),\n        };\n\n        let msg = InitMsg {\n            verifier,\n            beneficiary,\n        };\n        let env = mock_env(creator.as_str(), \u0026[]);\n        let res = init(\u0026mut deps, env, msg).unwrap();\n        assert_eq!(res.messages.len(), 0);\n        assert_eq!(res.log.len(), 1);\n        assert_eq!(res.log[0].key, \"Let the\");\n        assert_eq!(res.log[0].value, \"hacking begin\");\n\n        // it worked, let's check the state\n        let data = deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n        let state: State = from_slice(\u0026data).unwrap();\n        assert_eq!(state, expected_state);\n    }\n\n    #[test]\n    fn init_and_query() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        let verifier = HumanAddr(String::from(\"verifies\"));\n        let beneficiary = HumanAddr(String::from(\"benefits\"));\n        let creator = HumanAddr(String::from(\"creator\"));\n        let msg = InitMsg {\n            verifier: verifier.clone(),\n            beneficiary,\n        };\n        let env = mock_env(creator.as_str(), \u0026[]);\n        let res = init(\u0026mut deps, env, msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // now let's query\n        let query_response = query_verifier(\u0026deps).unwrap();\n        assert_eq!(query_response.verifier, verifier);\n    }\n\n    #[test]\n    fn migrate_verifier() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        let verifier = HumanAddr::from(\"verifies\");\n        let beneficiary = HumanAddr::from(\"benefits\");\n        let creator = HumanAddr::from(\"creator\");\n        let msg = InitMsg {\n            verifier: verifier.clone(),\n            beneficiary,\n        };\n        let env = mock_env(creator.as_str(), \u0026[]);\n        let res = init(\u0026mut deps, env, msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // check it is 'verifies'\n        let query_response = query(\u0026deps, QueryMsg::Verifier {}).unwrap();\n        assert_eq!(query_response.as_slice(), b\"{\\\"verifier\\\":\\\"verifies\\\"}\");\n\n        // change the verifier via migrate\n        let new_verifier = HumanAddr::from(\"someone else\");\n        let msg = MigrateMsg {\n            verifier: new_verifier.clone(),\n        };\n        let env = mock_env(creator.as_str(), \u0026[]);\n        let res = migrate(\u0026mut deps, env, msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // check it is 'someone else'\n        let query_response = query_verifier(\u0026deps).unwrap();\n        assert_eq!(query_response.verifier, new_verifier);\n    }\n\n    #[test]\n    fn querier_callbacks_work() {\n        let rich_addr = HumanAddr::from(\"foobar\");\n        let rich_balance = coins(10000, \"gold\");\n        let deps = mock_dependencies_with_balances(20, \u0026[(\u0026rich_addr, \u0026rich_balance)]);\n\n        // querying with balance gets the balance\n        let bal = query_other_balance(\u0026deps, rich_addr).unwrap();\n        assert_eq!(bal.amount, rich_balance);\n\n        // querying other accounts gets none\n        let bal = query_other_balance(\u0026deps, HumanAddr::from(\"someone else\")).unwrap();\n        assert_eq!(bal.amount, vec![]);\n    }\n\n    #[test]\n    fn handle_release_works() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        // initialize the store\n        let creator = HumanAddr::from(\"creator\");\n        let verifier = HumanAddr::from(\"verifies\");\n        let beneficiary = HumanAddr::from(\"benefits\");\n\n        let init_msg = InitMsg {\n            verifier: verifier.clone(),\n            beneficiary: beneficiary.clone(),\n        };\n        let init_amount = coins(1000, \"earth\");\n        let init_env = mock_env(creator.as_str(), \u0026init_amount);\n        let contract_addr = init_env.contract.address.clone();\n        let init_res = init(\u0026mut deps, init_env, init_msg).unwrap();\n        assert_eq!(init_res.messages.len(), 0);\n\n        // balance changed in init\n        deps.querier.update_balance(\u0026contract_addr, init_amount);\n\n        // beneficiary can release it\n        let handle_env = mock_env(verifier.as_str(), \u0026[]);\n        let handle_res = handle(\u0026mut deps, handle_env, HandleMsg::Release {}).unwrap();\n        assert_eq!(handle_res.messages.len(), 1);\n        let msg = handle_res.messages.get(0).expect(\"no message\");\n        assert_eq!(\n            msg,\n            \u0026BankMsg::Send {\n                from_address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n                to_address: beneficiary,\n                amount: coins(1000, \"earth\"),\n            }\n            .into(),\n        );\n        assert_eq!(\n            handle_res.log,\n            vec![log(\"action\", \"release\"), log(\"destination\", \"benefits\"),],\n        );\n        assert_eq!(handle_res.data, Some(vec![0xF0, 0x0B, 0xAA].into()));\n    }\n\n    #[test]\n    fn handle_release_fails_for_wrong_sender() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        // initialize the store\n        let creator = HumanAddr::from(\"creator\");\n        let verifier = HumanAddr::from(\"verifies\");\n        let beneficiary = HumanAddr::from(\"benefits\");\n\n        let init_msg = InitMsg {\n            verifier: verifier.clone(),\n            beneficiary: beneficiary.clone(),\n        };\n        let init_amount = coins(1000, \"earth\");\n        let init_env = mock_env(creator.as_str(), \u0026init_amount);\n        let contract_addr = init_env.contract.address.clone();\n        let init_res = init(\u0026mut deps, init_env, init_msg).unwrap();\n        assert_eq!(init_res.messages.len(), 0);\n\n        // balance changed in init\n        deps.querier.update_balance(\u0026contract_addr, init_amount);\n\n        // beneficiary cannot release it\n        let handle_env = mock_env(beneficiary.as_str(), \u0026[]);\n        let handle_res = handle(\u0026mut deps, handle_env, HandleMsg::Release {});\n        match handle_res.unwrap_err() {\n            StdError::Unauthorized { .. } =\u003e {}\n            _ =\u003e panic!(\"Expect unauthorized error\"),\n        }\n\n        // state should not change\n        let data = deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n        let state: State = from_slice(\u0026data).unwrap();\n        assert_eq!(\n            state,\n            State {\n                verifier: deps.api.canonical_address(\u0026verifier).unwrap(),\n                beneficiary: deps.api.canonical_address(\u0026beneficiary).unwrap(),\n                funder: deps.api.canonical_address(\u0026creator).unwrap(),\n            }\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"This page intentionally faulted\")]\n    fn handle_panic() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        // initialize the store\n        let verifier = HumanAddr(String::from(\"verifies\"));\n        let beneficiary = HumanAddr(String::from(\"benefits\"));\n        let creator = HumanAddr(String::from(\"creator\"));\n\n        let init_msg = InitMsg {\n            verifier: verifier.clone(),\n            beneficiary: beneficiary.clone(),\n        };\n        let init_env = mock_env(creator.as_str(), \u0026coins(1000, \"earth\"));\n        let init_res = init(\u0026mut deps, init_env, init_msg).unwrap();\n        assert_eq!(0, init_res.messages.len());\n\n        let handle_env = mock_env(beneficiary.as_str(), \u0026[]);\n        // this should panic\n        let _ = handle(\u0026mut deps, handle_env, HandleMsg::Panic {});\n    }\n\n    #[test]\n    fn handle_user_errors_in_api_calls() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n\n        let init_msg = InitMsg {\n            verifier: HumanAddr::from(\"verifies\"),\n            beneficiary: HumanAddr::from(\"benefits\"),\n        };\n        let init_env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        let init_res = init(\u0026mut deps, init_env, init_msg).unwrap();\n        assert_eq!(0, init_res.messages.len());\n\n        let handle_env = mock_env(\"anyone\", \u0026[]);\n        handle(\u0026mut deps, handle_env, HandleMsg::UserErrorsInApiCalls {}).unwrap();\n    }\n\n    #[test]\n    fn query_recursive() {\n        // the test framework doesn't handle contracts querying contracts yet,\n        // let's just make sure the last step looks right\n\n        let deps = mock_dependencies(20, \u0026[]);\n        let contract = HumanAddr::from(\"my-contract\");\n        let bin_contract: \u0026[u8] = b\"my-contract\";\n\n        // return the unhashed value here\n        let no_work_query = query_recurse(\u0026deps, 0, 0, contract.clone()).unwrap();\n        assert_eq!(no_work_query.hashed, Binary::from(bin_contract));\n\n        // let's see if 5 hashes are done right\n        let mut expected_hash = Sha256::digest(bin_contract);\n        for _ in 0..4 {\n            expected_hash = Sha256::digest(\u0026expected_hash);\n        }\n        let work_query = query_recurse(\u0026deps, 0, 5, contract).unwrap();\n        assert_eq!(work_query.hashed, expected_hash.to_vec().into());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","hackatom","src","lib.rs"],"content":"pub mod contract;\n\n#[cfg(target_arch = \"wasm32\")]\ncosmwasm_std::create_entry_points_with_migration!(contract);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","hackatom","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests as follows:\n//! 1. Copy them over verbatim\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n\nuse cosmwasm_std::{\n    coins, from_binary, log, to_vec, AllBalanceResponse, BankMsg, Empty, HandleResponse,\n    HandleResult, HumanAddr, InitResponse, InitResult, MigrateResponse, StdError,\n};\nuse cosmwasm_vm::{\n    call_handle, from_slice,\n    testing::{\n        handle, init, migrate, mock_env, mock_instance, mock_instance_with_balances, query,\n        test_io, MOCK_CONTRACT_ADDR,\n    },\n    Api, Storage, VmError,\n};\n\nuse hackatom::contract::{HandleMsg, InitMsg, MigrateMsg, QueryMsg, State, CONFIG_KEY};\n\nstatic WASM: \u0026[u8] = include_bytes!(\"../target/wasm32-unknown-unknown/release/hackatom.wasm\");\n\nfn make_init_msg() -\u003e (InitMsg, HumanAddr) {\n    let verifier = HumanAddr::from(\"verifies\");\n    let beneficiary = HumanAddr::from(\"benefits\");\n    let creator = HumanAddr::from(\"creator\");\n    (\n        InitMsg {\n            verifier: verifier.clone(),\n            beneficiary: beneficiary.clone(),\n        },\n        creator,\n    )\n}\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n    assert_eq!(deps.required_features.len(), 0);\n\n    let verifier = HumanAddr(String::from(\"verifies\"));\n    let beneficiary = HumanAddr(String::from(\"benefits\"));\n    let creator = HumanAddr(String::from(\"creator\"));\n    let expected_state = State {\n        verifier: deps.api.canonical_address(\u0026verifier).0.unwrap(),\n        beneficiary: deps.api.canonical_address(\u0026beneficiary).0.unwrap(),\n        funder: deps.api.canonical_address(\u0026creator).0.unwrap(),\n    };\n\n    let msg = InitMsg {\n        verifier,\n        beneficiary,\n    };\n    let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n    let res: InitResponse = init(\u0026mut deps, env, msg).unwrap();\n    assert_eq!(res.messages.len(), 0);\n    assert_eq!(res.log.len(), 1);\n    assert_eq!(res.log[0].key, \"Let the\");\n    assert_eq!(res.log[0].value, \"hacking begin\");\n\n    // it worked, let's check the state\n    let state: State = deps\n        .with_storage(|store| {\n            let data = store\n                .get(CONFIG_KEY)\n                .0\n                .expect(\"error reading db\")\n                .expect(\"no data stored\");\n            from_slice(\u0026data)\n        })\n        .unwrap();\n    assert_eq!(state, expected_state);\n}\n\n#[test]\nfn init_and_query() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let verifier = HumanAddr(String::from(\"verifies\"));\n    let beneficiary = HumanAddr(String::from(\"benefits\"));\n    let creator = HumanAddr(String::from(\"creator\"));\n    let msg = InitMsg {\n        verifier: verifier.clone(),\n        beneficiary,\n    };\n    let env = mock_env(creator.as_str(), \u0026coins(1000, \"earth\"));\n    let res: InitResponse = init(\u0026mut deps, env, msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // now let's query\n    let query_response = query(\u0026mut deps, QueryMsg::Verifier {}).unwrap();\n    assert_eq!(query_response.as_slice(), b\"{\\\"verifier\\\":\\\"verifies\\\"}\");\n\n    // bad query returns parse error (pass wrong type - this connection is not enforced)\n    let qres = query(\u0026mut deps, HandleMsg::Release {});\n    match qres.unwrap_err() {\n        StdError::ParseErr { .. } =\u003e {}\n        _ =\u003e panic!(\"Expected parse error\"),\n    }\n}\n\n#[test]\nfn migrate_verifier() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let verifier = HumanAddr::from(\"verifies\");\n    let beneficiary = HumanAddr::from(\"benefits\");\n    let creator = HumanAddr::from(\"creator\");\n    let msg = InitMsg {\n        verifier: verifier.clone(),\n        beneficiary,\n    };\n    let env = mock_env(creator.as_str(), \u0026[]);\n    let res: InitResponse = init(\u0026mut deps, env, msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // check it is 'verifies'\n    let query_response = query(\u0026mut deps, QueryMsg::Verifier {}).unwrap();\n    assert_eq!(query_response.as_slice(), b\"{\\\"verifier\\\":\\\"verifies\\\"}\");\n\n    // change the verifier via migrate\n    let msg = MigrateMsg {\n        verifier: HumanAddr::from(\"someone else\"),\n    };\n    let env = mock_env(creator.as_str(), \u0026[]);\n    let res: MigrateResponse = migrate(\u0026mut deps, env, msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // check it is 'someone else'\n    let query_response = query(\u0026mut deps, QueryMsg::Verifier {}).unwrap();\n    assert_eq!(\n        query_response.as_slice(),\n        b\"{\\\"verifier\\\":\\\"someone else\\\"}\"\n    );\n}\n\n#[test]\nfn querier_callbacks_work() {\n    let rich_addr = HumanAddr::from(\"foobar\");\n    let rich_balance = coins(10000, \"gold\");\n    let mut deps = mock_instance_with_balances(WASM, \u0026[(\u0026rich_addr, \u0026rich_balance)]);\n\n    // querying with balance gets the balance\n    let query_msg = QueryMsg::OtherBalance { address: rich_addr };\n    let query_response = query(\u0026mut deps, query_msg).unwrap();\n    let bal: AllBalanceResponse = from_binary(\u0026query_response).unwrap();\n    assert_eq!(bal.amount, rich_balance);\n\n    // querying other accounts gets none\n    let query_msg = QueryMsg::OtherBalance {\n        address: HumanAddr::from(\"someone else\"),\n    };\n    let query_response = query(\u0026mut deps, query_msg).unwrap();\n    let bal: AllBalanceResponse = from_binary(\u0026query_response).unwrap();\n    assert_eq!(bal.amount, vec![]);\n}\n\n#[test]\nfn fails_on_bad_init() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n    let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n    // bad init returns parse error (pass wrong type - this connection is not enforced)\n    let res: InitResult = init(\u0026mut deps, env, HandleMsg::Release {});\n    match res.unwrap_err() {\n        StdError::ParseErr { .. } =\u003e {}\n        _ =\u003e panic!(\"Expected parse error\"),\n    }\n}\n\n#[test]\nfn handle_release_works() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    // initialize the store\n    let creator = HumanAddr::from(\"creator\");\n    let verifier = HumanAddr::from(\"verifies\");\n    let beneficiary = HumanAddr::from(\"benefits\");\n\n    let init_msg = InitMsg {\n        verifier: verifier.clone(),\n        beneficiary: beneficiary.clone(),\n    };\n    let init_amount = coins(1000, \"earth\");\n    let init_env = mock_env(creator.as_str(), \u0026init_amount);\n    let contract_addr = init_env.contract.address.clone();\n    let init_res: InitResponse = init(\u0026mut deps, init_env, init_msg).unwrap();\n    assert_eq!(init_res.messages.len(), 0);\n\n    // balance changed in init\n    deps.with_querier(|querier| {\n        querier.update_balance(\u0026contract_addr, init_amount);\n        Ok(())\n    })\n    .unwrap();\n\n    // beneficiary can release it\n    let handle_env = mock_env(verifier.as_str(), \u0026[]);\n    let handle_res: HandleResponse = handle(\u0026mut deps, handle_env, HandleMsg::Release {}).unwrap();\n    assert_eq!(handle_res.messages.len(), 1);\n    let msg = handle_res.messages.get(0).expect(\"no message\");\n    assert_eq!(\n        msg,\n        \u0026BankMsg::Send {\n            from_address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            to_address: beneficiary,\n            amount: coins(1000, \"earth\"),\n        }\n        .into(),\n    );\n    assert_eq!(\n        handle_res.log,\n        vec![log(\"action\", \"release\"), log(\"destination\", \"benefits\"),],\n    );\n    assert_eq!(handle_res.data, Some(vec![0xF0, 0x0B, 0xAA].into()));\n}\n\n#[test]\nfn handle_release_fails_for_wrong_sender() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    // initialize the store\n    let creator = HumanAddr::from(\"creator\");\n    let verifier = HumanAddr::from(\"verifies\");\n    let beneficiary = HumanAddr::from(\"benefits\");\n\n    let init_msg = InitMsg {\n        verifier: verifier.clone(),\n        beneficiary: beneficiary.clone(),\n    };\n    let init_amount = coins(1000, \"earth\");\n    let init_env = mock_env(creator.as_str(), \u0026init_amount);\n    let contract_addr = init_env.contract.address.clone();\n    let init_res: InitResponse = init(\u0026mut deps, init_env, init_msg).unwrap();\n    assert_eq!(init_res.messages.len(), 0);\n\n    // balance changed in init\n    deps.with_querier(|querier| {\n        querier.update_balance(\u0026contract_addr, init_amount);\n        Ok(())\n    })\n    .unwrap();\n\n    // beneficiary cannot release it\n    let handle_env = mock_env(beneficiary.as_str(), \u0026[]);\n    let handle_res: HandleResult = handle(\u0026mut deps, handle_env, HandleMsg::Release {});\n    match handle_res.unwrap_err() {\n        StdError::Unauthorized { .. } =\u003e {}\n        _ =\u003e panic!(\"Expect unauthorized error\"),\n    }\n\n    // state should not change\n    let data = deps\n        .with_storage(|store| {\n            Ok(store\n                .get(CONFIG_KEY)\n                .0\n                .expect(\"error reading db\")\n                .expect(\"no data stored\"))\n        })\n        .unwrap();\n    let state: State = from_slice(\u0026data).unwrap();\n    assert_eq!(\n        state,\n        State {\n            verifier: deps.api.canonical_address(\u0026verifier).0.unwrap(),\n            beneficiary: deps.api.canonical_address(\u0026beneficiary).0.unwrap(),\n            funder: deps.api.canonical_address(\u0026creator).0.unwrap(),\n        }\n    );\n}\n\n#[test]\nfn handle_panic() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let (init_msg, creator) = make_init_msg();\n    let init_env = mock_env(creator.as_str(), \u0026[]);\n    let init_res: InitResponse = init(\u0026mut deps, init_env, init_msg).unwrap();\n    assert_eq!(0, init_res.messages.len());\n\n    let handle_env = mock_env(creator.as_str(), \u0026[]);\n    // panic inside contract should not panic out here\n    // Note: we need to use the production-call, not the testing call (which unwraps any vm error)\n    let handle_res = call_handle::\u003c_, _, _, Empty\u003e(\n        \u0026mut deps,\n        \u0026handle_env,\n        \u0026to_vec(\u0026HandleMsg::Panic {}).unwrap(),\n    );\n    match handle_res.unwrap_err() {\n        // TODO: Don't accept GasDepletion here (https://github.com/CosmWasm/cosmwasm/issues/501)\n        VmError::RuntimeErr { .. } | VmError::GasDepletion =\u003e {}\n        err =\u003e panic!(\"Unexpected error: {:?}\", err),\n    }\n}\n\n#[test]\nfn handle_user_errors_in_api_calls() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let (init_msg, creator) = make_init_msg();\n    let init_env = mock_env(creator.as_str(), \u0026[]);\n    let _init_res: InitResponse = init(\u0026mut deps, init_env, init_msg).unwrap();\n\n    let handle_env = mock_env(creator.as_str(), \u0026[]);\n    let _handle_res: HandleResponse =\n        handle(\u0026mut deps, handle_env, HandleMsg::UserErrorsInApiCalls {}).unwrap();\n}\n\n#[test]\nfn passes_io_tests() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n    test_io(\u0026mut deps);\n}\n\n#[cfg(feature = \"singlepass\")]\nmod singlepass_tests {\n    use super::*;\n\n    #[test]\n    fn handle_cpu_loop() {\n        let mut deps = mock_instance(WASM, \u0026[]);\n\n        let (init_msg, creator) = make_init_msg();\n        let init_env = mock_env(creator.as_str(), \u0026[]);\n        let init_res: InitResponse = init(\u0026mut deps, init_env, init_msg).unwrap();\n        assert_eq!(0, init_res.messages.len());\n\n        let handle_env = mock_env(creator.as_str(), \u0026[]);\n        // Note: we need to use the production-call, not the testing call (which unwraps any vm error)\n        let handle_res = call_handle::\u003c_, _, _, Empty\u003e(\n            \u0026mut deps,\n            \u0026handle_env,\n            \u0026to_vec(\u0026HandleMsg::CpuLoop {}).unwrap(),\n        );\n        assert!(handle_res.is_err());\n        assert_eq!(deps.get_gas_left(), 0);\n    }\n\n    #[test]\n    fn handle_storage_loop() {\n        let mut deps = mock_instance(WASM, \u0026[]);\n\n        let (init_msg, creator) = make_init_msg();\n        let init_env = mock_env(creator.as_str(), \u0026[]);\n        let init_res: InitResponse = init(\u0026mut deps, init_env, init_msg).unwrap();\n        assert_eq!(0, init_res.messages.len());\n\n        let handle_env = mock_env(creator.as_str(), \u0026[]);\n        // Note: we need to use the production-call, not the testing call (which unwraps any vm error)\n        let handle_res = call_handle::\u003c_, _, _, Empty\u003e(\n            \u0026mut deps,\n            \u0026handle_env,\n            \u0026to_vec(\u0026HandleMsg::StorageLoop {}).unwrap(),\n        );\n        assert!(handle_res.is_err());\n        assert_eq!(deps.get_gas_left(), 0);\n    }\n\n    #[test]\n    fn handle_memory_loop() {\n        let mut deps = mock_instance(WASM, \u0026[]);\n\n        let (init_msg, creator) = make_init_msg();\n        let init_env = mock_env(creator.as_str(), \u0026[]);\n        let init_res: InitResponse = init(\u0026mut deps, init_env, init_msg).unwrap();\n        assert_eq!(0, init_res.messages.len());\n\n        let handle_env = mock_env(creator.as_str(), \u0026[]);\n        // Note: we need to use the production-call, not the testing call (which unwraps any vm error)\n        let handle_res = call_handle::\u003c_, _, _, Empty\u003e(\n            \u0026mut deps,\n            \u0026handle_env,\n            \u0026to_vec(\u0026HandleMsg::MemoryLoop {}).unwrap(),\n        );\n        assert!(handle_res.is_err());\n        assert_eq!(deps.get_gas_left(), 0);\n\n        // Ran out of gas before consuming a significant amount of memory\n        assert!(deps.get_memory_size() \u003c 2 * 1024 * 1024);\n    }\n\n    #[test]\n    fn handle_allocate_large_memory() {\n        let mut deps = mock_instance(WASM, \u0026[]);\n\n        let (init_msg, creator) = make_init_msg();\n        let init_env = mock_env(creator.as_str(), \u0026[]);\n        let init_res: InitResponse = init(\u0026mut deps, init_env, init_msg).unwrap();\n        assert_eq!(0, init_res.messages.len());\n\n        let handle_env = mock_env(creator.as_str(), \u0026[]);\n        let gas_before = deps.get_gas_left();\n        // Note: we need to use the production-call, not the testing call (which unwraps any vm error)\n        let handle_res = call_handle::\u003c_, _, _, Empty\u003e(\n            \u0026mut deps,\n            \u0026handle_env,\n            \u0026to_vec(\u0026HandleMsg::AllocateLargeMemory {}).unwrap(),\n        );\n        let gas_used = gas_before - deps.get_gas_left();\n\n        // TODO: this must fail, see https://github.com/CosmWasm/cosmwasm/issues/81\n        assert_eq!(handle_res.is_err(), false);\n\n        // Gas consumtion is relatively small\n        // Note: the exact gas usage depends on the Rust version used to compile WASM,\n        // which we only fix when using cosmwasm-opt, not integration tests.\n        let expected = 35000; // +/- 20%\n        assert!(gas_used \u003e expected * 80 / 100, \"Gas used: {}\", gas_used);\n        assert!(gas_used \u003c expected * 120 / 100, \"Gas used: {}\", gas_used);\n\n        // Used between 100 and 102 MiB of memory\n        assert!(deps.get_memory_size() \u003e 100 * 1024 * 1024);\n        assert!(deps.get_memory_size() \u003c 102 * 1024 * 1024);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","mint","src","contract.rs"],"content":"use cosmwasm_std::{\n    log, to_binary, Api, Binary, BondedRatioResponse, Coin, CosmosMsg, Env, Extern, HandleResponse,\n    HumanAddr, InflationResponse, InitResponse, InitResult, MintQuery, Querier, RewardsResponse,\n    StdResult, Storage, VoteOption,\n};\n\nuse crate::msg::{HandleMsg, InitMsg};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    _msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::InflationRate {} =\u003e try_inflation_rate(deps, env),\n        HandleMsg::BondedRatio {} =\u003e try_bonded_ratio(deps, env),\n    }\n}\n\npub fn try_inflation_rate\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let query = MintQuery::Inflation {};\n\n    let mut query_rewards: InflationResponse =\n        deps.querier\n            .query(\u0026query.into())\n            .unwrap_or_else(|_| InflationResponse {\n                inflation_rate: \"\".to_string(),\n            });\n\n    let active_proposal = query_rewards.inflation_rate.as_bytes().to_vec();\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(Binary::from(active_proposal)),\n    })\n}\n\npub fn try_bonded_ratio\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let query = MintQuery::BondedRatio {};\n\n    let mut query_rewards: BondedRatioResponse =\n        deps.querier\n            .query(\u0026query.into())\n            .unwrap_or_else(|_| BondedRatioResponse {\n                bonded_ratio: \"\".to_string(),\n            });\n\n    let active_proposal = query_rewards.bonded_ratio.as_bytes().to_vec();\n\n    Ok(HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(Binary::from(active_proposal)),\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","mint","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        // do_query(\n        //     \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        //     msg_ptr,\n        // )\n        0\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","mint","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Binary, CosmosMsg, HumanAddr, QueryRequest};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    InflationRate {},\n    BondedRatio {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","queue","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse queue::contract::{CountResponse, HandleMsg, InitMsg, Item, QueryMsg, SumResponse};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(Item), \u0026out_dir);\n    export_schema(\u0026schema_for!(CountResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(SumResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","queue","src","contract.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{\n    from_slice, to_binary, to_vec, Api, Binary, Env, Extern, HandleResponse, InitResponse, Order,\n    Querier, QueryResponse, StdResult, Storage,\n};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {}\n\n// we store one entry for each item in the queue\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Item {\n    pub value: i32,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    // Enqueue will add some value to the end of list\n    Enqueue { value: i32 },\n    // Dequeue will remove value from start of the list\n    Dequeue {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    // how many items are in the queue\n    Count {},\n    // total of all values in the queue\n    Sum {},\n    // Reducer holds open two iterators at once\n    Reducer {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct CountResponse {\n    pub count: u32,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct SumResponse {\n    pub sum: i32,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n// the Vec contains pairs for every element in the queue\n// (value of item i, sum of all elements where value \u003e value[i])\npub struct ReducerResponse {\n    pub counters: Vec\u003c(i32, i32)\u003e,\n}\n\n// init is a no-op, just empty data\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    _msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Enqueue { value } =\u003e enqueue(deps, env, value),\n        HandleMsg::Dequeue {} =\u003e dequeue(deps, env),\n    }\n}\n\nconst FIRST_KEY: u8 = 0;\n\nfn enqueue\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    value: i32,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    // find the last element in the queue and extract key\n    let last_item = deps.storage.range(None, None, Order::Descending).next();\n\n    let new_key = match last_item {\n        None =\u003e FIRST_KEY,\n        Some((key, _)) =\u003e {\n            key[0] + 1 // all keys are one byte\n        }\n    };\n    let new_value = to_vec(\u0026Item { value })?;\n\n    deps.storage.set(\u0026[new_key], \u0026new_value);\n    Ok(HandleResponse::default())\n}\n\nfn dequeue\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    // find the first element in the queue and extract value\n    let first = deps.storage.range(None, None, Order::Ascending).next();\n\n    let mut res = HandleResponse::default();\n    if let Some((key, value)) = first {\n        // remove from storage and return old value\n        deps.storage.remove(\u0026key);\n        res.data = Some(Binary(value));\n        Ok(res)\n    } else {\n        Ok(res)\n    }\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cQueryResponse\u003e {\n    match msg {\n        QueryMsg::Count {} =\u003e to_binary(\u0026query_count(deps)?),\n        QueryMsg::Sum {} =\u003e to_binary(\u0026query_sum(deps)?),\n        QueryMsg::Reducer {} =\u003e to_binary(\u0026query_reducer(deps)?),\n    }\n}\n\nfn query_count\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cCountResponse\u003e {\n    let count = deps.storage.range(None, None, Order::Ascending).count() as u32;\n    Ok(CountResponse { count })\n}\n\nfn query_sum\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cSumResponse\u003e {\n    let values: StdResult\u003cVec\u003cItem\u003e\u003e = deps\n        .storage\n        .range(None, None, Order::Ascending)\n        .map(|(_, v)| from_slice(\u0026v))\n        .collect();\n    let sum = values?.iter().fold(0, |s, v| s + v.value);\n    Ok(SumResponse { sum })\n}\n\nfn query_reducer\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e StdResult\u003cReducerResponse\u003e {\n    let mut out: Vec\u003c(i32, i32)\u003e = vec![];\n    // val: StdResult\u003cItem\u003e\n    for val in deps\n        .storage\n        .range(None, None, Order::Ascending)\n        .map(|(_, v)| from_slice::\u003cItem\u003e(\u0026v))\n    {\n        // this returns error on parse error\n        let my_val = val?.value;\n        // now, let's do second iterator\n        let sum: i32 = deps\n            .storage\n            .range(None, None, Order::Ascending)\n            // get value. ignore parse errors, just count as 0\n            .map(|(_, v)| {\n                from_slice::\u003cItem\u003e(\u0026v)\n                    .map(|v| v.value)\n                    .expect(\"error in item\")\n            })\n            .filter(|v| *v \u003e my_val)\n            .sum();\n        out.push((my_val, sum))\n    }\n    Ok(ReducerResponse { counters: out })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::coins;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, MockApi, MockQuerier, MockStorage};\n\n    fn create_contract() -\u003e (Extern\u003cMockStorage, MockApi, MockQuerier\u003e, Env) {\n        let mut deps = mock_dependencies(20, \u0026coins(1000, \"earth\"));\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        let res = init(\u0026mut deps, env.clone(), InitMsg {}).unwrap();\n        assert_eq!(0, res.messages.len());\n        (deps, env)\n    }\n\n    fn get_count(deps: \u0026Extern\u003cMockStorage, MockApi, MockQuerier\u003e) -\u003e u32 {\n        query_count(deps).unwrap().count\n    }\n\n    fn get_sum(deps: \u0026Extern\u003cMockStorage, MockApi, MockQuerier\u003e) -\u003e i32 {\n        query_sum(deps).unwrap().sum\n    }\n\n    #[test]\n    fn init_and_query() {\n        let (deps, _) = create_contract();\n        assert_eq!(get_count(\u0026deps), 0);\n        assert_eq!(get_sum(\u0026deps), 0);\n    }\n\n    #[test]\n    fn push_and_query() {\n        let (mut deps, env) = create_contract();\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 25 }).unwrap();\n        assert_eq!(get_count(\u0026deps), 1);\n        assert_eq!(get_sum(\u0026deps), 25);\n    }\n\n    #[test]\n    fn multiple_push() {\n        let (mut deps, env) = create_contract();\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 25 }).unwrap();\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 35 }).unwrap();\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 45 }).unwrap();\n        assert_eq!(get_count(\u0026deps), 3);\n        assert_eq!(get_sum(\u0026deps), 105);\n    }\n\n    #[test]\n    fn push_and_pop() {\n        let (mut deps, env) = create_contract();\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 25 }).unwrap();\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 17 }).unwrap();\n        let res = handle(\u0026mut deps, env.clone(), HandleMsg::Dequeue {}).unwrap();\n        // ensure we popped properly\n        assert!(res.data.is_some());\n        let data = res.data.unwrap();\n        let state: Item = from_slice(data.as_slice()).unwrap();\n        assert_eq!(state.value, 25);\n\n        assert_eq!(get_count(\u0026deps), 1);\n        assert_eq!(get_sum(\u0026deps), 17);\n    }\n\n    #[test]\n    fn push_and_reduce() {\n        let (mut deps, env) = create_contract();\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 40 }).unwrap();\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 15 }).unwrap();\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 85 }).unwrap();\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: -10 }).unwrap();\n        assert_eq!(get_count(\u0026deps), 4);\n        assert_eq!(get_sum(\u0026deps), 130);\n        let counters = query_reducer(\u0026deps).unwrap().counters;\n        assert_eq!(counters, vec![(40, 85), (15, 125), (85, 0), (-10, 140)]);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","queue","src","lib.rs"],"content":"pub mod contract;\n\n#[cfg(target_arch = \"wasm32\")]\ncosmwasm_std::create_entry_points!(contract);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","queue","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests as follows:\n//! 1. Copy them over verbatim\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n\nuse cosmwasm_std::{from_binary, from_slice, Env, HandleResponse, HumanAddr, InitResponse};\nuse cosmwasm_vm::{\n    testing::{handle, init, mock_env, mock_instance, query, MockApi, MockQuerier, MockStorage},\n    Instance,\n};\n\nuse queue::contract::{\n    CountResponse, HandleMsg, InitMsg, Item, QueryMsg, ReducerResponse, SumResponse,\n};\n\nstatic WASM: \u0026[u8] = include_bytes!(\"../target/wasm32-unknown-unknown/release/queue.wasm\");\n\nfn create_contract() -\u003e (Instance\u003cMockStorage, MockApi, MockQuerier\u003e, Env) {\n    let mut deps = mock_instance(WASM, \u0026[]);\n    let creator = HumanAddr(String::from(\"creator\"));\n    let env = mock_env(creator.as_str(), \u0026[]);\n    let res: InitResponse = init(\u0026mut deps, env.clone(), InitMsg {}).unwrap();\n    assert_eq!(0, res.messages.len());\n    (deps, env)\n}\n\nfn get_count(deps: \u0026mut Instance\u003cMockStorage, MockApi, MockQuerier\u003e) -\u003e u32 {\n    let data = query(deps, QueryMsg::Count {}).unwrap();\n    let res: CountResponse = from_binary(\u0026data).unwrap();\n    res.count\n}\n\nfn get_sum(deps: \u0026mut Instance\u003cMockStorage, MockApi, MockQuerier\u003e) -\u003e i32 {\n    let data = query(deps, QueryMsg::Sum {}).unwrap();\n    let res: SumResponse = from_binary(\u0026data).unwrap();\n    res.sum\n}\n\n#[test]\nfn init_and_query() {\n    let (mut deps, _) = create_contract();\n    assert_eq!(get_count(\u0026mut deps), 0);\n    assert_eq!(get_sum(\u0026mut deps), 0);\n}\n\n#[test]\nfn push_and_query() {\n    let (mut deps, env) = create_contract();\n    let _: HandleResponse =\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 25 }).unwrap();\n    assert_eq!(get_count(\u0026mut deps), 1);\n    assert_eq!(get_sum(\u0026mut deps), 25);\n}\n\n#[test]\nfn multiple_push() {\n    let (mut deps, env) = create_contract();\n    let _: HandleResponse =\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 25 }).unwrap();\n    let _: HandleResponse =\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 35 }).unwrap();\n    let _: HandleResponse =\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 45 }).unwrap();\n    assert_eq!(get_count(\u0026mut deps), 3);\n    assert_eq!(get_sum(\u0026mut deps), 105);\n}\n\n#[test]\nfn push_and_pop() {\n    let (mut deps, env) = create_contract();\n    let _: HandleResponse =\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 25 }).unwrap();\n    let _: HandleResponse =\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 17 }).unwrap();\n    let res: HandleResponse = handle(\u0026mut deps, env.clone(), HandleMsg::Dequeue {}).unwrap();\n    // ensure we popped properly\n    assert!(res.data.is_some());\n    let data = res.data.unwrap();\n    let item: Item = from_slice(data.as_slice()).unwrap();\n    assert_eq!(item.value, 25);\n\n    assert_eq!(get_count(\u0026mut deps), 1);\n    assert_eq!(get_sum(\u0026mut deps), 17);\n}\n\n#[test]\nfn push_and_reduce() {\n    let (mut deps, env) = create_contract();\n    let _: HandleResponse =\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 40 }).unwrap();\n    let _: HandleResponse =\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 15 }).unwrap();\n    let _: HandleResponse =\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: 85 }).unwrap();\n    let _: HandleResponse =\n        handle(\u0026mut deps, env.clone(), HandleMsg::Enqueue { value: -10 }).unwrap();\n    assert_eq!(get_count(\u0026mut deps), 4);\n    assert_eq!(get_sum(\u0026mut deps), 130);\n    let data = query(\u0026mut deps, QueryMsg::Reducer {}).unwrap();\n    let counters = from_binary::\u003cReducerResponse\u003e(\u0026data).unwrap().counters;\n    assert_eq!(counters, vec![(40, 85), (15, 125), (85, 0), (-10, 140)]);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","reflect","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\nuse cosmwasm_std::HandleResponse;\n\nuse reflect::msg::{CustomMsg, HandleMsg, InitMsg, OwnerResponse, QueryMsg};\nuse reflect::state::State;\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(CustomMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleResponse\u003cCustomMsg\u003e), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(State), \u0026out_dir);\n    export_schema(\u0026schema_for!(OwnerResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","reflect","src","contract.rs"],"content":"use cosmwasm_std::{\n    log, to_binary, Api, Binary, CosmosMsg, Env, Extern, HandleResponse, HumanAddr, InitResponse,\n    Querier, StdError, StdResult, Storage,\n};\n\nuse crate::msg::{\n    CustomMsg, CustomQuery, CustomResponse, HandleMsg, InitMsg, OwnerResponse, QueryMsg,\n};\nuse crate::state::{config, config_read, State};\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    _msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003cCustomMsg\u003e\u003e {\n    let state = State {\n        owner: deps.api.canonical_address(\u0026env.message.sender)?,\n    };\n\n    config(\u0026mut deps.storage).save(\u0026state)?;\n\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003cCustomMsg\u003e\u003e {\n    match msg {\n        HandleMsg::ReflectMsg { msgs } =\u003e try_reflect(deps, env, msgs),\n        HandleMsg::ChangeOwner { owner } =\u003e try_change_owner(deps, env, owner),\n    }\n}\n\npub fn try_reflect\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msgs: Vec\u003cCosmosMsg\u003cCustomMsg\u003e\u003e,\n) -\u003e StdResult\u003cHandleResponse\u003cCustomMsg\u003e\u003e {\n    let state = config(\u0026mut deps.storage).load()?;\n    if deps.api.canonical_address(\u0026env.message.sender)? != state.owner {\n        return Err(StdError::unauthorized());\n    }\n    if msgs.is_empty() {\n        return Err(StdError::generic_err(\"Must reflect at least one message\"));\n    }\n    let res = HandleResponse {\n        messages: msgs,\n        log: vec![log(\"action\", \"reflect\")],\n        data: None,\n    };\n    Ok(res)\n}\n\npub fn try_change_owner\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    owner: HumanAddr,\n) -\u003e StdResult\u003cHandleResponse\u003cCustomMsg\u003e\u003e {\n    let api = deps.api;\n    config(\u0026mut deps.storage).update(|mut state| {\n        if api.canonical_address(\u0026env.message.sender)? != state.owner {\n            return Err(StdError::unauthorized());\n        }\n        state.owner = api.canonical_address(\u0026owner)?;\n        Ok(state)\n    })?;\n    Ok(HandleResponse {\n        log: vec![log(\"action\", \"change_owner\"), log(\"owner\", owner)],\n        ..HandleResponse::default()\n    })\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Owner {} =\u003e to_binary(\u0026query_owner(deps)?),\n        QueryMsg::ReflectCustom { text } =\u003e to_binary(\u0026query_reflect(deps, text)?),\n    }\n}\n\nfn query_owner\u003cS: Storage, A: Api, Q: Querier\u003e(deps: \u0026Extern\u003cS, A, Q\u003e) -\u003e StdResult\u003cOwnerResponse\u003e {\n    let state = config_read(\u0026deps.storage).load()?;\n    let resp = OwnerResponse {\n        owner: deps.api.human_address(\u0026state.owner)?,\n    };\n    Ok(resp)\n}\n\nfn query_reflect\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    text: String,\n) -\u003e StdResult\u003cCustomResponse\u003e {\n    let req = CustomQuery::Capital { text }.into();\n    deps.querier.custom_query(\u0026req)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::testing::mock_dependencies_with_custom_querier;\n    use cosmwasm_std::testing::{mock_env, MOCK_CONTRACT_ADDR};\n    use cosmwasm_std::{coin, coins, BankMsg, Binary, StakingMsg, StdError};\n\n    #[test]\n    fn proper_initialization() {\n        let mut deps = mock_dependencies_with_custom_querier(20, \u0026[]);\n\n        let msg = InitMsg {};\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n\n        // we can just call .unwrap() to assert this was a success\n        let res = init(\u0026mut deps, env, msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // it worked, let's query the state\n        let value = query_owner(\u0026deps).unwrap();\n        assert_eq!(\"creator\", value.owner.as_str());\n    }\n\n    #[test]\n    fn reflect() {\n        let mut deps = mock_dependencies_with_custom_querier(20, \u0026[]);\n\n        let msg = InitMsg {};\n        let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n        let _res = init(\u0026mut deps, env, msg).unwrap();\n\n        let payload = vec![BankMsg::Send {\n            from_address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            to_address: HumanAddr::from(\"friend\"),\n            amount: coins(1, \"token\"),\n        }\n        .into()];\n\n        let msg = HandleMsg::ReflectMsg {\n            msgs: payload.clone(),\n        };\n        let env = mock_env(\"creator\", \u0026[]);\n        let res = handle(\u0026mut deps, env, msg).unwrap();\n        assert_eq!(payload, res.messages);\n    }\n\n    #[test]\n    fn reflect_requires_owner() {\n        let mut deps = mock_dependencies_with_custom_querier(20, \u0026[]);\n\n        let msg = InitMsg {};\n        let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n        let _res = init(\u0026mut deps, env, msg).unwrap();\n\n        // signer is not owner\n        let payload = vec![BankMsg::Send {\n            from_address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            to_address: HumanAddr::from(\"friend\"),\n            amount: coins(1, \"token\"),\n        }\n        .into()];\n        let msg = HandleMsg::ReflectMsg {\n            msgs: payload.clone(),\n        };\n\n        let env = mock_env(\"random\", \u0026[]);\n        let res = handle(\u0026mut deps, env, msg);\n        match res {\n            Err(StdError::Unauthorized { .. }) =\u003e {}\n            _ =\u003e panic!(\"Must return unauthorized error\"),\n        }\n    }\n\n    #[test]\n    fn reflect_reject_empty_msgs() {\n        let mut deps = mock_dependencies_with_custom_querier(20, \u0026[]);\n\n        let msg = InitMsg {};\n        let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n        let _res = init(\u0026mut deps, env, msg).unwrap();\n\n        let env = mock_env(\"creator\", \u0026[]);\n        let payload = vec![];\n\n        let msg = HandleMsg::ReflectMsg {\n            msgs: payload.clone(),\n        };\n        let res = handle(\u0026mut deps, env, msg);\n        match res {\n            Err(StdError::GenericErr { msg, .. }) =\u003e {\n                assert_eq!(msg, \"Must reflect at least one message\")\n            }\n            _ =\u003e panic!(\"Must return contract error\"),\n        }\n    }\n\n    #[test]\n    fn reflect_multiple_messages() {\n        let mut deps = mock_dependencies_with_custom_querier(20, \u0026[]);\n\n        let msg = InitMsg {};\n        let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n        let _res = init(\u0026mut deps, env, msg).unwrap();\n\n        let payload = vec![\n            BankMsg::Send {\n                from_address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n                to_address: HumanAddr::from(\"friend\"),\n                amount: coins(1, \"token\"),\n            }\n            .into(),\n            // make sure we can pass through custom native messages\n            CustomMsg::Raw(Binary(b\"{\\\"foo\\\":123}\".to_vec())).into(),\n            CustomMsg::Debug(\"Hi, Dad!\".to_string()).into(),\n            StakingMsg::Delegate {\n                validator: HumanAddr::from(\"validator\"),\n                amount: coin(100, \"ustake\"),\n            }\n            .into(),\n        ];\n\n        let msg = HandleMsg::ReflectMsg {\n            msgs: payload.clone(),\n        };\n        let env = mock_env(\"creator\", \u0026[]);\n        let res = handle(\u0026mut deps, env, msg).unwrap();\n        assert_eq!(payload, res.messages);\n    }\n\n    #[test]\n    fn transfer() {\n        let mut deps = mock_dependencies_with_custom_querier(20, \u0026[]);\n\n        let msg = InitMsg {};\n        let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n        let _res = init(\u0026mut deps, env, msg).unwrap();\n\n        let env = mock_env(\"creator\", \u0026[]);\n        let new_owner = HumanAddr::from(\"friend\");\n        let msg = HandleMsg::ChangeOwner {\n            owner: new_owner.clone(),\n        };\n        let res = handle(\u0026mut deps, env, msg).unwrap();\n\n        // should change state\n        assert_eq!(0, res.messages.len());\n        let value = query_owner(\u0026deps).unwrap();\n        assert_eq!(\"friend\", value.owner.as_str());\n    }\n\n    #[test]\n    fn transfer_requires_owner() {\n        let mut deps = mock_dependencies_with_custom_querier(20, \u0026[]);\n\n        let msg = InitMsg {};\n        let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n        let _res = init(\u0026mut deps, env, msg).unwrap();\n\n        let env = mock_env(\"random\", \u0026[]);\n        let new_owner = HumanAddr::from(\"friend\");\n        let msg = HandleMsg::ChangeOwner {\n            owner: new_owner.clone(),\n        };\n\n        let res = handle(\u0026mut deps, env, msg);\n        match res {\n            Err(StdError::Unauthorized { .. }) =\u003e {}\n            _ =\u003e panic!(\"Must return unauthorized error\"),\n        }\n    }\n\n    #[test]\n    fn dispatch_custom_query() {\n        let deps = mock_dependencies_with_custom_querier(20, \u0026[]);\n\n        // we don't even initialize, just trigger a query\n        let value = query_reflect(\u0026deps, \"demo one\".to_string()).unwrap();\n        assert_eq!(value.msg, \"DEMO ONE\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","reflect","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\npub mod state;\n\n#[cfg(not(target_arch = \"wasm32\"))]\npub mod testing;\n\n#[cfg(target_arch = \"wasm32\")]\ncosmwasm_std::create_entry_points!(contract);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","reflect","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Binary, CosmosMsg, HumanAddr, QueryRequest};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    ReflectMsg { msgs: Vec\u003cCosmosMsg\u003cCustomMsg\u003e\u003e },\n    ChangeOwner { owner: HumanAddr },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    Owner {},\n    // this will call out to CustomQuery::Capitalize\n    ReflectCustom { text: String },\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct OwnerResponse {\n    pub owner: HumanAddr,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\n/// CustomMsg is an override of CosmosMsg::Custom to show this works and can be extended in the contract\npub enum CustomMsg {\n    Debug(String),\n    Raw(Binary),\n}\n\nimpl Into\u003cCosmosMsg\u003cCustomMsg\u003e\u003e for CustomMsg {\n    fn into(self) -\u003e CosmosMsg\u003cCustomMsg\u003e {\n        CosmosMsg::Custom(self)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\n/// CustomQuery is an override of QueryRequest::Custom to show this works and can be extended in the contract\npub enum CustomQuery {\n    Ping {},\n    Capital { text: String },\n}\n\n// TODO: do we want to standardize this somehow for all?\nimpl Into\u003cQueryRequest\u003cCustomQuery\u003e\u003e for CustomQuery {\n    fn into(self) -\u003e QueryRequest\u003cCustomQuery\u003e {\n        QueryRequest::Custom(self)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\n// All return values of CustomQuery are CustomResponse\npub struct CustomResponse {\n    pub msg: String,\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","reflect","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{CanonicalAddr, Storage};\nuse cosmwasm_storage::{singleton, singleton_read, ReadonlySingleton, Singleton};\n\nconst CONFIG_KEY: \u0026[u8] = b\"config\";\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct State {\n    pub owner: CanonicalAddr,\n}\n\npub fn config\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, State\u003e {\n    singleton(storage, CONFIG_KEY)\n}\n\npub fn config_read\u003cS: Storage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, State\u003e {\n    singleton_read(storage, CONFIG_KEY)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","reflect","src","testing.rs"],"content":"use crate::msg::{CustomQuery, CustomResponse};\n\nuse cosmwasm_std::testing::{MockApi, MockQuerier, MockStorage, MOCK_CONTRACT_ADDR};\nuse cosmwasm_std::{to_binary, Binary, Coin, Extern, HumanAddr, StdResult};\n\n/// A drop-in replacement for cosmwasm_std::testing::mock_dependencies\n/// this uses our CustomQuerier.\npub fn mock_dependencies_with_custom_querier(\n    canonical_length: usize,\n    contract_balance: \u0026[Coin],\n) -\u003e Extern\u003cMockStorage, MockApi, MockQuerier\u003cCustomQuery\u003e\u003e {\n    let contract_addr = HumanAddr::from(MOCK_CONTRACT_ADDR);\n    let custom_querier: MockQuerier\u003cCustomQuery\u003e =\n        MockQuerier::new(\u0026[(\u0026contract_addr, contract_balance)])\n            .with_custom_handler(|query| Ok(custom_query_execute(\u0026query)));\n    Extern {\n        storage: MockStorage::default(),\n        api: MockApi::new(canonical_length),\n        querier: custom_querier,\n    }\n}\n\npub fn custom_query_execute(query: \u0026CustomQuery) -\u003e StdResult\u003cBinary\u003e {\n    let msg = match query {\n        CustomQuery::Ping {} =\u003e \"pong\".to_string(),\n        CustomQuery::Capital { text } =\u003e text.to_uppercase(),\n    };\n    to_binary(\u0026CustomResponse { msg })\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::{from_binary, Querier, QueryRequest};\n\n    #[test]\n    fn custom_query_execute_ping() {\n        let res = custom_query_execute(\u0026CustomQuery::Ping {}).unwrap();\n        let response: CustomResponse = from_binary(\u0026res).unwrap();\n        assert_eq!(response.msg, \"pong\");\n    }\n\n    #[test]\n    fn custom_query_execute_capitalize() {\n        let res = custom_query_execute(\u0026CustomQuery::Capital {\n            text: \"fOObaR\".to_string(),\n        })\n        .unwrap();\n        let response: CustomResponse = from_binary(\u0026res).unwrap();\n        assert_eq!(response.msg, \"FOOBAR\");\n    }\n\n    #[test]\n    fn custom_querier() {\n        let deps = mock_dependencies_with_custom_querier(20, \u0026[]);\n        let req: QueryRequest\u003c_\u003e = CustomQuery::Capital {\n            text: \"food\".to_string(),\n        }\n        .into();\n        let response: CustomResponse = deps.querier.custom_query(\u0026req).unwrap();\n        assert_eq!(response.msg, \"FOOD\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","reflect","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests as follows:\n//! 1. Copy them over verbatim\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n\nuse cosmwasm_std::{\n    coin, coins, from_binary, BankMsg, Binary, Coin, HandleResponse, HandleResult, HumanAddr,\n    InitResponse, StakingMsg, StdError,\n};\nuse cosmwasm_vm::{\n    testing::{\n        handle, init, mock_env, mock_instance, query, MockApi, MockQuerier, MockStorage,\n        MOCK_CONTRACT_ADDR,\n    },\n    Extern, Instance,\n};\n\nuse reflect::msg::{\n    CustomMsg, CustomQuery, CustomResponse, HandleMsg, InitMsg, OwnerResponse, QueryMsg,\n};\nuse reflect::testing::custom_query_execute;\n\n// This line will test the output of cargo wasm\nstatic WASM: \u0026[u8] = include_bytes!(\"../target/wasm32-unknown-unknown/release/reflect.wasm\");\n// You can uncomment this line instead to test productionified build from cosmwasm-opt\n// static WASM: \u0026[u8] = include_bytes!(\"../contract.wasm\");\n\n/// A drop-in replacement for cosmwasm_vm::testing::mock_dependencies\n/// that supports CustomQuery.\npub fn mock_dependencies_with_custom_querier(\n    canonical_length: usize,\n    contract_balance: \u0026[Coin],\n) -\u003e Extern\u003cMockStorage, MockApi, MockQuerier\u003cCustomQuery\u003e\u003e {\n    let contract_addr = HumanAddr::from(MOCK_CONTRACT_ADDR);\n    let custom_querier: MockQuerier\u003cCustomQuery\u003e =\n        MockQuerier::new(\u0026[(\u0026contract_addr, contract_balance)])\n            .with_custom_handler(|query| Ok(custom_query_execute(query)));\n\n    Extern {\n        storage: MockStorage::default(),\n        api: MockApi::new(canonical_length),\n        querier: custom_querier,\n    }\n}\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let msg = InitMsg {};\n    let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n\n    // we can just call .unwrap() to assert this was a success\n    let res: InitResponse\u003cCustomMsg\u003e = init(\u0026mut deps, env, msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // it worked, let's query the state\n    let res = query(\u0026mut deps, QueryMsg::Owner {}).unwrap();\n    let value: OwnerResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(\"creator\", value.owner.as_str());\n}\n\n#[test]\nfn reflect() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let msg = InitMsg {};\n    let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n    let _res: InitResponse\u003cCustomMsg\u003e = init(\u0026mut deps, env, msg).unwrap();\n\n    let payload = vec![\n        BankMsg::Send {\n            from_address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            to_address: HumanAddr::from(\"friend\"),\n            amount: coins(1, \"token\"),\n        }\n        .into(),\n        // make sure we can pass through custom native messages\n        CustomMsg::Raw(Binary(b\"{\\\"foo\\\":123}\".to_vec())).into(),\n        CustomMsg::Debug(\"Hi, Dad!\".to_string()).into(),\n        StakingMsg::Delegate {\n            validator: HumanAddr::from(\"validator\"),\n            amount: coin(100, \"ustake\"),\n        }\n        .into(),\n    ];\n    let msg = HandleMsg::ReflectMsg {\n        msgs: payload.clone(),\n    };\n    let env = mock_env(\"creator\", \u0026[]);\n    let res: HandleResponse\u003cCustomMsg\u003e = handle(\u0026mut deps, env, msg).unwrap();\n\n    // should return payload\n    assert_eq!(payload, res.messages);\n}\n\n#[test]\nfn reflect_requires_owner() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let msg = InitMsg {};\n    let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n    let _res: InitResponse\u003cCustomMsg\u003e = init(\u0026mut deps, env, msg).unwrap();\n\n    // signer is not owner\n    let payload = vec![BankMsg::Send {\n        from_address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n        to_address: HumanAddr::from(\"friend\"),\n        amount: coins(1, \"token\"),\n    }\n    .into()];\n    let msg = HandleMsg::ReflectMsg {\n        msgs: payload.clone(),\n    };\n\n    let env = mock_env(\"someone\", \u0026[]);\n    let res: HandleResult\u003cCustomMsg\u003e = handle(\u0026mut deps, env, msg);\n    match res {\n        Err(StdError::Unauthorized { .. }) =\u003e {}\n        _ =\u003e panic!(\"Must return unauthorized error\"),\n    }\n}\n\n#[test]\nfn transfer() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let msg = InitMsg {};\n    let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n    let _res: InitResponse\u003cCustomMsg\u003e = init(\u0026mut deps, env, msg).unwrap();\n\n    let env = mock_env(\"creator\", \u0026[]);\n    let new_owner = HumanAddr::from(\"friend\");\n    let msg = HandleMsg::ChangeOwner {\n        owner: new_owner.clone(),\n    };\n    let res: HandleResponse\u003cCustomMsg\u003e = handle(\u0026mut deps, env, msg).unwrap();\n\n    // should change state\n    assert_eq!(0, res.messages.len());\n    let res = query(\u0026mut deps, QueryMsg::Owner {}).unwrap();\n    let value: OwnerResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(\"friend\", value.owner.as_str());\n}\n\n#[test]\nfn transfer_requires_owner() {\n    let mut deps = mock_instance(WASM, \u0026[]);\n\n    let msg = InitMsg {};\n    let env = mock_env(\"creator\", \u0026coins(2, \"token\"));\n    let _res: InitResponse\u003cCustomMsg\u003e = init(\u0026mut deps, env, msg).unwrap();\n\n    let env = mock_env(\"random\", \u0026[]);\n    let new_owner = HumanAddr::from(\"friend\");\n    let msg = HandleMsg::ChangeOwner {\n        owner: new_owner.clone(),\n    };\n\n    let res: HandleResult = handle(\u0026mut deps, env, msg);\n    match res {\n        Err(StdError::Unauthorized { .. }) =\u003e {}\n        _ =\u003e panic!(\"Must return unauthorized error\"),\n    }\n}\n\n#[test]\nfn dispatch_custom_query() {\n    // stub gives us defaults. Consume it and override...\n    let custom = mock_dependencies_with_custom_querier(20, \u0026[]);\n    // we cannot use mock_instance, so we just copy and modify code from cosmwasm_vm::testing\n    let mut deps = Instance::from_code(WASM, custom, 500_000).unwrap();\n\n    // we don't even initialize, just trigger a query\n    let res = query(\n        \u0026mut deps,\n        QueryMsg::ReflectCustom {\n            text: \"demo one\".to_string(),\n        },\n    )\n    .unwrap();\n    let value: CustomResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(value.msg, \"DEMO ONE\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","staking","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse staking::msg::{\n    BalanceResponse, ClaimsResponse, HandleMsg, InitMsg, InvestmentResponse, QueryMsg,\n    TokenInfoResponse,\n};\nuse staking::state::{InvestmentInfo, Supply};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InitMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(HandleMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(BalanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(ClaimsResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(InvestmentResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(TokenInfoResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(InvestmentInfo), \u0026out_dir);\n    export_schema(\u0026schema_for!(Supply), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","staking","src","contract.rs"],"content":"use cosmwasm_std::{\n    coin, log, to_binary, Api, BankMsg, Binary, Decimal, Env, Extern, HandleResponse, HumanAddr,\n    InitResponse, Querier, StakingMsg, StdError, StdResult, Storage, Uint128, WasmMsg,\n};\n\nuse crate::msg::{\n    BalanceResponse, ClaimsResponse, HandleMsg, InitMsg, InvestmentResponse, QueryMsg,\n    TokenInfoResponse,\n};\nuse crate::state::{\n    balances, balances_read, claims, claims_read, invest_info, invest_info_read, token_info,\n    token_info_read, total_supply, total_supply_read, InvestmentInfo, Supply,\n};\n\nconst FALLBACK_RATIO: Decimal = Decimal::one();\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e StdResult\u003cInitResponse\u003e {\n    // ensure the validator is registered\n    let vals = deps.querier.query_validators()?;\n    if !vals.iter().any(|v| v.address == msg.validator) {\n        return Err(StdError::generic_err(format!(\n            \"{} is not in the current validator set\",\n            msg.validator\n        )));\n    }\n\n    let token = TokenInfoResponse {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n    };\n    token_info(\u0026mut deps.storage).save(\u0026token)?;\n\n    let denom = deps.querier.query_bonded_denom()?;\n    let invest = InvestmentInfo {\n        owner: deps.api.canonical_address(\u0026env.message.sender)?,\n        exit_tax: msg.exit_tax,\n        bond_denom: denom,\n        validator: msg.validator,\n        min_withdrawal: msg.min_withdrawal,\n    };\n    invest_info(\u0026mut deps.storage).save(\u0026invest)?;\n\n    // set supply to 0\n    let supply = Supply::default();\n    total_supply(\u0026mut deps.storage).save(\u0026supply)?;\n\n    Ok(InitResponse::default())\n}\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    match msg {\n        HandleMsg::Transfer { recipient, amount } =\u003e transfer(deps, env, recipient, amount),\n        HandleMsg::Bond {} =\u003e bond(deps, env),\n        HandleMsg::Unbond { amount } =\u003e unbond(deps, env, amount),\n        HandleMsg::Claim {} =\u003e claim(deps, env),\n        HandleMsg::Reinvest {} =\u003e reinvest(deps, env),\n        HandleMsg::_BondAllTokens {} =\u003e _bond_all_tokens(deps, env),\n    }\n}\n\npub fn transfer\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    recipient: HumanAddr,\n    send: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let rcpt_raw = deps.api.canonical_address(\u0026recipient)?;\n    let sender_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n\n    let mut accounts = balances(\u0026mut deps.storage);\n    accounts.update(sender_raw.as_slice(), |balance: Option\u003cUint128\u003e| {\n        balance.unwrap_or_default() - send\n    })?;\n    accounts.update(rcpt_raw.as_slice(), |balance: Option\u003cUint128\u003e| {\n        Ok(balance.unwrap_or_default() + send)\n    })?;\n\n    let res = HandleResponse {\n        messages: vec![],\n        log: vec![\n            log(\"action\", \"transfer\"),\n            log(\"from\", env.message.sender),\n            log(\"to\", recipient),\n            log(\"amount\", send),\n        ],\n        data: None,\n    };\n    Ok(res)\n}\n\n// get_bonded returns the total amount of delegations from contract\n// it ensures they are all the same denom\nfn get_bonded\u003cQ: Querier\u003e(querier: \u0026Q, contract: \u0026HumanAddr) -\u003e StdResult\u003cUint128\u003e {\n    let bonds = querier.query_all_delegations(contract)?;\n    if bonds.is_empty() {\n        return Ok(Uint128(0));\n    }\n    let denom = bonds[0].amount.denom.as_str();\n    bonds.iter().fold(Ok(Uint128(0)), |racc, d| {\n        let acc = racc?;\n        if d.amount.denom.as_str() != denom {\n            Err(StdError::generic_err(format!(\n                \"different denoms in bonds: '{}' vs '{}'\",\n                denom, \u0026d.amount.denom\n            )))\n        } else {\n            Ok(acc + d.amount.amount)\n        }\n    })\n}\n\nfn assert_bonds(supply: \u0026Supply, bonded: Uint128) -\u003e StdResult\u003c()\u003e {\n    if supply.bonded != bonded {\n        Err(StdError::generic_err(format!(\n            \"Stored bonded {}, but query bonded: {}\",\n            supply.bonded, bonded\n        )))\n    } else {\n        Ok(())\n    }\n}\n\npub fn bond\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n\n    // ensure we have the proper denom\n    let invest = invest_info_read(\u0026deps.storage).load()?;\n    // payment finds the proper coin (or throws an error)\n    let payment = env\n        .message\n        .sent_funds\n        .iter()\n        .find(|x| x.denom == invest.bond_denom)\n        .ok_or_else(|| StdError::generic_err(format!(\"No {} tokens sent\", \u0026invest.bond_denom)))?;\n\n    // bonded is the total number of tokens we have delegated from this address\n    let bonded = get_bonded(\u0026deps.querier, \u0026env.contract.address)?;\n\n    // calculate to_mint and update total supply\n    let mut totals = total_supply(\u0026mut deps.storage);\n    let mut supply = totals.load()?;\n    // TODO: this is just temporary check - we should use dynamic query or have a way to recover\n    assert_bonds(\u0026supply, bonded)?;\n    let to_mint = if supply.issued.is_zero() || bonded.is_zero() {\n        FALLBACK_RATIO * payment.amount\n    } else {\n        payment.amount.multiply_ratio(supply.issued, bonded)\n    };\n    supply.bonded = bonded + payment.amount;\n    supply.issued += to_mint;\n    totals.save(\u0026supply)?;\n\n    // update the balance of the sender\n    balances(\u0026mut deps.storage).update(sender_raw.as_slice(), |balance| {\n        Ok(balance.unwrap_or_default() + to_mint)\n    })?;\n\n    // bond them to the validator\n    let res = HandleResponse {\n        messages: vec![StakingMsg::Delegate {\n            validator: invest.validator,\n            amount: payment.clone(),\n        }\n        .into()],\n        log: vec![\n            log(\"action\", \"bond\"),\n            log(\"from\", env.message.sender),\n            log(\"bonded\", payment.amount),\n            log(\"minted\", to_mint),\n        ],\n        data: None,\n    };\n    Ok(res)\n}\n\npub fn unbond\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    amount: Uint128,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let sender_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n\n    let invest = invest_info_read(\u0026deps.storage).load()?;\n    // ensure it is big enough to care\n    if amount \u003c invest.min_withdrawal {\n        return Err(StdError::generic_err(format!(\n            \"Must unbond at least {} {}\",\n            invest.min_withdrawal, invest.bond_denom\n        )));\n    }\n    // calculate tax and remainer to unbond\n    let tax = amount * invest.exit_tax;\n\n    // deduct all from the account\n    let mut accounts = balances(\u0026mut deps.storage);\n    accounts.update(sender_raw.as_slice(), |balance| {\n        balance.unwrap_or_default() - amount\n    })?;\n    if tax \u003e Uint128(0) {\n        // add tax to the owner\n        accounts.update(invest.owner.as_slice(), |balance: Option\u003cUint128\u003e| {\n            Ok(balance.unwrap_or_default() + tax)\n        })?;\n    }\n\n    // re-calculate bonded to ensure we have real values\n    // bonded is the total number of tokens we have delegated from this address\n    let bonded = get_bonded(\u0026deps.querier, \u0026env.contract.address)?;\n\n    // calculate how many native tokens this is worth and update supply\n    let remainder = (amount - tax)?;\n    let mut totals = total_supply(\u0026mut deps.storage);\n    let mut supply = totals.load()?;\n    // TODO: this is just temporary check - we should use dynamic query or have a way to recover\n    assert_bonds(\u0026supply, bonded)?;\n    let unbond = remainder.multiply_ratio(bonded, supply.issued);\n    supply.bonded = (bonded - unbond)?;\n    supply.issued = (supply.issued - remainder)?;\n    supply.claims += unbond;\n    totals.save(\u0026supply)?;\n\n    // add a claim to this user to get their tokens after the unbonding period\n    claims(\u0026mut deps.storage).update(sender_raw.as_slice(), |claim| {\n        Ok(claim.unwrap_or_default() + unbond)\n    })?;\n\n    // unbond them\n    let res = HandleResponse {\n        messages: vec![StakingMsg::Undelegate {\n            validator: invest.validator,\n            amount: coin(unbond.u128(), \u0026invest.bond_denom),\n        }\n        .into()],\n        log: vec![\n            log(\"action\", \"unbond\"),\n            log(\"to\", env.message.sender),\n            log(\"unbonded\", unbond),\n            log(\"burnt\", amount),\n        ],\n        data: None,\n    };\n    Ok(res)\n}\n\npub fn claim\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    // find how many tokens the contract has\n    let invest = invest_info_read(\u0026deps.storage).load()?;\n    let mut balance = deps\n        .querier\n        .query_balance(\u0026env.contract.address, \u0026invest.bond_denom)?;\n    if balance.amount \u003c invest.min_withdrawal {\n        return Err(StdError::generic_err(\n            \"Insufficient balance in contract to process claim\",\n        ));\n    }\n\n    // check how much to send - min(balance, claims[sender]), and reduce the claim\n    let sender_raw = deps.api.canonical_address(\u0026env.message.sender)?;\n    let mut to_send = balance.amount;\n    claims(\u0026mut deps.storage).update(sender_raw.as_slice(), |claim| {\n        let claim = claim.ok_or_else(|| StdError::generic_err(\"no claim for this address\"))?;\n        to_send = to_send.min(claim);\n        claim - to_send\n    })?;\n\n    // update total supply (lower claim)\n    total_supply(\u0026mut deps.storage).update(|mut supply| {\n        supply.claims = (supply.claims - to_send)?;\n        Ok(supply)\n    })?;\n\n    // transfer tokens to the sender\n    balance.amount = to_send;\n    let res = HandleResponse {\n        messages: vec![BankMsg::Send {\n            from_address: env.contract.address,\n            to_address: env.message.sender.clone(),\n            amount: vec![balance],\n        }\n        .into()],\n        log: vec![\n            log(\"action\", \"claim\"),\n            log(\"from\", env.message.sender),\n            log(\"amount\", to_send),\n        ],\n        data: None,\n    };\n    Ok(res)\n}\n\n/// reinvest will withdraw all pending rewards,\n/// then issue a callback to itself via _bond_all_tokens\n/// to reinvest the new earnings (and anything else that accumulated)\npub fn reinvest\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    let contract_addr = env.contract.address;\n    let invest = invest_info_read(\u0026deps.storage).load()?;\n    let msg = to_binary(\u0026HandleMsg::_BondAllTokens {})?;\n\n    // and bond them to the validator\n    let res = HandleResponse {\n        messages: vec![\n            StakingMsg::Withdraw {\n                validator: invest.validator,\n                recipient: Some(contract_addr.clone()),\n            }\n            .into(),\n            WasmMsg::Execute {\n                contract_addr,\n                callback_code_hash: env.contract_code_hash,\n                msg,\n                send: vec![],\n            }\n            .into(),\n        ],\n        log: vec![],\n        data: None,\n    };\n    Ok(res)\n}\n\npub fn _bond_all_tokens\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n) -\u003e StdResult\u003cHandleResponse\u003e {\n    // this is just meant as a call-back to ourself\n    if env.message.sender != env.contract.address {\n        return Err(StdError::unauthorized());\n    }\n\n    // find how many tokens we have to bond\n    let invest = invest_info_read(\u0026deps.storage).load()?;\n    let mut balance = deps\n        .querier\n        .query_balance(\u0026env.contract.address, \u0026invest.bond_denom)?;\n\n    // we deduct pending claims from our account balance before reinvesting.\n    // if there is not enough funds, we just return a no-op\n    match total_supply(\u0026mut deps.storage).update(|mut supply| {\n        balance.amount = (balance.amount - supply.claims)?;\n        // this just triggers the \"no op\" case if we don't have min_withdrawal left to reinvest\n        (balance.amount - invest.min_withdrawal)?;\n        supply.bonded += balance.amount;\n        Ok(supply)\n    }) {\n        Ok(_) =\u003e {}\n        // if it is below the minimum, we do a no-op (do not revert other state from withdrawal)\n        Err(StdError::Underflow { .. }) =\u003e return Ok(HandleResponse::default()),\n        Err(e) =\u003e return Err(e),\n    }\n\n    // and bond them to the validator\n    let res = HandleResponse {\n        messages: vec![StakingMsg::Delegate {\n            validator: invest.validator,\n            amount: balance.clone(),\n        }\n        .into()],\n        log: vec![log(\"action\", \"reinvest\"), log(\"bonded\", balance.amount)],\n        data: None,\n    };\n    Ok(res)\n}\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    msg: QueryMsg,\n) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::TokenInfo {} =\u003e to_binary(\u0026query_token_info(deps)?),\n        QueryMsg::Investment {} =\u003e to_binary(\u0026query_investment(deps)?),\n        QueryMsg::Balance { address } =\u003e to_binary(\u0026query_balance(deps, address)?),\n        QueryMsg::Claims { address } =\u003e to_binary(\u0026query_claims(deps, address)?),\n    }\n}\n\npub fn query_token_info\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e StdResult\u003cTokenInfoResponse\u003e {\n    token_info_read(\u0026deps.storage).load()\n}\n\npub fn query_balance\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    address: HumanAddr,\n) -\u003e StdResult\u003cBalanceResponse\u003e {\n    let address_raw = deps.api.canonical_address(\u0026address)?;\n    let balance = balances_read(\u0026deps.storage)\n        .may_load(address_raw.as_slice())?\n        .unwrap_or_default();\n    Ok(BalanceResponse { balance })\n}\n\npub fn query_claims\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    address: HumanAddr,\n) -\u003e StdResult\u003cClaimsResponse\u003e {\n    let address_raw = deps.api.canonical_address(\u0026address)?;\n    let claims = claims_read(\u0026deps.storage)\n        .may_load(address_raw.as_slice())?\n        .unwrap_or_default();\n    Ok(ClaimsResponse { claims })\n}\n\npub fn query_investment\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e StdResult\u003cInvestmentResponse\u003e {\n    let invest = invest_info_read(\u0026deps.storage).load()?;\n    let supply = total_supply_read(\u0026deps.storage).load()?;\n\n    let res = InvestmentResponse {\n        owner: deps.api.human_address(\u0026invest.owner)?,\n        exit_tax: invest.exit_tax,\n        validator: invest.validator,\n        min_withdrawal: invest.min_withdrawal,\n        token_supply: supply.issued,\n        staked_tokens: coin(supply.bonded.u128(), \u0026invest.bond_denom),\n        nominal_value: if supply.issued.is_zero() {\n            FALLBACK_RATIO\n        } else {\n            Decimal::from_ratio(supply.bonded, supply.issued)\n        },\n    };\n    Ok(res)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, MockQuerier, MOCK_CONTRACT_ADDR};\n    use cosmwasm_std::{coins, Coin, CosmosMsg, Decimal, FullDelegation, Validator};\n    use std::str::FromStr;\n\n    fn sample_validator\u003cU: Into\u003cHumanAddr\u003e\u003e(addr: U) -\u003e Validator {\n        Validator {\n            address: addr.into(),\n            commission: Decimal::percent(3),\n            max_commission: Decimal::percent(10),\n            max_change_rate: Decimal::percent(1),\n        }\n    }\n\n    fn sample_delegation\u003cU: Into\u003cHumanAddr\u003e\u003e(addr: U, amount: Coin) -\u003e FullDelegation {\n        let can_redelegate = amount.clone();\n        let accumulated_rewards = coin(0, \u0026amount.denom);\n        FullDelegation {\n            validator: addr.into(),\n            delegator: HumanAddr::from(MOCK_CONTRACT_ADDR),\n            amount,\n            can_redelegate,\n            accumulated_rewards,\n        }\n    }\n\n    fn set_validator(querier: \u0026mut MockQuerier) {\n        querier.update_staking(\"ustake\", \u0026[sample_validator(DEFAULT_VALIDATOR)], \u0026[]);\n    }\n\n    fn set_delegation(querier: \u0026mut MockQuerier, amount: u128, denom: \u0026str) {\n        querier.update_staking(\n            \"ustake\",\n            \u0026[sample_validator(DEFAULT_VALIDATOR)],\n            \u0026[sample_delegation(DEFAULT_VALIDATOR, coin(amount, denom))],\n        );\n    }\n\n    const DEFAULT_VALIDATOR: \u0026str = \"default-validator\";\n\n    fn default_init(tax_percent: u64, min_withdrawal: u128) -\u003e InitMsg {\n        InitMsg {\n            name: \"Cool Derivative\".to_string(),\n            symbol: \"DRV\".to_string(),\n            decimals: 9,\n            validator: HumanAddr::from(DEFAULT_VALIDATOR),\n            exit_tax: Decimal::percent(tax_percent),\n            min_withdrawal: Uint128(min_withdrawal),\n        }\n    }\n\n    fn get_balance\u003cS: Storage, A: Api, Q: Querier, U: Into\u003cHumanAddr\u003e\u003e(\n        deps: \u0026Extern\u003cS, A, Q\u003e,\n        addr: U,\n    ) -\u003e Uint128 {\n        query_balance(\u0026deps, addr.into()).unwrap().balance\n    }\n\n    fn get_claims\u003cS: Storage, A: Api, Q: Querier, U: Into\u003cHumanAddr\u003e\u003e(\n        deps: \u0026Extern\u003cS, A, Q\u003e,\n        addr: U,\n    ) -\u003e Uint128 {\n        query_claims(\u0026deps, addr.into()).unwrap().claims\n    }\n\n    #[test]\n    fn initialization_with_missing_validator() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n        deps.querier\n            .update_staking(\"ustake\", \u0026[sample_validator(\"john\")], \u0026[]);\n\n        let creator = HumanAddr::from(\"creator\");\n        let msg = InitMsg {\n            name: \"Cool Derivative\".to_string(),\n            symbol: \"DRV\".to_string(),\n            decimals: 9,\n            validator: HumanAddr::from(\"my-validator\"),\n            exit_tax: Decimal::percent(2),\n            min_withdrawal: Uint128(50),\n        };\n        let env = mock_env(\u0026creator, \u0026[]);\n\n        // make sure we can init with this\n        let res = init(\u0026mut deps, env, msg.clone());\n        match res.unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"my-validator is not in the current validator set\")\n            }\n            _ =\u003e panic!(\"expected unregistered validator error\"),\n        }\n    }\n\n    #[test]\n    fn proper_initialization() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n        deps.querier.update_staking(\n            \"ustake\",\n            \u0026[\n                sample_validator(\"john\"),\n                sample_validator(\"mary\"),\n                sample_validator(\"my-validator\"),\n            ],\n            \u0026[],\n        );\n\n        let creator = HumanAddr::from(\"creator\");\n        let msg = InitMsg {\n            name: \"Cool Derivative\".to_string(),\n            symbol: \"DRV\".to_string(),\n            decimals: 0,\n            validator: HumanAddr::from(\"my-validator\"),\n            exit_tax: Decimal::percent(2),\n            min_withdrawal: Uint128(50),\n        };\n        let env = mock_env(\u0026creator, \u0026[]);\n\n        // make sure we can init with this\n        let res = init(\u0026mut deps, env, msg.clone()).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // token info is proper\n        let token = query_token_info(\u0026deps).unwrap();\n        assert_eq!(\u0026token.name, \u0026msg.name);\n        assert_eq!(\u0026token.symbol, \u0026msg.symbol);\n        assert_eq!(token.decimals, msg.decimals);\n\n        // no balance\n        assert_eq!(get_balance(\u0026deps, \u0026creator), Uint128(0));\n        // no claims\n        assert_eq!(get_claims(\u0026deps, \u0026creator), Uint128(0));\n\n        // investment info correct\n        let invest = query_investment(\u0026deps).unwrap();\n        assert_eq!(\u0026invest.owner, \u0026creator);\n        assert_eq!(\u0026invest.validator, \u0026msg.validator);\n        assert_eq!(invest.exit_tax, msg.exit_tax);\n        assert_eq!(invest.min_withdrawal, msg.min_withdrawal);\n\n        assert_eq!(invest.token_supply, Uint128(0));\n        assert_eq!(invest.staked_tokens, coin(0, \"ustake\"));\n        assert_eq!(invest.nominal_value, Decimal::one());\n    }\n\n    #[test]\n    fn bonding_issues_tokens() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n        set_validator(\u0026mut deps.querier);\n\n        let creator = HumanAddr::from(\"creator\");\n        let init_msg = default_init(2, 50);\n        let env = mock_env(\u0026creator, \u0026[]);\n\n        // make sure we can init with this\n        let res = init(\u0026mut deps, env, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // let's bond some tokens now\n        let bob = HumanAddr::from(\"bob\");\n        let bond_msg = HandleMsg::Bond {};\n        let env = mock_env(\u0026bob, \u0026[coin(10, \"random\"), coin(1000, \"ustake\")]);\n\n        // try to bond and make sure we trigger delegation\n        let res = handle(\u0026mut deps, env, bond_msg).unwrap();\n        assert_eq!(1, res.messages.len());\n        let delegate = \u0026res.messages[0];\n        match delegate {\n            CosmosMsg::Staking(StakingMsg::Delegate { validator, amount }) =\u003e {\n                assert_eq!(validator.as_str(), DEFAULT_VALIDATOR);\n                assert_eq!(amount, \u0026coin(1000, \"ustake\"));\n            }\n            _ =\u003e panic!(\"Unexpected message: {:?}\", delegate),\n        }\n\n        // bob got 1000 DRV for 1000 stake at a 1.0 ratio\n        assert_eq!(get_balance(\u0026deps, \u0026bob), Uint128(1000));\n\n        // investment info correct (updated supply)\n        let invest = query_investment(\u0026deps).unwrap();\n        assert_eq!(invest.token_supply, Uint128(1000));\n        assert_eq!(invest.staked_tokens, coin(1000, \"ustake\"));\n        assert_eq!(invest.nominal_value, Decimal::one());\n    }\n\n    #[test]\n    fn rebonding_changes_pricing() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n        set_validator(\u0026mut deps.querier);\n\n        let creator = HumanAddr::from(\"creator\");\n        let init_msg = default_init(2, 50);\n        let env = mock_env(\u0026creator, \u0026[]);\n\n        // make sure we can init with this\n        let res = init(\u0026mut deps, env, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // let's bond some tokens now\n        let bob = HumanAddr::from(\"bob\");\n        let bond_msg = HandleMsg::Bond {};\n        let env = mock_env(\u0026bob, \u0026[coin(10, \"random\"), coin(1000, \"ustake\")]);\n        let contract_addr = env.contract.address.clone();\n        let res = handle(\u0026mut deps, env, bond_msg).unwrap();\n        assert_eq!(1, res.messages.len());\n\n        // update the querier with new bond\n        set_delegation(\u0026mut deps.querier, 1000, \"ustake\");\n\n        // fake a reinvestment (this must be sent by the contract itself)\n        let rebond_msg = HandleMsg::_BondAllTokens {};\n        let env = mock_env(\u0026contract_addr, \u0026[]);\n        deps.querier\n            .update_balance(\u0026contract_addr, coins(500, \"ustake\"));\n        let _ = handle(\u0026mut deps, env, rebond_msg).unwrap();\n\n        // update the querier with new bond\n        set_delegation(\u0026mut deps.querier, 1500, \"ustake\");\n\n        // we should now see 1000 issues and 1500 bonded (and a price of 1.5)\n        let invest = query_investment(\u0026deps).unwrap();\n        assert_eq!(invest.token_supply, Uint128(1000));\n        assert_eq!(invest.staked_tokens, coin(1500, \"ustake\"));\n        let ratio = Decimal::from_str(\"1.5\").unwrap();\n        assert_eq!(invest.nominal_value, ratio);\n\n        // we bond some other tokens and get a different issuance price (maintaining the ratio)\n        let alice = HumanAddr::from(\"alice\");\n        let bond_msg = HandleMsg::Bond {};\n        let env = mock_env(\u0026alice, \u0026[coin(3000, \"ustake\")]);\n        let res = handle(\u0026mut deps, env, bond_msg).unwrap();\n        assert_eq!(1, res.messages.len());\n\n        // update the querier with new bond\n        set_delegation(\u0026mut deps.querier, 3000, \"ustake\");\n\n        // alice should have gotten 2000 DRV for the 3000 stake, keeping the ratio at 1.5\n        assert_eq!(get_balance(\u0026deps, \u0026alice), Uint128(2000));\n\n        let invest = query_investment(\u0026deps).unwrap();\n        assert_eq!(invest.token_supply, Uint128(3000));\n        assert_eq!(invest.staked_tokens, coin(4500, \"ustake\"));\n        assert_eq!(invest.nominal_value, ratio);\n    }\n\n    #[test]\n    fn bonding_fails_with_wrong_denom() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n        set_validator(\u0026mut deps.querier);\n\n        let creator = HumanAddr::from(\"creator\");\n        let init_msg = default_init(2, 50);\n        let env = mock_env(\u0026creator, \u0026[]);\n\n        // make sure we can init with this\n        let res = init(\u0026mut deps, env, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // let's bond some tokens now\n        let bob = HumanAddr::from(\"bob\");\n        let bond_msg = HandleMsg::Bond {};\n        let env = mock_env(\u0026bob, \u0026[coin(500, \"photon\")]);\n\n        // try to bond and make sure we trigger delegation\n        let res = handle(\u0026mut deps, env, bond_msg);\n        match res.unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"No ustake tokens sent\"),\n            e =\u003e panic!(\"Expected wrong denom error, got: {:?}\", e),\n        };\n    }\n\n    #[test]\n    fn unbonding_maintains_price_ratio() {\n        let mut deps = mock_dependencies(20, \u0026[]);\n        set_validator(\u0026mut deps.querier);\n\n        let creator = HumanAddr::from(\"creator\");\n        let init_msg = default_init(10, 50);\n        let env = mock_env(\u0026creator, \u0026[]);\n\n        // make sure we can init with this\n        let res = init(\u0026mut deps, env, init_msg).unwrap();\n        assert_eq!(0, res.messages.len());\n\n        // let's bond some tokens now\n        let bob = HumanAddr::from(\"bob\");\n        let bond_msg = HandleMsg::Bond {};\n        let env = mock_env(\u0026bob, \u0026[coin(10, \"random\"), coin(1000, \"ustake\")]);\n        let contract_addr = env.contract.address.clone();\n        let res = handle(\u0026mut deps, env, bond_msg).unwrap();\n        assert_eq!(1, res.messages.len());\n\n        // update the querier with new bond\n        set_delegation(\u0026mut deps.querier, 1000, \"ustake\");\n\n        // fake a reinvestment (this must be sent by the contract itself)\n        // after this, we see 1000 issues and 1500 bonded (and a price of 1.5)\n        let rebond_msg = HandleMsg::_BondAllTokens {};\n        let env = mock_env(\u0026contract_addr, \u0026[]);\n        deps.querier\n            .update_balance(\u0026contract_addr, coins(500, \"ustake\"));\n        let _ = handle(\u0026mut deps, env, rebond_msg).unwrap();\n\n        // update the querier with new bond, lower balance\n        set_delegation(\u0026mut deps.querier, 1500, \"ustake\");\n        deps.querier.update_balance(\u0026contract_addr, vec![]);\n\n        // creator now tries to unbond these tokens - this must fail\n        let unbond_msg = HandleMsg::Unbond {\n            amount: Uint128(600),\n        };\n        let env = mock_env(\u0026creator, \u0026[]);\n        let res = handle(\u0026mut deps, env, unbond_msg);\n        match res.unwrap_err() {\n            StdError::Underflow { .. } =\u003e {}\n            e =\u003e panic!(\"unexpected error: {}\", e),\n        }\n\n        // bob unbonds 600 tokens at 10% tax...\n        // 60 are taken and send to the owner\n        // 540 are unbonded in exchange for 540 * 1.5 = 810 native tokens\n        let unbond_msg = HandleMsg::Unbond {\n            amount: Uint128(600),\n        };\n        let owner_cut = Uint128(60);\n        let bobs_claim = Uint128(810);\n        let bobs_balance = Uint128(400);\n        let env = mock_env(\u0026bob, \u0026[]);\n        let res = handle(\u0026mut deps, env, unbond_msg).unwrap();\n        assert_eq!(1, res.messages.len());\n        let delegate = \u0026res.messages[0];\n        match delegate {\n            CosmosMsg::Staking(StakingMsg::Undelegate { validator, amount }) =\u003e {\n                assert_eq!(validator.as_str(), DEFAULT_VALIDATOR);\n                assert_eq!(amount, \u0026coin(bobs_claim.u128(), \"ustake\"));\n            }\n            _ =\u003e panic!(\"Unexpected message: {:?}\", delegate),\n        }\n\n        // update the querier with new bond, lower balance\n        set_delegation(\u0026mut deps.querier, 690, \"ustake\");\n\n        // check balances\n        assert_eq!(get_balance(\u0026deps, \u0026bob), bobs_balance);\n        assert_eq!(get_balance(\u0026deps, \u0026creator), owner_cut);\n        // proper claims\n        assert_eq!(get_claims(\u0026deps, \u0026bob), bobs_claim);\n\n        // supplies updated, ratio the same (1.5)\n        let ratio = Decimal::from_str(\"1.5\").unwrap();\n\n        let invest = query_investment(\u0026deps).unwrap();\n        assert_eq!(invest.token_supply, bobs_balance + owner_cut);\n        assert_eq!(invest.staked_tokens, coin(690, \"ustake\")); // 1500 - 810\n        assert_eq!(invest.nominal_value, ratio);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","staking","src","lib.rs"],"content":"pub mod contract;\npub mod msg;\npub mod state;\n\n#[cfg(target_arch = \"wasm32\")]\ncosmwasm_std::create_entry_points!(contract);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","staking","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Coin, Decimal, HumanAddr, Uint128};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n    /// name of the derivative token (FIXME: auto-generate?)\n    pub name: String,\n    /// symbol / ticker of the derivative token\n    pub symbol: String,\n    /// decimal places of the derivative token (for UI)\n    /// TODO: does this make sense? Do we need to normalize on this?\n    /// We don't even know the decimals of the native token\n    pub decimals: u8,\n\n    /// This is the validator that all tokens will be bonded to\n    pub validator: HumanAddr,\n\n    /// this is how much the owner takes as a cut when someone unbonds\n    /// TODO\n    pub exit_tax: Decimal,\n    /// This is the minimum amount we will pull out to reinvest, as well as a minumum\n    /// that can be unbonded (to avoid needless staking tx)\n    pub min_withdrawal: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    /// Transfer moves the derivative token\n    Transfer {\n        recipient: HumanAddr,\n        amount: Uint128,\n    },\n    /// Bond will bond all staking tokens sent with the message and release derivative tokens\n    Bond {},\n    /// Unbond will \"burn\" the given amount of derivative tokens and send the unbonded\n    /// staking tokens to the message sender (after exit tax is deducted)\n    Unbond { amount: Uint128 },\n    /// Claim is used to claim your native tokens that you previously \"unbonded\"\n    /// after the chain-defined waiting period (eg. 3 weeks)\n    Claim {},\n    /// Reinvest will check for all accumulated rewards, withdraw them, and\n    /// re-bond them to the same validator. Anyone can call this, which updates\n    /// the value of the token (how much under custody).\n    Reinvest {},\n    /// _BondAllTokens can only be called by the contract itself, after all rewards have been\n    /// withdrawn. This is an example of using \"callbacks\" in message flows.\n    /// This can only be invoked by the contract itself as a return from Reinvest\n    _BondAllTokens {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    /// Balance shows the number of staking derivatives\n    Balance { address: HumanAddr },\n    /// Claims shows the number of tokens this address can access when they are done unbonding\n    Claims { address: HumanAddr },\n    /// TokenInfo shows the metadata of the token for UIs\n    TokenInfo {},\n    /// Investment shows info on total staking tokens under custody,\n    /// with which validator, as well as how many derivative tokens are lists.\n    /// It also shows with the exit tax.\n    Investment {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct BalanceResponse {\n    pub balance: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct ClaimsResponse {\n    pub claims: Uint128,\n}\n\n/// TokenInfoResponse is info to display the derivative token in a UI\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct TokenInfoResponse {\n    /// name of the derivative token\n    pub name: String,\n    /// symbol / ticker of the derivative token\n    pub symbol: String,\n    /// decimal places of the derivative token (for UI)\n    pub decimals: u8,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InvestmentResponse {\n    pub token_supply: Uint128,\n    pub staked_tokens: Coin,\n    // ratio of staked_tokens / token_supply (or how many native tokens that one derivative token is nominally worth)\n    pub nominal_value: Decimal,\n\n    /// owner created the contract and takes a cut\n    pub owner: HumanAddr,\n    /// this is how much the owner takes as a cut when someone unbonds\n    pub exit_tax: Decimal,\n    /// All tokens are bonded to this validator\n    pub validator: HumanAddr,\n    /// This is the minimum amount we will pull out to reinvest, as well as a minumum\n    /// that can be unbonded (to avoid needless staking tx)\n    pub min_withdrawal: Uint128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","staking","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{CanonicalAddr, Decimal, HumanAddr, ReadonlyStorage, Storage, Uint128};\nuse cosmwasm_storage::{\n    bucket, bucket_read, singleton, singleton_read, Bucket, ReadonlyBucket, ReadonlySingleton,\n    Singleton,\n};\n\nuse crate::msg::TokenInfoResponse;\n\npub const KEY_INVESTMENT: \u0026[u8] = b\"invest\";\npub const KEY_TOKEN_INFO: \u0026[u8] = b\"token\";\npub const KEY_TOTAL_SUPPLY: \u0026[u8] = b\"total_supply\";\n\npub const PREFIX_BALANCE: \u0026[u8] = b\"balance\";\npub const PREFIX_CLAIMS: \u0026[u8] = b\"claim\";\n\n/// balances are state of the erc20 tokens\npub fn balances\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Bucket\u003cS, Uint128\u003e {\n    bucket(PREFIX_BALANCE, storage)\n}\n\npub fn balances_read\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e ReadonlyBucket\u003cS, Uint128\u003e {\n    bucket_read(PREFIX_BALANCE, storage)\n}\n\n/// claims are the claims to money being unbonded\npub fn claims\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Bucket\u003cS, Uint128\u003e {\n    bucket(PREFIX_CLAIMS, storage)\n}\n\npub fn claims_read\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e ReadonlyBucket\u003cS, Uint128\u003e {\n    bucket_read(PREFIX_CLAIMS, storage)\n}\n\n/// Investment info is fixed at initialization, and is used to control the function of the contract\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InvestmentInfo {\n    /// owner created the contract and takes a cut\n    pub owner: CanonicalAddr,\n    /// this is the denomination we can stake (and only one we accept for payments)\n    pub bond_denom: String,\n    /// this is how much the owner takes as a cut when someone unbonds\n    pub exit_tax: Decimal,\n    /// All tokens are bonded to this validator\n    /// FIXME: humanize/canonicalize address doesn't work for validator addrresses\n    pub validator: HumanAddr,\n    /// This is the minimum amount we will pull out to reinvest, as well as a minumum\n    /// that can be unbonded (to avoid needless staking tx)\n    pub min_withdrawal: Uint128,\n}\n\n/// Supply is dynamic and tracks the current supply of staked and ERC20 tokens.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Default)]\npub struct Supply {\n    /// issued is how many derivative tokens this contract has issued\n    pub issued: Uint128,\n    /// bonded is how many native tokens exist bonded to the validator\n    pub bonded: Uint128,\n    /// claims is how many tokens need to be reserved paying back those who unbonded\n    pub claims: Uint128,\n}\n\npub fn invest_info\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, InvestmentInfo\u003e {\n    singleton(storage, KEY_INVESTMENT)\n}\n\npub fn invest_info_read\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, InvestmentInfo\u003e {\n    singleton_read(storage, KEY_INVESTMENT)\n}\n\npub fn token_info\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, TokenInfoResponse\u003e {\n    singleton(storage, KEY_TOKEN_INFO)\n}\n\npub fn token_info_read\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, TokenInfoResponse\u003e {\n    singleton_read(storage, KEY_TOKEN_INFO)\n}\n\npub fn total_supply\u003cS: Storage\u003e(storage: \u0026mut S) -\u003e Singleton\u003cS, Supply\u003e {\n    singleton(storage, KEY_TOTAL_SUPPLY)\n}\n\npub fn total_supply_read\u003cS: ReadonlyStorage\u003e(storage: \u0026S) -\u003e ReadonlySingleton\u003cS, Supply\u003e {\n    singleton_read(storage, KEY_TOTAL_SUPPLY)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","contracts","staking","tests","integration.rs"],"content":"//! This integration test tries to run and call the generated wasm.\n//! It depends on a Wasm build being available, which you can create with `cargo wasm`.\n//! Then running `cargo integration-test` will validate we can properly call into that generated Wasm.\n//!\n//! You can easily convert unit tests to integration tests as follows:\n//! 1. Copy them over verbatim\n//! 2. Then change\n//!      let mut deps = mock_dependencies(20, \u0026[]);\n//!    to\n//!      let mut deps = mock_instance(WASM, \u0026[]);\n//! 3. If you access raw storage, where ever you see something like:\n//!      deps.storage.get(CONFIG_KEY).expect(\"no data stored\");\n//!    replace it with:\n//!      deps.with_storage(|store| {\n//!          let data = store.get(CONFIG_KEY).expect(\"no data stored\");\n//!          //...\n//!      });\n//! 4. Anywhere you see query(\u0026deps, ...) you must replace it with query(\u0026mut deps, ...)\n\nuse cosmwasm_std::{\n    coin, from_binary, Decimal, HumanAddr, InitResponse, StdError, StdResult, Uint128, Validator,\n};\nuse cosmwasm_vm::testing::{init, mock_dependencies, mock_env, query};\nuse cosmwasm_vm::Instance;\n\nuse staking::msg::{\n    BalanceResponse, ClaimsResponse, InitMsg, InvestmentResponse, QueryMsg, TokenInfoResponse,\n};\n\n// This line will test the output of cargo wasm\nstatic WASM: \u0026[u8] = include_bytes!(\"../target/wasm32-unknown-unknown/release/staking.wasm\");\n// You can uncomment this line instead to test productionified build from cosmwasm-opt\n// static WASM: \u0026[u8] = include_bytes!(\"../contract.wasm\");\n\nfn sample_validator\u003cU: Into\u003cHumanAddr\u003e\u003e(addr: U) -\u003e Validator {\n    Validator {\n        address: addr.into(),\n        commission: Decimal::percent(3),\n        max_commission: Decimal::percent(10),\n        max_change_rate: Decimal::percent(1),\n    }\n}\n\n#[test]\nfn initialization_with_missing_validator() {\n    let mut ext = mock_dependencies(20, \u0026[]);\n    ext.querier\n        .update_staking(\"ustake\", \u0026[sample_validator(\"john\")], \u0026[]);\n    let mut deps = Instance::from_code(WASM, ext, 500_000).unwrap();\n\n    let creator = HumanAddr::from(\"creator\");\n    let msg = InitMsg {\n        name: \"Cool Derivative\".to_string(),\n        symbol: \"DRV\".to_string(),\n        decimals: 9,\n        validator: HumanAddr::from(\"my-validator\"),\n        exit_tax: Decimal::percent(2),\n        min_withdrawal: Uint128(50),\n    };\n    let env = mock_env(\u0026creator, \u0026[]);\n\n    // make sure we can init with this\n    let res: StdResult\u003cInitResponse\u003e = init(\u0026mut deps, env, msg.clone());\n    match res.unwrap_err() {\n        StdError::GenericErr { msg, .. } =\u003e {\n            assert_eq!(msg, \"my-validator is not in the current validator set\")\n        }\n        _ =\u003e panic!(\"expected unregistered validator error\"),\n    }\n}\n\n#[test]\nfn proper_initialization() {\n    // we need to use the verbose approach here to customize the querier with staking info\n    let mut ext = mock_dependencies(20, \u0026[]);\n    ext.querier.update_staking(\n        \"ustake\",\n        \u0026[\n            sample_validator(\"john\"),\n            sample_validator(\"mary\"),\n            sample_validator(\"my-validator\"),\n        ],\n        \u0026[],\n    );\n    let mut deps = Instance::from_code(WASM, ext, 500_000).unwrap();\n    assert_eq!(deps.required_features.len(), 1);\n    assert!(deps.required_features.contains(\"staking\"));\n\n    let creator = HumanAddr::from(\"creator\");\n    let msg = InitMsg {\n        name: \"Cool Derivative\".to_string(),\n        symbol: \"DRV\".to_string(),\n        decimals: 9,\n        validator: HumanAddr::from(\"my-validator\"),\n        exit_tax: Decimal::percent(2),\n        min_withdrawal: Uint128(50),\n    };\n    let env = mock_env(\u0026creator, \u0026[]);\n\n    // make sure we can init with this\n    let res: InitResponse = init(\u0026mut deps, env, msg.clone()).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // token info is proper\n    let res = query(\u0026mut deps, QueryMsg::TokenInfo {}).unwrap();\n    let token: TokenInfoResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(\u0026token.name, \u0026msg.name);\n    assert_eq!(\u0026token.symbol, \u0026msg.symbol);\n    assert_eq!(token.decimals, msg.decimals);\n\n    // no balance\n    let res = query(\n        \u0026mut deps,\n        QueryMsg::Balance {\n            address: creator.clone(),\n        },\n    )\n    .unwrap();\n    let bal: BalanceResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(bal.balance, Uint128(0));\n\n    // no claims\n    let res = query(\n        \u0026mut deps,\n        QueryMsg::Claims {\n            address: creator.clone(),\n        },\n    )\n    .unwrap();\n    let claim: ClaimsResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(claim.claims, Uint128(0));\n\n    // investment info correct\n    let res = query(\u0026mut deps, QueryMsg::Investment {}).unwrap();\n    let invest: InvestmentResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(\u0026invest.owner, \u0026creator);\n    assert_eq!(\u0026invest.validator, \u0026msg.validator);\n    assert_eq!(invest.exit_tax, msg.exit_tax);\n    assert_eq!(invest.min_withdrawal, msg.min_withdrawal);\n\n    assert_eq!(invest.token_supply, Uint128(0));\n    assert_eq!(invest.staked_tokens, coin(0, \"ustake\"));\n    assert_eq!(invest.nominal_value, Decimal::one());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","enclave-ffi-types","build.rs"],"content":"#[cfg(feature = \"build_headers\")]\nuse std::env;\n#[cfg(feature = \"build_headers\")]\nuse std::path::PathBuf;\n\n#[cfg(feature = \"build_headers\")]\nuse thiserror::Error;\n\n#[cfg(feature = \"build_headers\")]\n#[derive(Debug, Error)]\nenum Error {\n    #[error(transparent)]\n    CBindgenError {\n        #[from]\n        source: cbindgen::Error,\n    },\n    #[error(\"{path}\")]\n    BadOutDir { path: PathBuf },\n}\n#[cfg(feature = \"build_headers\")]\nfn main() -\u003e Result\u003c(), Error\u003e {\n    let crate_dir = env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n    // This is a directory under the `target` directory of the crate building us.\n    let out_dir = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    // This path will point to a file under the `target/headers` directory of whoever's building us.\n    let header_path = {\n        let mut path = out_dir.clone();\n        while path.file_name() != Some(\u0026std::ffi::OsString::from(\"target\")) {\n            // If for some reason we scanned the entire path and failed to find the `target` directory, return an error\n            if !path.pop() {\n                return Err(Error::BadOutDir { path: out_dir });\n            }\n        }\n        path.push(\"headers\");\n        path.push(\"enclave-ffi-types.h\"); // This should always equal the crate name\n        path\n    };\n\n    cbindgen::generate(crate_dir)?.write_to_file(header_path);\n\n    Ok(())\n}\n\n#[cfg(not(feature = \"build_headers\"))]\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","enclave-ffi-types","src","lib.rs"],"content":"#![no_std]\n#![allow(unused)]\n\nmod types;\n\npub use types::{\n    Ctx, EnclaveBuffer, EnclaveError, HandleResult, InitResult, NodeAuthResult, OcallReturn,\n    QueryResult, UntrustedVmError, UserSpaceBuffer, HealthCheckResult\n};\n\npub const ENCRYPTED_SEED_SIZE: usize = 48;\npub const PUBLIC_KEY_SIZE: usize = 32;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","enclave-ffi-types","src","types.rs"],"content":"#![allow(unused)]\n\nuse core::ffi::c_void;\nuse derive_more::Display;\n\n/// This type represents an opaque pointer to a memory address in normal user space.\n#[repr(C)]\npub struct UserSpaceBuffer {\n    pub ptr: *mut c_void,\n}\n\n/// This type represents an opaque pointer to a memory address inside the enclave.\n#[repr(C)]\npub struct EnclaveBuffer {\n    pub ptr: *mut c_void,\n}\n\nimpl EnclaveBuffer {\n    /// # Safety\n    /// Very unsafe. Much careful\n    pub unsafe fn unsafe_clone(\u0026self) -\u003e Self {\n        EnclaveBuffer { ptr: self.ptr }\n    }\n}\n\n/// This is safe because `Vec\u003cu8\u003e`s are `Send`\nunsafe impl Send for EnclaveBuffer {}\n\nimpl Default for EnclaveBuffer {\n    fn default() -\u003e Self {\n        Self {\n            ptr: core::ptr::null_mut(),\n        }\n    }\n}\n\n/// This struct holds a pointer to memory in userspace, that contains the storage\n#[repr(C)]\npub struct Ctx {\n    pub data: *mut c_void,\n}\n\nimpl Ctx {\n    /// # Safety\n    /// Very unsafe. Much careful\n    pub unsafe fn unsafe_clone(\u0026self) -\u003e Self {\n        Self { data: self.data }\n    }\n}\n\n/// This type represents the possible error conditions that can be encountered in the enclave\n/// cbindgen:prefix-with-name\n#[repr(C)]\n#[derive(Debug, Display)]\npub enum EnclaveError {\n    /// An ocall failed to execute. This can happen because of three scenarios:\n    /// 1. A VmError was thrown during the execution of the ocall. In this case, `vm_error` will be non-null.\n    /// 2. An error happened that prevented the ocall from running correctly. This can happen because of\n    ///    caught memory-handling issues, or a failed ecall during an ocall. `vm_error` will be null.\n    /// 3. We failed to call the ocall due to an SGX fault. `vm_error` will be null.\n    // TODO should we split these three cases for better diagnostics?\n    #[display(fmt = \"failed to execute ocall\")]\n    FailedOcall { vm_error: UntrustedVmError },\n    #[display(fmt = \"failed to validate transaction\")]\n    ValidationFailure,\n    // Problems with the module binary\n    /// The WASM code was invalid and could not be loaded.\n    #[display(fmt = \"tried to load invalid wasm code\")]\n    InvalidWasm,\n    #[display(fmt = \"failed to initialize wasm memory\")]\n    CannotInitializeWasmMemory,\n    /// The WASM module contained a start section, which is not allowed.\n    WasmModuleWithStart,\n    /// The WASM module contained floating point operations, which is not allowed.\n    #[display(fmt = \"found floating point operation in module code\")]\n    WasmModuleWithFP,\n    /// Fail to inject gas metering\n    #[display(fmt = \"failed to inject gas metering\")]\n    FailedGasMeteringInjection,\n    #[display(fmt = \"internal error during execution\")]\n    InternalError,\n    // runtime issues with the module\n    /// Ran out of gas\n    #[display(fmt = \"execution ran out of gas\")]\n    OutOfGas,\n    /// Calling a function in the contract failed.\n    #[display(fmt = \"calling a function in the contract failed for an unexpected reason\")]\n    FailedFunctionCall,\n    // These variants mimic the variants of `wasmi::TrapKind`\n    /// The contract panicked during execution.\n    #[display(fmt = \"the contract panicked\")]\n    ContractPanicUnreachable,\n    /// The contract tried to access memory out of bounds.\n    #[display(fmt = \"the contract tried to access memory out of bounds\")]\n    ContractPanicMemoryAccessOutOfBounds,\n    /// The contract tried to access a nonexistent resource.\n    #[display(fmt = \"the contract tried to access a nonexistent resource\")]\n    ContractPanicTableAccessOutOfBounds,\n    /// The contract tried to access an uninitialized resource.\n    #[display(fmt = \"the contract tried to access an uninitialized resource\")]\n    ContractPanicElemUninitialized,\n    /// The contract tried to divide by zero.\n    #[display(fmt = \"the contract tried to divide by zero\")]\n    ContractPanicDivisionByZero,\n    /// The contract tried to perform an invalid conversion to an integer.\n    #[display(fmt = \"the contract tried to perform an invalid conversion to an integer\")]\n    ContractPanicInvalidConversionToInt,\n    /// The contract has run out of space on the stack.\n    #[display(fmt = \"the contract has run out of space on the stack\")]\n    ContractPanicStackOverflow,\n    /// The contract tried to call a function but expected an incorrect function signature.\n    #[display(\n        fmt = \"the contract tried to call a function but expected an incorrect function signature\"\n    )]\n    ContractPanicUnexpectedSignature,\n\n    // Errors in contract ABI:\n    /// Failed to seal data\n    #[display(fmt = \"failed to seal data\")]\n    FailedSeal,\n    #[display(fmt = \"failed to unseal data\")]\n    FailedUnseal,\n    #[display(fmt = \"failed to authenticate secret contract\")]\n    FailedContractAuthentication,\n    #[display(fmt = \"failed to deserialize data\")]\n    FailedToDeserialize,\n    #[display(fmt = \"failed to serialize data\")]\n    FailedToSerialize,\n    #[display(fmt = \"failed to encrypt data\")]\n    EncryptionError,\n    #[display(fmt = \"failed to decrypt data\")]\n    DecryptionError,\n    #[display(fmt = \"failed to allocate memory\")]\n    MemoryAllocationError,\n    #[display(fmt = \"failed to allocate minimal safety buffer\")]\n    MemorySafetyAllocationError,\n    #[display(fmt = \"failed to read memory\")]\n    MemoryReadError,\n    #[display(fmt = \"failed to write memory\")]\n    MemoryWriteError,\n    #[display(fmt = \"function not implemented\")]\n    NotImplemented,\n    #[display(fmt = \"failed to verify transaction signature\")]\n    FailedTxVerification,\n    #[display(fmt = \"contract tried to write to storage during a query\")]\n    UnauthorizedWrite,\n\n    // serious issues\n    /// The host was caught trying to disrupt the enclave.\n    /// This can happen if e.g. the host provides invalid pointers as responses from ocalls.\n    #[display(fmt = \"communication with the enclave's host failed\")]\n    HostMisbehavior,\n    #[display(fmt = \"panicked due to unexpected behavior\")]\n    Panic,\n    #[display(fmt = \"enclave ran out of heap memory\")]\n    OutOfMemory,\n    #[display(fmt = \"depth of nested contract calls exceeded\")]\n    ExceededRecursionLimit,\n    /// Unexpected Error happened, no more details available\n    #[display(fmt = \"unknown error\")]\n    Unknown,\n}\n\n/// This type represents the possible error conditions that can be encountered in the\n/// enclave while authenticating a new node in the network.\n/// cbindgen:prefix-with-name\n#[repr(C)]\n#[derive(Debug, Display, PartialEq, Eq)]\npub enum NodeAuthResult {\n    #[display(fmt = \"Enclave quote is valid\")]\n    Success,\n    #[display(fmt = \"Enclave quote status was GROUP_OUT_OF_DATE which is not allowed\")]\n    GroupOutOfDate,\n    #[display(fmt = \"Enclave quote status was SIGNATURE_INVALID which is not allowed\")]\n    SignatureInvalid,\n    #[display(fmt = \"Enclave quote status was SIGNATURE_REVOKED which is not allowed\")]\n    SignatureRevoked,\n    #[display(fmt = \"Enclave quote status was GROUP_REVOKED which is not allowed\")]\n    GroupRevoked,\n    #[display(fmt = \"Enclave quote status was KEY_REVOKED which is not allowed\")]\n    KeyRevoked,\n    #[display(fmt = \"Enclave quote status was SIGRL_VERSION_MISMATCH which is not allowed\")]\n    SigrlVersionMismatch,\n    #[display(fmt = \"Enclave quote status was CONFIGURATION_NEEDED which is not allowed\")]\n    ConfigurationNeeded,\n    #[display(\n        fmt = \"Enclave quote status was CONFIGURATION_AND_SW_HARDENING_NEEDED which is not allowed\"\n    )]\n    SwHardeningAndConfigurationNeeded,\n    #[display(fmt = \"Enclave quote status invalid\")]\n    BadQuoteStatus,\n    #[display(fmt = \"Enclave version mismatch. Registering enclave had different code signature\")]\n    MrEnclaveMismatch,\n    #[display(fmt = \"Enclave version mismatch. Registering enclave had different signer\")]\n    MrSignerMismatch,\n    #[display(fmt = \"Enclave received invalid inputs\")]\n    InvalidInput,\n    #[display(fmt = \"The provided certificate was invalid\")]\n    InvalidCert,\n    #[display(fmt = \"Writing to file system from the enclave failed\")]\n    CantWriteToStorage,\n    #[display(fmt = \"The public key in the certificate appears to be malformed\")]\n    MalformedPublicKey,\n    #[display(fmt = \"Encrypting the seed failed\")]\n    SeedEncryptionFailed,\n    #[display(fmt = \"failed to allocate minimal safety buffer\")]\n    MemorySafetyAllocationError,\n    #[display(\n        fmt = \"Unexpected panic during node authentication. Certificate may be malformed or invalid\"\n    )]\n    Panic,\n}\n\n/// This type represents the possible error conditions that can be encountered in the\n/// enclave while authenticating a new node in the network.\n/// cbindgen:prefix-with-name\n#[repr(C)]\n#[derive(Debug, Display, PartialEq, Eq)]\npub enum HealthCheckResult {\n    Success,\n}\n\nimpl Default for HealthCheckResult {\n    fn default() -\u003e Self {\n        HealthCheckResult::Success\n    }\n}\n\n/// This type holds a pointer to a VmError that is boxed on the untrusted side\n// `VmError` is the standard error type for the `cosmwasm-sgx-vm` layer.\n// During an ocall, we call into the original implementation of `db_read`, `db_write`, and `db_remove`.\n// These call out all the way to the Go side. They return `VmError` when something goes wrong in this process.\n// These errors need to be propagated back into and out of the enclave, and then bacl into the `cosmwasm-sgx-vm` layer.\n// There is never anything we can do with these errors inside the enclave, so instead of converting `VmError`\n// to a type that the enclave can understand, we just box it bedore returning from the enclave, store the heap pointer\n// in an instance of `UntrustedVmError`, propagate this error all the way back to the point that called\n// into the enclave, and then finally unwrap the `VmError`, which gets propagated up the normal stack.\n//\n// For a more detailed discussion, see:\n// https://github.com/enigmampc/SecretNetwork/pull/307#issuecomment-651157410\n#[repr(C)]\n#[derive(Debug, Display)]\n#[display(fmt = \"VmError\")]\npub struct UntrustedVmError {\n    pub ptr: *mut c_void,\n}\n\nimpl UntrustedVmError {\n    pub fn new(ptr: *mut c_void) -\u003e Self {\n        Self { ptr }\n    }\n}\n\nimpl Default for UntrustedVmError {\n    fn default() -\u003e Self {\n        Self {\n            ptr: core::ptr::null_mut(),\n        }\n    }\n}\n\n// These implementations are safe because we know that it will only ever be a Box\u003cVmError\u003e,\n// which also has these traits.\nunsafe impl Send for UntrustedVmError {}\nunsafe impl Sync for UntrustedVmError {}\n\n/// This type represent return statuses from ocalls.\n///\n/// cbindgen:prefix-with-name\n#[repr(C)]\n#[derive(Debug, Display)]\npub enum OcallReturn {\n    /// Ocall returned successfully.\n    Success,\n    /// Ocall failed for some reason.\n    /// error parameters may be passed as out parameters.\n    Failure,\n    /// A panic happened during the ocall.\n    Panic,\n}\n\n/// This struct is returned from ecall_init.\n/// cbindgen:prefix-with-name\n#[repr(C)]\npub enum InitResult {\n    Success {\n        /// A pointer to the output of the calculation\n        output: UserSpaceBuffer,\n        /// The contract_key for this contract.\n        contract_key: [u8; 64],\n    },\n    Failure {\n        /// The error that happened in the enclave\n        err: EnclaveError,\n    },\n}\n\n/// This struct is returned from ecall_handle.\n/// cbindgen:prefix-with-name\n#[repr(C)]\npub enum HandleResult {\n    Success {\n        /// A pointer to the output of the calculation\n        output: UserSpaceBuffer,\n    },\n    Failure {\n        /// The error that happened in the enclave\n        err: EnclaveError,\n    },\n}\n\n/// This struct is returned from ecall_query.\n/// cbindgen:prefix-with-name\n#[repr(C)]\npub enum QueryResult {\n    Success {\n        /// A pointer to the output of the calculation\n        output: UserSpaceBuffer,\n    },\n    Failure {\n        /// The error that happened in the enclave\n        err: EnclaveError,\n    },\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","enclave-test","build.rs"],"content":"use std::env;\n\nfn main() {\n    let is_sim = env::var(\"SGX_MODE\").unwrap_or_else(|_| \"HW\".to_string());\n    let sdk_dir = env::var(\"SGX_SDK\").unwrap_or_else(|_| \"/opt/intel/sgxsdk\".to_string());\n\n    println!(\"cargo:rustc-link-search=native=./lib\");\n    println!(\"cargo:rustc-link-lib=static=Enclave_u\");\n\n    println!(\"cargo:rustc-link-search=native={}/lib64\", sdk_dir);\n    println!(\"cargo:rustc-link-lib=static=sgx_uprotected_fs\");\n    println!(\"cargo:rustc-link-lib=static=sgx_ukey_exchange\");\n\n    match is_sim.as_ref() {\n        \"SW\" =\u003e {\n            println!(\"cargo:rustc-link-lib=dylib=sgx_urts_sim\");\n            println!(\"cargo:rustc-link-lib=dylib=sgx_uae_service_sim\");\n        }\n        // Treat undefined as HW\n        _ =\u003e {\n            println!(\"cargo:rustc-link-lib=dylib=sgx_urts\");\n            println!(\"cargo:rustc-link-lib=dylib=sgx_uae_service\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","enclave-test","src","main.rs"],"content":"//! This file is a wrapper for tests running in the enclave.\nuse cosmwasm_sgx_vm::enclave_tests::run_tests;\n\nfn main() -\u003e Result\u003c(), ()\u003e {\n    match run_tests() {\n        Ok(failed_tests) =\u003e {\n            println!(\"{} tests failed in enclave test suite\", failed_tests);\n            match failed_tests {\n                0 =\u003e Ok(()),\n                _ =\u003e Err(()),\n            }\n        }\n        Err(status) =\u003e {\n            println!(\"Enclave returned {}\", status);\n            Err(())\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","schema","src","casing.rs"],"content":"pub fn to_snake_case(name: \u0026str) -\u003e String {\n    let mut out = String::new();\n    for (index, ch) in name.char_indices() {\n        if index != 0 \u0026\u0026 ch.is_uppercase() {\n            out.push('_');\n        }\n        out.push(ch.to_ascii_lowercase());\n    }\n    out\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn to_snake_case_leaves_snake_case_untouched() {\n        assert_eq!(to_snake_case(\"\"), \"\");\n        assert_eq!(to_snake_case(\"a\"), \"a\");\n        assert_eq!(to_snake_case(\"abc\"), \"abc\");\n        assert_eq!(to_snake_case(\"a_bc\"), \"a_bc\");\n    }\n\n    #[test]\n    fn to_snake_case_works_for_camel_case() {\n        assert_eq!(to_snake_case(\"Foobar\"), \"foobar\");\n        assert_eq!(to_snake_case(\"FooBar\"), \"foo_bar\");\n        assert_eq!(to_snake_case(\"ABC\"), \"a_b_c\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","schema","src","export.rs"],"content":"//! Export schema to file\n\nuse std::fs::write;\nuse std::path::PathBuf;\n\nuse schemars::schema::RootSchema;\n\nuse crate::casing::to_snake_case;\n\n// Exports a schema, auto-generating filename based on the metadata title of the generated schema.\npub fn export_schema(schema: \u0026RootSchema, out_dir: \u0026PathBuf) {\n    let title = schema\n        .schema\n        .metadata\n        .as_ref()\n        .map(|b| b.title.clone().unwrap_or_else(|| \"untitled\".to_string()))\n        .unwrap_or_else(|| \"unknown\".to_string());\n    write_schema(schema, out_dir, \u0026title);\n}\n\n// use this if you want to override the auto-detected name of the object.\n// very useful when creating an alias for a type-alias.\npub fn export_schema_with_title(schema: \u0026mut RootSchema, out_dir: \u0026PathBuf, title: \u0026str) {\n    // set the title explicitly on the schemas metadata\n    let metadata = \u0026mut schema.schema.metadata;\n    if let Some(data) = metadata {\n        data.title = Some(title.to_string());\n    }\n    write_schema(schema, out_dir, \u0026title);\n}\n\n/// Writes schema to file. Overwrites existing file.\n/// Panics on any error writing out the schema.\nfn write_schema(schema: \u0026RootSchema, out_dir: \u0026PathBuf, title: \u0026str) {\n    // first, we set the title as we wish\n    let path = out_dir.join(format!(\"{}.json\", to_snake_case(\u0026title)));\n    let json = serde_json::to_string_pretty(schema).unwrap();\n    write(\u0026path, json + \"\\n\").unwrap();\n    println!(\"Created {}\", path.to_str().unwrap());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","schema","src","lib.rs"],"content":"mod casing;\nmod export;\nmod remove;\n\npub use export::{export_schema, export_schema_with_title};\npub use remove::remove_schemas;\n\n// Re-exports\npub use schemars::schema_for;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","schema","src","remove.rs"],"content":"use std::{fs, io, path};\n\nfn is_regular_file(path: \u0026path::Path) -\u003e Result\u003cbool, io::Error\u003e {\n    Ok(path.symlink_metadata()?.is_file())\n}\n\nfn is_hidden(path: \u0026path::Path) -\u003e bool {\n    match path.file_name() {\n        Some(name) =\u003e name.to_os_string().to_string_lossy().starts_with('.'),\n        None =\u003e false, // a path without filename is no .*\n    }\n}\n\nfn is_json(path: \u0026path::Path) -\u003e bool {\n    match path.file_name() {\n        Some(name) =\u003e name.to_os_string().to_string_lossy().ends_with(\".json\"),\n        None =\u003e false, // a path without filename is no *.json\n    }\n}\n\npub fn remove_schemas(schemas_dir: \u0026path::Path) -\u003e Result\u003c(), io::Error\u003e {\n    let file_paths = fs::read_dir(schemas_dir)?\n        .filter_map(Result::ok) // skip read errors on entries\n        .map(|entry| entry.path())\n        .filter(|path| is_regular_file(path).unwrap_or(false)) // skip directories and symlinks\n        .filter(|path| !is_hidden(path)) // skip hidden\n        .filter(|path| is_json(path)) // skip non JSON\n        ;\n\n    for file_path in file_paths {\n        println!(\"Removing {:?} …\", file_path);\n        fs::remove_file(file_path)?;\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use std::ffi::OsStr;\n    use std::path::Path;\n\n    #[test]\n    fn is_hidden_works() {\n        assert_eq!(is_hidden(Path::new(\"/foo\")), false);\n        assert_eq!(is_hidden(Path::new(\"/foo/bar\")), false);\n        assert_eq!(is_hidden(Path::new(\"/foo/bar.txt\")), false);\n        assert_eq!(is_hidden(Path::new(\"~foo\")), false);\n        assert_eq!(is_hidden(Path::new(\"foo\")), false);\n\n        assert_eq!(is_hidden(Path::new(\"/.foo\")), true);\n        assert_eq!(is_hidden(Path::new(\"/foo/.bar\")), true);\n        assert_eq!(is_hidden(Path::new(\"/foo/.bar.txt\")), true);\n        assert_eq!(is_hidden(Path::new(\".foo\")), true);\n\n        // no filename\n        assert_eq!(is_hidden(Path::new(\"/\")), false);\n        assert_eq!(is_hidden(Path::new(\"\")), false);\n\n        // invalid UTF-8\n        #[cfg(any(unix, target_os = \"redox\"))]\n        {\n            use std::os::unix::ffi::OsStrExt;\n            let non_hidden = OsStr::from_bytes(\u0026[0x66, 0x6f, 0x80, 0x6f]); // fo�o\n            assert_eq!(is_hidden(Path::new(non_hidden)), false);\n            let hidden = OsStr::from_bytes(\u0026[0x2e, 0x66, 0x6f, 0x80, 0x6f]); // .fo�o\n            assert_eq!(is_hidden(Path::new(hidden)), true);\n        }\n    }\n\n    #[test]\n    fn is_json_works() {\n        assert_eq!(is_json(Path::new(\"/foo\")), false);\n        assert_eq!(is_json(Path::new(\"/foo/bar\")), false);\n        assert_eq!(is_json(Path::new(\"/foo/bar.txt\")), false);\n        assert_eq!(is_json(Path::new(\"~foo\")), false);\n        assert_eq!(is_json(Path::new(\"foo\")), false);\n        assert_eq!(is_json(Path::new(\"foo.json5\")), false);\n\n        assert_eq!(is_json(Path::new(\"/.json\")), true);\n        assert_eq!(is_json(Path::new(\"/foo/.bar.json\")), true);\n        assert_eq!(is_json(Path::new(\"/foo/bar.json\")), true);\n        assert_eq!(is_json(Path::new(\"foo.json\")), true);\n\n        // no filename\n        assert_eq!(is_json(Path::new(\"/\")), false);\n        assert_eq!(is_json(Path::new(\"\")), false);\n\n        // invalid UTF-8\n        #[cfg(any(unix, target_os = \"redox\"))]\n        {\n            use std::os::unix::ffi::OsStrExt;\n            let non_hidden = OsStr::from_bytes(\u0026[0x66, 0x6f, 0x80, 0x6f]); // fo�o\n            assert_eq!(is_json(Path::new(non_hidden)), false);\n            let hidden = OsStr::from_bytes(\u0026[0x66, 0x6f, 0x80, 0x6f, 0x2e, 0x6a, 0x73, 0x6f, 0x6e]); // fo�o.json\n            assert_eq!(is_json(Path::new(hidden)), true);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","attestation.rs"],"content":"use std::net::{SocketAddr, TcpStream};\nuse std::os::unix::io::IntoRawFd;\n\nuse std::{self};\n\nuse log::*;\nuse sgx_types::*;\nuse sgx_types::{sgx_status_t, SgxResult};\n\nuse enclave_ffi_types::{NodeAuthResult, ENCRYPTED_SEED_SIZE};\n\nuse crate::enclave::get_enclave;\n\nextern \"C\" {\n    pub fn ecall_get_attestation_report(\n        eid: sgx_enclave_id_t,\n        retval: *mut sgx_status_t,\n        spid: *const u8,\n        spid_len: u32,\n        api_key: *const u8,\n        api_key_len: u32,\n    ) -\u003e sgx_status_t;\n    pub fn ecall_authenticate_new_node(\n        eid: sgx_enclave_id_t,\n        retval: *mut NodeAuthResult,\n        cert: *const u8,\n        cert_len: u32,\n        seed: \u0026mut [u8; ENCRYPTED_SEED_SIZE],\n    ) -\u003e sgx_status_t;\n}\n\n#[no_mangle]\npub extern \"C\" fn ocall_sgx_init_quote(\n    ret_ti: *mut sgx_target_info_t,\n    ret_gid: *mut sgx_epid_group_id_t,\n) -\u003e sgx_status_t {\n    trace!(\"Entering ocall_sgx_init_quote\");\n    unsafe { sgx_init_quote(ret_ti, ret_gid) }\n}\n\npub fn lookup_ipv4(host: \u0026str, port: u16) -\u003e SocketAddr {\n    use std::net::ToSocketAddrs;\n\n    let addrs = (host, port).to_socket_addrs().unwrap();\n    for addr in addrs {\n        if let SocketAddr::V4(_) = addr {\n            return addr;\n        }\n    }\n\n    unreachable!(\"Cannot lookup address\");\n}\n\n#[no_mangle]\npub extern \"C\" fn ocall_get_ias_socket(ret_fd: *mut c_int) -\u003e sgx_status_t {\n    let port = 443;\n    let hostname = \"api.trustedservices.intel.com\";\n    let addr = lookup_ipv4(hostname, port);\n    let sock = TcpStream::connect(\u0026addr).expect(\"[-] Connect tls server failed!\");\n\n    unsafe {\n        *ret_fd = sock.into_raw_fd();\n    }\n\n    sgx_status_t::SGX_SUCCESS\n}\n\n#[no_mangle]\npub extern \"C\" fn ocall_get_quote(\n    p_sigrl: *const u8,\n    sigrl_len: u32,\n    p_report: *const sgx_report_t,\n    quote_type: sgx_quote_sign_type_t,\n    p_spid: *const sgx_spid_t,\n    p_nonce: *const sgx_quote_nonce_t,\n    p_qe_report: *mut sgx_report_t,\n    p_quote: *mut u8,\n    _maxlen: u32,\n    p_quote_len: *mut u32,\n) -\u003e sgx_status_t {\n    trace!(\"Entering ocall_get_quote\");\n\n    let mut real_quote_len: u32 = 0;\n\n    let ret = unsafe { sgx_calc_quote_size(p_sigrl, sigrl_len, \u0026mut real_quote_len as *mut u32) };\n\n    if ret != sgx_status_t::SGX_SUCCESS {\n        trace!(\"sgx_calc_quote_size returned {}\", ret);\n        return ret;\n    }\n\n    trace!(\"quote size = {}\", real_quote_len);\n    unsafe {\n        *p_quote_len = real_quote_len;\n    }\n\n    let ret = unsafe {\n        sgx_get_quote(\n            p_report,\n            quote_type,\n            p_spid,\n            p_nonce,\n            p_sigrl,\n            sigrl_len,\n            p_qe_report,\n            p_quote as *mut sgx_quote_t,\n            real_quote_len,\n        )\n    };\n\n    if ret != sgx_status_t::SGX_SUCCESS {\n        trace!(\"sgx_calc_quote_size returned {}\", ret);\n        return ret;\n    }\n\n    trace!(\"sgx_calc_quote_size returned {}\", ret);\n    ret\n}\n\n#[no_mangle]\npub extern \"C\" fn ocall_get_update_info(\n    platform_blob: *const sgx_platform_info_t,\n    enclave_trusted: i32,\n    update_info: *mut sgx_update_info_bit_t,\n) -\u003e sgx_status_t {\n    unsafe { sgx_report_attestation_status(platform_blob, enclave_trusted, update_info) }\n}\n\npub fn create_attestation_report_u(spid: \u0026[u8], api_key: \u0026[u8]) -\u003e SgxResult\u003c()\u003e {\n    let enclave = get_enclave()?;\n\n    let eid = enclave.geteid();\n    let mut retval = sgx_status_t::SGX_SUCCESS;\n    let status = unsafe {\n        ecall_get_attestation_report(\n            eid,\n            \u0026mut retval,\n            spid.as_ptr(),\n            spid.len() as u32,\n            api_key.as_ptr(),\n            api_key.len() as u32,\n        )\n    };\n\n    if status != sgx_status_t::SGX_SUCCESS {\n        return Err(status);\n    }\n\n    if retval != sgx_status_t::SGX_SUCCESS {\n        return Err(retval);\n    }\n\n    Ok(())\n}\n\npub fn untrusted_get_encrypted_seed(\n    cert: \u0026[u8],\n) -\u003e SgxResult\u003cResult\u003c[u8; ENCRYPTED_SEED_SIZE], NodeAuthResult\u003e\u003e {\n    let enclave = get_enclave()?;\n    let eid = enclave.geteid();\n    let mut retval = NodeAuthResult::Success;\n    let mut seed = [0u8; ENCRYPTED_SEED_SIZE];\n    let status = unsafe {\n        ecall_authenticate_new_node(\n            eid,\n            \u0026mut retval,\n            cert.as_ptr(),\n            cert.len() as u32,\n            \u0026mut seed,\n        )\n    };\n\n    if status != sgx_status_t::SGX_SUCCESS {\n        return Err(status);\n    }\n\n    if retval != NodeAuthResult::Success {\n        return Ok(Err(retval));\n    }\n\n    if seed.is_empty() {\n        error!(\"Got empty seed from encryption\");\n        return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);\n    }\n\n    Ok(Ok(seed))\n}\n\n#[cfg(test)]\nmod test {\n    use crate::attestation::retry_quote;\n    use crate::esgx::general::init_enclave_wrapper;\n    use crate::instance::init_enclave as init_enclave_wrapper;\n\n    // isans SPID = \"3DDB338BD52EE314B01F1E4E1E84E8AA\"\n    // victors spid = 68A8730E9ABF1829EA3F7A66321E84D0\n    //const SPID: \u0026str = \"B0335FD3BC1CCA8F804EB98A6420592D\";\n\n    // #[test]\n    // fn test_produce_quote() {\n    //     // initiate the enclave\n    //     let enclave = init_enclave_wrapper().unwrap();\n    //     // produce a quote\n    //\n    //     let tested_encoded_quote = match retry_quote(enclave.geteid(), \u0026SPID, 18) {\n    //         Ok(encoded_quote) =\u003e encoded_quote,\n    //         Err(e) =\u003e {\n    //             error!(\"Produce quote Err {}, {}\", e.as_fail(), e.backtrace());\n    //             assert_eq!(0, 1);\n    //             return;\n    //         }\n    //     };\n    //     debug!(\"-------------------------\");\n    //     debug!(\"{}\", tested_encoded_quote);\n    //     debug!(\"-------------------------\");\n    //     enclave.destroy();\n    //     assert!(!tested_encoded_quote.is_empty());\n    //     // assert_eq!(real_encoded_quote, tested_encoded_quote);\n    // }\n\n    // #[test]\n    // fn test_produce_and_verify_qoute() {\n    //     let enclave = init_enclave_wrapper().unwrap();\n    //     let quote = retry_quote(enclave.geteid(), \u0026SPID, 18).unwrap();\n    //     let service = AttestationService::new(attestation_service::constants::ATTESTATION_SERVICE_URL);\n    //     let as_response = service.get_report(quote).unwrap();\n    //\n    //     assert!(as_response.result.verify_report().unwrap());\n    // }\n    //\n    // #[test]\n    // fn test_signing_key_against_quote() {\n    //     let enclave = init_enclave_wrapper().unwrap();\n    //     let quote = retry_quote(enclave.geteid(), \u0026SPID, 18).unwrap();\n    //     let service = AttestationService::new(attestation_service::constants::ATTESTATION_SERVICE_URL);\n    //     let as_response = service.get_report(quote).unwrap();\n    //     assert!(as_response.result.verify_report().unwrap());\n    //     let key = super::get_register_signing_address(enclave.geteid()).unwrap();\n    //     let quote = as_response.get_quote().unwrap();\n    //     assert_eq!(key, \u0026quote.report_body.report_data[..20]);\n    // }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","backends","cranelift.rs"],"content":"#![cfg(any(feature = \"cranelift\", feature = \"default-cranelift\"))]\nuse wasmer_clif_backend::CraneliftCompiler;\nuse wasmer_runtime_core::{\n    backend::Compiler, backend::CompilerConfig, compile_with_config, module::Module, vm::Ctx,\n};\n\nuse crate::errors::VmResult;\n\nconst FAKE_GAS_AVAILABLE: u64 = 1_000_000;\n\npub fn compile(code: \u0026[u8]) -\u003e VmResult\u003cModule\u003e {\n    let config = CompilerConfig {\n        enable_verification: false, // As discussed in https://github.com/CosmWasm/cosmwasm/issues/155\n        ..Default::default()\n    };\n    let module = compile_with_config(code, compiler().as_ref(), config)?;\n    Ok(module)\n}\n\npub fn compiler() -\u003e Box\u003cdyn Compiler\u003e {\n    Box::new(CraneliftCompiler::new())\n}\n\npub fn backend() -\u003e \u0026'static str {\n    \"cranelift\"\n}\n\n/// Set the amount of gas units that can be used in the context.\npub fn set_gas_left(_ctx: \u0026mut Ctx, _amount: u64) {}\n\n/// Get how many more gas units can be used in the context.\npub fn get_gas_left(_ctx: \u0026Ctx) -\u003e u64 {\n    FAKE_GAS_AVAILABLE\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","backends","enclave.rs"],"content":"#![cfg(any(feature = \"enclave\", feature = \"default-enclave\"))]\nuse crate::traits::{Querier, Storage};\nuse crate::wasmi::Module;\n\n/// Get how many more gas units can be used in the instance.\n#[allow(unused)]\npub fn get_gas_left\u003cS, Q\u003e(instance: \u0026Module\u003cS, Q\u003e) -\u003e u64\nwhere\n    S: Storage,\n    Q: Querier,\n{\n    instance.gas_left()\n}\n\n/// Get how many gas units were used in the instance.\npub fn get_gas_used\u003cS, Q\u003e(instance: \u0026Module\u003cS, Q\u003e) -\u003e u64\nwhere\n    S: Storage,\n    Q: Querier,\n{\n    instance.gas_used()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","backends","mod.rs"],"content":"/*\npub mod cranelift;\npub mod singlepass;\n*/\npub mod enclave;\n\n/*\npub use wasmer_runtime_core::backend::Compiler;\nuse wasmer_runtime_core::vm::Ctx;\n\npub fn compiler_for_backend(backend: \u0026str) -\u003e Option\u003cBox\u003cdyn Compiler\u003e\u003e {\n    match backend {\n        #[cfg(any(feature = \"cranelift\", feature = \"default-cranelift\"))]\n        \"cranelift\" =\u003e Some(cranelift::compiler()),\n\n        #[cfg(any(feature = \"singlepass\", feature = \"default-singlepass\"))]\n        \"singlepass\" =\u003e Some(singlepass::compiler()),\n\n        _ =\u003e None,\n    }\n}\n\n#[derive(Debug)]\npub struct InsufficientGasLeft;\n\n/// Decreases gas left by the given amount.\n/// If the amount exceeds the available gas, the remaining gas is set to 0 and\n/// an InsufficientGasLeft error is returned.\npub fn decrease_gas_left(ctx: \u0026mut Ctx, amount: u64) -\u003e Result\u003c(), InsufficientGasLeft\u003e {\n    let remaining = get_gas_left(ctx);\n    if amount \u003e remaining {\n        set_gas_left(ctx, 0);\n        Err(InsufficientGasLeft)\n    } else {\n        set_gas_left(ctx, remaining - amount);\n        Ok(())\n    }\n}\n*/\n\n#[cfg(feature = \"default-cranelift\")]\npub use cranelift::{backend, compile, get_gas_left, set_gas_left};\n\n#[cfg(feature = \"default-singlepass\")]\npub use singlepass::{backend, compile, get_gas_left, set_gas_left};\n\n#[cfg(feature = \"default-enclave\")]\npub use enclave::{get_gas_left, get_gas_used};\n\n#[cfg(test)]\n#[cfg(feature = \"default-singlepass\")]\nmod test {\n    use super::*;\n    use wabt::wat2wasm;\n    use wasmer_runtime_core::{imports, Instance as WasmerInstance};\n\n    fn instantiate(code: \u0026[u8]) -\u003e WasmerInstance {\n        let module = compile(code).unwrap();\n        let import_obj = imports! { \"env\" =\u003e {}, };\n        module.instantiate(\u0026import_obj).unwrap()\n    }\n\n    #[test]\n    fn decrease_gas_left_works() {\n        let wasm = wat2wasm(\"(module)\").unwrap();\n        let mut instance = instantiate(\u0026wasm);\n\n        let before = get_gas_left(instance.context());\n        decrease_gas_left(instance.context_mut(), 32).unwrap();\n        let after = get_gas_left(instance.context());\n        assert_eq!(after, before - 32);\n    }\n\n    #[test]\n    fn decrease_gas_left_can_consume_all_gas() {\n        let wasm = wat2wasm(\"(module)\").unwrap();\n        let mut instance = instantiate(\u0026wasm);\n\n        let before = get_gas_left(instance.context());\n        decrease_gas_left(instance.context_mut(), before).unwrap();\n        let after = get_gas_left(instance.context());\n        assert_eq!(after, 0);\n    }\n\n    #[test]\n    fn decrease_gas_left_errors_for_amount_greater_than_remaining() {\n        let wasm = wat2wasm(\"(module)\").unwrap();\n        let mut instance = instantiate(\u0026wasm);\n\n        let before = get_gas_left(instance.context());\n        let result = decrease_gas_left(instance.context_mut(), before + 1);\n        match result.unwrap_err() {\n            InsufficientGasLeft =\u003e {}\n        }\n        let after = get_gas_left(instance.context());\n        assert_eq!(after, 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","backends","singlepass.rs"],"content":"#![cfg(any(feature = \"singlepass\", feature = \"default-singlepass\"))]\nuse wasmer_middleware_common::metering;\nuse wasmer_runtime_core::{\n    backend::Compiler,\n    codegen::{MiddlewareChain, StreamingCompiler},\n    compile_with,\n    module::Module,\n    vm::Ctx,\n};\nuse wasmer_singlepass_backend::ModuleCodeGenerator as SinglePassMCG;\n\nuse crate::errors::VmResult;\nuse crate::middleware::DeterministicMiddleware;\n\n/// In Wasmer, the gas limit is set on modules during compilation and is included in the cached modules.\n/// This causes issues when trying to instantiate the same compiled module with a different gas limit.\n/// A fix for this is proposed here: https://github.com/wasmerio/wasmer/pull/996.\n///\n/// To work around this limitation, we set the gas limit of all Wasmer instances to this very high value,\n/// assuming users won't request more than this amount of gas. In order to set the real gas limit, we pretend\n/// to consume the difference between the two in `set_gas_left` (\"points used\" in the metering middleware).\n/// Since we observed overflow behaviour in the points used, we ensure both MAX_GAS_LIMIT and points used stay\n/// far below u64::MAX.\nconst MAX_GAS_LIMIT: u64 = u64::MAX / 2;\n\npub fn compile(code: \u0026[u8]) -\u003e VmResult\u003cModule\u003e {\n    let module = compile_with(code, compiler().as_ref())?;\n    Ok(module)\n}\n\npub fn compiler() -\u003e Box\u003cdyn Compiler\u003e {\n    let c: StreamingCompiler\u003cSinglePassMCG, _, _, _, _\u003e = StreamingCompiler::new(move || {\n        let mut chain = MiddlewareChain::new();\n        chain.push(DeterministicMiddleware::new());\n        chain.push(metering::Metering::new(MAX_GAS_LIMIT));\n        chain\n    });\n    Box::new(c)\n}\n\npub fn backend() -\u003e \u0026'static str {\n    \"singlepass\"\n}\n\n/// Set the amount of gas units that can be used in the context.\npub fn set_gas_left(ctx: \u0026mut Ctx, amount: u64) {\n    if amount \u003e MAX_GAS_LIMIT {\n        panic!(\n            \"Attempted to set gas limit larger than max gas limit (got: {}; maximum: {}).\",\n            amount, MAX_GAS_LIMIT\n        );\n    } else {\n        let used = MAX_GAS_LIMIT - amount;\n        metering::set_points_used_ctx(ctx, used);\n    }\n}\n\n/// Get how many more gas units can be used in the context.\npub fn get_gas_left(ctx: \u0026Ctx) -\u003e u64 {\n    let used = metering::get_points_used_ctx(ctx);\n    // when running out of gas, get_points_used can exceed MAX_GAS_LIMIT\n    MAX_GAS_LIMIT.saturating_sub(used)\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use wabt::wat2wasm;\n    use wasmer_runtime_core::{imports, Instance as WasmerInstance};\n\n    fn instantiate(code: \u0026[u8]) -\u003e WasmerInstance {\n        let module = compile(code).unwrap();\n        let import_obj = imports! { \"env\" =\u003e {}, };\n        module.instantiate(\u0026import_obj).unwrap()\n    }\n\n    #[test]\n    fn get_gas_left_defaults_to_constant() {\n        let wasm = wat2wasm(\"(module)\").unwrap();\n        let instance = instantiate(\u0026wasm);\n        let gas_left = get_gas_left(instance.context());\n        assert_eq!(gas_left, MAX_GAS_LIMIT);\n    }\n\n    #[test]\n    fn set_gas_left_works() {\n        let wasm = wat2wasm(\"(module)\").unwrap();\n        let mut instance = instantiate(\u0026wasm);\n\n        let limit = 3456789;\n        set_gas_left(instance.context_mut(), limit);\n        assert_eq!(get_gas_left(instance.context()), limit);\n\n        let limit = 1;\n        set_gas_left(instance.context_mut(), limit);\n        assert_eq!(get_gas_left(instance.context()), limit);\n\n        let limit = 0;\n        set_gas_left(instance.context_mut(), limit);\n        assert_eq!(get_gas_left(instance.context()), limit);\n\n        let limit = MAX_GAS_LIMIT;\n        set_gas_left(instance.context_mut(), limit);\n        assert_eq!(get_gas_left(instance.context()), limit);\n    }\n\n    #[test]\n    #[should_panic(\n        expected = \"Attempted to set gas limit larger than max gas limit (got: 9223372036854775808; maximum: 9223372036854775807).\"\n    )]\n    fn set_gas_left_panic_for_values_too_large() {\n        let wasm = wat2wasm(\"(module)\").unwrap();\n        let mut instance = instantiate(\u0026wasm);\n\n        let limit = MAX_GAS_LIMIT + 1;\n        set_gas_left(instance.context_mut(), limit);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","cache.rs"],"content":"use std::collections::HashSet;\nuse std::fs::{create_dir_all, File, OpenOptions};\nuse std::io::{Read, Write};\nuse std::marker::PhantomData;\nuse std::path::PathBuf;\n\n/*\nuse crate::backends::{backend, compile};\n*/\nuse crate::checksum::Checksum;\nuse crate::compatability::check_wasm;\nuse crate::errors::{VmError, VmResult};\nuse crate::instance::Instance;\n/*\nuse crate::modules::FileSystemCache;\n*/\nuse crate::traits::{Api, Extern, Querier, Storage};\n\nconst WASM_DIR: \u0026str = \"wasm\";\n/*\nconst MODULES_DIR: \u0026str = \"modules\";\n*/\n\n#[derive(Debug, Default, Clone)]\nstruct Stats {\n    hits_module: u32,\n    misses: u32,\n}\n\npub struct CosmCache\u003cS: Storage + 'static, A: Api + 'static, Q: Querier + 'static\u003e {\n    wasm_path: PathBuf,\n    supported_features: HashSet\u003cString\u003e,\n    /*\n    modules: FileSystemCache,\n    */\n    stats: Stats,\n    // Those two don't store data but only fix type information\n    type_storage: PhantomData\u003cS\u003e,\n    type_api: PhantomData\u003cA\u003e,\n    type_querier: PhantomData\u003cQ\u003e,\n}\n\nimpl\u003cS, A, Q\u003e CosmCache\u003cS, A, Q\u003e\nwhere\n    S: Storage + 'static,\n    A: Api + 'static,\n    Q: Querier + 'static,\n{\n    /// new stores the data for cache under base_dir\n    ///\n    /// Instance caching is disabled since 0.8.1 and any cache size value will be treated as 0.\n    ///\n    /// # Safety\n    ///\n    /// This function is marked unsafe due to `FileSystemCache::new`, which implicitly\n    /// assumes the disk contents are correct, and there's no way to ensure the artifacts\n    //  stored in the cache haven't been corrupted or tampered with.\n    pub unsafe fn new\u003cP: Into\u003cPathBuf\u003e\u003e(\n        base_dir: P,\n        supported_features: HashSet\u003cString\u003e,\n    ) -\u003e VmResult\u003cSelf\u003e {\n        let base = base_dir.into();\n        let wasm_path = base.join(WASM_DIR);\n        create_dir_all(\u0026wasm_path)\n            .map_err(|e| VmError::cache_err(format!(\"Error creating Wasm dir for cache: {}\", e)))?;\n\n        /*\n        let modules = FileSystemCache::new(base.join(MODULES_DIR))\n            .map_err(|e| VmError::cache_err(format!(\"Error file system cache: {}\", e)))?;\n        */\n        Ok(CosmCache {\n            wasm_path,\n            supported_features,\n            /*\n            modules,\n            */\n            stats: Stats::default(),\n            type_storage: PhantomData::\u003cS\u003e,\n            type_api: PhantomData::\u003cA\u003e,\n            type_querier: PhantomData::\u003cQ\u003e,\n        })\n    }\n\n    pub fn save_wasm(\u0026mut self, wasm: \u0026[u8]) -\u003e VmResult\u003cChecksum\u003e {\n        check_wasm(wasm, \u0026self.supported_features)?;\n        let checksum = save_wasm_to_disk(\u0026self.wasm_path, wasm)?;\n        /*\n        let module = compile(wasm)?;\n        self.modules.store(\u0026checksum, module)?;\n        */\n        Ok(checksum)\n    }\n\n    /// Retrieves a Wasm blob that was previously stored via save_wasm.\n    /// When the cache is instantiated with the same base dir, this finds Wasm files on disc across multiple cache instances (i.e. node restarts).\n    /// This function is public to allow a checksum to Wasm lookup in the blockchain.\n    ///\n    /// If the given ID is not found or the content does not match the hash (=ID), an error is returned.\n    pub fn load_wasm(\u0026self, checksum: \u0026Checksum) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n        let code = load_wasm_from_disk(\u0026self.wasm_path, checksum)?;\n        // verify hash matches (integrity check)\n        if Checksum::generate(\u0026code) != *checksum {\n            Err(VmError::integrity_err())\n        } else {\n            Ok(code)\n        }\n    }\n\n    /// Returns an Instance tied to a previously saved Wasm.\n    /// Depending on availability, this is either generated from a cached instance, a cached module or Wasm code.\n    pub fn get_instance(\n        \u0026mut self,\n        checksum: \u0026Checksum,\n        deps: Extern\u003cS, A, Q\u003e,\n        gas_limit: u64,\n    ) -\u003e VmResult\u003cInstance\u003cS, A, Q\u003e\u003e {\n        /*\n        // try from the module cache\n        let res = self.modules.load_with_backend(checksum, backend());\n        if let Ok(module) = res {\n            self.stats.hits_module += 1;\n            return Instance::from_module(\u0026module, deps, gas_limit);\n        }\n        */\n\n        // fall back to wasm cache (and re-compiling) - this is for backends that don't support serialization\n        let wasm = self.load_wasm(checksum)?;\n        self.stats.misses += 1;\n        Instance::from_code(\u0026wasm, deps, gas_limit)\n    }\n}\n\n/// save stores the wasm code in the given directory and returns an ID for lookup.\n/// It will create the directory if it doesn't exist.\n/// Saving the same byte code multiple times is allowed.\nfn save_wasm_to_disk\u003cP: Into\u003cPathBuf\u003e\u003e(dir: P, wasm: \u0026[u8]) -\u003e VmResult\u003cChecksum\u003e {\n    // calculate filename\n    let checksum = Checksum::generate(wasm);\n    let filename = checksum.to_hex();\n    let filepath = dir.into().join(\u0026filename);\n\n    // write data to file\n    // Since the same filename (a collision resistent hash) cannot be generated from two different byte codes\n    // (even if a malicious actor tried), it is safe to override.\n    let mut file = OpenOptions::new()\n        .write(true)\n        .create(true)\n        .open(filepath)\n        .map_err(|e| VmError::cache_err(format!(\"Error opening Wasm file for writing: {}\", e)))?;\n    file.write_all(wasm)\n        .map_err(|e| VmError::cache_err(format!(\"Error writing Wasm file: {}\", e)))?;\n\n    Ok(checksum)\n}\n\nfn load_wasm_from_disk\u003cP: Into\u003cPathBuf\u003e\u003e(dir: P, checksum: \u0026Checksum) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n    // this requires the directory and file to exist\n    let path = dir.into().join(checksum.to_hex());\n    let mut file = File::open(path)\n        .map_err(|e| VmError::cache_err(format!(\"Error opening Wasm file for reading: {}\", e)))?;\n\n    let mut wasm = Vec::\u003cu8\u003e::new();\n    file.read_to_end(\u0026mut wasm)\n        .map_err(|e| VmError::cache_err(format!(\"Error reading Wasm file: {}\", e)))?;\n    Ok(wasm)\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::calls::{call_handle, call_init};\n    use crate::errors::VmError;\n    use crate::features::features_from_csv;\n    use crate::testing::{mock_dependencies, mock_env, MockApi, MockQuerier, MockStorage};\n    use cosmwasm_std::{coins, Empty};\n    use std::fs::OpenOptions;\n    use std::io::Write;\n    use tempfile::TempDir;\n    use wabt::wat2wasm;\n\n    const TESTING_GAS_LIMIT: u64 = 400_000;\n    static CONTRACT: \u0026[u8] = include_bytes!(\"../testdata/contract.wasm\");\n\n    fn default_features() -\u003e HashSet\u003cString\u003e {\n        features_from_csv(\"staking\")\n    }\n\n    #[test]\n    fn save_wasm_works() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache: CosmCache\u003cMockStorage, MockApi, MockQuerier\u003e =\n            unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        cache.save_wasm(CONTRACT).unwrap();\n    }\n\n    #[test]\n    // This property is required when the same bytecode is uploaded multiple times\n    fn save_wasm_allows_saving_multiple_times() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache: CosmCache\u003cMockStorage, MockApi, MockQuerier\u003e =\n            unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        cache.save_wasm(CONTRACT).unwrap();\n        cache.save_wasm(CONTRACT).unwrap();\n    }\n\n    #[test]\n    fn save_wasm_rejects_invalid_contract() {\n        // Invalid because it doesn't contain required memory and exports\n        let wasm = wat2wasm(\n            r#\"(module\n            (type $t0 (func (param i32) (result i32)))\n            (func $add_one (export \"add_one\") (type $t0) (param $p0 i32) (result i32)\n              get_local $p0\n              i32.const 1\n              i32.add))\n            \"#,\n        )\n        .unwrap();\n\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache: CosmCache\u003cMockStorage, MockApi, MockQuerier\u003e =\n            unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let save_result = cache.save_wasm(\u0026wasm);\n        match save_result.unwrap_err() {\n            VmError::StaticValidationErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Wasm contract doesn\\'t have a memory section\")\n            }\n            e =\u003e panic!(\"Unexpected error {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn load_wasm_works() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache: CosmCache\u003cMockStorage, MockApi, MockQuerier\u003e =\n            unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let id = cache.save_wasm(CONTRACT).unwrap();\n\n        let restored = cache.load_wasm(\u0026id).unwrap();\n        assert_eq!(restored, CONTRACT);\n    }\n\n    #[test]\n    fn load_wasm_works_across_multiple_cache_instances() {\n        let tmp_dir = TempDir::new().unwrap();\n        let tmp_path = tmp_dir.path();\n        let id: Checksum;\n\n        {\n            let mut cache1: CosmCache\u003cMockStorage, MockApi, MockQuerier\u003e =\n                unsafe { CosmCache::new(tmp_path, default_features()).unwrap() };\n            id = cache1.save_wasm(CONTRACT).unwrap();\n        }\n\n        {\n            let cache2: CosmCache\u003cMockStorage, MockApi, MockQuerier\u003e =\n                unsafe { CosmCache::new(tmp_path, default_features()).unwrap() };\n            let restored = cache2.load_wasm(\u0026id).unwrap();\n            assert_eq!(restored, CONTRACT);\n        }\n    }\n\n    #[test]\n    fn load_wasm_errors_for_non_existent_id() {\n        let tmp_dir = TempDir::new().unwrap();\n        let cache: CosmCache\u003cMockStorage, MockApi, MockQuerier\u003e =\n            unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let checksum = Checksum::from([\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5,\n        ]);\n\n        match cache.load_wasm(\u0026checksum).unwrap_err() {\n            VmError::CacheErr { msg, .. } =\u003e {\n                assert!(msg\n                    .starts_with(\"Error opening Wasm file for reading: No such file or directory\"))\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn load_wasm_errors_for_corrupted_wasm() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache: CosmCache\u003cMockStorage, MockApi, MockQuerier\u003e =\n            unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let checksum = cache.save_wasm(CONTRACT).unwrap();\n\n        // Corrupt cache file\n        let filepath = tmp_dir.path().join(WASM_DIR).join(\u0026checksum.to_hex());\n        let mut file = OpenOptions::new().write(true).open(filepath).unwrap();\n        file.write_all(b\"broken data\").unwrap();\n\n        let res = cache.load_wasm(\u0026checksum);\n        match res {\n            Err(VmError::IntegrityErr { .. }) =\u003e {}\n            Err(e) =\u003e panic!(\"Unexpected error: {:?}\", e),\n            Ok(_) =\u003e panic!(\"This must not succeed\"),\n        }\n    }\n\n    #[test]\n    fn get_instance_finds_cached_module() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache = unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let id = cache.save_wasm(CONTRACT).unwrap();\n        let deps = mock_dependencies(20, \u0026[]);\n        let _instance = cache.get_instance(\u0026id, deps, TESTING_GAS_LIMIT).unwrap();\n        assert_eq!(cache.stats.hits_module, 1);\n        assert_eq!(cache.stats.misses, 0);\n    }\n\n    #[test]\n    fn get_instance_finds_cached_instance() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache = unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let id = cache.save_wasm(CONTRACT).unwrap();\n        let deps1 = mock_dependencies(20, \u0026[]);\n        let deps2 = mock_dependencies(20, \u0026[]);\n        let deps3 = mock_dependencies(20, \u0026[]);\n        let _instance1 = cache.get_instance(\u0026id, deps1, TESTING_GAS_LIMIT).unwrap();\n        let _instance2 = cache.get_instance(\u0026id, deps2, TESTING_GAS_LIMIT).unwrap();\n        let _instance3 = cache.get_instance(\u0026id, deps3, TESTING_GAS_LIMIT).unwrap();\n        assert_eq!(cache.stats.hits_module, 3);\n        assert_eq!(cache.stats.misses, 0);\n    }\n\n    #[test]\n    fn init_cached_contract() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache = unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let id = cache.save_wasm(CONTRACT).unwrap();\n        let deps = mock_dependencies(20, \u0026[]);\n        let mut instance = cache.get_instance(\u0026id, deps, TESTING_GAS_LIMIT).unwrap();\n\n        // run contract\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        let msg = r#\"{\"verifier\": \"verifies\", \"beneficiary\": \"benefits\"}\"#.as_bytes();\n\n        // call and check\n        let res = call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg).unwrap();\n        let msgs = res.unwrap().messages;\n        assert_eq!(msgs.len(), 0);\n    }\n\n    #[test]\n    fn run_cached_contract() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache = unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let id = cache.save_wasm(CONTRACT).unwrap();\n        // TODO: contract balance\n        let deps = mock_dependencies(20, \u0026[]);\n        let mut instance = cache.get_instance(\u0026id, deps, TESTING_GAS_LIMIT).unwrap();\n\n        // init contract\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        let msg = r#\"{\"verifier\": \"verifies\", \"beneficiary\": \"benefits\"}\"#.as_bytes();\n        let res = call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg).unwrap();\n        let msgs = res.unwrap().messages;\n        assert_eq!(msgs.len(), 0);\n\n        // run contract - just sanity check - results validate in contract unit tests\n        let env = mock_env(\"verifies\", \u0026coins(15, \"earth\"));\n        let msg = br#\"{\"release\":{}}\"#;\n        let res = call_handle::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg).unwrap();\n        let msgs = res.unwrap().messages;\n        assert_eq!(1, msgs.len());\n    }\n\n    #[test]\n    fn use_multiple_cached_instances_of_same_contract() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache = unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let id = cache.save_wasm(CONTRACT).unwrap();\n\n        // these differentiate the two instances of the same contract\n        let deps1 = mock_dependencies(20, \u0026[]);\n        let deps2 = mock_dependencies(20, \u0026[]);\n\n        // init instance 1\n        let mut instance = cache.get_instance(\u0026id, deps1, TESTING_GAS_LIMIT).unwrap();\n        let env = mock_env(\"owner1\", \u0026coins(1000, \"earth\"));\n        let msg = r#\"{\"verifier\": \"sue\", \"beneficiary\": \"mary\"}\"#.as_bytes();\n        let res = call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg).unwrap();\n        let msgs = res.unwrap().messages;\n        assert_eq!(msgs.len(), 0);\n        let deps1 = instance.recycle().unwrap();\n\n        // init instance 2\n        let mut instance = cache.get_instance(\u0026id, deps2, TESTING_GAS_LIMIT).unwrap();\n        let env = mock_env(\"owner2\", \u0026coins(500, \"earth\"));\n        let msg = r#\"{\"verifier\": \"bob\", \"beneficiary\": \"john\"}\"#.as_bytes();\n        let res = call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg).unwrap();\n        let msgs = res.unwrap().messages;\n        assert_eq!(msgs.len(), 0);\n        let deps2 = instance.recycle().unwrap();\n\n        // run contract 2 - just sanity check - results validate in contract unit tests\n        let mut instance = cache.get_instance(\u0026id, deps2, TESTING_GAS_LIMIT).unwrap();\n        let env = mock_env(\"bob\", \u0026coins(15, \"earth\"));\n        let msg = br#\"{\"release\":{}}\"#;\n        let res = call_handle::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg).unwrap();\n        let msgs = res.unwrap().messages;\n        assert_eq!(1, msgs.len());\n\n        // run contract 1 - just sanity check - results validate in contract unit tests\n        let mut instance = cache.get_instance(\u0026id, deps1, TESTING_GAS_LIMIT).unwrap();\n        let env = mock_env(\"sue\", \u0026coins(15, \"earth\"));\n        let msg = br#\"{\"release\":{}}\"#;\n        let res = call_handle::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg).unwrap();\n        let msgs = res.unwrap().messages;\n        assert_eq!(1, msgs.len());\n    }\n\n    #[test]\n    #[cfg(feature = \"default-singlepass\")]\n    fn resets_gas_when_reusing_instance() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache = unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let id = cache.save_wasm(CONTRACT).unwrap();\n\n        let deps1 = mock_dependencies(20, \u0026[]);\n        let deps2 = mock_dependencies(20, \u0026[]);\n\n        // Init from module cache\n        let mut instance1 = cache.get_instance(\u0026id, deps1, TESTING_GAS_LIMIT).unwrap();\n        assert_eq!(cache.stats.hits_module, 1);\n        assert_eq!(cache.stats.misses, 0);\n        let original_gas = instance1.get_gas_left();\n\n        // Consume some gas\n        let env = mock_env(\"owner1\", \u0026coins(1000, \"earth\"));\n        let msg = r#\"{\"verifier\": \"sue\", \"beneficiary\": \"mary\"}\"#.as_bytes();\n        call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance1, \u0026env, msg)\n            .unwrap()\n            .unwrap();\n        assert!(instance1.get_gas_left() \u003c original_gas);\n\n        // Init from instance cache\n        let instance2 = cache.get_instance(\u0026id, deps2, TESTING_GAS_LIMIT).unwrap();\n        assert_eq!(cache.stats.hits_module, 2);\n        assert_eq!(cache.stats.misses, 0);\n        assert_eq!(instance2.get_gas_left(), TESTING_GAS_LIMIT);\n    }\n\n    #[test]\n    #[cfg(feature = \"default-singlepass\")]\n    fn recovers_from_out_of_gas() {\n        let tmp_dir = TempDir::new().unwrap();\n        let mut cache = unsafe { CosmCache::new(tmp_dir.path(), default_features()).unwrap() };\n        let id = cache.save_wasm(CONTRACT).unwrap();\n\n        let deps1 = mock_dependencies(20, \u0026[]);\n        let deps2 = mock_dependencies(20, \u0026[]);\n\n        // Init from module cache\n        let mut instance1 = cache.get_instance(\u0026id, deps1, 10).unwrap();\n        assert_eq!(cache.stats.hits_module, 1);\n        assert_eq!(cache.stats.misses, 0);\n\n        // Consume some gas. This fails\n        let env1 = mock_env(\"owner1\", \u0026coins(1000, \"earth\"));\n        let msg1 = r#\"{\"verifier\": \"sue\", \"beneficiary\": \"mary\"}\"#.as_bytes();\n        match call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance1, \u0026env1, msg1).unwrap_err() {\n            VmError::GasDepletion { .. } =\u003e (), // all good, continue\n            e =\u003e panic!(\"unexpected error, {:?}\", e),\n        }\n        assert_eq!(instance1.get_gas_left(), 0);\n\n        // Init from instance cache\n        let mut instance2 = cache.get_instance(\u0026id, deps2, TESTING_GAS_LIMIT).unwrap();\n        assert_eq!(cache.stats.hits_module, 2);\n        assert_eq!(cache.stats.misses, 0);\n        assert_eq!(instance2.get_gas_left(), TESTING_GAS_LIMIT);\n\n        // Now it works\n        let env2 = mock_env(\"owner2\", \u0026coins(500, \"earth\"));\n        let msg2 = r#\"{\"verifier\": \"bob\", \"beneficiary\": \"john\"}\"#.as_bytes();\n        call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance2, \u0026env2, msg2)\n            .unwrap()\n            .unwrap();\n    }\n\n    #[test]\n    fn save_wasm_to_disk_works_for_same_data_multiple_times() {\n        let tmp_dir = TempDir::new().unwrap();\n        let path = tmp_dir.path();\n        let code = vec![12u8; 17];\n\n        save_wasm_to_disk(path, \u0026code).unwrap();\n        save_wasm_to_disk(path, \u0026code).unwrap();\n    }\n\n    #[test]\n    fn save_wasm_to_disk_fails_on_non_existent_dir() {\n        let tmp_dir = TempDir::new().unwrap();\n        let path = tmp_dir.path().join(\"something\");\n        let code = vec![12u8; 17];\n        let res = save_wasm_to_disk(path.to_str().unwrap(), \u0026code);\n        assert!(res.is_err());\n    }\n\n    #[test]\n    fn load_wasm_from_disk_works() {\n        let tmp_dir = TempDir::new().unwrap();\n        let path = tmp_dir.path();\n        let code = vec![12u8; 17];\n        let id = save_wasm_to_disk(path, \u0026code).unwrap();\n\n        let loaded = load_wasm_from_disk(path, \u0026id).unwrap();\n        assert_eq!(code, loaded);\n    }\n\n    #[test]\n    fn load_wasm_from_disk_works_in_subfolder() {\n        let tmp_dir = TempDir::new().unwrap();\n        let path = tmp_dir.path().join(\"something\");\n        create_dir_all(\u0026path).unwrap();\n        let code = vec![12u8; 17];\n        let id = save_wasm_to_disk(\u0026path, \u0026code).unwrap();\n\n        let loaded = load_wasm_from_disk(\u0026path, \u0026id).unwrap();\n        assert_eq!(code, loaded);\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":25},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","calls.rs"],"content":"use serde::de::DeserializeOwned;\nuse std::fmt;\n\nuse cosmwasm_std::{Env, HandleResult, InitResult, MigrateResult, QueryResult};\n\nuse crate::errors::{VmError, VmResult};\n/*\nuse crate::instance::{Func, Instance};\n*/\nuse crate::instance::Instance;\nuse crate::serde::{from_slice, to_vec};\nuse crate::traits::{Api, Querier, Storage};\nuse schemars::JsonSchema;\n\n/*\nconst MAX_LENGTH_INIT: usize = 100_000;\nconst MAX_LENGTH_HANDLE: usize = 100_000;\nconst MAX_LENGTH_MIGRATE: usize = 100_000;\nconst MAX_LENGTH_QUERY: usize = 100_000;\n*/\n\n/*\npub fn call_init\u003cS, A, Q, U\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n    env: \u0026Env,\n    msg: \u0026[u8],\n) -\u003e VmResult\u003cInitResult\u003cU\u003e\u003e\nwhere\n    S: Storage + 'static,\n    A: Api + 'static,\n    Q: Querier + 'static,\n    U: DeserializeOwned + Clone + fmt::Debug + JsonSchema + PartialEq,\n{\n    let env = to_vec(env)?;\n    let data = call_init_raw(instance, \u0026env, msg)?;\n    let result: InitResult\u003cU\u003e = from_slice(\u0026data)?;\n    Ok(result)\n}\n\npub fn call_handle\u003cS, A, Q, U\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n    env: \u0026Env,\n    msg: \u0026[u8],\n) -\u003e VmResult\u003cHandleResult\u003cU\u003e\u003e\nwhere\n    S: Storage + 'static,\n    A: Api + 'static,\n    Q: Querier + 'static,\n    U: DeserializeOwned + Clone + fmt::Debug + JsonSchema + PartialEq,\n{\n    let env = to_vec(env)?;\n    let data = call_handle_raw(instance, \u0026env, msg)?;\n    let result: HandleResult\u003cU\u003e = from_slice(\u0026data)?;\n    Ok(result)\n}\n\npub fn call_migrate\u003cS, A, Q, U\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n    env: \u0026Env,\n    msg: \u0026[u8],\n) -\u003e VmResult\u003cMigrateResult\u003cU\u003e\u003e\nwhere\n    S: Storage + 'static,\n    A: Api + 'static,\n    Q: Querier + 'static,\n    U: DeserializeOwned + Clone + fmt::Debug + JsonSchema + PartialEq,\n{\n    let env = to_vec(env)?;\n    let data = call_migrate_raw(instance, \u0026env, msg)?;\n    let result: MigrateResult\u003cU\u003e = from_slice(\u0026data)?;\n    Ok(result)\n}\n\npub fn call_query\u003cS: Storage + 'static, A: Api + 'static, Q: Querier + 'static\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n    msg: \u0026[u8],\n) -\u003e VmResult\u003cQueryResult\u003e {\n    let data = call_query_raw(instance, msg)?;\n    let result: QueryResult = from_slice(\u0026data)?;\n\n    // Ensure query response is valid JSON\n    if let Ok(binary_response) = \u0026result {\n        serde_json::from_slice::\u003cserde_json::Value\u003e(binary_response.as_slice()).map_err(|e| {\n            VmError::generic_err(format!(\"Query response must be valid JSON. {}\", e))\n        })?;\n    }\n\n    Ok(result)\n}\n*/\n\n/// Calls Wasm export \"init\" and returns raw data from the contract.\n/// The result is length limited to prevent abuse but otherwise unchecked.\npub fn call_init_raw\u003cS: Storage + 'static, A: Api + 'static, Q: Querier + 'static\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n    env: \u0026[u8],\n    msg: \u0026[u8],\n    sig_info: \u0026[u8],\n) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n    instance.set_storage_readonly(false);\n    /*\n    call_raw(instance, \"init\", \u0026[env, msg], MAX_LENGTH_INIT)\n    */\n    instance.call_init(env, msg, sig_info)\n}\n\n/// Calls Wasm export \"handle\" and returns raw data from the contract.\n/// The result is length limited to prevent abuse but otherwise unchecked.\npub fn call_handle_raw\u003cS: Storage + 'static, A: Api + 'static, Q: Querier + 'static\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n    env: \u0026[u8],\n    msg: \u0026[u8],\n    sig_info: \u0026[u8],\n) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n    instance.set_storage_readonly(false);\n    /*\n    call_raw(instance, \"handle\", \u0026[env, msg], MAX_LENGTH_HANDLE)\n    */\n    instance.call_handle(env, msg, sig_info)\n}\n\n/// Calls Wasm export \"migrate\" and returns raw data from the contract.\n/// The result is length limited to prevent abuse but otherwise unchecked.\npub fn call_migrate_raw\u003cS: Storage + 'static, A: Api + 'static, Q: Querier + 'static\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n    env: \u0026[u8],\n    msg: \u0026[u8],\n) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n    instance.set_storage_readonly(false);\n    /*\n    call_raw(instance, \"migrate\", \u0026[env, msg], MAX_LENGTH_MIGRATE)\n    */\n    instance.call_migrate(env, msg)\n}\n\n/// Calls Wasm export \"query\" and returns raw data from the contract.\n/// The result is length limited to prevent abuse but otherwise unchecked.\npub fn call_query_raw\u003cS: Storage + 'static, A: Api + 'static, Q: Querier + 'static\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n    msg: \u0026[u8],\n) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n    instance.set_storage_readonly(true);\n    /*\n    call_raw(instance, \"query\", \u0026[msg], MAX_LENGTH_QUERY)\n    */\n    instance.call_query(msg)\n}\n\n#[cfg(not(feature = \"default-enclave\"))]\nfn call_raw\u003cS: Storage + 'static, A: Api + 'static, Q: Querier + 'static\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n    name: \u0026str,\n    args: \u0026[\u0026[u8]],\n    result_max_length: usize,\n) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n    let mut arg_region_ptrs = Vec::\u003cu32\u003e::with_capacity(args.len());\n    for arg in args {\n        let region_ptr = instance.allocate(arg.len())?;\n        instance.write_memory(region_ptr, arg)?;\n        arg_region_ptrs.push(region_ptr);\n    }\n\n    let res_region_ptr = match args.len() {\n        1 =\u003e {\n            let func: Func\u003cu32, u32\u003e = instance.func(name)?;\n            func.call(arg_region_ptrs[0])?\n        }\n        2 =\u003e {\n            let func: Func\u003c(u32, u32), u32\u003e = instance.func(name)?;\n            func.call(arg_region_ptrs[0], arg_region_ptrs[1])?\n        }\n        _ =\u003e panic!(\"call_raw called with unsupported number of arguments\"),\n    };\n\n    let data = instance.read_memory(res_region_ptr, result_max_length)?;\n    // free return value in wasm (arguments were freed in wasm code)\n    instance.deallocate(res_region_ptr)?;\n    Ok(data)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","checksum.rs"],"content":"use std::convert::TryFrom;\n\nuse sha2::{Digest, Sha256};\n\nuse crate::errors::VmError;\n\n/// A SHA-256 checksum of a Wasm blob, used to identify a Wasm code.\n/// This must remain stable since this checksum is stored in the blockchain state.\n///\n/// This is often referred to as \"code ID\" in go-cosmwasm, even if code ID\n/// usually refers to an auto-incrementing number.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\npub struct Checksum([u8; 32]);\n\nimpl Checksum {\n    pub fn generate(wasm: \u0026[u8]) -\u003e Self {\n        Checksum(Sha256::digest(wasm).into())\n    }\n\n    /// Creates a lowercase hex encoded copy of this checksum\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.0)\n    }\n}\n\nimpl From\u003c[u8; 32]\u003e for Checksum {\n    fn from(data: [u8; 32]) -\u003e Self {\n        Checksum(data)\n    }\n}\n\nimpl TryFrom\u003c\u0026[u8]\u003e for Checksum {\n    type Error = VmError;\n\n    fn try_from(value: \u0026[u8]) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if value.len() != 32 {\n            return Err(VmError::cache_err(\"Checksum not of length 32\"));\n        }\n        let mut data = [0u8; 32];\n        data.copy_from_slice(value);\n        Ok(Checksum(data))\n    }\n}\n\nimpl Into\u003cVec\u003cu8\u003e\u003e for Checksum {\n    fn into(self) -\u003e Vec\u003cu8\u003e {\n        // Rust 1.43+ also supports self.0.into()\n        self.0.to_vec()\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn generate_works() {\n        let wasm = vec![0x68, 0x69, 0x6a];\n        let checksum = Checksum::generate(\u0026wasm);\n\n        // echo -n \"hij\" | sha256sum\n        let expected = [\n            0x72, 0x2c, 0x8c, 0x99, 0x3f, 0xd7, 0x5a, 0x76, 0x27, 0xd6, 0x9e, 0xd9, 0x41, 0x34,\n            0x4f, 0xe2, 0xa1, 0x42, 0x3a, 0x3e, 0x75, 0xef, 0xd3, 0xe6, 0x77, 0x8a, 0x14, 0x28,\n            0x84, 0x22, 0x71, 0x04,\n        ];\n        assert_eq!(checksum.0, expected);\n    }\n\n    #[test]\n    fn to_hex_works() {\n        let wasm = vec![0x68, 0x69, 0x6a];\n        let checksum = Checksum::generate(\u0026wasm);\n        // echo -n \"hij\" | sha256sum\n        assert_eq!(\n            checksum.to_hex(),\n            \"722c8c993fd75a7627d69ed941344fe2a1423a3e75efd3e6778a142884227104\"\n        );\n    }\n\n    #[test]\n    fn into_vec_works() {\n        let checksum = Checksum::generate(\u0026vec![12u8; 17]);\n        let as_vec: Vec\u003cu8\u003e = checksum.into();\n        assert_eq!(as_vec, checksum.0);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","compatability.rs"],"content":"use parity_wasm::elements::{deserialize_buffer, External, ImportEntry, Module};\nuse std::collections::BTreeSet;\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\n\nuse crate::errors::{VmError, VmResult};\nuse crate::features::required_features_from_module;\n\n/// Lists all imports we provide upon instantiating the instance in Instance::from_module()\n/// This should be updated when new imports are added\nconst SUPPORTED_IMPORTS: \u0026[\u0026str] = \u0026[\n    \"env.db_read\",\n    \"env.db_write\",\n    \"env.db_remove\",\n    \"env.canonicalize_address\",\n    \"env.humanize_address\",\n    \"env.query_chain\",\n    #[cfg(feature = \"iterator\")]\n    \"env.db_scan\",\n    #[cfg(feature = \"iterator\")]\n    \"env.db_next\",\n];\n\n/// Lists all entry points we expect to be present when calling a contract.\n/// Basically, anything that is used in calls.rs\n/// This is unlikely to change much, must be frozen at 1.0 to avoid breaking existing contracts\nconst REQUIRED_EXPORTS: \u0026[\u0026str] = \u0026[\n    \"cosmwasm_vm_version_3\",\n    \"query\",\n    \"init\",\n    \"handle\",\n    \"allocate\",\n    \"deallocate\",\n];\n\nconst MEMORY_LIMIT: u32 = 512; // in pages\n\n/// Checks if the data is valid wasm and compatibility with the CosmWasm API (imports and exports)\npub fn check_wasm(wasm_code: \u0026[u8], supported_features: \u0026HashSet\u003cString\u003e) -\u003e VmResult\u003c()\u003e {\n    let module = match deserialize_buffer(\u0026wasm_code) {\n        Ok(deserialized) =\u003e deserialized,\n        Err(err) =\u003e {\n            return Err(VmError::static_validation_err(format!(\n                \"Wasm bytecode could not be deserialized. Deserialization error: \\\"{}\\\"\",\n                err\n            )));\n        }\n    };\n    check_wasm_memories(\u0026module)?;\n    check_wasm_exports(\u0026module)?;\n    check_wasm_imports(\u0026module)?;\n    check_wasm_features(\u0026module, supported_features)?;\n    Ok(())\n}\n\nfn check_wasm_memories(module: \u0026Module) -\u003e VmResult\u003c()\u003e {\n    let section = match module.memory_section() {\n        Some(section) =\u003e section,\n        None =\u003e {\n            return Err(VmError::static_validation_err(\n                \"Wasm contract doesn't have a memory section\",\n            ));\n        }\n    };\n\n    let memories = section.entries();\n    if memories.len() != 1 {\n        return Err(VmError::static_validation_err(\n            \"Wasm contract must contain exactly one memory\",\n        ));\n    }\n\n    let memory = memories[0];\n    // println!(\"Memory: {:?}\", memory);\n    let limits = memory.limits();\n\n    if limits.initial() \u003e MEMORY_LIMIT {\n        return Err(VmError::static_validation_err(format!(\n            \"Wasm contract memory's minimum must not exceed {} pages.\",\n            MEMORY_LIMIT\n        )));\n    }\n\n    if limits.maximum() != None {\n        return Err(VmError::static_validation_err(\n            \"Wasm contract memory's maximum must be unset. The host will set it for you.\",\n        ));\n    }\n    Ok(())\n}\n\nfn check_wasm_exports(module: \u0026Module) -\u003e VmResult\u003c()\u003e {\n    let available_exports: Vec\u003cString\u003e = module.export_section().map_or(vec![], |export_section| {\n        export_section\n            .entries()\n            .iter()\n            .map(|entry| entry.field().to_string())\n            .collect()\n    });\n\n    for required_export in REQUIRED_EXPORTS {\n        if !available_exports.iter().any(|x| x == required_export) {\n            return Err(VmError::static_validation_err(format!(\n                \"Wasm contract doesn't have required export: \\\"{}\\\". Exports required by VM: {:?}. Contract version too old for this VM?\",\n                required_export, REQUIRED_EXPORTS\n            )));\n        }\n    }\n    Ok(())\n}\n\n/// Checks if the import requirements of the contract are satisfied.\n/// When this is not the case, we either have an incompatibility between contract and VM\n/// or a error in the contract.\nfn check_wasm_imports(module: \u0026Module) -\u003e VmResult\u003c()\u003e {\n    let required_imports: Vec\u003cImportEntry\u003e = module\n        .import_section()\n        .map_or(vec![], |import_section| import_section.entries().to_vec());\n\n    for required_import in required_imports {\n        let full_name = format!(\"{}.{}\", required_import.module(), required_import.field());\n        if !SUPPORTED_IMPORTS.contains(\u0026full_name.as_str()) {\n            return Err(VmError::static_validation_err(format!(\n                \"Wasm contract requires unsupported import: \\\"{}\\\". Imports supported by VM: {:?}. Contract version too new for this VM?\",\n                full_name, SUPPORTED_IMPORTS\n            )));\n        }\n\n        match required_import.external() {\n            External::Function(_) =\u003e {}, // ok\n            _ =\u003e return Err(VmError::static_validation_err(format!(\n                \"Wasm contract requires non-function import: \\\"{}\\\". Right now, all supported imports are functions.\",\n                full_name\n            ))),\n        };\n    }\n    Ok(())\n}\n\nfn check_wasm_features(module: \u0026Module, supported_features: \u0026HashSet\u003cString\u003e) -\u003e VmResult\u003c()\u003e {\n    let required_features = required_features_from_module(module);\n    if !required_features.is_subset(supported_features) {\n        // We switch to BTreeSet to get a sorted error message\n        let unsupported = BTreeSet::from_iter(required_features.difference(\u0026supported_features));\n        return Err(VmError::static_validation_err(format!(\n            \"Wasm contract requires unsupported features: {:?}\",\n            unsupported\n        )));\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::errors::VmError;\n    use std::iter::FromIterator;\n    use wabt::wat2wasm;\n\n    static CONTRACT_0_6: \u0026[u8] = include_bytes!(\"../testdata/contract_0.6.wasm\");\n    static CONTRACT_0_7: \u0026[u8] = include_bytes!(\"../testdata/contract_0.7.wasm\");\n    static CONTRACT: \u0026[u8] = include_bytes!(\"../testdata/contract.wasm\");\n    static CORRUPTED: \u0026[u8] = include_bytes!(\"../testdata/corrupted.wasm\");\n\n    fn default_features() -\u003e HashSet\u003cString\u003e {\n        HashSet::from_iter([\"staking\".to_string()].iter().cloned())\n    }\n\n    #[test]\n    fn test_check_wasm() {\n        // this is our reference check, must pass\n        check_wasm(CONTRACT, \u0026default_features()).unwrap();\n    }\n\n    #[test]\n    fn test_check_wasm_old_contract() {\n        match check_wasm(CONTRACT_0_7, \u0026default_features()) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e assert!(msg.starts_with(\n                \"Wasm contract doesn't have required export: \\\"cosmwasm_vm_version_3\\\"\"\n            )),\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"This must not succeeed\"),\n        };\n\n        match check_wasm(CONTRACT_0_6, \u0026default_features()) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e assert!(msg.starts_with(\n                \"Wasm contract doesn't have required export: \\\"cosmwasm_vm_version_3\\\"\"\n            )),\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"This must not succeeed\"),\n        };\n    }\n\n    #[test]\n    fn test_check_wasm_corrupted_data() {\n        match check_wasm(CORRUPTED, \u0026default_features()) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e {\n                assert!(msg.starts_with(\"Wasm bytecode could not be deserialized.\"))\n            }\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"This must not succeeed\"),\n        }\n    }\n\n    #[test]\n    fn test_check_wasm_memories_ok() {\n        let wasm = wat2wasm(\"(module (memory 1))\").unwrap();\n        check_wasm_memories(\u0026deserialize_buffer(\u0026wasm).unwrap()).unwrap()\n    }\n\n    #[test]\n    fn test_check_wasm_memories_no_memory() {\n        let wasm = wat2wasm(\"(module)\").unwrap();\n        match check_wasm_memories(\u0026deserialize_buffer(\u0026wasm).unwrap()) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e {\n                assert!(msg.starts_with(\"Wasm contract doesn't have a memory section\"));\n            }\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"Didn't reject wasm with invalid api\"),\n        }\n    }\n\n    #[test]\n    fn test_check_wasm_memories_two_memories() {\n        // Generated manually because wat2wasm protects us from creating such Wasm:\n        // \"error: only one memory block allowed\"\n        let wasm = hex::decode(concat!(\n            \"0061736d\", // magic bytes\n            \"01000000\", // binary version (uint32)\n            \"05\",       // section type (memory)\n            \"05\",       // section length\n            \"02\",       // number of memories\n            \"0009\",     // element of type \"resizable_limits\", min=9, max=unset\n            \"0009\",     // element of type \"resizable_limits\", min=9, max=unset\n        ))\n        .unwrap();\n\n        match check_wasm_memories(\u0026deserialize_buffer(\u0026wasm).unwrap()) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e {\n                assert!(msg.starts_with(\"Wasm contract must contain exactly one memory\"));\n            }\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"Didn't reject wasm with invalid api\"),\n        }\n    }\n\n    #[test]\n    fn test_check_wasm_memories_zero_memories() {\n        // Generated manually because wat2wasm would not create an empty memory section\n        let wasm = hex::decode(concat!(\n            \"0061736d\", // magic bytes\n            \"01000000\", // binary version (uint32)\n            \"05\",       // section type (memory)\n            \"01\",       // section length\n            \"00\",       // number of memories\n        ))\n        .unwrap();\n\n        match check_wasm_memories(\u0026deserialize_buffer(\u0026wasm).unwrap()) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e {\n                assert!(msg.starts_with(\"Wasm contract must contain exactly one memory\"));\n            }\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"Didn't reject wasm with invalid api\"),\n        }\n    }\n\n    #[test]\n    fn test_check_wasm_memories_initial_size() {\n        let wasm_ok = wat2wasm(\"(module (memory 512))\").unwrap();\n        check_wasm_memories(\u0026deserialize_buffer(\u0026wasm_ok).unwrap()).unwrap();\n\n        let wasm_too_big = wat2wasm(\"(module (memory 513))\").unwrap();\n        match check_wasm_memories(\u0026deserialize_buffer(\u0026wasm_too_big).unwrap()) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e {\n                assert!(msg.starts_with(\"Wasm contract memory's minimum must not exceed 512 pages\"));\n            }\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"Didn't reject wasm with invalid api\"),\n        }\n    }\n\n    #[test]\n    fn test_check_wasm_memories_maximum_size() {\n        let wasm_max = wat2wasm(\"(module (memory 1 5))\").unwrap();\n        match check_wasm_memories(\u0026deserialize_buffer(\u0026wasm_max).unwrap()) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e {\n                assert!(msg.starts_with(\"Wasm contract memory's maximum must be unset\"));\n            }\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"Didn't reject wasm with invalid api\"),\n        }\n    }\n\n    #[test]\n    fn test_check_wasm_exports() {\n        // this is invalid, as it doesn't contain all required exports\n        const WAT_MISSING_EXPORTS: \u0026'static str = r#\"\n            (module\n              (type $t0 (func (param i32) (result i32)))\n              (func $add_one (export \"add_one\") (type $t0) (param $p0 i32) (result i32)\n                get_local $p0\n                i32.const 1\n                i32.add))\n        \"#;\n        let wasm_missing_exports = wat2wasm(WAT_MISSING_EXPORTS).unwrap();\n\n        let module = deserialize_buffer(\u0026wasm_missing_exports).unwrap();\n        match check_wasm_exports(\u0026module) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e {\n                assert!(msg.starts_with(\n                    \"Wasm contract doesn't have required export: \\\"cosmwasm_vm_version_3\\\"\"\n                ));\n            }\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"Didn't reject wasm with invalid api\"),\n        }\n    }\n\n    #[test]\n    fn test_check_wasm_exports_of_old_contract() {\n        let module = deserialize_buffer(CONTRACT_0_7).unwrap();\n        match check_wasm_exports(\u0026module) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e {\n                assert!(msg.starts_with(\n                    \"Wasm contract doesn't have required export: \\\"cosmwasm_vm_version_3\\\"\"\n                ));\n            }\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"Didn't reject wasm with invalid api\"),\n        }\n    }\n\n    #[test]\n    fn check_wasm_imports_ok() {\n        let wasm = wat2wasm(\n            r#\"(module\n            (import \"env\" \"db_read\" (func (param i32 i32) (result i32)))\n            (import \"env\" \"db_write\" (func (param i32 i32) (result i32)))\n            (import \"env\" \"db_remove\" (func (param i32) (result i32)))\n            (import \"env\" \"canonicalize_address\" (func (param i32 i32) (result i32)))\n            (import \"env\" \"humanize_address\" (func (param i32 i32) (result i32)))\n        )\"#,\n        )\n        .unwrap();\n        check_wasm_imports(\u0026deserialize_buffer(\u0026wasm).unwrap()).unwrap();\n    }\n\n    #[test]\n    fn test_check_wasm_imports_of_old_contract() {\n        let module = deserialize_buffer(CONTRACT_0_7).unwrap();\n        match check_wasm_imports(\u0026module) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e {\n                assert!(\n                    msg.starts_with(\"Wasm contract requires unsupported import: \\\"env.read_db\\\"\")\n                );\n            }\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"Didn't reject wasm with invalid api\"),\n        }\n    }\n\n    #[test]\n    fn test_check_wasm_imports_wrong_type() {\n        let wasm = wat2wasm(r#\"(module (import \"env\" \"db_read\" (memory 1 1)))\"#).unwrap();\n        match check_wasm_imports(\u0026deserialize_buffer(\u0026wasm).unwrap()) {\n            Err(VmError::StaticValidationErr { msg, .. }) =\u003e {\n                assert!(\n                    msg.starts_with(\"Wasm contract requires non-function import: \\\"env.db_read\\\"\")\n                );\n            }\n            Err(e) =\u003e panic!(\"Unexpected error {:?}\", e),\n            Ok(_) =\u003e panic!(\"Didn't reject wasm with invalid api\"),\n        }\n    }\n\n    #[test]\n    fn check_wasm_features_ok() {\n        let wasm = wat2wasm(\n            r#\"(module\n            (type (func))\n            (func (type 0) nop)\n            (export \"requires_water\" (func 0))\n            (export \"requires_\" (func 0))\n            (export \"requires_nutrients\" (func 0))\n            (export \"require_milk\" (func 0))\n            (export \"REQUIRES_air\" (func 0))\n            (export \"requires_sun\" (func 0))\n        )\"#,\n        )\n        .unwrap();\n        let module = deserialize_buffer(\u0026wasm).unwrap();\n        let supported = HashSet::from_iter(\n            [\n                \"water\".to_string(),\n                \"nutrients\".to_string(),\n                \"sun\".to_string(),\n                \"freedom\".to_string(),\n            ]\n            .iter()\n            .cloned(),\n        );\n        check_wasm_features(\u0026module, \u0026supported).unwrap();\n    }\n\n    #[test]\n    fn check_wasm_features_fails_for_missing() {\n        let wasm = wat2wasm(\n            r#\"(module\n            (type (func))\n            (func (type 0) nop)\n            (export \"requires_water\" (func 0))\n            (export \"requires_\" (func 0))\n            (export \"requires_nutrients\" (func 0))\n            (export \"require_milk\" (func 0))\n            (export \"REQUIRES_air\" (func 0))\n            (export \"requires_sun\" (func 0))\n        )\"#,\n        )\n        .unwrap();\n        let module = deserialize_buffer(\u0026wasm).unwrap();\n\n        // Support set 1\n        let supported = HashSet::from_iter(\n            [\n                \"water\".to_string(),\n                \"nutrients\".to_string(),\n                \"freedom\".to_string(),\n            ]\n            .iter()\n            .cloned(),\n        );\n        match check_wasm_features(\u0026module, \u0026supported).unwrap_err() {\n            VmError::StaticValidationErr { msg, .. } =\u003e assert_eq!(\n                msg,\n                \"Wasm contract requires unsupported features: {\\\"sun\\\"}\"\n            ),\n            _ =\u003e panic!(\"Got unexpected error\"),\n        }\n\n        // Support set 2\n        let supported = HashSet::from_iter(\n            [\n                \"nutrients\".to_string(),\n                \"freedom\".to_string(),\n                \"Water\".to_string(), // features are case sensitive (and lowercase by convention)\n            ]\n            .iter()\n            .cloned(),\n        );\n        match check_wasm_features(\u0026module, \u0026supported).unwrap_err() {\n            VmError::StaticValidationErr { msg, .. } =\u003e assert_eq!(\n                msg,\n                \"Wasm contract requires unsupported features: {\\\"sun\\\", \\\"water\\\"}\"\n            ),\n            _ =\u003e panic!(\"Got unexpected error\"),\n        }\n\n        // Support set 3\n        let supported = HashSet::from_iter([\"freedom\".to_string()].iter().cloned());\n        match check_wasm_features(\u0026module, \u0026supported).unwrap_err() {\n            VmError::StaticValidationErr { msg, .. } =\u003e assert_eq!(\n                msg,\n                \"Wasm contract requires unsupported features: {\\\"nutrients\\\", \\\"sun\\\", \\\"water\\\"}\"\n            ),\n            _ =\u003e panic!(\"Got unexpected error\"),\n        }\n\n        // Support set 4\n        let supported = HashSet::from_iter([].iter().cloned());\n        match check_wasm_features(\u0026module, \u0026supported).unwrap_err() {\n            VmError::StaticValidationErr { msg, .. } =\u003e assert_eq!(\n                msg,\n                \"Wasm contract requires unsupported features: {\\\"nutrients\\\", \\\"sun\\\", \\\"water\\\"}\"\n            ),\n            _ =\u003e panic!(\"Got unexpected error\"),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","context.rs"],"content":"//! Internal details to be used by instance.rs only\n#[cfg(feature = \"iterator\")]\nuse std::collections::HashMap;\n#[cfg(feature = \"iterator\")]\nuse std::convert::TryInto;\nuse std::ffi::c_void;\n#[cfg(not(feature = \"iterator\"))]\nuse std::marker::PhantomData;\n/*\nuse std::ptr::NonNull;\n\nuse wasmer_runtime_core::{\n    typed_func::{Func, Wasm, WasmTypeList},\n    vm::Ctx,\n    Instance as WasmerInstance,\n};\n*/\n\nuse enclave_ffi_types::Ctx;\n\n// use crate::backends::decrease_gas_left;\nuse crate::errors::{VmError, VmResult};\n// use crate::ffi::GasInfo;\n#[cfg(feature = \"iterator\")]\nuse crate::traits::StorageIterator;\nuse crate::traits::{Querier, Storage};\n\n/** context data **/\n\n#[cfg(not(feature = \"default-enclave\"))]\n#[derive(Clone, PartialEq, Debug, Default)]\npub struct GasState {\n    /// Gas limit for the computation.\n    pub gas_limit: u64,\n    /// Tracking the gas used in the cosmos SDK, in cosmwasm units.\n    #[allow(unused)]\n    pub externally_used_gas: u64,\n}\n\n#[cfg(not(feature = \"default-enclave\"))]\nimpl GasState {\n    fn with_limit(gas_limit: u64) -\u003e Self {\n        Self {\n            gas_limit,\n            externally_used_gas: 0,\n        }\n    }\n\n    #[allow(unused)]\n    fn increase_externally_used_gas(\u0026mut self, amount: u64) {\n        self.externally_used_gas += amount;\n    }\n\n    pub(crate) fn set_gas_limit(\u0026mut self, gas_limit: u64) {\n        self.gas_limit = gas_limit;\n    }\n\n    /// Get the amount of gas units still left for the rest of the calculation.\n    ///\n    /// We need the amount of gas used in wasmer since it is not tracked inside this object.\n    #[allow(unused)]\n    fn get_gas_left(\u0026self, wasmer_used_gas: u64) -\u003e u64 {\n        self.gas_limit\n            .saturating_sub(self.externally_used_gas)\n            .saturating_sub(wasmer_used_gas)\n    }\n\n    /// Get the amount of gas units used so far inside wasmer.\n    ///\n    /// We need the amount of gas left in wasmer since it is not tracked inside this object.\n    #[allow(unused)]\n    pub(crate) fn get_gas_used_in_wasmer(\u0026self, wasmer_gas_left: u64) -\u003e u64 {\n        self.gas_limit\n            .saturating_sub(self.externally_used_gas)\n            .saturating_sub(wasmer_gas_left)\n    }\n}\n\nstruct ContextData\u003c'a, S: Storage, Q: Querier\u003e {\n    /*\n    gas_state: GasState,\n    */\n    storage: Option\u003cS\u003e,\n    storage_readonly: bool,\n    querier: Option\u003cQ\u003e,\n    /*\n    /// A non-owning link to the wasmer instance\n    wasmer_instance: Option\u003cNonNull\u003cWasmerInstance\u003e\u003e,\n    */\n    #[cfg(feature = \"iterator\")]\n    iterators: HashMap\u003cu32, Box\u003cdyn StorageIterator + 'a\u003e\u003e,\n    #[cfg(not(feature = \"iterator\"))]\n    iterators: PhantomData\u003c\u0026'a mut ()\u003e,\n}\n\npub fn setup_context\u003cS: Storage, Q: Querier\u003e(gas_limit: u64) -\u003e (*mut c_void, fn(*mut c_void)) {\n    (\n        create_unmanaged_context_data::\u003cS, Q\u003e(gas_limit),\n        destroy_unmanaged_context_data::\u003cS, Q\u003e,\n    )\n}\n\nfn create_unmanaged_context_data\u003cS: Storage, Q: Querier\u003e(_gas_limit: u64) -\u003e *mut c_void {\n    let data = ContextData::\u003cS, Q\u003e {\n        /*\n        gas_state: GasState::with_limit(_gas_limit),\n        */\n        storage: None,\n        storage_readonly: true,\n        querier: None,\n        /*\n        wasmer_instance: None,\n        */\n        #[cfg(feature = \"iterator\")]\n        iterators: HashMap::new(),\n        #[cfg(not(feature = \"iterator\"))]\n        iterators: PhantomData::default(),\n    };\n    let heap_data = Box::new(data); // move from stack to heap\n    Box::into_raw(heap_data) as *mut c_void // give up ownership\n}\n\nfn destroy_unmanaged_context_data\u003cS: Storage, Q: Querier\u003e(ptr: *mut c_void) {\n    if !ptr.is_null() {\n        // obtain ownership and drop instance of ContextData when box gets out of scope\n        let mut dying = unsafe { Box::from_raw(ptr as *mut ContextData\u003cS, Q\u003e) };\n        // Ensure all iterators are dropped before the storage\n        destroy_iterators(\u0026mut dying);\n    }\n}\n\n/// Get a mutable reference to the context's data. Ownership remains in the Context.\n// NOTE: This is actually not really implemented safely at the moment. I did this as a\n// nicer and less-terrible version of the previous solution to the following issue:\n//\n//                                                   +---\u003e\u003e Go pointer\n//                                                   |\n// Ctx -\u003e\u003e ContextData +-\u003e iterators: Box\u003cdyn Iterator + 'a\u003e --+\n//                     |                                       |\n//                     +-\u003e storage: impl Storage \u003c\u003c------------+\n//                     |\n//                     +-\u003e querier: impl Querier\n//\n// -\u003e  : Ownership\n// -\u003e\u003e : Mutable borrow\n//\n// As you can see, there's a cyclical reference here... changing this function to return the same lifetime as it\n// returns (and adjusting a few other functions to only have one lifetime instead of two) triggers an error\n// elsewhere where we try to add iterators to the context. That's not legal according to Rust's rules, and it\n// complains that we're trying to borrow ctx mutably twice. This needs a better solution because this function\n// probably triggers unsoundness.\nfn get_context_data_mut\u003c'a, 'b, S: Storage, Q: Querier\u003e(\n    ctx: \u0026'a mut Ctx,\n) -\u003e \u0026'b mut ContextData\u003c'b, S, Q\u003e {\n    use crate::wasmi::FullContext;\n\n    unsafe {\n        let ptr = (*(ctx.data as *mut FullContext)).context_data as *mut ContextData\u003cS, Q\u003e;\n        ptr.as_mut()\n            .expect(\"The pointer ctx.data was null in get_context_data_mut; this is a bug.\")\n    }\n}\n\n#[cfg(not(feature = \"default-enclave\"))]\nfn get_context_data\u003c'a, 'b, S: Storage, Q: Querier\u003e(ctx: \u0026'a Ctx) -\u003e \u0026'b ContextData\u003c'b, S, Q\u003e {\n    use crate::wasmi::FullContext;\n\n    unsafe {\n        let ptr = (*(ctx.data as *mut FullContext)).context_data as *mut ContextData\u003cS, Q\u003e;\n        ptr.as_ref()\n            .expect(\"The pointer ctx.data was null in get_context_data; this is a bug.\")\n    }\n}\n\n#[cfg(not(feature = \"default-enclave\"))]\n/// Creates a back reference from a contact to its partent instance\npub fn set_wasmer_instance\u003cS: Storage, Q: Querier\u003e(\n    ctx: \u0026mut Ctx,\n    wasmer_instance: Option\u003cNonNull\u003cWasmerInstance\u003e\u003e,\n) {\n    let context_data = ctx.data as *mut ContextData\u003cS, Q\u003e;\n    unsafe {\n        (*context_data).wasmer_instance = wasmer_instance;\n    }\n}\n\n#[cfg(feature = \"iterator\")]\nfn destroy_iterators\u003cS: Storage, Q: Querier\u003e(context: \u0026mut ContextData\u003cS, Q\u003e) {\n    context.iterators.clear();\n}\n\n#[cfg(not(feature = \"iterator\"))]\nfn destroy_iterators\u003cS: Storage, Q: Querier\u003e(_context: \u0026mut ContextData\u003cS, Q\u003e) {}\n\n/// Returns the original storage and querier as owned instances, and closes any remaining\n/// iterators. This is meant to be called when recycling the instance.\npub(crate) fn move_out_of_context\u003cS: Storage, Q: Querier\u003e(\n    source: \u0026mut Ctx,\n) -\u003e (Option\u003cS\u003e, Option\u003cQ\u003e) {\n    let mut b = get_context_data_mut::\u003cS, Q\u003e(source);\n    // Destroy all existing iterators which are (in contrast to the storage)\n    // not reused between different instances.\n    // This is also important because the iterators are pointers to Go memory which should not be stored long term\n    // Paragraphs 5-7: https://golang.org/cmd/cgo/#hdr-Passing_pointers\n    destroy_iterators(\u0026mut b);\n    (b.storage.take(), b.querier.take())\n}\n\n/// Moves owned instances of storage and querier into the context.\n/// Should be followed by exactly one call to move_out_of_context when the instance is finished.\npub(crate) fn move_into_context\u003cS: Storage, Q: Querier\u003e(target: \u0026mut Ctx, storage: S, querier: Q) {\n    let b = get_context_data_mut::\u003cS, Q\u003e(target);\n    b.storage = Some(storage);\n    b.querier = Some(querier);\n}\n\n#[cfg(not(feature = \"default-enclave\"))]\npub fn get_gas_state_mut\u003c'a, 'b, S: Storage, Q: Querier + 'b\u003e(\n    ctx: \u0026'a mut Ctx,\n) -\u003e \u0026'b mut GasState {\n    \u0026mut get_context_data_mut::\u003cS, Q\u003e(ctx).gas_state\n}\n\n#[cfg(not(feature = \"default-enclave\"))]\npub fn get_gas_state\u003c'a, 'b, S: Storage, Q: Querier + 'b\u003e(ctx: \u0026'a Ctx) -\u003e \u0026'b GasState {\n    \u0026get_context_data::\u003cS, Q\u003e(ctx).gas_state\n}\n\n#[cfg(not(feature = \"default-enclave\"))]\npub fn process_gas_info\u003cS: Storage, Q: Querier\u003e(ctx: \u0026mut Ctx, info: GasInfo) -\u003e VmResult\u003c()\u003e {\n    decrease_gas_left(ctx, info.cost)?;\n    account_for_externally_used_gas::\u003cS, Q\u003e(ctx, info.externally_used)?;\n    Ok(())\n}\n\n/// Use this function to adjust the VM's gas limit when a call into the backend\n/// reported there was externally metered gas used.\n/// This does not increase the VM's gas usage but ensures the overall limit is not exceeded.\n#[cfg(not(feature = \"default-enclave\"))]\nfn account_for_externally_used_gas\u003cS: Storage, Q: Querier\u003e(\n    ctx: \u0026mut Ctx,\n    amount: u64,\n) -\u003e VmResult\u003c()\u003e {\n    account_for_externally_used_gas_impl::\u003cS, Q\u003e(ctx, amount)\n}\n\n#[cfg(feature = \"default-singlepass\")]\nfn account_for_externally_used_gas_impl\u003cS: Storage, Q: Querier\u003e(\n    ctx: \u0026mut Ctx,\n    used_gas: u64,\n) -\u003e VmResult\u003c()\u003e {\n    use crate::backends::{get_gas_left, set_gas_left};\n\n    let ctx_data = get_context_data_mut::\u003cS, Q\u003e(ctx);\n    if let Some(mut instance_ptr) = ctx_data.wasmer_instance {\n        let instance = unsafe { instance_ptr.as_mut() };\n        let gas_state = \u0026mut ctx_data.gas_state;\n\n        let wasmer_used_gas = gas_state.get_gas_used_in_wasmer(get_gas_left(instance.context()));\n\n        gas_state.increase_externally_used_gas(used_gas);\n        // These lines reduce the amount of gas available to wasmer\n        // so it can not consume gas that was consumed externally.\n        let new_limit = gas_state.get_gas_left(wasmer_used_gas);\n        // This tells wasmer how much more gas it can consume from this point in time.\n        set_gas_left(instance.context_mut(), new_limit);\n\n        if gas_state.externally_used_gas + wasmer_used_gas \u003e gas_state.gas_limit {\n            Err(VmError::GasDepletion)\n        } else {\n            Ok(())\n        }\n    } else {\n        Err(VmError::uninitialized_context_data(\"wasmer_instance\"))\n    }\n}\n\n#[cfg(feature = \"default-cranelift\")]\nfn account_for_externally_used_gas_impl\u003cS: Storage, Q: Querier\u003e(\n    _ctx: \u0026mut Ctx,\n    _used_gas: u64,\n) -\u003e VmResult\u003c()\u003e {\n    Ok(())\n}\n\n/// Returns true iff the storage is set to readonly mode\n#[cfg(not(feature = \"default-enclave\"))]\npub fn is_storage_readonly\u003cS: Storage, Q: Querier\u003e(ctx: \u0026Ctx) -\u003e bool {\n    let context_data = get_context_data::\u003cS, Q\u003e(ctx);\n    context_data.storage_readonly\n}\n\npub fn set_storage_readonly\u003cS: Storage, Q: Querier\u003e(ctx: \u0026mut Ctx, new_value: bool) {\n    let mut context_data = get_context_data_mut::\u003cS, Q\u003e(ctx);\n    context_data.storage_readonly = new_value;\n}\n\n/// Add the iterator to the context's data. A new ID is assigned and returned.\n/// IDs are guaranteed to be in the range [0, 2**31-1], i.e. fit in the non-negative part if type i32.\n#[cfg(feature = \"iterator\")]\n#[must_use = \"without the returned iterator ID, the iterator cannot be accessed\"]\npub fn add_iterator\u003c'a, S: Storage, Q: Querier\u003e(\n    ctx: \u0026mut Ctx,\n    iter: Box\u003cdyn StorageIterator + 'a\u003e,\n) -\u003e u32 {\n    let b = get_context_data_mut::\u003cS, Q\u003e(ctx);\n    let last_id: u32 = b\n        .iterators\n        .len()\n        .try_into()\n        .expect(\"Found more iterator IDs than supported\");\n    let new_id = last_id + 1;\n    if new_id \u003e (i32::MAX as u32) {\n        panic!(\"Iterator ID exceeded i32::MAX. This must not happen.\");\n    }\n    b.iterators.insert(new_id, iter);\n    new_id\n}\n\n#[cfg(not(feature = \"default-enclave\"))]\npub(crate) fn with_func_from_context\u003cS, Q, Args, Rets, Callback, CallbackData\u003e(\n    ctx: \u0026mut Ctx,\n    name: \u0026str,\n    callback: Callback,\n) -\u003e VmResult\u003cCallbackData\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n    Args: WasmTypeList,\n    Rets: WasmTypeList,\n    Callback: FnOnce(Func\u003cArgs, Rets, Wasm\u003e) -\u003e VmResult\u003cCallbackData\u003e,\n{\n    let ctx_data = get_context_data::\u003cS, Q\u003e(ctx);\n    match ctx_data.wasmer_instance {\n        Some(instance_ptr) =\u003e {\n            let func = unsafe { instance_ptr.as_ref() }.exports.get(name)?;\n            callback(func)\n        }\n        None =\u003e Err(VmError::uninitialized_context_data(\"wasmer_instance\")),\n    }\n}\n\npub(crate) fn with_storage_from_context\u003c'a, 'b, S, Q: 'b, F, T\u003e(\n    ctx: \u0026'a mut Ctx,\n    func: F,\n) -\u003e VmResult\u003cT\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n    F: FnOnce(\u0026'b mut S) -\u003e VmResult\u003cT\u003e,\n{\n    let b = get_context_data_mut::\u003cS, Q\u003e(ctx);\n    match b.storage.as_mut() {\n        Some(data) =\u003e func(data),\n        None =\u003e Err(VmError::uninitialized_context_data(\"storage\")),\n    }\n}\n\npub(crate) fn with_querier_from_context\u003c'a, 'b, S, Q: 'b, F, T\u003e(\n    ctx: \u0026'a mut Ctx,\n    func: F,\n) -\u003e VmResult\u003cT\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n    F: FnOnce(\u0026'b mut Q) -\u003e VmResult\u003cT\u003e,\n{\n    let b = get_context_data_mut::\u003cS, Q\u003e(ctx);\n    match b.querier.as_mut() {\n        Some(querier) =\u003e func(querier),\n        None =\u003e Err(VmError::uninitialized_context_data(\"querier\")),\n    }\n}\n\n#[cfg(feature = \"iterator\")]\npub(crate) fn with_iterator_from_context\u003c'a, 'b, S, Q: 'b, F, T\u003e(\n    ctx: \u0026'a mut Ctx,\n    iterator_id: u32,\n    func: F,\n) -\u003e VmResult\u003cT\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n    F: FnOnce(\u0026'b mut (dyn StorageIterator + 'b)) -\u003e VmResult\u003cT\u003e,\n{\n    let b = get_context_data_mut::\u003cS, Q\u003e(ctx);\n    match b.iterators.get_mut(\u0026iterator_id) {\n        Some(iterator) =\u003e func(iterator),\n        None =\u003e Err(VmError::iterator_does_not_exist(iterator_id)),\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::backends::{compile, decrease_gas_left, set_gas_left};\n    use crate::errors::VmError;\n    #[cfg(feature = \"iterator\")]\n    use crate::testing::MockIterator;\n    use crate::testing::{MockQuerier, MockStorage};\n    use crate::traits::Storage;\n    use cosmwasm_std::{\n        coins, from_binary, to_vec, AllBalanceResponse, BankQuery, Empty, HumanAddr, QueryRequest,\n    };\n    use wasmer_runtime_core::{imports, typed_func::Func};\n\n    static CONTRACT: \u0026[u8] = include_bytes!(\"../testdata/contract.wasm\");\n\n    // shorthands for function generics below\n    type MS = MockStorage;\n    type MQ = MockQuerier;\n\n    // prepared data\n    const INIT_KEY: \u0026[u8] = b\"foo\";\n    const INIT_VALUE: \u0026[u8] = b\"bar\";\n    // this account has some coins\n    const INIT_ADDR: \u0026str = \"someone\";\n    const INIT_AMOUNT: u128 = 500;\n    const INIT_DENOM: \u0026str = \"TOKEN\";\n\n    const GAS_LIMIT: u64 = 5_000_000;\n    const DEFAULT_QUERY_GAS_LIMIT: u64 = 300_000;\n\n    fn make_instance() -\u003e Box\u003cWasmerInstance\u003e {\n        let module = compile(\u0026CONTRACT).unwrap();\n        // we need stubs for all required imports\n        let import_obj = imports! {\n            || { setup_context::\u003cMockStorage, MockQuerier\u003e(GAS_LIMIT) },\n            \"env\" =\u003e {\n                \"db_read\" =\u003e Func::new(|_a: u32| -\u003e u32 { 0 }),\n                \"db_write\" =\u003e Func::new(|_a: u32, _b: u32| {}),\n                \"db_remove\" =\u003e Func::new(|_a: u32| {}),\n                \"db_scan\" =\u003e Func::new(|_a: u32, _b: u32, _c: i32| -\u003e u32 { 0 }),\n                \"db_next\" =\u003e Func::new(|_a: u32| -\u003e u32 { 0 }),\n                \"query_chain\" =\u003e Func::new(|_a: u32| -\u003e u32 { 0 }),\n                \"canonicalize_address\" =\u003e Func::new(|_a: u32, _b: u32| -\u003e u32 { 0 }),\n                \"humanize_address\" =\u003e Func::new(|_a: u32, _b: u32| -\u003e u32 { 0 }),\n            },\n        };\n        let mut instance = Box::from(module.instantiate(\u0026import_obj).unwrap());\n\n        let instance_ptr = NonNull::from(instance.as_ref());\n        set_wasmer_instance::\u003cMS, MQ\u003e(instance.context_mut(), Some(instance_ptr));\n\n        instance\n    }\n\n    fn leave_default_data(ctx: \u0026mut Ctx) {\n        // create some mock data\n        let mut storage = MockStorage::new();\n        storage\n            .set(INIT_KEY, INIT_VALUE)\n            .0\n            .expect(\"error setting value\");\n        let querier: MockQuerier\u003cEmpty\u003e =\n            MockQuerier::new(\u0026[(\u0026HumanAddr::from(INIT_ADDR), \u0026coins(INIT_AMOUNT, INIT_DENOM))]);\n        move_into_context(ctx, storage, querier);\n    }\n\n    #[test]\n    fn leave_and_take_context_data() {\n        // this creates an instance\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n\n        // empty data on start\n        let (inits, initq) = move_out_of_context::\u003cMS, MQ\u003e(ctx);\n        assert!(inits.is_none());\n        assert!(initq.is_none());\n\n        // store it on the instance\n        leave_default_data(ctx);\n        let (s, q) = move_out_of_context::\u003cMS, MQ\u003e(ctx);\n        assert!(s.is_some());\n        assert!(q.is_some());\n        assert_eq!(\n            s.unwrap().get(INIT_KEY).0.unwrap(),\n            Some(INIT_VALUE.to_vec())\n        );\n\n        // now is empty again\n        let (ends, endq) = move_out_of_context::\u003cMS, MQ\u003e(ctx);\n        assert!(ends.is_none());\n        assert!(endq.is_none());\n    }\n\n    #[test]\n    #[cfg(feature = \"default-singlepass\")]\n    fn gas_tracking_works_correctly() {\n        let mut instance = make_instance();\n\n        let gas_limit = 100;\n        set_gas_left(instance.context_mut(), gas_limit);\n        get_gas_state_mut::\u003cMS, MQ\u003e(instance.context_mut()).set_gas_limit(gas_limit);\n        let context = instance.context_mut();\n\n        // Consume all the Gas that we allocated\n        account_for_externally_used_gas::\u003cMS, MQ\u003e(context, 70).unwrap();\n        account_for_externally_used_gas::\u003cMS, MQ\u003e(context, 4).unwrap();\n        account_for_externally_used_gas::\u003cMS, MQ\u003e(context, 6).unwrap();\n        account_for_externally_used_gas::\u003cMS, MQ\u003e(context, 20).unwrap();\n        // Using one more unit of gas triggers a failure\n        match account_for_externally_used_gas::\u003cMS, MQ\u003e(context, 1).unwrap_err() {\n            VmError::GasDepletion =\u003e {}\n            err =\u003e panic!(\"unexpected error: {:?}\", err),\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"default-singlepass\")]\n    fn gas_tracking_works_correctly_with_gas_consumption_in_wasmer() {\n        let mut instance = make_instance();\n\n        let gas_limit = 100;\n        set_gas_left(instance.context_mut(), gas_limit);\n        get_gas_state_mut::\u003cMS, MQ\u003e(instance.context_mut()).set_gas_limit(gas_limit);\n        let context = instance.context_mut();\n\n        // Some gas was consumed externally\n        account_for_externally_used_gas::\u003cMS, MQ\u003e(context, 50).unwrap();\n        account_for_externally_used_gas::\u003cMS, MQ\u003e(context, 4).unwrap();\n\n        // Consume 20 gas directly in wasmer\n        decrease_gas_left(instance.context_mut(), 20).unwrap();\n\n        let context = instance.context_mut();\n        account_for_externally_used_gas::\u003cMS, MQ\u003e(context, 6).unwrap();\n        account_for_externally_used_gas::\u003cMS, MQ\u003e(context, 20).unwrap();\n        // Using one more unit of gas triggers a failure\n        match account_for_externally_used_gas::\u003cMS, MQ\u003e(context, 1).unwrap_err() {\n            VmError::GasDepletion =\u003e {}\n            err =\u003e panic!(\"unexpected error: {:?}\", err),\n        }\n    }\n\n    #[test]\n    fn is_storage_readonly_defaults_to_true() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        assert_eq!(is_storage_readonly::\u003cMS, MQ\u003e(ctx), true);\n    }\n\n    #[test]\n    fn set_storage_readonly_can_change_flag() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        // change\n        set_storage_readonly::\u003cMS, MQ\u003e(ctx, false);\n        assert_eq!(is_storage_readonly::\u003cMS, MQ\u003e(ctx), false);\n\n        // still false\n        set_storage_readonly::\u003cMS, MQ\u003e(ctx, false);\n        assert_eq!(is_storage_readonly::\u003cMS, MQ\u003e(ctx), false);\n\n        // change back\n        set_storage_readonly::\u003cMS, MQ\u003e(ctx, true);\n        assert_eq!(is_storage_readonly::\u003cMS, MQ\u003e(ctx), true);\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn add_iterator_works() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        assert_eq!(get_context_data_mut::\u003cMS, MQ\u003e(ctx).iterators.len(), 0);\n        let id1 = add_iterator::\u003cMS, MQ\u003e(ctx, Box::new(MockIterator::empty()));\n        let id2 = add_iterator::\u003cMS, MQ\u003e(ctx, Box::new(MockIterator::empty()));\n        let id3 = add_iterator::\u003cMS, MQ\u003e(ctx, Box::new(MockIterator::empty()));\n        assert_eq!(get_context_data_mut::\u003cMS, MQ\u003e(ctx).iterators.len(), 3);\n        assert!(get_context_data_mut::\u003cMS, MQ\u003e(ctx)\n            .iterators\n            .contains_key(\u0026id1));\n        assert!(get_context_data_mut::\u003cMS, MQ\u003e(ctx)\n            .iterators\n            .contains_key(\u0026id2));\n        assert!(get_context_data_mut::\u003cMS, MQ\u003e(ctx)\n            .iterators\n            .contains_key(\u0026id3));\n    }\n\n    #[test]\n    fn with_func_from_context_works() {\n        let mut instance = make_instance();\n        leave_default_data(instance.context_mut());\n\n        let ctx = instance.context_mut();\n        let ptr = with_func_from_context::\u003cMS, MQ, u32, u32, _, _\u003e(ctx, \"allocate\", |alloc_func| {\n            let ptr = alloc_func.call(10)?;\n            Ok(ptr)\n        })\n        .unwrap();\n        assert!(ptr \u003e 0);\n    }\n\n    #[test]\n    fn with_func_from_context_fails_for_missing_instance() {\n        let mut instance = make_instance();\n        leave_default_data(instance.context_mut());\n\n        // Clear context's wasmer_instance\n        set_wasmer_instance::\u003cMS, MQ\u003e(instance.context_mut(), None);\n\n        let ctx = instance.context_mut();\n        let res = with_func_from_context::\u003cMS, MQ, u32, u32, _, ()\u003e(ctx, \"allocate\", |_func| {\n            panic!(\"unexpected callback call\");\n        });\n        match res.unwrap_err() {\n            VmError::UninitializedContextData { kind, .. } =\u003e assert_eq!(kind, \"wasmer_instance\"),\n            e =\u003e panic!(\"Unexpected error: {}\", e),\n        }\n    }\n\n    #[test]\n    fn with_func_from_context_fails_for_missing_function() {\n        let mut instance = make_instance();\n        leave_default_data(instance.context_mut());\n\n        let ctx = instance.context_mut();\n        let res = with_func_from_context::\u003cMS, MQ, u32, u32, _, ()\u003e(ctx, \"doesnt_exist\", |_func| {\n            panic!(\"unexpected callback call\");\n        });\n        match res.unwrap_err() {\n            VmError::ResolveErr { msg, .. } =\u003e {\n                assert_eq!(\n                    msg,\n                    \"Wasmer resolve error: ExportNotFound { name: \\\"doesnt_exist\\\" }\"\n                );\n            }\n            e =\u003e panic!(\"Unexpected error: {}\", e),\n        }\n    }\n\n    #[test]\n    fn with_storage_from_context_set_get() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let val = with_storage_from_context::\u003cMS, MQ, _, _\u003e(ctx, |store| {\n            Ok(store.get(INIT_KEY).0.expect(\"error getting value\"))\n        })\n        .unwrap();\n        assert_eq!(val, Some(INIT_VALUE.to_vec()));\n\n        let set_key: \u0026[u8] = b\"more\";\n        let set_value: \u0026[u8] = b\"data\";\n\n        with_storage_from_context::\u003cMS, MQ, _, _\u003e(ctx, |store| {\n            store\n                .set(set_key, set_value)\n                .0\n                .expect(\"error setting value\");\n            Ok(())\n        })\n        .unwrap();\n\n        with_storage_from_context::\u003cMS, MQ, _, _\u003e(ctx, |store| {\n            assert_eq!(store.get(INIT_KEY).0.unwrap(), Some(INIT_VALUE.to_vec()));\n            assert_eq!(store.get(set_key).0.unwrap(), Some(set_value.to_vec()));\n            Ok(())\n        })\n        .unwrap();\n    }\n\n    #[test]\n    #[should_panic(expected = \"A panic occurred in the callback.\")]\n    fn with_storage_from_context_handles_panics() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        with_storage_from_context::\u003cMS, MQ, _, ()\u003e(ctx, |_store| {\n            panic!(\"A panic occurred in the callback.\")\n        })\n        .unwrap();\n    }\n\n    #[test]\n    fn with_querier_from_context_works() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let res = with_querier_from_context::\u003cMS, MQ, _, _\u003e(ctx, |querier| {\n            let req: QueryRequest\u003cEmpty\u003e = QueryRequest::Bank(BankQuery::AllBalances {\n                address: HumanAddr::from(INIT_ADDR),\n            });\n            let (result, _gas_info) =\n                querier.query_raw(\u0026to_vec(\u0026req).unwrap(), DEFAULT_QUERY_GAS_LIMIT);\n            Ok(result.unwrap())\n        })\n        .unwrap()\n        .unwrap()\n        .unwrap();\n        let balance: AllBalanceResponse = from_binary(\u0026res).unwrap();\n\n        assert_eq!(balance.amount, coins(INIT_AMOUNT, INIT_DENOM));\n    }\n\n    #[test]\n    #[should_panic(expected = \"A panic occurred in the callback.\")]\n    fn with_querier_from_context_handles_panics() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        with_querier_from_context::\u003cMS, MQ, _, ()\u003e(ctx, |_querier| {\n            panic!(\"A panic occurred in the callback.\")\n        })\n        .unwrap();\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn with_iterator_from_context_works() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let id = add_iterator::\u003cMS, MQ\u003e(ctx, Box::new(MockIterator::empty()));\n        with_iterator_from_context::\u003cMS, MQ, _, ()\u003e(ctx, id, |iter| {\n            assert!(iter.next().0.unwrap().is_none());\n            Ok(())\n        })\n        .expect(\"must not error\");\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn with_iterator_from_context_errors_for_non_existent_iterator_id() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let missing_id = 42u32;\n        let result = with_iterator_from_context::\u003cMS, MQ, _, ()\u003e(ctx, missing_id, |_iter| {\n            panic!(\"this should not be called\");\n        });\n        match result.unwrap_err() {\n            VmError::IteratorDoesNotExist { id, .. } =\u003e assert_eq!(id, missing_id),\n            e =\u003e panic!(\"Unexpected error: {}\", e),\n        }\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","conversion.rs"],"content":"use std::any::type_name;\nuse std::convert::TryInto;\nuse std::fmt::Display;\n\nuse crate::errors::{VmError, VmResult};\n\n/// Safely converts input of type T to u32.\n/// Errors with a cosmwasm_vm::errors::VmError::ConversionErr if conversion cannot be done.\n#[cfg(not(feature = \"default-enclave\"))]\npub fn to_u32\u003cT: TryInto\u003cu32\u003e + Display + Copy\u003e(input: T) -\u003e VmResult\u003cu32\u003e {\n    input.try_into().map_err(|_| {\n        VmError::conversion_err(type_name::\u003cT\u003e(), type_name::\u003cu32\u003e(), input.to_string())\n    })\n}\n\n/// Safely converts input of type T to i32.\n/// Errors with a cosmwasm_vm::errors::VmError::ConversionErr if conversion cannot be done.\n///\n/// Used in tests and in iterator, but not with default build\n#[allow(dead_code)]\npub fn to_i32\u003cT: TryInto\u003ci32\u003e + Display + Copy\u003e(input: T) -\u003e VmResult\u003ci32\u003e {\n    input.try_into().map_err(|_| {\n        VmError::conversion_err(type_name::\u003cT\u003e(), type_name::\u003ci32\u003e(), input.to_string())\n    })\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::errors::VmError;\n\n    #[test]\n    fn to_u32_works_for_usize() {\n        assert_eq!(to_u32(0usize).unwrap(), 0);\n        assert_eq!(to_u32(1usize).unwrap(), 1);\n        assert_eq!(to_u32(2147483647usize).unwrap(), 2147483647);\n        assert_eq!(to_u32(2147483648usize).unwrap(), 2147483648);\n        assert_eq!(to_u32(4294967295usize).unwrap(), 4294967295);\n\n        match to_u32(4294967296usize) {\n            Err(VmError::ConversionErr {\n                from_type,\n                to_type,\n                input,\n                ..\n            }) =\u003e {\n                assert_eq!(from_type, \"usize\");\n                assert_eq!(to_type, \"u32\");\n                assert_eq!(input, \"4294967296\");\n            }\n            Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n            Ok(_) =\u003e panic!(\"must not succeed\"),\n        };\n    }\n\n    #[test]\n    fn to_u32_works_for_u64() {\n        assert_eq!(to_u32(0u64).unwrap(), 0);\n        assert_eq!(to_u32(1u64).unwrap(), 1);\n        assert_eq!(to_u32(2147483647u64).unwrap(), 2147483647);\n        assert_eq!(to_u32(2147483648u64).unwrap(), 2147483648);\n        assert_eq!(to_u32(4294967295u64).unwrap(), 4294967295);\n\n        match to_u32(4294967296u64) {\n            Err(VmError::ConversionErr {\n                from_type,\n                to_type,\n                input,\n                ..\n            }) =\u003e {\n                assert_eq!(from_type, \"u64\");\n                assert_eq!(to_type, \"u32\");\n                assert_eq!(input, \"4294967296\");\n            }\n            Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n            Ok(_) =\u003e panic!(\"must not succeed\"),\n        };\n    }\n\n    #[test]\n    fn to_u32_works_for_i32() {\n        assert_eq!(to_u32(0i32).unwrap(), 0);\n        assert_eq!(to_u32(1i32).unwrap(), 1);\n        assert_eq!(to_u32(2147483647i32).unwrap(), 2147483647);\n\n        match to_u32(-1i32) {\n            Err(VmError::ConversionErr {\n                from_type,\n                to_type,\n                input,\n                ..\n            }) =\u003e {\n                assert_eq!(from_type, \"i32\");\n                assert_eq!(to_type, \"u32\");\n                assert_eq!(input, \"-1\");\n            }\n            Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n            Ok(_) =\u003e panic!(\"must not succeed\"),\n        };\n    }\n\n    #[test]\n    fn to_i32_works_for_usize() {\n        assert_eq!(to_i32(0usize).unwrap(), 0);\n        assert_eq!(to_i32(1usize).unwrap(), 1);\n        assert_eq!(to_i32(2147483647usize).unwrap(), 2147483647);\n\n        match to_i32(2147483648usize) {\n            Err(VmError::ConversionErr {\n                from_type,\n                to_type,\n                input,\n                ..\n            }) =\u003e {\n                assert_eq!(from_type, \"usize\");\n                assert_eq!(to_type, \"i32\");\n                assert_eq!(input, \"2147483648\");\n            }\n            Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n            Ok(_) =\u003e panic!(\"must not succeed\"),\n        };\n    }\n\n    #[test]\n    fn to_i32_works_for_i64() {\n        assert_eq!(to_i32(0i64).unwrap(), 0);\n        assert_eq!(to_i32(1i64).unwrap(), 1);\n        assert_eq!(to_i32(2147483647i64).unwrap(), 2147483647);\n\n        assert_eq!(to_i32(-1i64).unwrap(), -1);\n        assert_eq!(to_i32(-2147483647i64).unwrap(), -2147483647);\n        assert_eq!(to_i32(-2147483648i64).unwrap(), -2147483648);\n\n        match to_i32(-2147483649i64) {\n            Err(VmError::ConversionErr {\n                from_type,\n                to_type,\n                input,\n                ..\n            }) =\u003e {\n                assert_eq!(from_type, \"i64\");\n                assert_eq!(to_type, \"i32\");\n                assert_eq!(input, \"-2147483649\");\n            }\n            Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n            Ok(_) =\u003e panic!(\"must not succeed\"),\n        };\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","enclave.rs"],"content":"use std::{\n    env,\n    path::{Path, PathBuf},\n};\n\nuse sgx_types::{\n    sgx_attributes_t, sgx_launch_token_t, sgx_misc_attribute_t, sgx_status_t, SgxResult,\n};\nuse sgx_urts::SgxEnclave;\n\nuse lazy_static::lazy_static;\nuse log::*;\n\nstatic ENCLAVE_FILE: \u0026str = \"librust_cosmwasm_enclave.signed.so\";\n\n#[cfg(feature = \"production\")]\nconst ENCLAVE_DEBUG: i32 = 0;\n\n#[cfg(not(feature = \"production\"))]\nconst ENCLAVE_DEBUG: i32 = 1;\n\nfn init_enclave() -\u003e SgxResult\u003cSgxEnclave\u003e {\n    let mut launch_token: sgx_launch_token_t = [0; 1024];\n    let mut launch_token_updated: i32 = 0;\n    // call sgx_create_enclave to initialize an enclave instance\n    // Debug Support: set 2nd parameter to 1\n    let debug: i32 = ENCLAVE_DEBUG;\n    let mut misc_attr = sgx_misc_attribute_t {\n        secs_attr: sgx_attributes_t { flags: 0, xfrm: 0 },\n        misc_select: 0,\n    };\n\n    // Step : try to create a .enigma folder for storing all the files\n    // Create a directory, returns `io::Result\u003c()\u003e`\n    let enclave_directory = env::var(\"SCRT_ENCLAVE_DIR\").unwrap_or_else(|_| '.'.to_string());\n\n    let path = Path::new(\u0026enclave_directory);\n\n    let mut enclave_file_path: PathBuf = path.join(ENCLAVE_FILE);\n\n    trace!(\n        \"Looking for the enclave file in {:?}\",\n        enclave_file_path.to_str()\n    );\n\n    if !enclave_file_path.exists() {\n        enclave_file_path = Path::new(\"/lib\").join(ENCLAVE_FILE);\n\n        trace!(\n            \"Looking for the enclave file in {:?}\",\n            enclave_file_path.to_str()\n        );\n        if !enclave_file_path.exists() {\n            enclave_file_path = Path::new(\"/usr/lib\").join(ENCLAVE_FILE);\n\n            trace!(\n                \"Looking for the enclave file in {:?}\",\n                enclave_file_path.to_str()\n            );\n            if !enclave_file_path.exists() {\n                enclave_file_path = Path::new(\"/usr/local/lib\").join(ENCLAVE_FILE);\n            }\n        }\n    }\n\n    if !enclave_file_path.exists() {\n        warn!(\n            \"Cannot find the enclave file. Try pointing the SCRT_ENCLAVE_DIR envirinment variable to the directory that has {:?}\",\n            ENCLAVE_FILE\n        );\n        return Err(sgx_status_t::SGX_ERROR_INVALID_ENCLAVE);\n    }\n\n    SgxEnclave::create(\n        enclave_file_path,\n        debug,\n        \u0026mut launch_token,\n        \u0026mut launch_token_updated,\n        \u0026mut misc_attr,\n    )\n}\n\nlazy_static! {\n    static ref SGX_ENCLAVE: SgxResult\u003cSgxEnclave\u003e = init_enclave();\n}\n\n/// Use this method when trying to get access to the enclave.\n/// You can unwrap the result when you are certain that the enclave\n/// must have been initialized if you even reached that point in the code.\npub fn get_enclave() -\u003e SgxResult\u003c\u0026'static SgxEnclave\u003e {\n    SGX_ENCLAVE.as_ref().map_err(|status| *status)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","enclave_tests.rs"],"content":"use sgx_types;\nuse sgx_types::{sgx_enclave_id_t, sgx_status_t, SgxResult};\n\nuse crate::enclave::get_enclave;\n\nextern \"C\" {\n    pub fn ecall_run_tests(eid: sgx_enclave_id_t, retval: *mut u32) -\u003e sgx_status_t;\n}\n\npub fn run_tests() -\u003e SgxResult\u003cu32\u003e {\n    let enclave = get_enclave()?;\n    let mut failed_tests = 0;\n    let status = unsafe { ecall_run_tests(enclave.geteid(), \u0026mut failed_tests) };\n    match status {\n        sgx_status_t::SGX_SUCCESS =\u003e Ok(failed_tests),\n        other =\u003e Err(other),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","errors","communication_error.rs"],"content":"use snafu::Snafu;\nuse std::fmt::Debug;\n\nuse super::region_validation_error::RegionValidationError;\n\n/// An error in the communcation between contract and host. Those happen around imports and exports.\n#[derive(Debug, Snafu)]\n#[non_exhaustive]\npub enum CommunicationError {\n    #[snafu(display(\n        \"The Wasm memory address {} provided by the contract could not be dereferenced: {}\",\n        offset,\n        msg\n    ))]\n    DerefErr {\n        /// the position in a Wasm linear memory\n        offset: u32,\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Got an invalid value for iteration order: {}\", value))]\n    InvalidOrder {\n        value: i32,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Got an invalid region: {}\", source))]\n    InvalidRegion {\n        #[snafu(backtrace)]\n        source: RegionValidationError,\n    },\n    /// Whenever UTF-8 bytes cannot be decoded into a unicode string, e.g. in String::from_utf8 or str::from_utf8.\n    #[snafu(display(\"Cannot decode UTF8 bytes into string: {}\", msg))]\n    InvalidUtf8 {\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Region length too big. Got {}, limit {}\", length, max_length))]\n    // Note: this only checks length, not capacity\n    RegionLengthTooBig {\n        length: usize,\n        max_length: usize,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Region too small. Got {}, required {}\", size, required))]\n    RegionTooSmall {\n        size: usize,\n        required: usize,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Got a zero Wasm address\"))]\n    ZeroAddress { backtrace: snafu::Backtrace },\n}\n\n#[allow(unused)]\nimpl CommunicationError {\n    pub(crate) fn deref_err\u003cS: Into\u003cString\u003e\u003e(offset: u32, msg: S) -\u003e Self {\n        DerefErr {\n            offset,\n            msg: msg.into(),\n        }\n        .build()\n    }\n\n    #[allow(dead_code)]\n    pub(crate) fn invalid_order(value: i32) -\u003e Self {\n        InvalidOrder { value }.build()\n    }\n\n    #[allow(dead_code)]\n    pub(crate) fn invalid_utf8\u003cS: ToString\u003e(msg: S) -\u003e Self {\n        InvalidUtf8 {\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n\n    pub(crate) fn region_length_too_big(length: usize, max_length: usize) -\u003e Self {\n        RegionLengthTooBig { length, max_length }.build()\n    }\n\n    pub(crate) fn region_too_small(size: usize, required: usize) -\u003e Self {\n        RegionTooSmall { size, required }.build()\n    }\n\n    pub(crate) fn zero_address() -\u003e Self {\n        ZeroAddress {}.build()\n    }\n}\n\nimpl From\u003cRegionValidationError\u003e for CommunicationError {\n    fn from(region_validation_error: RegionValidationError) -\u003e Self {\n        CommunicationError::InvalidRegion {\n            source: region_validation_error,\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    // constructors\n\n    #[test]\n    fn deref_err() {\n        let error = CommunicationError::deref_err(345, \"broken stuff\");\n        match error {\n            CommunicationError::DerefErr { offset, msg, .. } =\u003e {\n                assert_eq!(offset, 345);\n                assert_eq!(msg, \"broken stuff\");\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn invalid_order() {\n        let error = CommunicationError::invalid_order(-745);\n        match error {\n            CommunicationError::InvalidOrder { value, .. } =\u003e assert_eq!(value, -745),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn invalid_utf8() {\n        let error = CommunicationError::invalid_utf8(\"broken\");\n        match error {\n            CommunicationError::InvalidUtf8 { msg, .. } =\u003e assert_eq!(msg, \"broken\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn region_length_too_big_works() {\n        let error = CommunicationError::region_length_too_big(50, 20);\n        match error {\n            CommunicationError::RegionLengthTooBig {\n                length, max_length, ..\n            } =\u003e {\n                assert_eq!(length, 50);\n                assert_eq!(max_length, 20);\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn region_too_small_works() {\n        let error = CommunicationError::region_too_small(12, 33);\n        match error {\n            CommunicationError::RegionTooSmall { size, required, .. } =\u003e {\n                assert_eq!(size, 12);\n                assert_eq!(required, 33);\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn zero_address() {\n        let error = CommunicationError::zero_address();\n        match error {\n            CommunicationError::ZeroAddress { .. } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n}\n","traces":[{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","errors","enclave.rs"],"content":"use super::VmError;\nuse snafu::{Backtrace, Snafu};\n\n/// An error in the communication with the enclave\n#[derive(Debug, Snafu)]\n#[non_exhaustive]\npub enum EnclaveError {\n    #[snafu(display(\"{}\", error))]\n    EnclaveErr {\n        error: enclave_ffi_types::EnclaveError,\n        backtrace: Backtrace,\n    },\n    #[snafu(display(\"SGX error: {:?}\", status))]\n    SdkErr {\n        status: sgx_types::sgx_status_t,\n        backtrace: Backtrace,\n    },\n}\n\nimpl EnclaveError {\n    pub fn enclave_err(error: enclave_ffi_types::EnclaveError) -\u003e Self {\n        EnclaveErr { error }.build()\n    }\n\n    pub fn sdk_err(status: sgx_types::sgx_status_t) -\u003e Self {\n        SdkErr { status }.build()\n    }\n}\n\nimpl From\u003cEnclaveError\u003e for VmError {\n    fn from(error: EnclaveError) -\u003e Self {\n        VmError::EnclaveErr { source: error }\n    }\n}\n\nimpl From\u003cenclave_ffi_types::EnclaveError\u003e for VmError {\n    fn from(error: enclave_ffi_types::EnclaveError) -\u003e Self {\n        match error {\n            enclave_ffi_types::EnclaveError::OutOfGas =\u003e VmError::GasDepletion,\n            enclave_ffi_types::EnclaveError::FailedOcall { vm_error }\n                if !vm_error.ptr.is_null() =\u003e\n            // This error is boxed during ocalls.\n            unsafe { *Box::\u003cVmError\u003e::from_raw(vm_error.ptr as *mut _) }\n            other =\u003e EnclaveError::enclave_err(other).into(),\n        }\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","errors","mod.rs"],"content":"mod communication_error;\nmod region_validation_error;\nmod vm_error;\n\nmod enclave;\n\npub use communication_error::CommunicationError;\npub use region_validation_error::RegionValidationError;\npub use vm_error::VmError;\n\npub use enclave::EnclaveError;\n\npub type CommunicationResult\u003cT\u003e = core::result::Result\u003cT, CommunicationError\u003e;\npub type RegionValidationResult\u003cT\u003e = core::result::Result\u003cT, RegionValidationError\u003e;\npub type VmResult\u003cT\u003e = core::result::Result\u003cT, VmError\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","errors","region_validation_error.rs"],"content":"use snafu::Snafu;\nuse std::fmt::Debug;\n\n/// An error validating a Region\n#[derive(Debug, Snafu)]\n#[non_exhaustive]\npub enum RegionValidationError {\n    #[snafu(display(\n        \"Region length exceeds capacity. Length {}, capacity {}\",\n        length,\n        capacity\n    ))]\n    LengthExceedsCapacity {\n        length: u32,\n        capacity: u32,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\n        \"Region exceeds address space. Offset {}, capacity {}\",\n        offset,\n        capacity\n    ))]\n    OutOfRange {\n        offset: u32,\n        capacity: u32,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Got a zero Wasm address in the offset\"))]\n    ZeroOffset { backtrace: snafu::Backtrace },\n}\n\n#[allow(unused)]\nimpl RegionValidationError {\n    pub(crate) fn length_exceeds_capacity(length: u32, capacity: u32) -\u003e Self {\n        LengthExceedsCapacity { length, capacity }.build()\n    }\n\n    pub(crate) fn out_of_range(offset: u32, capacity: u32) -\u003e Self {\n        OutOfRange { offset, capacity }.build()\n    }\n\n    pub(crate) fn zero_offset() -\u003e Self {\n        ZeroOffset {}.build()\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    // constructors\n\n    #[test]\n    fn length_exceeds_capacity_works() {\n        let error = RegionValidationError::length_exceeds_capacity(50, 20);\n        match error {\n            RegionValidationError::LengthExceedsCapacity {\n                length, capacity, ..\n            } =\u003e {\n                assert_eq!(length, 50);\n                assert_eq!(capacity, 20);\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn out_of_range_works() {\n        let error = RegionValidationError::out_of_range(u32::MAX, 1);\n        match error {\n            RegionValidationError::OutOfRange {\n                offset, capacity, ..\n            } =\u003e {\n                assert_eq!(offset, u32::MAX);\n                assert_eq!(capacity, 1);\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn zero_offset() {\n        let error = RegionValidationError::zero_offset();\n        match error {\n            RegionValidationError::ZeroOffset { .. } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","errors","vm_error.rs"],"content":"use snafu::Snafu;\nuse std::fmt::{Debug, Display};\n\nuse super::communication_error::CommunicationError;\n// use crate::backends::InsufficientGasLeft;\nuse crate::ffi::FfiError;\n\nuse super::EnclaveError;\n\n#[derive(Debug, Snafu)]\n#[non_exhaustive]\npub enum VmError {\n    #[snafu(display(\"Cache error: {}\", msg))]\n    CacheErr {\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Error in guest/host communication: {}\", source))]\n    CommunicationErr {\n        #[snafu(backtrace)]\n        source: CommunicationError,\n    },\n    #[snafu(display(\"Error compiling Wasm: {}\", msg))]\n    CompileErr {\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Couldn't convert from {} to {}. Input: {}\", from_type, to_type, input))]\n    ConversionErr {\n        from_type: String,\n        to_type: String,\n        input: String,\n        backtrace: snafu::Backtrace,\n    },\n    /// Whenever there is no specific error type available\n    #[snafu(display(\"Generic error: {}\", msg))]\n    GenericErr {\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Error instantiating a Wasm module: {}\", msg))]\n    InstantiationErr {\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Hash doesn't match stored data\"))]\n    IntegrityErr { backtrace: snafu::Backtrace },\n    #[snafu(display(\"Iterator with ID {} does not exist\", id))]\n    IteratorDoesNotExist {\n        id: u32,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Error parsing into type {}: {}\", target, msg))]\n    ParseErr {\n        /// the target type that was attempted\n        target: String,\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Error serializing type {}: {}\", source, msg))]\n    SerializeErr {\n        /// the source type that was attempted\n        #[snafu(source(false))]\n        source: String,\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Error resolving Wasm function: {}\", msg))]\n    ResolveErr {\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Error executing Wasm: {}\", msg))]\n    RuntimeErr {\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Error during static Wasm validation: {}\", msg))]\n    StaticValidationErr {\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Uninitialized Context Data: {}\", kind))]\n    UninitializedContextData {\n        kind: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Calling external function through FFI: {}\", source))]\n    FfiErr {\n        #[snafu(backtrace)]\n        source: FfiError,\n    },\n    #[snafu(display(\"Ran out of gas during contract execution\"))]\n    GasDepletion,\n    #[snafu(display(\"Must not call a writing storage function in this context.\"))]\n    WriteAccessDenied { backtrace: snafu::Backtrace },\n\n    #[snafu(display(\"Enclave: {}\", source))]\n    EnclaveErr {\n        #[snafu(backtrace)]\n        source: EnclaveError,\n    },\n}\n\n#[allow(unused)]\nimpl VmError {\n    pub(crate) fn cache_err\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self {\n        CacheErr { msg: msg.into() }.build()\n    }\n\n    pub(crate) fn compile_err\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self {\n        CompileErr { msg: msg.into() }.build()\n    }\n\n    pub(crate) fn conversion_err\u003cS: Into\u003cString\u003e, T: Into\u003cString\u003e, U: Into\u003cString\u003e\u003e(\n        from_type: S,\n        to_type: T,\n        input: U,\n    ) -\u003e Self {\n        ConversionErr {\n            from_type: from_type.into(),\n            to_type: to_type.into(),\n            input: input.into(),\n        }\n        .build()\n    }\n\n    pub(crate) fn generic_err\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self {\n        GenericErr { msg: msg.into() }.build()\n    }\n\n    pub(crate) fn instantiation_err\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self {\n        InstantiationErr { msg: msg.into() }.build()\n    }\n\n    pub(crate) fn integrity_err() -\u003e Self {\n        IntegrityErr {}.build()\n    }\n\n    #[cfg(feature = \"iterator\")]\n    pub(crate) fn iterator_does_not_exist(iterator_id: u32) -\u003e Self {\n        IteratorDoesNotExist { id: iterator_id }.build()\n    }\n\n    pub(crate) fn parse_err\u003cT: Into\u003cString\u003e, M: Display\u003e(target: T, msg: M) -\u003e Self {\n        ParseErr {\n            target: target.into(),\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n\n    pub(crate) fn serialize_err\u003cS: Into\u003cString\u003e, M: Display\u003e(source: S, msg: M) -\u003e Self {\n        SerializeErr {\n            source: source.into(),\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n\n    pub(crate) fn resolve_err\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self {\n        ResolveErr { msg: msg.into() }.build()\n    }\n\n    pub(crate) fn runtime_err\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self {\n        RuntimeErr { msg: msg.into() }.build()\n    }\n\n    pub(crate) fn static_validation_err\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self {\n        StaticValidationErr { msg: msg.into() }.build()\n    }\n\n    pub(crate) fn uninitialized_context_data\u003cS: Into\u003cString\u003e\u003e(kind: S) -\u003e Self {\n        UninitializedContextData { kind: kind.into() }.build()\n    }\n\n    pub(crate) fn write_access_denied() -\u003e Self {\n        WriteAccessDenied {}.build()\n    }\n}\n\nimpl From\u003cCommunicationError\u003e for VmError {\n    fn from(communication_error: CommunicationError) -\u003e Self {\n        VmError::CommunicationErr {\n            source: communication_error,\n        }\n    }\n}\n\nimpl From\u003cFfiError\u003e for VmError {\n    fn from(ffi_error: FfiError) -\u003e Self {\n        match ffi_error {\n            FfiError::OutOfGas {} =\u003e VmError::GasDepletion,\n            _ =\u003e VmError::FfiErr { source: ffi_error },\n        }\n    }\n}\n\n/*\nimpl From\u003cwasmer_runtime_core::cache::Error\u003e for VmError {\n    fn from(original: wasmer_runtime_core::cache::Error) -\u003e Self {\n        VmError::cache_err(format!(\"Wasmer cache error: {:?}\", original))\n    }\n}\n\nimpl From\u003cwasmer_runtime_core::error::CompileError\u003e for VmError {\n    fn from(original: wasmer_runtime_core::error::CompileError) -\u003e Self {\n        VmError::compile_err(format!(\"Wasmer compile error: {:?}\", original))\n    }\n}\n\nimpl From\u003cwasmer_runtime_core::error::ResolveError\u003e for VmError {\n    fn from(original: wasmer_runtime_core::error::ResolveError) -\u003e Self {\n        VmError::resolve_err(format!(\"Wasmer resolve error: {:?}\", original))\n    }\n}\n\nimpl From\u003cwasmer_runtime_core::error::RuntimeError\u003e for VmError {\n    fn from(original: wasmer_runtime_core::error::RuntimeError) -\u003e Self {\n        use wasmer_runtime_core::error::{InvokeError, RuntimeError};\n\n        fn runtime_error(err: RuntimeError) -\u003e VmError {\n            VmError::runtime_err(format!(\"Wasmer runtime error: {:?}\", err))\n        }\n\n        match original {\n            // TODO: fix the issue described below:\n            // `InvokeError::FailedWithNoError` happens when running out of gas in singlepass v0.17\n            // but it's supposed to indicate bugs in Wasmer...\n            // https://github.com/wasmerio/wasmer/issues/1452\n            // https://github.com/CosmWasm/cosmwasm/issues/375\n            RuntimeError::InvokeError(InvokeError::FailedWithNoError) =\u003e VmError::GasDepletion,\n            // This variant contains the error we return from imports.\n            RuntimeError::User(err) =\u003e match err.downcast::\u003cVmError\u003e() {\n                Ok(err) =\u003e *err,\n                Err(err) =\u003e runtime_error(RuntimeError::User(err)),\n            },\n            _ =\u003e runtime_error(original),\n        }\n    }\n}\n\nimpl From\u003cInsufficientGasLeft\u003e for VmError {\n    fn from(_original: InsufficientGasLeft) -\u003e Self {\n        VmError::GasDepletion\n    }\n}\n*/\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    // constructors\n\n    #[test]\n    fn cache_err_works() {\n        let error = VmError::cache_err(\"something went wrong\");\n        match error {\n            VmError::CacheErr { msg, .. } =\u003e assert_eq!(msg, \"something went wrong\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn compile_err_works() {\n        let error = VmError::compile_err(\"something went wrong\");\n        match error {\n            VmError::CompileErr { msg, .. } =\u003e assert_eq!(msg, \"something went wrong\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn conversion_err_works() {\n        let error = VmError::conversion_err(\"i32\", \"u32\", \"-9\");\n        match error {\n            VmError::ConversionErr {\n                from_type,\n                to_type,\n                input,\n                ..\n            } =\u003e {\n                assert_eq!(from_type, \"i32\");\n                assert_eq!(to_type, \"u32\");\n                assert_eq!(input, \"-9\");\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn generic_err_works() {\n        let guess = 7;\n        let error = VmError::generic_err(format!(\"{} is too low\", guess));\n        match error {\n            VmError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, String::from(\"7 is too low\"));\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn instantiation_err_works() {\n        let error = VmError::instantiation_err(\"something went wrong\");\n        match error {\n            VmError::InstantiationErr { msg, .. } =\u003e assert_eq!(msg, \"something went wrong\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn integrity_err_works() {\n        let error = VmError::integrity_err();\n        match error {\n            VmError::IntegrityErr { .. } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn iterator_does_not_exist_works() {\n        let error = VmError::iterator_does_not_exist(15);\n        match error {\n            VmError::IteratorDoesNotExist { id, .. } =\u003e assert_eq!(id, 15),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn parse_err_works() {\n        let error = VmError::parse_err(\"Book\", \"Missing field: title\");\n        match error {\n            VmError::ParseErr { target, msg, .. } =\u003e {\n                assert_eq!(target, \"Book\");\n                assert_eq!(msg, \"Missing field: title\");\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn serialize_err_works() {\n        let error = VmError::serialize_err(\"Book\", \"Content too long\");\n        match error {\n            VmError::SerializeErr { source, msg, .. } =\u003e {\n                assert_eq!(source, \"Book\");\n                assert_eq!(msg, \"Content too long\");\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn resolve_err_works() {\n        let error = VmError::resolve_err(\"function has different signature\");\n        match error {\n            VmError::ResolveErr { msg, .. } =\u003e assert_eq!(msg, \"function has different signature\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn runtime_err_works() {\n        let error = VmError::runtime_err(\"something went wrong\");\n        match error {\n            VmError::RuntimeErr { msg, .. } =\u003e assert_eq!(msg, \"something went wrong\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn static_validation_err_works() {\n        let error = VmError::static_validation_err(\"export xy missing\");\n        match error {\n            VmError::StaticValidationErr { msg, .. } =\u003e assert_eq!(msg, \"export xy missing\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn uninitialized_context_data_works() {\n        let error = VmError::uninitialized_context_data(\"foo\");\n        match error {\n            VmError::UninitializedContextData { kind, .. } =\u003e assert_eq!(kind, \"foo\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn write_access_denied() {\n        let error = VmError::write_access_denied();\n        match error {\n            VmError::WriteAccessDenied { .. } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n}\n","traces":[{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":33},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","features.rs"],"content":"use parity_wasm::elements::{Internal, Module};\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\n// use wasmer_runtime_core::{export::Export, Instance as WasmerInstance};\n\nconst REQUIRES_PREFIX: \u0026str = \"requires_\";\n\n/// Takes a comma-separated string, splits it by commas, removes empty elements and returns a set of features.\n/// This can be used e.g. to initialize the cache.\npub fn features_from_csv(csv: \u0026str) -\u003e HashSet\u003cString\u003e {\n    HashSet::from_iter(\n        csv.split(',')\n            .map(|x| x.trim().to_string())\n            .filter(|f| !f.is_empty()),\n    )\n}\n\n/*\npub fn required_features_from_wasmer_instance(wasmer_instance: \u0026WasmerInstance) -\u003e HashSet\u003cString\u003e {\n    HashSet::from_iter(wasmer_instance.exports().filter_map(|(mut name, export)| {\n        if let Export::Function { .. } = export {\n            if name.starts_with(REQUIRES_PREFIX) \u0026\u0026 name.len() \u003e REQUIRES_PREFIX.len() {\n                let required_feature = name.split_off(REQUIRES_PREFIX.len());\n                return Some(required_feature);\n            }\n        }\n        None\n    }))\n}\n*/\n\n/// Implementation for check_wasm, based on static analysis of the bytecode.\n/// This is used for code upload, to perform check before compiling the Wasm.\npub fn required_features_from_module(module: \u0026Module) -\u003e HashSet\u003cString\u003e {\n    match module.export_section() {\n        None =\u003e HashSet::new(),\n        Some(export_section) =\u003e {\n            HashSet::from_iter(export_section.entries().iter().filter_map(|entry| {\n                if let Internal::Function(_) = entry.internal() {\n                    let name = entry.field();\n                    if name.starts_with(REQUIRES_PREFIX) \u0026\u0026 name.len() \u003e REQUIRES_PREFIX.len() {\n                        let (_, required_feature) = name.split_at(REQUIRES_PREFIX.len());\n                        return Some(required_feature.to_string());\n                    }\n                }\n                None\n            }))\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use parity_wasm::elements::deserialize_buffer;\n    use wabt::wat2wasm;\n\n    #[test]\n    fn features_from_csv_works() {\n        let set = features_from_csv(\"foo, bar,baz \");\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(\"foo\"));\n        assert!(set.contains(\"bar\"));\n        assert!(set.contains(\"baz\"));\n    }\n\n    #[test]\n    fn features_from_csv_skips_empty() {\n        let set = features_from_csv(\"\");\n        assert_eq!(set.len(), 0);\n        let set = features_from_csv(\"a,,b\");\n        assert_eq!(set.len(), 2);\n        assert!(set.contains(\"a\"));\n        assert!(set.contains(\"b\"));\n        let set = features_from_csv(\"a,b,\");\n        assert_eq!(set.len(), 2);\n        assert!(set.contains(\"a\"));\n        assert!(set.contains(\"b\"));\n    }\n\n    #[test]\n    fn required_features_from_module_works() {\n        let wasm = wat2wasm(\n            r#\"(module\n            (type (func))\n            (func (type 0) nop)\n            (export \"requires_water\" (func 0))\n            (export \"requires_\" (func 0))\n            (export \"requires_nutrients\" (func 0))\n            (export \"require_milk\" (func 0))\n            (export \"REQUIRES_air\" (func 0))\n            (export \"requires_sun\" (func 0))\n            )\"#,\n        )\n        .unwrap();\n        let module = deserialize_buffer(\u0026wasm).unwrap();\n\n        let required_features = required_features_from_module(\u0026module);\n        assert_eq!(required_features.len(), 3);\n        assert!(required_features.contains(\"nutrients\"));\n        assert!(required_features.contains(\"sun\"));\n        assert!(required_features.contains(\"water\"));\n    }\n\n    #[test]\n    fn required_features_from_module_works_without_exports_section() {\n        let wasm = wat2wasm(r#\"(module)\"#).unwrap();\n        let module = deserialize_buffer(\u0026wasm).unwrap();\n        let required_features = required_features_from_module(\u0026module);\n        assert_eq!(required_features.len(), 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","ffi.rs"],"content":"use snafu::Snafu;\nuse std::fmt::Debug;\nuse std::string::FromUtf8Error;\n\n/// A result type for calling into the backend via FFI. Such a call causes\n/// non-negligible computational cost and must always have gas information\n/// attached. In order to prevent new calls from forgetting such gas information\n/// to be passed, the inner success and failure types contain gas information.\npub type FfiResult\u003cT\u003e = (core::result::Result\u003cT, FfiError\u003e, GasInfo);\n\n#[derive(Copy, Clone, Debug)]\npub struct GasInfo {\n    /// The gas cost of a computation that was executed already but not yet charged\n    pub cost: u64,\n    /// Gas that was used and charged externally. This is needed to\n    /// adjust the VM's gas limit but does not affect the gas usage.\n    pub externally_used: u64,\n}\n\nimpl GasInfo {\n    pub fn with_cost(amount: u64) -\u003e Self {\n        GasInfo {\n            cost: amount,\n            externally_used: 0,\n        }\n    }\n\n    pub fn with_externally_used(amount: u64) -\u003e Self {\n        GasInfo {\n            cost: 0,\n            externally_used: amount,\n        }\n    }\n\n    /// Creates a gas information with no cost for the caller and with zero externally used gas.\n    ///\n    /// Caution: when using this you need to make sure no gas was metered externally to keep the gas values in sync.\n    pub fn free() -\u003e Self {\n        GasInfo {\n            cost: 0,\n            externally_used: 0,\n        }\n    }\n}\n\n#[derive(Debug, Snafu)]\npub enum FfiError {\n    #[snafu(display(\"Panic in FFI call\"))]\n    ForeignPanic { backtrace: snafu::Backtrace },\n    #[snafu(display(\"bad argument passed to FFI\"))]\n    BadArgument { backtrace: snafu::Backtrace },\n    #[snafu(display(\"VM received invalid UTF-8 data from backend\"))]\n    InvalidUtf8 { backtrace: snafu::Backtrace },\n    #[snafu(display(\"Ran out of gas during FFI call\"))]\n    OutOfGas {},\n    #[snafu(display(\"Unknown error during FFI call: {:?}\", msg))]\n    Unknown {\n        msg: Option\u003cString\u003e,\n        backtrace: snafu::Backtrace,\n    },\n    // This is the only error case of FfiError that is reported back to the contract.\n    #[snafu(display(\"User error during FFI call: {}\", msg))]\n    UserErr {\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n}\n\nimpl FfiError {\n    pub fn foreign_panic() -\u003e Self {\n        ForeignPanic {}.build()\n    }\n\n    pub fn bad_argument() -\u003e Self {\n        BadArgument {}.build()\n    }\n\n    pub fn out_of_gas() -\u003e Self {\n        OutOfGas {}.build()\n    }\n\n    pub fn unknown\u003cS: ToString\u003e(msg: S) -\u003e Self {\n        Unknown {\n            msg: Some(msg.to_string()),\n        }\n        .build()\n    }\n\n    /// Use `::unknown(msg: S)` if possible\n    pub fn unknown_without_message() -\u003e Self {\n        Unknown { msg: None }.build()\n    }\n\n    pub fn user_err\u003cS: ToString\u003e(msg: S) -\u003e Self {\n        UserErr {\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n}\n\nimpl From\u003cFromUtf8Error\u003e for FfiError {\n    fn from(_original: FromUtf8Error) -\u003e Self {\n        InvalidUtf8 {}.build()\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn gas_info_with_cost_works() {\n        let gas_info = GasInfo::with_cost(21);\n        assert_eq!(gas_info.cost, 21);\n        assert_eq!(gas_info.externally_used, 0);\n    }\n\n    #[test]\n    fn gas_info_with_externally_used_works() {\n        let gas_info = GasInfo::with_externally_used(65);\n        assert_eq!(gas_info.cost, 0);\n        assert_eq!(gas_info.externally_used, 65);\n    }\n\n    #[test]\n    fn gas_info_free_works() {\n        let gas_info = GasInfo::free();\n        assert_eq!(gas_info.cost, 0);\n        assert_eq!(gas_info.externally_used, 0);\n    }\n\n    // constructors\n\n    #[test]\n    fn ffi_error_foreign_panic() {\n        let error = FfiError::foreign_panic();\n        match error {\n            FfiError::ForeignPanic { .. } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn ffi_error_bad_argument() {\n        let error = FfiError::bad_argument();\n        match error {\n            FfiError::BadArgument { .. } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn ffi_error_out_of_gas() {\n        let error = FfiError::out_of_gas();\n        match error {\n            FfiError::OutOfGas { .. } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn ffi_error_unknown() {\n        let error = FfiError::unknown(\"broken\");\n        match error {\n            FfiError::Unknown { msg, .. } =\u003e assert_eq!(msg.unwrap(), \"broken\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn ffi_error_unknown_without_message() {\n        let error = FfiError::unknown_without_message();\n        match error {\n            FfiError::Unknown { msg, .. } =\u003e assert!(msg.is_none()),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn ffi_error_user_err() {\n        let error = FfiError::user_err(\"invalid input\");\n        match error {\n            FfiError::UserErr { msg, .. } =\u003e assert_eq!(msg, \"invalid input\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    // conversions\n\n    #[test]\n    fn convert_from_fromutf8error() {\n        let error: FfiError = String::from_utf8(vec![0x80]).unwrap_err().into();\n        match error {\n            FfiError::InvalidUtf8 { .. } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","imports.rs"],"content":"//! Import implementations\n\n#[cfg(feature = \"iterator\")]\nuse std::convert::TryInto;\n\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::Order;\nuse cosmwasm_std::{Binary, CanonicalAddr, HumanAddr};\nuse wasmer_runtime_core::vm::Ctx;\n\nuse crate::backends::get_gas_left;\n#[cfg(feature = \"iterator\")]\nuse crate::context::{add_iterator, with_iterator_from_context};\nuse crate::context::{\n    is_storage_readonly, process_gas_info, with_func_from_context, with_querier_from_context,\n    with_storage_from_context,\n};\nuse crate::conversion::to_u32;\nuse crate::errors::{CommunicationError, VmError, VmResult};\nuse crate::ffi::FfiError;\n#[cfg(feature = \"iterator\")]\nuse crate::memory::maybe_read_region;\nuse crate::memory::{read_region, write_region};\nuse crate::serde::to_vec;\nuse crate::traits::{Api, Querier, Storage};\n\n/// A kibi (kilo binary)\nconst KI: usize = 1024;\n/// Max key length for db_write (i.e. when VM reads from Wasm memory)\nconst MAX_LENGTH_DB_KEY: usize = 64 * KI;\n/// Max key length for db_write (i.e. when VM reads from Wasm memory)\nconst MAX_LENGTH_DB_VALUE: usize = 128 * KI;\n/// Typically 20 (Cosmos SDK, Ethereum) or 32 (Nano, Substrate)\nconst MAX_LENGTH_CANONICAL_ADDRESS: usize = 32;\n/// The maximum allowed size for bech32 (https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32)\nconst MAX_LENGTH_HUMAN_ADDRESS: usize = 90;\nconst MAX_LENGTH_QUERY_CHAIN_REQUEST: usize = 64 * KI;\n\n/// Reads a storage entry from the VM's storage into Wasm memory\npub fn do_read\u003cS: Storage, Q: Querier\u003e(ctx: \u0026mut Ctx, key_ptr: u32) -\u003e VmResult\u003cu32\u003e {\n    let key = read_region(ctx, key_ptr, MAX_LENGTH_DB_KEY)?;\n\n    let (result, gas_info) =\n        with_storage_from_context::\u003cS, Q, _, _\u003e(ctx, |store| Ok(store.get(\u0026key)))?;\n    process_gas_info::\u003cS, Q\u003e(ctx, gas_info)?;\n    let value = result?;\n\n    let out_data = match value {\n        Some(data) =\u003e data,\n        None =\u003e return Ok(0),\n    };\n    write_to_contract::\u003cS, Q\u003e(ctx, \u0026out_data)\n}\n\n/// Writes a storage entry from Wasm memory into the VM's storage\npub fn do_write\u003cS: Storage, Q: Querier\u003e(\n    ctx: \u0026mut Ctx,\n    key_ptr: u32,\n    value_ptr: u32,\n) -\u003e VmResult\u003c()\u003e {\n    if is_storage_readonly::\u003cS, Q\u003e(ctx) {\n        return Err(VmError::write_access_denied());\n    }\n\n    let key = read_region(ctx, key_ptr, MAX_LENGTH_DB_KEY)?;\n    let value = read_region(ctx, value_ptr, MAX_LENGTH_DB_VALUE)?;\n\n    let (result, gas_info) =\n        with_storage_from_context::\u003cS, Q, _, _\u003e(ctx, |store| Ok(store.set(\u0026key, \u0026value)))?;\n    process_gas_info::\u003cS, Q\u003e(ctx, gas_info)?;\n    result?;\n\n    Ok(())\n}\n\npub fn do_remove\u003cS: Storage, Q: Querier\u003e(ctx: \u0026mut Ctx, key_ptr: u32) -\u003e VmResult\u003c()\u003e {\n    if is_storage_readonly::\u003cS, Q\u003e(ctx) {\n        return Err(VmError::write_access_denied());\n    }\n\n    let key = read_region(ctx, key_ptr, MAX_LENGTH_DB_KEY)?;\n\n    let (result, gas_info) =\n        with_storage_from_context::\u003cS, Q, _, _\u003e(ctx, |store| Ok(store.remove(\u0026key)))?;\n    process_gas_info::\u003cS, Q\u003e(ctx, gas_info)?;\n    result?;\n\n    Ok(())\n}\n\npub fn do_canonicalize_address\u003cA: Api, S: Storage, Q: Querier\u003e(\n    api: A,\n    ctx: \u0026mut Ctx,\n    source_ptr: u32,\n    destination_ptr: u32,\n) -\u003e VmResult\u003cu32\u003e {\n    let source_data = read_region(ctx, source_ptr, MAX_LENGTH_HUMAN_ADDRESS)?;\n    if source_data.is_empty() {\n        return Ok(write_to_contract::\u003cS, Q\u003e(ctx, b\"Input is empty\")?);\n    }\n\n    let source_string = match String::from_utf8(source_data) {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e return Ok(write_to_contract::\u003cS, Q\u003e(ctx, b\"Input is not valid UTF-8\")?),\n    };\n    let human: HumanAddr = source_string.into();\n\n    let (result, gas_info) = api.canonical_address(\u0026human);\n    process_gas_info::\u003cS, Q\u003e(ctx, gas_info)?;\n    match result {\n        Ok(canonical) =\u003e {\n            write_region(ctx, destination_ptr, canonical.as_slice())?;\n            Ok(0)\n        }\n        Err(FfiError::UserErr { msg, .. }) =\u003e Ok(write_to_contract::\u003cS, Q\u003e(ctx, msg.as_bytes())?),\n        Err(err) =\u003e Err(VmError::from(err)),\n    }\n}\n\npub fn do_humanize_address\u003cA: Api, S: Storage, Q: Querier\u003e(\n    api: A,\n    ctx: \u0026mut Ctx,\n    source_ptr: u32,\n    destination_ptr: u32,\n) -\u003e VmResult\u003cu32\u003e {\n    let canonical = Binary(read_region(ctx, source_ptr, MAX_LENGTH_CANONICAL_ADDRESS)?);\n\n    let (result, gas_info) = api.human_address(\u0026CanonicalAddr(canonical));\n    process_gas_info::\u003cS, Q\u003e(ctx, gas_info)?;\n    match result {\n        Ok(human) =\u003e {\n            write_region(ctx, destination_ptr, human.as_str().as_bytes())?;\n            Ok(0)\n        }\n        Err(FfiError::UserErr { msg, .. }) =\u003e Ok(write_to_contract::\u003cS, Q\u003e(ctx, msg.as_bytes())?),\n        Err(err) =\u003e Err(VmError::from(err)),\n    }\n}\n\n/// Creates a Region in the contract, writes the given data to it and returns the memory location\nfn write_to_contract\u003cS: Storage, Q: Querier\u003e(ctx: \u0026mut Ctx, input: \u0026[u8]) -\u003e VmResult\u003cu32\u003e {\n    let target_ptr = with_func_from_context::\u003cS, Q, u32, u32, _, _\u003e(ctx, \"allocate\", |allocate| {\n        let out_size = to_u32(input.len())?;\n        let ptr = allocate.call(out_size)?;\n        if ptr == 0 {\n            return Err(CommunicationError::zero_address().into());\n        }\n        Ok(ptr)\n    })?;\n    write_region(ctx, target_ptr, input)?;\n    Ok(target_ptr)\n}\n\npub fn do_query_chain\u003cS: Storage, Q: Querier\u003e(ctx: \u0026mut Ctx, request_ptr: u32) -\u003e VmResult\u003cu32\u003e {\n    let request = read_region(ctx, request_ptr, MAX_LENGTH_QUERY_CHAIN_REQUEST)?;\n\n    let gas_remaining = get_gas_left(ctx);\n    let (result, gas_info) = with_querier_from_context::\u003cS, Q, _, _\u003e(ctx, |querier| {\n        Ok(querier.query_raw(\u0026request, gas_remaining))\n    })?;\n    process_gas_info::\u003cS, Q\u003e(ctx, gas_info)?;\n    let serialized = to_vec(\u0026result?)?;\n    write_to_contract::\u003cS, Q\u003e(ctx, \u0026serialized)\n}\n\n#[cfg(feature = \"iterator\")]\npub fn do_scan\u003cS: Storage + 'static, Q: Querier\u003e(\n    ctx: \u0026mut Ctx,\n    start_ptr: u32,\n    end_ptr: u32,\n    order: i32,\n) -\u003e VmResult\u003cu32\u003e {\n    let start = maybe_read_region(ctx, start_ptr, MAX_LENGTH_DB_KEY)?;\n    let end = maybe_read_region(ctx, end_ptr, MAX_LENGTH_DB_KEY)?;\n    let order: Order = order\n        .try_into()\n        .map_err(|_| CommunicationError::invalid_order(order))?;\n\n    let (result, gas_info) = with_storage_from_context::\u003cS, Q, _, _\u003e(ctx, |store| {\n        Ok(store.range(start.as_deref(), end.as_deref(), order))\n    })?;\n    process_gas_info::\u003cS, Q\u003e(ctx, gas_info)?;\n    let iterator = result?;\n    let iterator_id = add_iterator::\u003cS, Q\u003e(ctx, iterator);\n    Ok(iterator_id)\n}\n\n#[cfg(feature = \"iterator\")]\npub fn do_next\u003cS: Storage, Q: Querier\u003e(ctx: \u0026mut Ctx, iterator_id: u32) -\u003e VmResult\u003cu32\u003e {\n    let (result, gas_info) =\n        with_iterator_from_context::\u003cS, Q, _, _\u003e(ctx, iterator_id, |iter| Ok(iter.next()))?;\n    process_gas_info::\u003cS, Q\u003e(ctx, gas_info)?;\n\n    // Empty key will later be treated as _no more element_.\n    let (key, value) = result?.unwrap_or_else(|| (Vec::\u003cu8\u003e::new(), Vec::\u003cu8\u003e::new()));\n\n    // Build value || key || keylen\n    let keylen_bytes = to_u32(key.len())?.to_be_bytes();\n    let mut out_data = value;\n    out_data.reserve(key.len() + 4);\n    out_data.extend(key);\n    out_data.extend_from_slice(\u0026keylen_bytes);\n\n    write_to_contract::\u003cS, Q\u003e(ctx, \u0026out_data)\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::{\n        coins, from_binary, AllBalanceResponse, BankQuery, Empty, HumanAddr, QueryRequest,\n        SystemError, WasmQuery,\n    };\n    use std::ptr::NonNull;\n    use wasmer_runtime_core::{imports, typed_func::Func, Instance as WasmerInstance};\n\n    use crate::backends::compile;\n    use crate::context::{\n        move_into_context, set_storage_readonly, set_wasmer_instance, setup_context,\n    };\n    use crate::testing::{MockApi, MockQuerier, MockStorage};\n    use crate::traits::Storage;\n    use crate::FfiError;\n\n    static CONTRACT: \u0026[u8] = include_bytes!(\"../testdata/contract.wasm\");\n\n    // shorthands for function generics below\n    type MA = MockApi;\n    type MS = MockStorage;\n    type MQ = MockQuerier;\n\n    // prepared data\n    const KEY1: \u0026[u8] = b\"ant\";\n    const VALUE1: \u0026[u8] = b\"insect\";\n    const KEY2: \u0026[u8] = b\"tree\";\n    const VALUE2: \u0026[u8] = b\"plant\";\n\n    // this account has some coins\n    const INIT_ADDR: \u0026str = \"someone\";\n    const INIT_AMOUNT: u128 = 500;\n    const INIT_DENOM: \u0026str = \"TOKEN\";\n\n    const GAS_LIMIT: u64 = 5_000_000;\n\n    fn make_instance() -\u003e Box\u003cWasmerInstance\u003e {\n        let module = compile(\u0026CONTRACT).unwrap();\n        // we need stubs for all required imports\n        let import_obj = imports! {\n            || { setup_context::\u003cMockStorage, MockQuerier\u003e(GAS_LIMIT) },\n            \"env\" =\u003e {\n                \"db_read\" =\u003e Func::new(|_a: u32| -\u003e u32 { 0 }),\n                \"db_write\" =\u003e Func::new(|_a: u32, _b: u32| {}),\n                \"db_remove\" =\u003e Func::new(|_a: u32| {}),\n                \"db_scan\" =\u003e Func::new(|_a: u32, _b: u32, _c: i32| -\u003e u32 { 0 }),\n                \"db_next\" =\u003e Func::new(|_a: u32| -\u003e u32 { 0 }),\n                \"query_chain\" =\u003e Func::new(|_a: u32| -\u003e u32 { 0 }),\n                \"canonicalize_address\" =\u003e Func::new(|_a: i32, _b: i32| -\u003e u32 { 0 }),\n                \"humanize_address\" =\u003e Func::new(|_a: i32, _b: i32| -\u003e u32 { 0 }),\n            },\n        };\n        let mut instance = Box::from(module.instantiate(\u0026import_obj).unwrap());\n\n        let instance_ptr = NonNull::from(instance.as_ref());\n        set_wasmer_instance::\u003cMS, MQ\u003e(instance.context_mut(), Some(instance_ptr));\n        set_storage_readonly::\u003cMS, MQ\u003e(instance.context_mut(), false);\n\n        instance\n    }\n\n    fn leave_default_data(ctx: \u0026mut Ctx) {\n        // create some mock data\n        let mut storage = MockStorage::new();\n        storage.set(KEY1, VALUE1).0.expect(\"error setting\");\n        storage.set(KEY2, VALUE2).0.expect(\"error setting\");\n        let querier: MockQuerier\u003cEmpty\u003e =\n            MockQuerier::new(\u0026[(\u0026HumanAddr::from(INIT_ADDR), \u0026coins(INIT_AMOUNT, INIT_DENOM))]);\n        move_into_context(ctx, storage, querier);\n    }\n\n    fn write_data(wasmer_instance: \u0026mut WasmerInstance, data: \u0026[u8]) -\u003e u32 {\n        let allocate: Func\u003cu32, u32\u003e = wasmer_instance\n            .exports\n            .get(\"allocate\")\n            .expect(\"error getting function\");\n        let region_ptr = allocate\n            .call(data.len() as u32)\n            .expect(\"error calling allocate\");\n        write_region(wasmer_instance.context_mut(), region_ptr, data).expect(\"error writing\");\n        region_ptr\n    }\n\n    fn create_empty(wasmer_instance: \u0026mut WasmerInstance, capacity: u32) -\u003e u32 {\n        let allocate: Func\u003cu32, u32\u003e = wasmer_instance\n            .exports\n            .get(\"allocate\")\n            .expect(\"error getting function\");\n        let region_ptr = allocate.call(capacity).expect(\"error calling allocate\");\n        region_ptr\n    }\n\n    /// A Region reader that is just good enough for the tests in this file\n    fn force_read(ctx: \u0026mut Ctx, region_ptr: u32) -\u003e Vec\u003cu8\u003e {\n        read_region(ctx, region_ptr, 5000).unwrap()\n    }\n\n    #[test]\n    fn do_read_works() {\n        let mut instance = make_instance();\n        leave_default_data(instance.context_mut());\n\n        let key_ptr = write_data(\u0026mut instance, KEY1);\n        let ctx = instance.context_mut();\n        let result = do_read::\u003cMS, MQ\u003e(ctx, key_ptr);\n        let value_ptr = result.unwrap();\n        assert!(value_ptr \u003e 0);\n        assert_eq!(force_read(ctx, value_ptr as u32), VALUE1);\n    }\n\n    #[test]\n    fn do_read_works_for_non_existent_key() {\n        let mut instance = make_instance();\n        leave_default_data(instance.context_mut());\n\n        let key_ptr = write_data(\u0026mut instance, b\"I do not exist in storage\");\n        let ctx = instance.context_mut();\n        let result = do_read::\u003cMS, MQ\u003e(ctx, key_ptr);\n        assert_eq!(result.unwrap(), 0);\n    }\n\n    #[test]\n    fn do_read_fails_for_large_key() {\n        let mut instance = make_instance();\n        leave_default_data(instance.context_mut());\n\n        let key_ptr = write_data(\u0026mut instance, \u0026vec![7u8; 300 * 1024]);\n        let ctx = instance.context_mut();\n        let result = do_read::\u003cMS, MQ\u003e(ctx, key_ptr);\n        match result.unwrap_err() {\n            VmError::CommunicationErr {\n                source: CommunicationError::RegionLengthTooBig { length, .. },\n            } =\u003e assert_eq!(length, 300 * 1024),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn do_write_works() {\n        let mut instance = make_instance();\n\n        let key_ptr = write_data(\u0026mut instance, b\"new storage key\");\n        let value_ptr = write_data(\u0026mut instance, b\"new value\");\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        do_write::\u003cMS, MQ\u003e(ctx, key_ptr, value_ptr).unwrap();\n\n        let val = with_storage_from_context::\u003cMS, MQ, _, _\u003e(ctx, |store| {\n            Ok(store\n                .get(b\"new storage key\")\n                .0\n                .expect(\"error getting value\"))\n        })\n        .unwrap();\n        assert_eq!(val, Some(b\"new value\".to_vec()));\n    }\n\n    #[test]\n    fn do_write_can_override() {\n        let mut instance = make_instance();\n\n        let key_ptr = write_data(\u0026mut instance, KEY1);\n        let value_ptr = write_data(\u0026mut instance, VALUE2);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        do_write::\u003cMS, MQ\u003e(ctx, key_ptr, value_ptr).unwrap();\n\n        let val = with_storage_from_context::\u003cMS, MQ, _, _\u003e(ctx, |store| {\n            Ok(store.get(KEY1).0.expect(\"error getting value\"))\n        })\n        .unwrap();\n        assert_eq!(val, Some(VALUE2.to_vec()));\n    }\n\n    #[test]\n    fn do_write_works_for_empty_value() {\n        let mut instance = make_instance();\n\n        let key_ptr = write_data(\u0026mut instance, b\"new storage key\");\n        let value_ptr = write_data(\u0026mut instance, b\"\");\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        do_write::\u003cMS, MQ\u003e(ctx, key_ptr, value_ptr).unwrap();\n\n        let val = with_storage_from_context::\u003cMS, MQ, _, _\u003e(ctx, |store| {\n            Ok(store\n                .get(b\"new storage key\")\n                .0\n                .expect(\"error getting value\"))\n        })\n        .unwrap();\n        assert_eq!(val, Some(b\"\".to_vec()));\n    }\n\n    #[test]\n    fn do_write_fails_for_large_key() {\n        let mut instance = make_instance();\n\n        let key_ptr = write_data(\u0026mut instance, \u0026vec![4u8; 300 * 1024]);\n        let value_ptr = write_data(\u0026mut instance, b\"new value\");\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let result = do_write::\u003cMS, MQ\u003e(ctx, key_ptr, value_ptr);\n        match result.unwrap_err() {\n            VmError::CommunicationErr {\n                source:\n                    CommunicationError::RegionLengthTooBig {\n                        length, max_length, ..\n                    },\n            } =\u003e {\n                assert_eq!(length, 300 * 1024);\n                assert_eq!(max_length, MAX_LENGTH_DB_KEY);\n            }\n            err =\u003e panic!(\"unexpected error: {:?}\", err),\n        };\n    }\n\n    #[test]\n    fn do_write_fails_for_large_value() {\n        let mut instance = make_instance();\n\n        let key_ptr = write_data(\u0026mut instance, b\"new storage key\");\n        let value_ptr = write_data(\u0026mut instance, \u0026vec![5u8; 300 * 1024]);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let result = do_write::\u003cMS, MQ\u003e(ctx, key_ptr, value_ptr);\n        match result.unwrap_err() {\n            VmError::CommunicationErr {\n                source:\n                    CommunicationError::RegionLengthTooBig {\n                        length, max_length, ..\n                    },\n            } =\u003e {\n                assert_eq!(length, 300 * 1024);\n                assert_eq!(max_length, MAX_LENGTH_DB_VALUE);\n            }\n            err =\u003e panic!(\"unexpected error: {:?}\", err),\n        };\n    }\n\n    #[test]\n    fn do_write_is_prohibited_in_readonly_contexts() {\n        let mut instance = make_instance();\n\n        let key_ptr = write_data(\u0026mut instance, b\"new storage key\");\n        let value_ptr = write_data(\u0026mut instance, b\"new value\");\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n        set_storage_readonly::\u003cMS, MQ\u003e(ctx, true);\n\n        let result = do_write::\u003cMS, MQ\u003e(ctx, key_ptr, value_ptr);\n        match result.unwrap_err() {\n            VmError::WriteAccessDenied { .. } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn do_remove_works() {\n        let mut instance = make_instance();\n\n        let existing_key = KEY1;\n        let key_ptr = write_data(\u0026mut instance, existing_key);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        do_remove::\u003cMS, MQ\u003e(ctx, key_ptr).unwrap();\n\n        let value = with_storage_from_context::\u003cMS, MQ, _, _\u003e(ctx, |store| {\n            Ok(store.get(existing_key).0.expect(\"error getting value\"))\n        })\n        .unwrap();\n        assert_eq!(value, None);\n    }\n\n    #[test]\n    fn do_remove_works_for_non_existent_key() {\n        let mut instance = make_instance();\n\n        let non_existent_key = b\"I do not exist\";\n        let key_ptr = write_data(\u0026mut instance, non_existent_key);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        // Note: right now we cannot differnetiate between an existent and a non-existent key\n        do_remove::\u003cMS, MQ\u003e(ctx, key_ptr).unwrap();\n\n        let value = with_storage_from_context::\u003cMS, MQ, _, _\u003e(ctx, |store| {\n            Ok(store.get(non_existent_key).0.expect(\"error getting value\"))\n        })\n        .unwrap();\n        assert_eq!(value, None);\n    }\n\n    #[test]\n    fn do_remove_fails_for_large_key() {\n        let mut instance = make_instance();\n\n        let key_ptr = write_data(\u0026mut instance, \u0026vec![26u8; 300 * 1024]);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let result = do_remove::\u003cMS, MQ\u003e(ctx, key_ptr);\n        match result.unwrap_err() {\n            VmError::CommunicationErr {\n                source:\n                    CommunicationError::RegionLengthTooBig {\n                        length, max_length, ..\n                    },\n            } =\u003e {\n                assert_eq!(length, 300 * 1024);\n                assert_eq!(max_length, MAX_LENGTH_DB_KEY);\n            }\n            err =\u003e panic!(\"unexpected error: {:?}\", err),\n        };\n    }\n\n    #[test]\n    fn do_remove_is_prohibited_in_readonly_contexts() {\n        let mut instance = make_instance();\n\n        let key_ptr = write_data(\u0026mut instance, b\"a storage key\");\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n        set_storage_readonly::\u003cMS, MQ\u003e(ctx, true);\n\n        let result = do_remove::\u003cMS, MQ\u003e(ctx, key_ptr);\n        match result.unwrap_err() {\n            VmError::WriteAccessDenied { .. } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn do_canonicalize_address_works() {\n        let mut instance = make_instance();\n\n        let source_ptr = write_data(\u0026mut instance, b\"foo\");\n        let dest_ptr = create_empty(\u0026mut instance, 8);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let api = MockApi::new(8);\n        do_canonicalize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr, dest_ptr).unwrap();\n        assert_eq!(force_read(ctx, dest_ptr), b\"foo\\0\\0\\0\\0\\0\");\n    }\n\n    #[test]\n    fn do_canonicalize_address_reports_invalid_input_back_to_contract() {\n        let mut instance = make_instance();\n\n        let source_ptr1 = write_data(\u0026mut instance, b\"fo\\x80o\"); // invalid UTF-8 (fo�o)\n        let source_ptr2 = write_data(\u0026mut instance, b\"\"); // empty\n        let source_ptr3 = write_data(\u0026mut instance, b\"addressexceedingaddressspace\"); // too long\n        let dest_ptr = create_empty(\u0026mut instance, 8);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n        let api = MockApi::new(8);\n\n        let res = do_canonicalize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr1, dest_ptr).unwrap();\n        assert_ne!(res, 0);\n        let err = String::from_utf8(force_read(ctx, res)).unwrap();\n        assert_eq!(err, \"Input is not valid UTF-8\");\n\n        let res = do_canonicalize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr2, dest_ptr).unwrap();\n        assert_ne!(res, 0);\n        let err = String::from_utf8(force_read(ctx, res)).unwrap();\n        assert_eq!(err, \"Input is empty\");\n\n        let res = do_canonicalize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr3, dest_ptr).unwrap();\n        assert_ne!(res, 0);\n        let err = String::from_utf8(force_read(ctx, res)).unwrap();\n        assert_eq!(err, \"Invalid input: human address too long\");\n    }\n\n    #[test]\n    fn do_canonicalize_address_fails_for_broken_backend() {\n        let mut instance = make_instance();\n\n        let source_ptr = write_data(\u0026mut instance, b\"foo\");\n        let dest_ptr = create_empty(\u0026mut instance, 7);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let api = MockApi::new_failing(8, \"Temporarily unavailable\");\n        let result = do_canonicalize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr, dest_ptr);\n        match result.unwrap_err() {\n            VmError::FfiErr {\n                source: FfiError::Unknown { msg, .. },\n            } =\u003e {\n                assert_eq!(msg.unwrap(), \"Temporarily unavailable\");\n            }\n            err =\u003e panic!(\"Incorrect error returned: {:?}\", err),\n        }\n    }\n\n    #[test]\n    fn do_canonicalize_address_fails_for_large_inputs() {\n        let mut instance = make_instance();\n\n        let source_ptr = write_data(\u0026mut instance, \u0026vec![61; 100]);\n        let dest_ptr = create_empty(\u0026mut instance, 8);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let api = MockApi::new(8);\n        let result = do_canonicalize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr, dest_ptr);\n        match result.unwrap_err() {\n            VmError::CommunicationErr {\n                source:\n                    CommunicationError::RegionLengthTooBig {\n                        length, max_length, ..\n                    },\n            } =\u003e {\n                assert_eq!(length, 100);\n                assert_eq!(max_length, 90);\n            }\n            err =\u003e panic!(\"Incorrect error returned: {:?}\", err),\n        }\n    }\n\n    #[test]\n    fn do_canonicalize_address_fails_for_small_destination_region() {\n        let mut instance = make_instance();\n\n        let source_ptr = write_data(\u0026mut instance, b\"foo\");\n        let dest_ptr = create_empty(\u0026mut instance, 7);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let api = MockApi::new(8);\n        let result = do_canonicalize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr, dest_ptr);\n        match result.unwrap_err() {\n            VmError::CommunicationErr {\n                source: CommunicationError::RegionTooSmall { size, required, .. },\n            } =\u003e {\n                assert_eq!(size, 7);\n                assert_eq!(required, 8);\n            }\n            err =\u003e panic!(\"Incorrect error returned: {:?}\", err),\n        }\n    }\n\n    #[test]\n    fn do_humanize_address_works() {\n        let mut instance = make_instance();\n\n        let source_ptr = write_data(\u0026mut instance, b\"foo\\0\\0\\0\\0\\0\");\n        let dest_ptr = create_empty(\u0026mut instance, 50);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let api = MockApi::new(8);\n        let error_ptr = do_humanize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr, dest_ptr).unwrap();\n        assert_eq!(error_ptr, 0);\n        assert_eq!(force_read(ctx, dest_ptr), b\"foo\");\n    }\n\n    #[test]\n    fn do_humanize_address_reports_invalid_input_back_to_contract() {\n        let mut instance = make_instance();\n\n        let source_ptr = write_data(\u0026mut instance, b\"foo\"); // too short\n        let dest_ptr = create_empty(\u0026mut instance, 50);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let api = MockApi::new(8);\n        let res = do_humanize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr, dest_ptr).unwrap();\n        assert_ne!(res, 0);\n        let err = String::from_utf8(force_read(ctx, res)).unwrap();\n        assert_eq!(err, \"Invalid input: canonical address length not correct\");\n    }\n\n    #[test]\n    fn do_humanize_address_fails_for_broken_backend() {\n        let mut instance = make_instance();\n\n        let source_ptr = write_data(\u0026mut instance, b\"foo\\0\\0\\0\\0\\0\");\n        let dest_ptr = create_empty(\u0026mut instance, 50);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let api = MockApi::new_failing(8, \"Temporarily unavailable\");\n        let result = do_humanize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr, dest_ptr);\n        match result.unwrap_err() {\n            VmError::FfiErr {\n                source: FfiError::Unknown { msg, .. },\n            } =\u003e assert_eq!(msg.unwrap(), \"Temporarily unavailable\"),\n            err =\u003e panic!(\"Incorrect error returned: {:?}\", err),\n        };\n    }\n\n    #[test]\n    fn do_humanize_address_fails_for_input_too_long() {\n        let mut instance = make_instance();\n\n        let source_ptr = write_data(\u0026mut instance, \u0026vec![61; 33]);\n        let dest_ptr = create_empty(\u0026mut instance, 50);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let api = MockApi::new(8);\n        let result = do_humanize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr, dest_ptr);\n        match result.unwrap_err() {\n            VmError::CommunicationErr {\n                source:\n                    CommunicationError::RegionLengthTooBig {\n                        length, max_length, ..\n                    },\n            } =\u003e {\n                assert_eq!(length, 33);\n                assert_eq!(max_length, 32);\n            }\n            err =\u003e panic!(\"Incorrect error returned: {:?}\", err),\n        }\n    }\n\n    #[test]\n    fn do_humanize_address_fails_for_destination_region_too_small() {\n        let mut instance = make_instance();\n\n        let source_ptr = write_data(\u0026mut instance, b\"foo\\0\\0\\0\\0\\0\");\n        let dest_ptr = create_empty(\u0026mut instance, 2);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let api = MockApi::new(8);\n        let result = do_humanize_address::\u003cMA, MS, MQ\u003e(api, ctx, source_ptr, dest_ptr);\n        match result.unwrap_err() {\n            VmError::CommunicationErr {\n                source: CommunicationError::RegionTooSmall { size, required, .. },\n            } =\u003e {\n                assert_eq!(size, 2);\n                assert_eq!(required, 3);\n            }\n            err =\u003e panic!(\"Incorrect error returned: {:?}\", err),\n        }\n    }\n\n    #[test]\n    fn do_query_chain_works() {\n        let mut instance = make_instance();\n\n        let request: QueryRequest\u003cEmpty\u003e = QueryRequest::Bank(BankQuery::AllBalances {\n            address: HumanAddr::from(INIT_ADDR),\n        });\n        let request_data = cosmwasm_std::to_vec(\u0026request).unwrap();\n        let request_ptr = write_data(\u0026mut instance, \u0026request_data);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let response_ptr = do_query_chain::\u003cMS, MQ\u003e(ctx, request_ptr).unwrap();\n        let response = force_read(ctx, response_ptr);\n\n        let query_result: cosmwasm_std::QuerierResult =\n            cosmwasm_std::from_slice(\u0026response).unwrap();\n        let query_result_inner = query_result.unwrap();\n        let query_result_inner_inner = query_result_inner.unwrap();\n        let parsed_again: AllBalanceResponse = from_binary(\u0026query_result_inner_inner).unwrap();\n        assert_eq!(parsed_again.amount, coins(INIT_AMOUNT, INIT_DENOM));\n    }\n\n    #[test]\n    fn do_query_chain_fails_for_broken_request() {\n        let mut instance = make_instance();\n\n        let request = b\"Not valid JSON for sure\";\n        let request_ptr = write_data(\u0026mut instance, request);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let response_ptr = do_query_chain::\u003cMS, MQ\u003e(ctx, request_ptr).unwrap();\n        let response = force_read(ctx, response_ptr);\n\n        let query_result: cosmwasm_std::QuerierResult =\n            cosmwasm_std::from_slice(\u0026response).unwrap();\n        match query_result {\n            Ok(_) =\u003e panic!(\"This must not succeed\"),\n            Err(SystemError::InvalidRequest { request: err, .. }) =\u003e {\n                assert_eq!(err.as_slice(), request)\n            }\n            Err(error) =\u003e panic!(\"Unexpeted error: {:?}\", error),\n        }\n    }\n\n    #[test]\n    fn do_query_chain_fails_for_missing_contract() {\n        let mut instance = make_instance();\n\n        let request: QueryRequest\u003cEmpty\u003e = QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: HumanAddr::from(\"non-existent\"),\n            msg: Binary::from(b\"{}\" as \u0026[u8]),\n        });\n        let request_data = cosmwasm_std::to_vec(\u0026request).unwrap();\n        let request_ptr = write_data(\u0026mut instance, \u0026request_data);\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let response_ptr = do_query_chain::\u003cMS, MQ\u003e(ctx, request_ptr).unwrap();\n        let response = force_read(ctx, response_ptr);\n\n        let query_result: cosmwasm_std::QuerierResult =\n            cosmwasm_std::from_slice(\u0026response).unwrap();\n        match query_result {\n            Ok(_) =\u003e panic!(\"This must not succeed\"),\n            Err(SystemError::NoSuchContract { addr }) =\u003e {\n                assert_eq!(addr, HumanAddr::from(\"non-existent\"))\n            }\n            Err(error) =\u003e panic!(\"Unexpeted error: {:?}\", error),\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn do_scan_unbound_works() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        // set up iterator over all space\n        let id = do_scan::\u003cMS, MQ\u003e(ctx, 0, 0, Order::Ascending.into()).unwrap();\n        assert_eq!(1, id);\n\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id, |iter| Ok(iter.next())).unwrap();\n        assert_eq!(item.0.unwrap().unwrap(), (KEY1.to_vec(), VALUE1.to_vec()));\n\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id, |iter| Ok(iter.next())).unwrap();\n        assert_eq!(item.0.unwrap().unwrap(), (KEY2.to_vec(), VALUE2.to_vec()));\n\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id, |iter| Ok(iter.next())).unwrap();\n        assert!(item.0.unwrap().is_none());\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn do_scan_unbound_descending_works() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        // set up iterator over all space\n        let id = do_scan::\u003cMS, MQ\u003e(ctx, 0, 0, Order::Descending.into()).unwrap();\n        assert_eq!(1, id);\n\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id, |iter| Ok(iter.next())).unwrap();\n        assert_eq!(item.0.unwrap().unwrap(), (KEY2.to_vec(), VALUE2.to_vec()));\n\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id, |iter| Ok(iter.next())).unwrap();\n        assert_eq!(item.0.unwrap().unwrap(), (KEY1.to_vec(), VALUE1.to_vec()));\n\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id, |iter| Ok(iter.next())).unwrap();\n        assert!(item.0.unwrap().is_none());\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn do_scan_bound_works() {\n        let mut instance = make_instance();\n\n        let start = write_data(\u0026mut instance, b\"anna\");\n        let end = write_data(\u0026mut instance, b\"bert\");\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let id = do_scan::\u003cMS, MQ\u003e(ctx, start, end, Order::Ascending.into()).unwrap();\n\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id, |iter| Ok(iter.next())).unwrap();\n        assert_eq!(item.0.unwrap().unwrap(), (KEY1.to_vec(), VALUE1.to_vec()));\n\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id, |iter| Ok(iter.next())).unwrap();\n        assert!(item.0.unwrap().is_none());\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn do_scan_multiple_iterators() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        // unbounded, ascending and descending\n        let id1 = do_scan::\u003cMS, MQ\u003e(ctx, 0, 0, Order::Ascending.into()).unwrap();\n        let id2 = do_scan::\u003cMS, MQ\u003e(ctx, 0, 0, Order::Descending.into()).unwrap();\n        assert_eq!(id1, 1);\n        assert_eq!(id2, 2);\n\n        // first item, first iterator\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id1, |iter| Ok(iter.next())).unwrap();\n        assert_eq!(item.0.unwrap().unwrap(), (KEY1.to_vec(), VALUE1.to_vec()));\n\n        // second item, first iterator\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id1, |iter| Ok(iter.next())).unwrap();\n        assert_eq!(item.0.unwrap().unwrap(), (KEY2.to_vec(), VALUE2.to_vec()));\n\n        // first item, second iterator\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id2, |iter| Ok(iter.next())).unwrap();\n        assert_eq!(item.0.unwrap().unwrap(), (KEY2.to_vec(), VALUE2.to_vec()));\n\n        // end, first iterator\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id1, |iter| Ok(iter.next())).unwrap();\n        assert!(item.0.unwrap().is_none());\n\n        // second item, second iterator\n        let item =\n            with_iterator_from_context::\u003cMS, MQ, _, _\u003e(ctx, id2, |iter| Ok(iter.next())).unwrap();\n        assert_eq!(item.0.unwrap().unwrap(), (KEY1.to_vec(), VALUE1.to_vec()));\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn do_scan_errors_for_invalid_order_value() {\n        let mut instance = make_instance();\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        // set up iterator over all space\n        let result = do_scan::\u003cMS, MQ\u003e(ctx, 0, 0, 42);\n        match result.unwrap_err() {\n            VmError::CommunicationErr {\n                source: CommunicationError::InvalidOrder { .. },\n            } =\u003e {}\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn do_next_works() {\n        let mut instance = make_instance();\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let id = do_scan::\u003cMS, MQ\u003e(ctx, 0, 0, Order::Ascending.into()).unwrap();\n\n        // Entry 1\n        let kv_region_ptr = do_next::\u003cMS, MQ\u003e(ctx, id).unwrap();\n        assert_eq!(\n            force_read(ctx, kv_region_ptr),\n            [VALUE1, KEY1, b\"\\0\\0\\0\\x03\"].concat()\n        );\n\n        // Entry 2\n        let kv_region_ptr = do_next::\u003cMS, MQ\u003e(ctx, id).unwrap();\n        assert_eq!(\n            force_read(ctx, kv_region_ptr),\n            [VALUE2, KEY2, b\"\\0\\0\\0\\x04\"].concat()\n        );\n\n        // End\n        let kv_region_ptr = do_next::\u003cMS, MQ\u003e(ctx, id).unwrap();\n        assert_eq!(force_read(ctx, kv_region_ptr), b\"\\0\\0\\0\\0\");\n        // API makes no guarantees for value_ptr in this case\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn do_next_fails_for_non_existent_id() {\n        let mut instance = make_instance();\n\n        let ctx = instance.context_mut();\n        leave_default_data(ctx);\n\n        let non_existent_id = 42u32;\n        let result = do_next::\u003cMS, MQ\u003e(ctx, non_existent_id);\n        match result.unwrap_err() {\n            VmError::IteratorDoesNotExist { id, .. } =\u003e assert_eq!(id, non_existent_id),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","instance.rs"],"content":"/*\nuse std::collections::HashSet;\n*/\nuse std::marker::PhantomData;\n/*\nuse std::ptr::NonNull;\n*/\n\n/*\npub use wasmer_runtime_core::typed_func::Func;\nuse wasmer_runtime_core::{\n    imports,\n    module::Module,\n    typed_func::{Wasm, WasmTypeList},\n    vm::Ctx,\n    Instance as WasmerInstance,\n};\n*/\n\nuse crate::backends::get_gas_used;\nuse crate::context::{\n    move_into_context, move_out_of_context, set_storage_readonly, setup_context,\n    with_querier_from_context, with_storage_from_context,\n};\n/*\nuse crate::conversion::to_u32;\n*/\nuse crate::errors::{EnclaveError, VmResult};\n/*\nuse crate::features::required_features_from_wasmer_instance;\nuse crate::imports::{\n    do_canonicalize_address, do_humanize_address, do_query_chain, do_read, do_remove, do_write,\n};\n#[cfg(feature = \"iterator\")]\nuse crate::imports::{do_next, do_scan};\nuse crate::memory::{get_memory_info, read_region, write_region};\n*/\nuse crate::traits::{Api, Extern, Querier, Storage};\n\nuse crate::enclave::get_enclave;\nuse crate::wasmi::Module;\n\n/*\nconst WASM_PAGE_SIZE: u64 = 64 * 1024;\n*/\n\n#[derive(Copy, Clone, Debug)]\npub struct GasReport {\n    /// The original limit the instance was created with\n    pub limit: u64,\n    /// The remaining gas that can be spend\n    pub remaining: u64,\n    /// The amount of gas that was spend and metered externally in operations triggered by this instance\n    pub used_externally: u64,\n    /// The amount of gas that was spend and metered internally (i.e. by executing Wasm and calling\n    /// API methods which are not metered externally)\n    pub used_internally: u64,\n}\n\npub struct Instance\u003cS: Storage + 'static, A: Api + 'static, Q: Querier + 'static\u003e {\n    /*\n    /// We put this instance in a box to maintain a constant memory address for the entire\n    /// lifetime of the instance in the cache. This is needed e.g. when linking the wasmer\n    /// instance to a context. See also https://github.com/CosmWasm/cosmwasm/pull/245\n    inner: Box\u003cWasmerInstance\u003e,\n    */\n    inner: Module\u003cS, Q\u003e,\n    pub api: A,\n    /*\n    pub required_features: HashSet\u003cString\u003e,\n    */\n    // This does not store data but only fixes type information\n    type_storage: PhantomData\u003cS\u003e,\n    type_querier: PhantomData\u003cQ\u003e,\n}\n\nimpl\u003cS, A, Q\u003e Instance\u003cS, A, Q\u003e\nwhere\n    S: Storage + 'static,\n    A: Api + 'static,\n    Q: Querier + 'static,\n{\n    /// This is the only Instance constructor that can be called from outside of cosmwasm-vm,\n    /// e.g. in test code that needs a customized variant of cosmwasm_vm::testing::mock_instance*.\n    pub fn from_code(code: \u0026[u8], deps: Extern\u003cS, A, Q\u003e, gas_limit: u64) -\u003e VmResult\u003cSelf\u003e {\n        /*\n        let module = compile(code)?;\n        Instance::from_module(\u0026module, deps, gas_limit)\n        */\n        let enclave = get_enclave().map_err(EnclaveError::sdk_err)?;\n        let module = Module::\u003cS, Q\u003e::new(\n            code.to_vec(),\n            gas_limit,\n            enclave,\n            setup_context::\u003cS, Q\u003e(gas_limit),\n        );\n        Ok(Instance::from_wasmer(module, deps, gas_limit))\n    }\n\n    #[cfg(not(feature = \"default-enclave\"))]\n    pub(crate) fn from_module(\n        module: \u0026Module,\n        deps: Extern\u003cS, A, Q\u003e,\n        gas_limit: u64,\n    ) -\u003e VmResult\u003cSelf\u003e {\n        let mut import_obj =\n            imports! { move || { setup_context::\u003cS, Q\u003e(gas_limit) }, \"env\" =\u003e {}, };\n\n        // copy this so it can be moved into the closures, without pulling in deps\n        let api = deps.api;\n        import_obj.extend(imports! {\n            \"env\" =\u003e {\n                // Reads the database entry at the given key into the the value.\n                // Returns 0 if key does not exist and pointer to result region otherwise.\n                // Ownership of the key pointer is not transferred to the host.\n                // Ownership of the value pointer is transferred to the contract.\n                \"db_read\" =\u003e Func::new(move |ctx: \u0026mut Ctx, key_ptr: u32| -\u003e VmResult\u003cu32\u003e {\n                    do_read::\u003cS, Q\u003e(ctx, key_ptr)\n                }),\n                // Writes the given value into the database entry at the given key.\n                // Ownership of both input and output pointer is not transferred to the host.\n                \"db_write\" =\u003e Func::new(move |ctx: \u0026mut Ctx, key_ptr: u32, value_ptr: u32| -\u003e VmResult\u003c()\u003e {\n                    do_write::\u003cS, Q\u003e(ctx, key_ptr, value_ptr)\n                }),\n                // Removes the value at the given key. Different than writing \u0026[] as future\n                // scans will not find this key.\n                // At the moment it is not possible to differentiate between a key that existed before and one that did not exist (https://github.com/CosmWasm/cosmwasm/issues/290).\n                // Ownership of both key pointer is not transferred to the host.\n                \"db_remove\" =\u003e Func::new(move |ctx: \u0026mut Ctx, key_ptr: u32| -\u003e VmResult\u003c()\u003e {\n                    do_remove::\u003cS, Q\u003e(ctx, key_ptr)\n                }),\n                // Reads human address from source_ptr and writes canonicalized representation to destination_ptr.\n                // A prepared and sufficiently large memory Region is expected at destination_ptr that points to pre-allocated memory.\n                // Returns 0 on success. Returns a non-zero memory location to a Region containing an UTF-8 encoded error string for invalid inputs.\n                // Ownership of both input and output pointer is not transferred to the host.\n                \"canonicalize_address\" =\u003e Func::new(move |ctx: \u0026mut Ctx, source_ptr: u32, destination_ptr: u32| -\u003e VmResult\u003cu32\u003e {\n                    do_canonicalize_address::\u003cA, S, Q\u003e(api, ctx, source_ptr, destination_ptr)\n                }),\n                // Reads canonical address from source_ptr and writes humanized representation to destination_ptr.\n                // A prepared and sufficiently large memory Region is expected at destination_ptr that points to pre-allocated memory.\n                // Returns 0 on success. Returns a non-zero memory location to a Region containing an UTF-8 encoded error string for invalid inputs.\n                // Ownership of both input and output pointer is not transferred to the host.\n                \"humanize_address\" =\u003e Func::new(move |ctx: \u0026mut Ctx, source_ptr: u32, destination_ptr: u32| -\u003e VmResult\u003cu32\u003e {\n                    do_humanize_address::\u003cA, S, Q\u003e(api, ctx, source_ptr, destination_ptr)\n                }),\n                \"query_chain\" =\u003e Func::new(move |ctx: \u0026mut Ctx, request_ptr: u32| -\u003e VmResult\u003cu32\u003e {\n                    do_query_chain::\u003cS, Q\u003e(ctx, request_ptr)\n                }),\n            },\n        });\n\n        #[cfg(feature = \"iterator\")]\n        import_obj.extend(imports! {\n            \"env\" =\u003e {\n                // Creates an iterator that will go from start to end.\n                // If start_ptr == 0, the start is unbounded.\n                // If end_ptr == 0, the end is unbounded.\n                // Order is defined in cosmwasm_std::Order and may be 1 (ascending) or 2 (descending). All other values result in an error.\n                // Ownership of both start and end pointer is not transferred to the host.\n                // Returns an iterator ID.\n                \"db_scan\" =\u003e Func::new(move |ctx: \u0026mut Ctx, start_ptr: u32, end_ptr: u32, order: i32| -\u003e VmResult\u003cu32\u003e {\n                    do_scan::\u003cS, Q\u003e(ctx, start_ptr, end_ptr, order)\n                }),\n                // Get next element of iterator with ID `iterator_id`.\n                // Creates a region containing both key and value and returns its address.\n                // Ownership of the result region is transferred to the contract.\n                // The KV region uses the format value || key || keylen, where keylen is a fixed size big endian u32 value.\n                // An empty key (i.e. KV region ends with \\0\\0\\0\\0) means no more element, no matter what the value is.\n                \"db_next\" =\u003e Func::new(move |ctx: \u0026mut Ctx, iterator_id: u32| -\u003e VmResult\u003cu32\u003e {\n                    do_next::\u003cS, Q\u003e(ctx, iterator_id)\n                }),\n            },\n        });\n\n        let wasmer_instance = Box::from(module.instantiate(\u0026import_obj).map_err(|original| {\n            VmError::instantiation_err(format!(\"Error instantiating module: {:?}\", original))\n        })?);\n        Ok(Instance::from_wasmer(wasmer_instance, deps, gas_limit))\n    }\n\n    pub(crate) fn from_wasmer(\n        /*\n        mut wasmer_instance: Box\u003cWasmerInstance\u003e,\n        */\n        mut module: Module\u003cS, Q\u003e,\n        deps: Extern\u003cS, A, Q\u003e,\n        _gas_limit: u64,\n    ) -\u003e Self {\n        /*\n        set_gas_left(wasmer_instance.context_mut(), gas_limit);\n        get_gas_state_mut::\u003cS, Q\u003e(wasmer_instance.context_mut()).set_gas_limit(gas_limit);\n        let required_features = required_features_from_wasmer_instance(wasmer_instance.as_ref());\n        let instance_ptr = NonNull::from(wasmer_instance.as_ref());\n        set_wasmer_instance::\u003cS, Q\u003e(wasmer_instance.context_mut(), Some(instance_ptr));\n        */\n        move_into_context(module.context_mut(), deps.storage, deps.querier);\n        Instance {\n            inner: module,\n            api: deps.api,\n            /*\n            required_features,\n            */\n            type_storage: PhantomData::\u003cS\u003e {},\n            type_querier: PhantomData::\u003cQ\u003e {},\n        }\n    }\n\n    /// Decomposes this instance into its components.\n    /// External dependencies are returned for reuse, the rest is dropped.\n    pub fn recycle(mut self) -\u003e Option\u003cExtern\u003cS, A, Q\u003e\u003e {\n        if let (Some(storage), Some(querier)) = move_out_of_context(self.inner.context_mut()) {\n            Some(Extern {\n                storage,\n                api: self.api,\n                querier,\n            })\n        } else {\n            None\n        }\n    }\n\n    /// Returns the size of the default memory in bytes.\n    /// This provides a rough idea of the peak memory consumption. Note that\n    /// Wasm memory always grows in 64 KiB steps (pages) and can never shrink\n    /// (https://github.com/WebAssembly/design/issues/1300#issuecomment-573867836).\n    #[cfg(not(feature = \"default-enclave\"))]\n    pub fn get_memory_size(\u0026self) -\u003e u64 {\n        (get_memory_info(self.inner.context()).size as u64) * WASM_PAGE_SIZE\n    }\n\n    /// Returns the currently remaining gas.\n    pub fn get_gas_left(\u0026self) -\u003e u64 {\n        self.create_gas_report().remaining\n    }\n\n    /// Creates and returns a gas report.\n    /// This is a snapshot and multiple reports can be created during the lifetime of\n    /// an instance.\n    #[cfg(not(feature = \"default-enclave\"))]\n    pub fn create_gas_report(\u0026self) -\u003e GasReport {\n        let state = get_gas_state::\u003cS, Q\u003e(self.inner.context()).clone();\n        let gas_left = get_gas_left(self.inner.context());\n        GasReport {\n            limit: state.gas_limit,\n            remaining: gas_left,\n            used_externally: state.externally_used_gas,\n            used_internally: state.get_gas_used_in_wasmer(gas_left),\n        }\n    }\n\n    /// Creates and returns a gas report.\n    /// This is a snapshot and multiple reports can be created during the lifetime of\n    /// an instance.\n    #[cfg(feature = \"default-enclave\")]\n    pub fn create_gas_report(\u0026self) -\u003e GasReport {\n        let limit = self.inner.gas_limit();\n        let remaining = self.inner.gas_left();\n        let used_internally = self.inner.gas_used();\n        let used_externally = limit.saturating_sub(remaining).saturating_sub(used_internally);\n        GasReport {\n            limit,\n            remaining,\n            used_externally,\n            used_internally,\n        }\n    }\n\n    /// Returns the currently remaining gas.\n    pub fn get_gas_used(\u0026self) -\u003e u64 {\n        get_gas_used(\u0026self.inner)\n    }\n\n    /// Sets the readonly storage flag on this instance. Since one instance can be used\n    /// for multiple calls in integration tests, this should be set to the desired value\n    /// right before every call.\n    pub fn set_storage_readonly(\u0026mut self, new_value: bool) {\n        set_storage_readonly::\u003cS, Q\u003e(self.inner.context_mut(), new_value);\n    }\n\n    pub fn with_storage\u003cF: FnOnce(\u0026mut S) -\u003e VmResult\u003cT\u003e, T\u003e(\u0026mut self, func: F) -\u003e VmResult\u003cT\u003e {\n        with_storage_from_context::\u003cS, Q, F, T\u003e(self.inner.context_mut(), func)\n    }\n\n    pub fn with_querier\u003cF: FnOnce(\u0026mut Q) -\u003e VmResult\u003cT\u003e, T\u003e(\u0026mut self, func: F) -\u003e VmResult\u003cT\u003e {\n        with_querier_from_context::\u003cS, Q, F, T\u003e(self.inner.context_mut(), func)\n    }\n\n    /// Requests memory allocation by the instance and returns a pointer\n    /// in the Wasm address space to the created Region object.\n    #[cfg(not(feature = \"default-enclave\"))]\n    pub(crate) fn allocate(\u0026mut self, size: usize) -\u003e VmResult\u003cu32\u003e {\n        let alloc: Func\u003cu32, u32\u003e = self.func(\"allocate\")?;\n        let ptr = alloc.call(to_u32(size)?)?;\n        if ptr == 0 {\n            return Err(CommunicationError::zero_address().into());\n        }\n        Ok(ptr)\n    }\n\n    // deallocate frees memory in the instance and that was either previously\n    // allocated by us, or a pointer from a return value after we copy it into rust.\n    // we need to clean up the wasm-side buffers to avoid memory leaks\n    #[cfg(not(feature = \"default-enclave\"))]\n    pub(crate) fn deallocate(\u0026mut self, ptr: u32) -\u003e VmResult\u003c()\u003e {\n        let dealloc: Func\u003cu32, ()\u003e = self.func(\"deallocate\")?;\n        dealloc.call(ptr)?;\n        Ok(())\n    }\n\n    /// Copies all data described by the Region at the given pointer from Wasm to the caller.\n    #[cfg(not(feature = \"default-enclave\"))]\n    pub(crate) fn read_memory(\u0026self, region_ptr: u32, max_length: usize) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n        read_region(self.inner.context(), region_ptr, max_length)\n    }\n\n    /// Copies data to the memory region that was created before using allocate.\n    #[cfg(not(feature = \"default-enclave\"))]\n    pub(crate) fn write_memory(\u0026mut self, region_ptr: u32, data: \u0026[u8]) -\u003e VmResult\u003c()\u003e {\n        write_region(self.inner.context(), region_ptr, data)?;\n        Ok(())\n    }\n\n    #[cfg(not(feature = \"default-enclave\"))]\n    pub(crate) fn func\u003cArgs, Rets\u003e(\u0026self, name: \u0026str) -\u003e VmResult\u003cFunc\u003cArgs, Rets, Wasm\u003e\u003e\n    where\n        Args: WasmTypeList,\n        Rets: WasmTypeList,\n    {\n        let function = self.inner.exports.get(name)?;\n        Ok(function)\n    }\n\n    pub fn call_init(\u0026mut self, env: \u0026[u8], msg: \u0026[u8], sig_info: \u0026[u8]) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n        let init_result = self.inner.init(env, msg, sig_info)?;\n        Ok(init_result.into_output())\n    }\n\n    pub fn call_handle(\u0026mut self, env: \u0026[u8], msg: \u0026[u8], sig_info: \u0026[u8]) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n        let init_result = self.inner.handle(env, msg, sig_info)?;\n        Ok(init_result.into_output())\n    }\n\n    pub fn call_migrate(\u0026mut self, _env: \u0026[u8], _msg: \u0026[u8]) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n        Ok(Vec::new())\n    }\n\n    pub fn call_query(\u0026mut self, msg: \u0026[u8]) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n        let init_result = self.inner.query(msg)?;\n        Ok(init_result.into_output())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::context::is_storage_readonly;\n    use crate::errors::VmError;\n    use crate::testing::{\n        mock_dependencies, mock_env, mock_instance, mock_instance_with_balances,\n        mock_instance_with_failing_api, mock_instance_with_gas_limit, MockQuerier, MockStorage,\n    };\n    use crate::traits::Storage;\n    use crate::{call_init, FfiError};\n    use cosmwasm_std::{\n        coin, coins, from_binary, AllBalanceResponse, BalanceResponse, BankQuery, Empty, HumanAddr,\n        QueryRequest,\n    };\n    use wabt::wat2wasm;\n\n    const KIB: usize = 1024;\n    const MIB: usize = 1024 * 1024;\n    const DEFAULT_GAS_LIMIT: u64 = 500_000;\n    const DEFAULT_QUERY_GAS_LIMIT: u64 = 300_000;\n    static CONTRACT: \u0026[u8] = include_bytes!(\"../testdata/contract.wasm\");\n\n    // shorthands for function generics below\n    type MS = MockStorage;\n    type MQ = MockQuerier;\n\n    #[test]\n    fn required_features_works() {\n        let deps = mock_dependencies(20, \u0026[]);\n        let instance = Instance::from_code(CONTRACT, deps, DEFAULT_GAS_LIMIT).unwrap();\n        assert_eq!(instance.required_features.len(), 0);\n    }\n\n    #[test]\n    fn required_features_works_for_many_exports() {\n        let wasm = wat2wasm(\n            r#\"(module\n            (type (func))\n            (func (type 0) nop)\n            (export \"requires_water\" (func 0))\n            (export \"requires_\" (func 0))\n            (export \"requires_nutrients\" (func 0))\n            (export \"require_milk\" (func 0))\n            (export \"REQUIRES_air\" (func 0))\n            (export \"requires_sun\" (func 0))\n            )\"#,\n        )\n        .unwrap();\n\n        let deps = mock_dependencies(20, \u0026[]);\n        let instance = Instance::from_code(\u0026wasm, deps, DEFAULT_GAS_LIMIT).unwrap();\n        assert_eq!(instance.required_features.len(), 3);\n        assert!(instance.required_features.contains(\"nutrients\"));\n        assert!(instance.required_features.contains(\"sun\"));\n        assert!(instance.required_features.contains(\"water\"));\n    }\n\n    /*\n    #[test]\n    fn func_works() {\n        let instance = mock_instance(\u0026CONTRACT, \u0026[]);\n\n        // can get func\n        let allocate: Func\u003cu32, u32\u003e = instance.func(\"allocate\").expect(\"error getting func\");\n\n        // can call a few times\n        let _ptr1 = allocate.call(0).expect(\"error calling allocate func\");\n        let _ptr2 = allocate.call(1).expect(\"error calling allocate func\");\n        let _ptr3 = allocate.call(33).expect(\"error calling allocate func\");\n    }\n    */\n\n    #[test]\n    fn func_errors_for_non_existent_function() {\n        let instance = mock_instance(\u0026CONTRACT, \u0026[]);\n        let missing_function = \"bar_foo345\";\n        match instance.func::\u003c(), ()\u003e(missing_function).err().unwrap() {\n            VmError::ResolveErr { msg, .. } =\u003e assert_eq!(\n                msg,\n                \"Wasmer resolve error: ExportNotFound { name: \\\"bar_foo345\\\" }\"\n            ),\n            e =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn func_errors_for_wrong_signature() {\n        let instance = mock_instance(\u0026CONTRACT, \u0026[]);\n        match instance.func::\u003c(), ()\u003e(\"allocate\").err().unwrap() {\n            VmError::ResolveErr { msg, .. } =\u003e assert_eq!(\n                msg,\n                \"Wasmer resolve error: Signature { expected: FuncSig { params: [I32], returns: [I32] }, found: [] }\"\n            ),\n            e =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn allocate_deallocate_works() {\n        let mut instance = mock_instance(\u0026CONTRACT, \u0026[]);\n\n        let sizes: Vec\u003cusize\u003e = vec![\n            0,\n            4,\n            40,\n            400,\n            4 * KIB,\n            40 * KIB,\n            400 * KIB,\n            4 * MIB,\n            40 * MIB,\n            400 * MIB,\n        ];\n        for size in sizes.into_iter() {\n            let region_ptr = instance.allocate(size).expect(\"error allocating\");\n            instance.deallocate(region_ptr).expect(\"error deallocating\");\n        }\n    }\n\n    #[test]\n    fn write_and_read_memory_works() {\n        let mut instance = mock_instance(\u0026CONTRACT, \u0026[]);\n\n        let sizes: Vec\u003cusize\u003e = vec![\n            0,\n            4,\n            40,\n            400,\n            4 * KIB,\n            40 * KIB,\n            400 * KIB,\n            4 * MIB,\n            // disabled for performance reasons, but pass as well\n            // 40 * MIB,\n            // 400 * MIB,\n        ];\n        for size in sizes.into_iter() {\n            let region_ptr = instance.allocate(size).expect(\"error allocating\");\n            let original = vec![170u8; size];\n            instance\n                .write_memory(region_ptr, \u0026original)\n                .expect(\"error writing\");\n            let data = instance\n                .read_memory(region_ptr, size)\n                .expect(\"error reading\");\n            assert_eq!(data, original);\n            instance.deallocate(region_ptr).expect(\"error deallocating\");\n        }\n    }\n\n    #[test]\n    fn errors_in_imports_are_unwrapped_from_wasmer_errors() {\n        // set up an instance that will experience an error in an import\n        let error_message = \"Api failed intentionally\";\n        let mut instance = mock_instance_with_failing_api(\u0026CONTRACT, \u0026[], error_message);\n        let init_result = call_init::\u003c_, _, _, serde_json::Value\u003e(\n            \u0026mut instance,\n            \u0026mock_env(\"someone\", \u0026[]),\n            b\"{\\\"verifier\\\": \\\"some1\\\", \\\"beneficiary\\\": \\\"some2\\\"}\",\n        );\n\n        // in this case we get a `VmError::FfiError` rather than a `VmError::RuntimeErr` because the conversion\n        // from wasmer `RuntimeError` to `VmError` unwraps errors that happen in WASM imports.\n        match init_result.unwrap_err() {\n            VmError::FfiErr {\n                source: FfiError::Unknown { msg, .. },\n            } if msg == Some(error_message.to_string()) =\u003e {}\n            other =\u003e panic!(\"unexpected error: {:?}\", other),\n        }\n    }\n\n    #[test]\n    fn read_memory_errors_when_when_length_is_too_long() {\n        let length = 6;\n        let max_length = 5;\n        let mut instance = mock_instance(\u0026CONTRACT, \u0026[]);\n\n        // Allocate sets length to 0. Write some data to increase length.\n        let region_ptr = instance.allocate(length).expect(\"error allocating\");\n        let data = vec![170u8; length];\n        instance\n            .write_memory(region_ptr, \u0026data)\n            .expect(\"error writing\");\n\n        let result = instance.read_memory(region_ptr, max_length);\n        match result.unwrap_err() {\n            VmError::CommunicationErr {\n                source:\n                    CommunicationError::RegionLengthTooBig {\n                        length, max_length, ..\n                    },\n            } =\u003e {\n                assert_eq!(length, 6);\n                assert_eq!(max_length, 5);\n            }\n            err =\u003e panic!(\"unexpected error: {:?}\", err),\n        };\n\n        instance.deallocate(region_ptr).expect(\"error deallocating\");\n    }\n\n    #[test]\n    fn get_memory_size_works() {\n        let mut instance = mock_instance(\u0026CONTRACT, \u0026[]);\n\n        assert_eq!(instance.get_memory_size(), 17 * WASM_PAGE_SIZE);\n\n        // 100 KiB require two more pages\n        let region_ptr = instance.allocate(100 * 1024).expect(\"error allocating\");\n\n        assert_eq!(instance.get_memory_size(), 19 * WASM_PAGE_SIZE);\n\n        // Deallocating does not shrink memory\n        instance.deallocate(region_ptr).expect(\"error deallocating\");\n        assert_eq!(instance.get_memory_size(), 19 * WASM_PAGE_SIZE);\n    }\n\n    #[test]\n    #[cfg(feature = \"default-cranelift\")]\n    fn set_get_and_gas_cranelift() {\n        let instance = mock_instance_with_gas_limit(\u0026CONTRACT, 123321);\n        let orig_gas = instance.get_gas_left();\n        assert_eq!(orig_gas, 1_000_000); // We expect a dummy value for cranelift\n    }\n\n    #[test]\n    #[cfg(feature = \"default-singlepass\")]\n    fn set_get_and_gas_singlepass() {\n        let instance = mock_instance_with_gas_limit(\u0026CONTRACT, 123321);\n        let orig_gas = instance.get_gas_left();\n        assert_eq!(orig_gas, 123321);\n    }\n\n    #[test]\n    #[cfg(feature = \"default-cranelift\")]\n    fn create_gas_report_works_cranelift() {\n        const LIMIT: u64 = 7_000_000;\n        /// Value hardcoded in cranelift backend\n        const FAKE_REMANING: u64 = 1_000_000;\n        let mut instance = mock_instance_with_gas_limit(\u0026CONTRACT, LIMIT);\n\n        let report1 = instance.create_gas_report();\n        assert_eq!(report1.used_externally, 0);\n        assert_eq!(report1.used_internally, LIMIT - FAKE_REMANING);\n        assert_eq!(report1.limit, LIMIT);\n        assert_eq!(report1.remaining, FAKE_REMANING);\n\n        // init contract\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        let msg = r#\"{\"verifier\": \"verifies\", \"beneficiary\": \"benefits\"}\"#.as_bytes();\n        call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg)\n            .unwrap()\n            .unwrap();\n\n        let report2 = instance.create_gas_report();\n        assert_eq!(report2.used_externally, 0);\n        assert_eq!(report2.used_internally, LIMIT - FAKE_REMANING);\n        assert_eq!(report2.limit, LIMIT);\n        assert_eq!(report2.remaining, FAKE_REMANING);\n    }\n\n    #[test]\n    #[cfg(feature = \"default-singlepass\")]\n    fn create_gas_report_works_singlepass() {\n        const LIMIT: u64 = 7_000_000;\n        let mut instance = mock_instance_with_gas_limit(\u0026CONTRACT, LIMIT);\n\n        let report1 = instance.create_gas_report();\n        assert_eq!(report1.used_externally, 0);\n        assert_eq!(report1.used_internally, 0);\n        assert_eq!(report1.limit, LIMIT);\n        assert_eq!(report1.remaining, LIMIT);\n\n        // init contract\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        let msg = r#\"{\"verifier\": \"verifies\", \"beneficiary\": \"benefits\"}\"#.as_bytes();\n        call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg)\n            .unwrap()\n            .unwrap();\n\n        let report2 = instance.create_gas_report();\n        assert_eq!(report2.used_externally, 134);\n        assert_eq!(report2.used_internally, 63027);\n        assert_eq!(report2.limit, LIMIT);\n        assert_eq!(\n            report2.remaining,\n            LIMIT - report2.used_externally - report2.used_internally\n        );\n    }\n\n    #[test]\n    fn set_storage_readonly_works() {\n        let mut instance = mock_instance(\u0026CONTRACT, \u0026[]);\n\n        assert_eq!(\n            is_storage_readonly::\u003cMS, MQ\u003e(instance.inner.context()),\n            true\n        );\n\n        instance.set_storage_readonly(false);\n        assert_eq!(\n            is_storage_readonly::\u003cMS, MQ\u003e(instance.inner.context()),\n            false\n        );\n\n        instance.set_storage_readonly(false);\n        assert_eq!(\n            is_storage_readonly::\u003cMS, MQ\u003e(instance.inner.context()),\n            false\n        );\n\n        instance.set_storage_readonly(true);\n        assert_eq!(\n            is_storage_readonly::\u003cMS, MQ\u003e(instance.inner.context()),\n            true\n        );\n    }\n\n    #[test]\n    fn with_storage_works() {\n        let mut instance = mock_instance(\u0026CONTRACT, \u0026[]);\n\n        // initial check\n        instance\n            .with_storage(|store| {\n                assert!(store.get(b\"foo\").0.unwrap().is_none());\n                Ok(())\n            })\n            .unwrap();\n\n        // write some data\n        instance\n            .with_storage(|store| {\n                store.set(b\"foo\", b\"bar\").0.unwrap();\n                Ok(())\n            })\n            .unwrap();\n\n        // read some data\n        instance\n            .with_storage(|store| {\n                assert_eq!(store.get(b\"foo\").0.unwrap(), Some(b\"bar\".to_vec()));\n                Ok(())\n            })\n            .unwrap();\n    }\n\n    #[test]\n    #[should_panic]\n    fn with_storage_safe_for_panic() {\n        // this should fail with the assertion, but not cause a double-free crash (issue #59)\n        let mut instance = mock_instance(\u0026CONTRACT, \u0026[]);\n        instance\n            .with_storage::\u003c_, ()\u003e(|_store| panic!(\"trigger failure\"))\n            .unwrap();\n    }\n\n    #[test]\n    fn with_querier_works_readonly() {\n        let rich_addr = HumanAddr::from(\"foobar\");\n        let rich_balance = vec![coin(10000, \"gold\"), coin(8000, \"silver\")];\n        let mut instance = mock_instance_with_balances(\u0026CONTRACT, \u0026[(\u0026rich_addr, \u0026rich_balance)]);\n\n        // query one\n        instance\n            .with_querier(|querier| {\n                let response = querier\n                    .query::\u003cEmpty\u003e(\n                        \u0026QueryRequest::Bank(BankQuery::Balance {\n                            address: rich_addr.clone(),\n                            denom: \"silver\".to_string(),\n                        }),\n                        DEFAULT_QUERY_GAS_LIMIT,\n                    )\n                    .0\n                    .unwrap()\n                    .unwrap()\n                    .unwrap();\n                let BalanceResponse { amount } = from_binary(\u0026response).unwrap();\n                assert_eq!(amount.amount.u128(), 8000);\n                assert_eq!(amount.denom, \"silver\");\n                Ok(())\n            })\n            .unwrap();\n\n        // query all\n        instance\n            .with_querier(|querier| {\n                let response = querier\n                    .query::\u003cEmpty\u003e(\n                        \u0026QueryRequest::Bank(BankQuery::AllBalances {\n                            address: rich_addr.clone(),\n                        }),\n                        DEFAULT_QUERY_GAS_LIMIT,\n                    )\n                    .0\n                    .unwrap()\n                    .unwrap()\n                    .unwrap();\n                let AllBalanceResponse { amount } = from_binary(\u0026response).unwrap();\n                assert_eq!(amount.len(), 2);\n                assert_eq!(amount[0].amount.u128(), 10000);\n                assert_eq!(amount[0].denom, \"gold\");\n                assert_eq!(amount[1].amount.u128(), 8000);\n                assert_eq!(amount[1].denom, \"silver\");\n\n                Ok(())\n            })\n            .unwrap();\n    }\n\n    /// This is needed for writing intagration tests in which the balance of a contract changes over time\n    #[test]\n    fn with_querier_allows_updating_balances() {\n        let rich_addr = HumanAddr::from(\"foobar\");\n        let rich_balance1 = vec![coin(10000, \"gold\"), coin(500, \"silver\")];\n        let rich_balance2 = vec![coin(10000, \"gold\"), coin(8000, \"silver\")];\n        let mut instance = mock_instance_with_balances(\u0026CONTRACT, \u0026[(\u0026rich_addr, \u0026rich_balance1)]);\n\n        // Get initial state\n        instance\n            .with_querier(|querier| {\n                let response = querier\n                    .query::\u003cEmpty\u003e(\n                        \u0026QueryRequest::Bank(BankQuery::Balance {\n                            address: rich_addr.clone(),\n                            denom: \"silver\".to_string(),\n                        }),\n                        DEFAULT_QUERY_GAS_LIMIT,\n                    )\n                    .0\n                    .unwrap()\n                    .unwrap()\n                    .unwrap();\n                let BalanceResponse { amount } = from_binary(\u0026response).unwrap();\n                assert_eq!(amount.amount.u128(), 500);\n                Ok(())\n            })\n            .unwrap();\n\n        // Update balance\n        instance\n            .with_querier(|querier| {\n                querier.update_balance(\u0026rich_addr, rich_balance2);\n                Ok(())\n            })\n            .unwrap();\n\n        // Get updated state\n        instance\n            .with_querier(|querier| {\n                let response = querier\n                    .query::\u003cEmpty\u003e(\n                        \u0026QueryRequest::Bank(BankQuery::Balance {\n                            address: rich_addr.clone(),\n                            denom: \"silver\".to_string(),\n                        }),\n                        DEFAULT_QUERY_GAS_LIMIT,\n                    )\n                    .0\n                    .unwrap()\n                    .unwrap()\n                    .unwrap();\n                let BalanceResponse { amount } = from_binary(\u0026response).unwrap();\n                assert_eq!(amount.amount.u128(), 8000);\n                Ok(())\n            })\n            .unwrap();\n    }\n}\n\n#[cfg(test)]\n#[cfg(feature = \"default-singlepass\")]\nmod singlepass_test {\n    use cosmwasm_std::{coins, Empty};\n\n    use crate::calls::{call_handle, call_init, call_query};\n    use crate::testing::{mock_env, mock_instance, mock_instance_with_gas_limit};\n\n    static CONTRACT: \u0026[u8] = include_bytes!(\"../testdata/contract.wasm\");\n\n    #[test]\n    fn contract_deducts_gas_init() {\n        let mut instance = mock_instance(\u0026CONTRACT, \u0026[]);\n        let orig_gas = instance.get_gas_left();\n\n        // init contract\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        let msg = r#\"{\"verifier\": \"verifies\", \"beneficiary\": \"benefits\"}\"#.as_bytes();\n        call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg)\n            .unwrap()\n            .unwrap();\n\n        let init_used = orig_gas - instance.get_gas_left();\n        println!(\"init used: {}\", init_used);\n        assert_eq!(init_used, 63161);\n    }\n\n    #[test]\n    fn contract_deducts_gas_handle() {\n        let mut instance = mock_instance(\u0026CONTRACT, \u0026[]);\n\n        // init contract\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        let msg = r#\"{\"verifier\": \"verifies\", \"beneficiary\": \"benefits\"}\"#.as_bytes();\n        call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg)\n            .unwrap()\n            .unwrap();\n\n        // run contract - just sanity check - results validate in contract unit tests\n        let gas_before_handle = instance.get_gas_left();\n        let env = mock_env(\"verifies\", \u0026coins(15, \"earth\"));\n        let msg = br#\"{\"release\":{}}\"#;\n        call_handle::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg)\n            .unwrap()\n            .unwrap();\n\n        let handle_used = gas_before_handle - instance.get_gas_left();\n        println!(\"handle used: {}\", handle_used);\n        assert_eq!(handle_used, 193119);\n    }\n\n    #[test]\n    fn contract_enforces_gas_limit() {\n        let mut instance = mock_instance_with_gas_limit(\u0026CONTRACT, 20_000);\n\n        // init contract\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        let msg = r#\"{\"verifier\": \"verifies\", \"beneficiary\": \"benefits\"}\"#.as_bytes();\n        let res = call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg);\n        assert!(res.is_err());\n    }\n\n    #[test]\n    fn query_works_with_metering() {\n        let mut instance = mock_instance(\u0026CONTRACT, \u0026[]);\n\n        // init contract\n        let env = mock_env(\"creator\", \u0026coins(1000, \"earth\"));\n        let msg = r#\"{\"verifier\": \"verifies\", \"beneficiary\": \"benefits\"}\"#.as_bytes();\n        let _res = call_init::\u003c_, _, _, Empty\u003e(\u0026mut instance, \u0026env, msg)\n            .unwrap()\n            .unwrap();\n\n        // run contract - just sanity check - results validate in contract unit tests\n        let gas_before_query = instance.get_gas_left();\n        // we need to encode the key in base64\n        let msg = r#\"{\"verifier\":{}}\"#.as_bytes();\n        let res = call_query(\u0026mut instance, msg).unwrap();\n        let answer = res.unwrap();\n        assert_eq!(answer.as_slice(), b\"{\\\"verifier\\\":\\\"verifies\\\"}\");\n\n        let query_used = gas_before_query - instance.get_gas_left();\n        println!(\"query used: {}\", query_used);\n        assert_eq!(query_used, 32070);\n    }\n}\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":97},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","lib.rs"],"content":"mod backends;\nmod cache;\nmod calls;\nmod checksum;\nmod compatability;\nmod context;\nmod conversion;\nmod errors;\nmod features;\nmod ffi;\n// mod imports;\nmod instance;\n// mod memory;\n// mod middleware;\n// mod modules;\nmod serde;\npub mod testing;\nmod traits;\n\n// Secret Network specific modules\nmod attestation;\nmod enclave;\nmod seed;\nmod wasmi;\n\n#[cfg(feature = \"enclave-tests\")]\npub mod enclave_tests;\n\npub use crate::cache::CosmCache;\npub use crate::calls::{call_handle_raw, call_init_raw, call_migrate_raw, call_query_raw};\npub use crate::checksum::Checksum;\npub use crate::errors::{\n    CommunicationError, CommunicationResult, RegionValidationError, RegionValidationResult,\n    VmError, VmResult,\n};\npub use crate::features::features_from_csv;\npub use crate::ffi::{FfiError, FfiResult, GasInfo};\npub use crate::instance::{GasReport, Instance};\n/*\npub use crate::modules::FileSystemCache;\n*/\npub use crate::serde::{from_slice, to_vec};\npub use crate::traits::{Api, Extern, Querier, Storage};\n\n#[cfg(feature = \"iterator\")]\npub use crate::traits::StorageIterator;\n\n// Secret Network specific exports\npub use crate::attestation::{create_attestation_report_u, untrusted_get_encrypted_seed};\npub use crate::seed::{\n    untrusted_health_check, untrusted_init_bootstrap, untrusted_init_node, untrusted_key_gen,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","memory.rs"],"content":"use wasmer_runtime_core::{\n    memory::ptr::{Array, WasmPtr},\n    types::ValueType,\n    vm::Ctx,\n};\n\nuse crate::conversion::to_u32;\nuse crate::errors::{\n    CommunicationError, CommunicationResult, RegionValidationError, RegionValidationResult,\n    VmResult,\n};\n\n/****** read/write to wasm memory buffer ****/\n\n/// Refers to some heap allocated data in Wasm.\n/// A pointer to an instance of this can be returned over FFI boundaries.\n///\n/// This is the same as cosmwasm::memory::Region\n/// but defined here to allow Wasmer specific implementation.\n#[repr(C)]\n#[derive(Default, Clone, Copy, Debug)]\nstruct Region {\n    pub offset: u32,\n    /// The number of bytes available in this region\n    pub capacity: u32,\n    /// The number of bytes used in this region\n    pub length: u32,\n}\n\nunsafe impl ValueType for Region {}\n\n/// A Wasm memory descriptor\n#[derive(Debug, Clone)]\npub struct MemoryDescriptor {\n    /// The minimum number of allowed pages\n    pub minimum: u32,\n    /// The maximum number of allowed pages\n    pub maximum: Option\u003cu32\u003e,\n    /// This memory can be shared between Wasm threads\n    pub shared: bool,\n}\n\n#[derive(Debug, Clone)]\npub struct MemoryInfo {\n    pub descriptor: MemoryDescriptor,\n    /// Current memory size in pages\n    pub size: u32,\n}\n\n/// Get information about the default memory `memory(0)`\npub fn get_memory_info(ctx: \u0026Ctx) -\u003e MemoryInfo {\n    let memory = ctx.memory(0);\n    let descriptor = memory.descriptor();\n    MemoryInfo {\n        descriptor: MemoryDescriptor {\n            minimum: descriptor.minimum.0,\n            maximum: descriptor.maximum.map(|pages| pages.0),\n            shared: descriptor.shared,\n        },\n        size: memory.size().0,\n    }\n}\n\n/// Expects a (fixed size) Region struct at ptr, which is read. This links to the\n/// memory region, which is copied in the second step.\n/// Errors if the length of the region exceeds `max_length`.\npub fn read_region(ctx: \u0026Ctx, ptr: u32, max_length: usize) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e {\n    let region = get_region(ctx, ptr)?;\n\n    if region.length \u003e to_u32(max_length)? {\n        return Err(\n            CommunicationError::region_length_too_big(region.length as usize, max_length).into(),\n        );\n    }\n\n    let memory = ctx.memory(0);\n    match WasmPtr::\u003cu8, Array\u003e::new(region.offset).deref(memory, 0, region.length) {\n        Some(cells) =\u003e {\n            // In case you want to do some premature optimization, this shows how to cast a `\u0026'mut [Cell\u003cu8\u003e]` to `\u0026mut [u8]`:\n            // https://github.com/wasmerio/wasmer/blob/0.13.1/lib/wasi/src/syscalls/mod.rs#L79-L81\n            let len = region.length as usize;\n            let mut result = vec![0u8; len];\n            for i in 0..len {\n                result[i] = cells[i].get();\n            }\n            Ok(result)\n        }\n        None =\u003e Err(CommunicationError::deref_err(region.offset, format!(\n            \"Tried to access memory of region {:?} in wasm memory of size {} bytes. This typically happens when the given Region pointer does not point to a proper Region struct.\",\n            region,\n            memory.size().bytes().0\n        )).into()),\n    }\n}\n\n/// maybe_read_region is like read_region, but gracefully handles null pointer (0) by returning None\n/// meant to be used where the argument is optional (like scan)\n#[cfg(feature = \"iterator\")]\npub fn maybe_read_region(ctx: \u0026Ctx, ptr: u32, max_length: usize) -\u003e VmResult\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e {\n    if ptr == 0 {\n        Ok(None)\n    } else {\n        read_region(ctx, ptr, max_length).map(Some)\n    }\n}\n\n/// A prepared and sufficiently large memory Region is expected at ptr that points to pre-allocated memory.\n///\n/// Returns number of bytes written on success.\npub fn write_region(ctx: \u0026Ctx, ptr: u32, data: \u0026[u8]) -\u003e VmResult\u003c()\u003e {\n    let mut region = get_region(ctx, ptr)?;\n\n    let region_capacity = region.capacity as usize;\n    if data.len() \u003e region_capacity {\n        return Err(CommunicationError::region_too_small(region_capacity, data.len()).into());\n    }\n\n    let memory = ctx.memory(0);\n    match WasmPtr::\u003cu8, Array\u003e::new(region.offset).deref(memory, 0, region.capacity) {\n        Some(cells) =\u003e {\n            // In case you want to do some premature optimization, this shows how to cast a `\u0026'mut [Cell\u003cu8\u003e]` to `\u0026mut [u8]`:\n            // https://github.com/wasmerio/wasmer/blob/0.13.1/lib/wasi/src/syscalls/mod.rs#L79-L81\n            for i in 0..data.len() {\n                cells[i].set(data[i])\n            }\n            region.length = data.len() as u32;\n            set_region(ctx, ptr, region)?;\n            Ok(())\n        },\n        None =\u003e Err(CommunicationError::deref_err(region.offset, format!(\n            \"Tried to access memory of region {:?} in wasm memory of size {} bytes. This typically happens when the given Region pointer does not point to a proper Region struct.\",\n            region,\n            memory.size().bytes().0\n        )).into()),\n    }\n}\n\n/// Reads in a Region at ptr in wasm memory and returns a copy of it\nfn get_region(ctx: \u0026Ctx, ptr: u32) -\u003e CommunicationResult\u003cRegion\u003e {\n    let memory = ctx.memory(0);\n    let wptr = WasmPtr::\u003cRegion\u003e::new(ptr);\n    match wptr.deref(memory) {\n        Some(cell) =\u003e {\n            let region = cell.get();\n            validate_region(\u0026region)?;\n            Ok(region)\n        }\n        None =\u003e Err(CommunicationError::deref_err(\n            ptr,\n            \"Could not dereference this pointer to a Region\",\n        )),\n    }\n}\n\n/// Performs plausibility checks in the given Region. Regions are always created by the\n/// contract and this can be used to detect problems in the standard library of the contract.\nfn validate_region(region: \u0026Region) -\u003e RegionValidationResult\u003c()\u003e {\n    if region.offset == 0 {\n        return Err(RegionValidationError::zero_offset());\n    }\n    if region.length \u003e region.capacity {\n        return Err(RegionValidationError::length_exceeds_capacity(\n            region.length,\n            region.capacity,\n        ));\n    }\n    if region.capacity \u003e (u32::MAX - region.offset) {\n        return Err(RegionValidationError::out_of_range(\n            region.offset,\n            region.capacity,\n        ));\n    }\n    Ok(())\n}\n\n/// Overrides a Region at ptr in wasm memory with data\nfn set_region(ctx: \u0026Ctx, ptr: u32, data: Region) -\u003e CommunicationResult\u003c()\u003e {\n    let memory = ctx.memory(0);\n    let wptr = WasmPtr::\u003cRegion\u003e::new(ptr);\n\n    match wptr.deref(memory) {\n        Some(cell) =\u003e {\n            cell.set(data);\n            Ok(())\n        }\n        None =\u003e Err(CommunicationError::deref_err(\n            ptr,\n            \"Could not dereference this pointer to a Region\",\n        )),\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn validate_region_passes_for_valid_region() {\n        // empty\n        let region = Region {\n            offset: 23,\n            capacity: 500,\n            length: 0,\n        };\n        validate_region(\u0026region).unwrap();\n\n        // half full\n        let region = Region {\n            offset: 23,\n            capacity: 500,\n            length: 250,\n        };\n        validate_region(\u0026region).unwrap();\n\n        // full\n        let region = Region {\n            offset: 23,\n            capacity: 500,\n            length: 500,\n        };\n        validate_region(\u0026region).unwrap();\n\n        // at end of linear memory (1)\n        let region = Region {\n            offset: u32::MAX,\n            capacity: 0,\n            length: 0,\n        };\n        validate_region(\u0026region).unwrap();\n\n        // at end of linear memory (2)\n        let region = Region {\n            offset: 1,\n            capacity: u32::MAX - 1,\n            length: 0,\n        };\n        validate_region(\u0026region).unwrap();\n    }\n\n    #[test]\n    fn validate_region_fails_for_zero_offset() {\n        let region = Region {\n            offset: 0,\n            capacity: 500,\n            length: 250,\n        };\n        let result = validate_region(\u0026region);\n        match result.unwrap_err() {\n            RegionValidationError::ZeroOffset { .. } =\u003e {}\n            e =\u003e panic!(\"Got unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn validate_region_fails_for_length_exceeding_capacity() {\n        let region = Region {\n            offset: 23,\n            capacity: 500,\n            length: 501,\n        };\n        let result = validate_region(\u0026region);\n        match result.unwrap_err() {\n            RegionValidationError::LengthExceedsCapacity {\n                length, capacity, ..\n            } =\u003e {\n                assert_eq!(length, 501);\n                assert_eq!(capacity, 500);\n            }\n            e =\u003e panic!(\"Got unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn validate_region_fails_when_exceeding_address_space() {\n        let region = Region {\n            offset: 23,\n            capacity: u32::MAX,\n            length: 501,\n        };\n        let result = validate_region(\u0026region);\n        match result.unwrap_err() {\n            RegionValidationError::OutOfRange {\n                offset, capacity, ..\n            } =\u003e {\n                assert_eq!(offset, 23);\n                assert_eq!(capacity, u32::MAX);\n            }\n            e =\u003e panic!(\"Got unexpected error: {:?}\", e),\n        }\n\n        let region = Region {\n            offset: u32::MAX,\n            capacity: 1,\n            length: 0,\n        };\n        let result = validate_region(\u0026region);\n        match result.unwrap_err() {\n            RegionValidationError::OutOfRange {\n                offset, capacity, ..\n            } =\u003e {\n                assert_eq!(offset, u32::MAX);\n                assert_eq!(capacity, 1);\n            }\n            e =\u003e panic!(\"Got unexpected error: {:?}\", e),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","middleware","deterministic.rs"],"content":"/**\nThis code is a slightly modified version of ValidationMiddleware taken from spacemesh vm,\nunder the MIT license.\n\nOriginal source: https://github.com/spacemeshos/svm/blob/5df80288c8b9a5ab3665297251c283cb614ebb81/crates/svm-compiler/src/middleware/validation.rs\n*/\nuse wasmer_runtime_core::{\n    codegen::{Event, EventSink, FunctionMiddleware},\n    error::CompileError,\n    module::ModuleInfo,\n    wasmparser::Operator,\n};\n\n/// The `DeterministicMiddleware` has one main objective:\n/// * validation - make sure the wasm is valid and doesn't contain any non-deterministic opcodes (for example: floats)\npub struct DeterministicMiddleware;\n\nimpl DeterministicMiddleware {\n    // this is only use in singlepass, not cranelift, so don't trigger ci linting errors\n    #[allow(dead_code)]\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n}\n\nimpl FunctionMiddleware for DeterministicMiddleware {\n    type Error = CompileError;\n\n    fn feed_event\u003c'a, 'b: 'a\u003e(\n        \u0026mut self,\n        event: Event\u003c'a, 'b\u003e,\n        _module_info: \u0026ModuleInfo,\n        sink: \u0026mut EventSink\u003c'a, 'b\u003e,\n        _source_loc: u32,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        match event {\n            Event::Wasm(op) =\u003e parse_wasm_opcode(op)?,\n            Event::WasmOwned(ref op) =\u003e parse_wasm_opcode(op)?,\n            _ =\u003e (),\n        };\n\n        sink.push(event);\n        Ok(())\n    }\n}\n\n/// we explicitly whitelist the supported opcodes\nfn parse_wasm_opcode(opcode: \u0026Operator) -\u003e Result\u003c(), CompileError\u003e {\n    match opcode {\n        Operator::Unreachable\n        | Operator::Nop\n        | Operator::Block { .. }\n        | Operator::Loop { .. }\n        | Operator::If { .. }\n        | Operator::Else\n        | Operator::End\n        | Operator::Br { .. }\n        | Operator::BrIf { .. }\n        | Operator::BrTable { .. }\n        | Operator::Return\n        | Operator::Call { .. }\n        | Operator::CallIndirect { .. }\n        | Operator::Drop\n        | Operator::Select\n        | Operator::LocalGet { .. }\n        | Operator::LocalSet { .. }\n        | Operator::LocalTee { .. }\n        | Operator::GlobalGet { .. }\n        | Operator::GlobalSet { .. }\n        | Operator::I32Load { .. }\n        | Operator::I64Load { .. }\n        | Operator::I32Load8S { .. }\n        | Operator::I32Load8U { .. }\n        | Operator::I32Load16S { .. }\n        | Operator::I32Load16U { .. }\n        | Operator::I64Load8S { .. }\n        | Operator::I64Load8U { .. }\n        | Operator::I64Load16S { .. }\n        | Operator::I64Load16U { .. }\n        | Operator::I64Load32S { .. }\n        | Operator::I64Load32U { .. }\n        | Operator::I32Store { .. }\n        | Operator::I64Store { .. }\n        | Operator::I32Store8 { .. }\n        | Operator::I32Store16 { .. }\n        | Operator::I64Store8 { .. }\n        | Operator::I64Store16 { .. }\n        | Operator::I64Store32 { .. }\n        | Operator::MemorySize { .. }\n        | Operator::MemoryGrow { .. }\n        | Operator::I32Const { .. }\n        | Operator::I64Const { .. }\n        | Operator::I32Eqz\n        | Operator::I32Eq\n        | Operator::I32Ne\n        | Operator::I32LtS\n        | Operator::I32LtU\n        | Operator::I32GtS\n        | Operator::I32GtU\n        | Operator::I32LeS\n        | Operator::I32LeU\n        | Operator::I32GeS\n        | Operator::I32GeU\n        | Operator::I64Eqz\n        | Operator::I64Eq\n        | Operator::I64Ne\n        | Operator::I64LtS\n        | Operator::I64LtU\n        | Operator::I64GtS\n        | Operator::I64GtU\n        | Operator::I64LeS\n        | Operator::I64LeU\n        | Operator::I64GeS\n        | Operator::I64GeU\n        | Operator::I32Clz\n        | Operator::I32Ctz\n        | Operator::I32Popcnt\n        | Operator::I32Add\n        | Operator::I32Sub\n        | Operator::I32Mul\n        | Operator::I32DivS\n        | Operator::I32DivU\n        | Operator::I32RemS\n        | Operator::I32RemU\n        | Operator::I32And\n        | Operator::I32Or\n        | Operator::I32Xor\n        | Operator::I32Shl\n        | Operator::I32ShrS\n        | Operator::I32ShrU\n        | Operator::I32Rotl\n        | Operator::I32Rotr\n        | Operator::I64Clz\n        | Operator::I64Ctz\n        | Operator::I64Popcnt\n        | Operator::I64Add\n        | Operator::I64Sub\n        | Operator::I64Mul\n        | Operator::I64DivS\n        | Operator::I64DivU\n        | Operator::I64RemS\n        | Operator::I64RemU\n        | Operator::I64And\n        | Operator::I64Or\n        | Operator::I64Xor\n        | Operator::I64Shl\n        | Operator::I64ShrS\n        | Operator::I64ShrU\n        | Operator::I64Rotl\n        | Operator::I64Rotr\n        | Operator::I32WrapI64\n        | Operator::I32Extend8S\n        | Operator::I32Extend16S\n        | Operator::I64Extend8S\n        | Operator::I64Extend16S\n        | Operator::I64ExtendI32S\n        | Operator::I64ExtendI32U =\u003e Ok(()),\n        _ =\u003e Err(CompileError::ValidationError {\n            msg: format!(\"non-deterministic opcode: {:?}\", opcode),\n        }),\n    }\n}\n\n/// Middleware is only supported in singlepass backend, see\n/// https://github.com/CosmWasm/cosmwasm/issues/311\n#[cfg(all(test, feature = \"default-singlepass\"))]\nmod tests {\n    // No 'use super::*;' here. This is strange and means we are not testing the functions in this module directly.\n    use crate::backends::compile;\n    use crate::errors::VmError;\n    use wabt::wat2wasm;\n    use wasmer_runtime_core::{imports, typed_func::Func};\n\n    #[test]\n    fn valid_wasm_instance_sanity() {\n        let input = r#\"\n            (module\n                (func (export \"sum\") (param i32 i32) (result i32)\n                    get_local 0\n                    get_local 1\n                    i32.add\n                ))\n            \"#;\n        let wasm = wat2wasm(input).unwrap();\n        let module = compile(\u0026wasm).unwrap();\n        let instance = module.instantiate(\u0026imports! {}).unwrap();\n\n        let func: Func\u003c(i32, i32), i32\u003e = instance.exports.get(\"sum\").unwrap();\n        let res = func.call(10, 20);\n        assert!(res.is_ok());\n        assert_eq!(30, res.unwrap());\n    }\n\n    #[test]\n    fn parser_floats_are_not_supported() {\n        let input = r#\"\n            (module\n                (func $to_float (param i32) (result f32)\n                    get_local 0\n                    f32.convert_u/i32\n                ))\n            \"#;\n        let wasm = wat2wasm(input).unwrap();\n        let res = compile(\u0026wasm);\n\n        match res.err().unwrap() {\n            VmError::CompileErr { msg, .. } =\u003e assert_eq!(msg, \"Wasmer compile error: InternalError { msg: \\\"Codegen(\\\\\\\"ValidationError { msg: \\\\\\\\\\\\\\\"non-deterministic opcode: F32ConvertI32U\\\\\\\\\\\\\\\" }\\\\\\\")\\\" }\"),\n            e =\u003e panic!(\"unexpected error: {:?}\", e),\n        }\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","middleware","mod.rs"],"content":"mod deterministic;\n\npub use deterministic::DeterministicMiddleware;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","modules.rs"],"content":"// copied from https://github.com/wasmerio/wasmer/blob/0.8.0/lib/runtime/src/cache.rs\n// with some minor modifications\n\nuse memmap::Mmap;\nuse std::{\n    fs::{self, File},\n    io::{self, Write},\n    path::PathBuf,\n};\n\nuse wasmer_runtime_core::{cache::Artifact, module::Module};\n\nuse crate::backends::{backend, compiler_for_backend};\nuse crate::checksum::Checksum;\nuse crate::errors::{VmError, VmResult};\n\n/// Representation of a directory that contains compiled Wasm artifacts.\npub struct FileSystemCache {\n    path: PathBuf,\n}\n\nimpl FileSystemCache {\n    /// Construct a new `FileSystemCache` around the specified directory.\n    /// The contents of the cache are stored in sub-versioned directories.\n    ///\n    /// # Safety\n    ///\n    /// This method is unsafe because there's no way to ensure the artifacts\n    /// stored in this cache haven't been corrupted or tampered with.\n    pub unsafe fn new\u003cP: Into\u003cPathBuf\u003e\u003e(path: P) -\u003e io::Result\u003cSelf\u003e {\n        let path: PathBuf = path.into();\n        if path.exists() {\n            let metadata = path.metadata()?;\n            if metadata.is_dir() {\n                if !metadata.permissions().readonly() {\n                    Ok(Self { path })\n                } else {\n                    // This directory is readonly.\n                    Err(io::Error::new(\n                        io::ErrorKind::PermissionDenied,\n                        format!(\"the supplied path is readonly: {}\", path.display()),\n                    ))\n                }\n            } else {\n                // This path points to a file.\n                Err(io::Error::new(\n                    io::ErrorKind::PermissionDenied,\n                    format!(\n                        \"the supplied path already points to a file: {}\",\n                        path.display()\n                    ),\n                ))\n            }\n        } else {\n            // Create the directory and any parent directories if they don't yet exist.\n            fs::create_dir_all(\u0026path)?;\n            Ok(Self { path })\n        }\n    }\n\n    pub fn load(\u0026self, checksum: \u0026Checksum) -\u003e VmResult\u003cModule\u003e {\n        self.load_with_backend(checksum, backend())\n    }\n\n    pub fn load_with_backend(\u0026self, checksum: \u0026Checksum, backend: \u0026str) -\u003e VmResult\u003cModule\u003e {\n        let filename = checksum.to_hex();\n        let file_path = self.path.clone().join(backend).join(filename);\n        let file = File::open(file_path)\n            .map_err(|e| VmError::cache_err(format!(\"Error opening module file: {}\", e)))?;\n        let mmap = unsafe { Mmap::map(\u0026file) }\n            .map_err(|e| VmError::cache_err(format!(\"Mmap error: {}\", e)))?;\n\n        let serialized_cache = Artifact::deserialize(\u0026mmap[..])?;\n        let module = unsafe {\n            wasmer_runtime_core::load_cache_with(\n                serialized_cache,\n                compiler_for_backend(backend)\n                    .ok_or_else(|| VmError::cache_err(format!(\"Unsupported backend: {}\", backend)))?\n                    .as_ref(),\n            )\n        }?;\n        Ok(module)\n    }\n\n    pub fn store(\u0026mut self, checksum: \u0026Checksum, module: Module) -\u003e VmResult\u003c()\u003e {\n        let backend_str = module.info().backend.to_string();\n        let modules_dir = self.path.clone().join(backend_str);\n        fs::create_dir_all(\u0026modules_dir)\n            .map_err(|e| VmError::cache_err(format!(\"Error creating direcory: {}\", e)))?;\n\n        let serialized_cache = module.cache()?;\n        let buffer = serialized_cache.serialize()?;\n\n        let filename = checksum.to_hex();\n        let mut file = File::create(modules_dir.join(filename))\n            .map_err(|e| VmError::cache_err(format!(\"Error creating module file: {}\", e)))?;\n        file.write_all(\u0026buffer)\n            .map_err(|e| VmError::cache_err(format!(\"Error writing module to disk: {}\", e)))?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::backends::compile;\n    use std::env;\n    use wabt::wat2wasm;\n\n    #[test]\n    fn test_file_system_cache_run() {\n        use wasmer_runtime_core::{imports, typed_func::Func};\n\n        let wasm = wat2wasm(\n            r#\"(module\n            (type $t0 (func (param i32) (result i32)))\n            (func $add_one (export \"add_one\") (type $t0) (param $p0 i32) (result i32)\n                get_local $p0\n                i32.const 1\n                i32.add))\n            \"#,\n        )\n        .unwrap();\n        let checksum = Checksum::generate(\u0026wasm);\n\n        let module = compile(\u0026wasm).unwrap();\n\n        // assert we are using the proper backend\n        assert_eq!(backend().to_string(), module.info().backend.to_string());\n\n        let cache_dir = env::temp_dir();\n        let mut fs_cache = unsafe { FileSystemCache::new(cache_dir).unwrap() };\n\n        // store module\n        fs_cache.store(\u0026checksum, module.clone()).unwrap();\n\n        // load module\n        let cached_result = fs_cache.load(\u0026checksum);\n\n        let cached_module = cached_result.unwrap();\n        let import_object = imports! {};\n        let instance = cached_module.instantiate(\u0026import_object).unwrap();\n        let add_one: Func\u003ci32, i32\u003e = instance.exports.get(\"add_one\").unwrap();\n\n        let value = add_one.call(42).unwrap();\n\n        // verify it works\n        assert_eq!(value, 43);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":45},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","seed.rs"],"content":"use enclave_ffi_types::HealthCheckResult;\nuse sgx_types::*;\n\nuse log::{debug, info};\n\nuse crate::enclave::get_enclave;\n\nextern \"C\" {\n    pub fn ecall_init_node(\n        eid: sgx_enclave_id_t,\n        retval: *mut sgx_status_t,\n        master_cert: *const u8,\n        master_cert_len: u32,\n        encrypted_seed: *const u8,\n        encrypted_seed_len: u32,\n    ) -\u003e sgx_status_t;\n\n    pub fn ecall_init_bootstrap(\n        eid: sgx_enclave_id_t,\n        retval: *mut sgx_status_t,\n        public_key: \u0026mut [u8; 32],\n        spid: *const u8,\n        spid_len: u32,\n        api_key: *const u8,\n        api_key_len: u32,\n    ) -\u003e sgx_status_t;\n\n    pub fn ecall_key_gen(\n        eid: sgx_enclave_id_t,\n        retval: *mut sgx_status_t,\n        public_key: \u0026mut [u8; 32],\n    ) -\u003e sgx_status_t;\n\n    /// Trigger a query method in a wasm contract\n    pub fn ecall_health_check(\n        eid: sgx_enclave_id_t,\n        retval: *mut HealthCheckResult,\n    ) -\u003e sgx_status_t;\n}\n\npub fn untrusted_health_check() -\u003e SgxResult\u003cHealthCheckResult\u003e {\n    //info!(\"Initializing enclave..\");\n    let enclave = get_enclave()?;\n    //debug!(\"Initialized enclave successfully!\");\n\n    let eid = enclave.geteid();\n    let mut ret = HealthCheckResult::default();\n\n    let status = unsafe { ecall_health_check(eid, \u0026mut ret) };\n\n    if status != sgx_status_t::SGX_SUCCESS {\n        return Err(status);\n    }\n\n    Ok(ret)\n}\n\npub fn untrusted_init_node(master_cert: \u0026[u8], encrypted_seed: \u0026[u8]) -\u003e SgxResult\u003c()\u003e {\n    info!(\"Initializing enclave..\");\n    let enclave = get_enclave()?;\n    info!(\"Initialized enclave successfully!\");\n\n    let eid = enclave.geteid();\n    let mut ret = sgx_status_t::SGX_SUCCESS;\n\n    let status = unsafe {\n        ecall_init_node(\n            eid,\n            \u0026mut ret,\n            master_cert.as_ptr(),\n            master_cert.len() as u32,\n            encrypted_seed.as_ptr(),\n            encrypted_seed.len() as u32,\n        )\n    };\n\n    if status != sgx_status_t::SGX_SUCCESS {\n        return Err(status);\n    }\n\n    if ret != sgx_status_t::SGX_SUCCESS {\n        return Err(ret);\n    }\n\n    Ok(())\n}\n\npub fn untrusted_key_gen() -\u003e SgxResult\u003c[u8; 32]\u003e {\n    info!(\"Initializing enclave..\");\n    let enclave = get_enclave()?;\n    info!(\"Initialized enclave successfully!\");\n\n    let eid = enclave.geteid();\n    let mut retval = sgx_status_t::SGX_SUCCESS;\n    let mut public_key = [0u8; 32];\n    // let status = unsafe { ecall_get_encrypted_seed(eid, \u0026mut retval, cert, cert_len, \u0026 mut seed) };\n    let status = unsafe { ecall_key_gen(eid, \u0026mut retval, \u0026mut public_key) };\n\n    if status != sgx_status_t::SGX_SUCCESS {\n        return Err(status);\n    }\n\n    if retval != sgx_status_t::SGX_SUCCESS {\n        return Err(retval);\n    }\n\n    Ok(public_key)\n}\n\npub fn untrusted_init_bootstrap(spid: \u0026[u8], api_key: \u0026[u8]) -\u003e SgxResult\u003c[u8; 32]\u003e {\n    info!(\"Hello from just before initializing - untrusted_init_bootstrap\");\n    let enclave = get_enclave()?;\n    info!(\"Hello from just after initializing - untrusted_init_bootstrap\");\n\n    let eid = enclave.geteid();\n    let mut retval = sgx_status_t::SGX_SUCCESS;\n    let mut public_key = [0u8; 32];\n    // let status = unsafe { ecall_get_encrypted_seed(eid, \u0026mut retval, cert, cert_len, \u0026 mut seed) };\n    let status = unsafe {\n        ecall_init_bootstrap(\n            eid,\n            \u0026mut retval,\n            \u0026mut public_key,\n            spid.as_ptr(),\n            spid.len() as u32,\n            api_key.as_ptr(),\n            api_key.len() as u32,\n        )\n    };\n\n    if status != sgx_status_t::SGX_SUCCESS {\n        return Err(status);\n    }\n\n    if retval != sgx_status_t::SGX_SUCCESS {\n        return Err(retval);\n    }\n\n    Ok(public_key)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","serde.rs"],"content":"//! This file simply re-exports some methods from serde_json\n//! The reason is two fold:\n//! 1. To easily ensure that all calling libraries use the same version (minimize code size)\n//! 2. To allow us to switch out to eg. serde-json-core more easily\nuse serde::{Deserialize, Serialize};\nuse std::any::type_name;\n\nuse crate::errors::{VmError, VmResult};\n\npub fn from_slice\u003c'a, T\u003e(value: \u0026'a [u8]) -\u003e VmResult\u003cT\u003e\nwhere\n    T: Deserialize\u003c'a\u003e,\n{\n    serde_json::from_slice(value).map_err(|e| VmError::parse_err(type_name::\u003cT\u003e(), e))\n}\n\npub fn to_vec\u003cT\u003e(data: \u0026T) -\u003e VmResult\u003cVec\u003cu8\u003e\u003e\nwhere\n    T: Serialize + ?Sized,\n{\n    serde_json::to_vec(data).map_err(|e| VmError::serialize_err(type_name::\u003cT\u003e(), e))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","testing","calls.rs"],"content":"//! This file has some helpers for integration tests.\n//! They should be imported via full path to ensure there is no confusion\n//! use cosmwasm_vm::testing::X\n\n/*\nuse schemars::JsonSchema;\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::fmt;\n\nuse cosmwasm_std::{\n    to_vec, Env, HandleResult, InitResult, MigrateResult, QueryResponse, StdResult,\n};\n\nuse crate::calls::{call_handle, call_init, call_migrate, call_query};\nuse crate::instance::Instance;\nuse crate::{Api, Querier, Storage};\n\n// init mimicks the call signature of the smart contracts.\n// thus it moves env and msg rather than take them as reference.\n// this is inefficient here, but only used in test code\npub fn init\u003cS, A, Q, M, U\u003e(instance: \u0026mut Instance\u003cS, A, Q\u003e, env: Env, msg: M) -\u003e InitResult\u003cU\u003e\nwhere\n    S: Storage + 'static,\n    A: Api + 'static,\n    Q: Querier + 'static,\n    M: Serialize + JsonSchema,\n    U: DeserializeOwned + Clone + PartialEq + JsonSchema + fmt::Debug,\n{\n    let serialized_msg = to_vec(\u0026msg)?;\n    call_init(instance, \u0026env, \u0026serialized_msg).expect(\"VM error\")\n}\n\n// handle mimicks the call signature of the smart contracts.\n// thus it moves env and msg rather than take them as reference.\n// this is inefficient here, but only used in test code\npub fn handle\u003cS, A, Q, M, U\u003e(instance: \u0026mut Instance\u003cS, A, Q\u003e, env: Env, msg: M) -\u003e HandleResult\u003cU\u003e\nwhere\n    S: Storage + 'static,\n    A: Api + 'static,\n    Q: Querier + 'static,\n    M: Serialize + JsonSchema,\n    U: DeserializeOwned + Clone + PartialEq + JsonSchema + fmt::Debug,\n{\n    let serialized_msg = to_vec(\u0026msg)?;\n    call_handle(instance, \u0026env, \u0026serialized_msg).expect(\"VM error\")\n}\n\n// migrate mimicks the call signature of the smart contracts.\n// thus it moves env and msg rather than take them as reference.\n// this is inefficient here, but only used in test code\npub fn migrate\u003cS, A, Q, M, U\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n    env: Env,\n    msg: M,\n) -\u003e MigrateResult\u003cU\u003e\nwhere\n    S: Storage + 'static,\n    A: Api + 'static,\n    Q: Querier + 'static,\n    M: Serialize + JsonSchema,\n    U: DeserializeOwned + Clone + PartialEq + JsonSchema + fmt::Debug,\n{\n    let serialized_msg = to_vec(\u0026msg)?;\n    call_migrate(instance, \u0026env, \u0026serialized_msg).expect(\"VM error\")\n}\n\n// query mimicks the call signature of the smart contracts.\n// thus it moves env and msg rather than take them as reference.\n// this is inefficient here, but only used in test code\npub fn query\u003cS, A, Q, M\u003e(instance: \u0026mut Instance\u003cS, A, Q\u003e, msg: M) -\u003e StdResult\u003cQueryResponse\u003e\nwhere\n    S: Storage + 'static,\n    A: Api + 'static,\n    Q: Querier + 'static,\n    M: Serialize + JsonSchema,\n{\n    let serialized_msg = to_vec(\u0026msg)?;\n    call_query(instance, \u0026serialized_msg).expect(\"VM error\")\n}\n*/\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","testing","instance.rs"],"content":"//! This file has some helpers for integration tests.\n//! They should be imported via full path to ensure there is no confusion\n//! use cosmwasm_vm::testing::X\nuse cosmwasm_std::{Coin, HumanAddr};\nuse std::collections::HashSet;\n\nuse crate::compatability::check_wasm;\nuse crate::features::features_from_csv;\nuse crate::instance::Instance;\nuse crate::Extern;\n\nuse super::mock::{MockApi, MOCK_CONTRACT_ADDR};\nuse super::querier::MockQuerier;\nuse super::storage::MockStorage;\n\npub fn mock_instance(\n    wasm: \u0026[u8],\n    contract_balance: \u0026[Coin],\n) -\u003e Instance\u003cMockStorage, MockApi, MockQuerier\u003e {\n    mock_instance_with_options(\n        wasm,\n        MockInstanceOptions {\n            contract_balance: Some(contract_balance),\n            ..Default::default()\n        },\n    )\n}\n\npub fn mock_instance_with_failing_api(\n    wasm: \u0026[u8],\n    contract_balance: \u0026[Coin],\n    backend_error: \u0026'static str,\n) -\u003e Instance\u003cMockStorage, MockApi, MockQuerier\u003e {\n    mock_instance_with_options(\n        wasm,\n        MockInstanceOptions {\n            contract_balance: Some(contract_balance),\n            backend_error: Some(backend_error),\n            ..Default::default()\n        },\n    )\n}\n\npub fn mock_instance_with_balances(\n    wasm: \u0026[u8],\n    balances: \u0026[(\u0026HumanAddr, \u0026[Coin])],\n) -\u003e Instance\u003cMockStorage, MockApi, MockQuerier\u003e {\n    mock_instance_with_options(\n        wasm,\n        MockInstanceOptions {\n            balances,\n            ..Default::default()\n        },\n    )\n}\n\npub fn mock_instance_with_gas_limit(\n    wasm: \u0026[u8],\n    gas_limit: u64,\n) -\u003e Instance\u003cMockStorage, MockApi, MockQuerier\u003e {\n    mock_instance_with_options(\n        wasm,\n        MockInstanceOptions {\n            gas_limit,\n            ..Default::default()\n        },\n    )\n}\n\n#[derive(Debug)]\npub struct MockInstanceOptions\u003c'a\u003e {\n    // dependencies\n    pub canonical_address_length: usize,\n    pub balances: \u0026'a [(\u0026'a HumanAddr, \u0026'a [Coin])],\n    /// This option is merged into balances and might override an existing value\n    pub contract_balance: Option\u003c\u0026'a [Coin]\u003e,\n    /// When set, all calls to the API fail with FfiError::Unknown containing this message\n    pub backend_error: Option\u003c\u0026'static str\u003e,\n\n    // instance\n    pub supported_features: HashSet\u003cString\u003e,\n    pub gas_limit: u64,\n}\n\nimpl Default for MockInstanceOptions\u003c'_\u003e {\n    fn default() -\u003e Self {\n        Self {\n            // dependencies\n            canonical_address_length: 20,\n            balances: Default::default(),\n            contract_balance: Default::default(),\n            backend_error: None,\n\n            // instance\n            supported_features: features_from_csv(\"staking\"),\n            gas_limit: 500_000,\n        }\n    }\n}\n\npub fn mock_instance_with_options(\n    wasm: \u0026[u8],\n    options: MockInstanceOptions,\n) -\u003e Instance\u003cMockStorage, MockApi, MockQuerier\u003e {\n    check_wasm(wasm, \u0026options.supported_features).unwrap();\n    let contract_address = HumanAddr::from(MOCK_CONTRACT_ADDR);\n\n    // merge balances\n    let mut balances = options.balances.to_vec();\n    if let Some(contract_balance) = options.contract_balance {\n        // Remove old entry if exists\n        if let Some(pos) = balances.iter().position(|item| *item.0 == contract_address) {\n            balances.remove(pos);\n        }\n        balances.push((\u0026contract_address, contract_balance));\n    }\n\n    let api = if let Some(backend_error) = options.backend_error {\n        MockApi::new_failing(options.canonical_address_length, backend_error)\n    } else {\n        MockApi::new(options.canonical_address_length)\n    };\n\n    let deps = Extern {\n        storage: MockStorage::default(),\n        querier: MockQuerier::new(\u0026balances),\n        api,\n    };\n    Instance::from_code(wasm, deps, options.gas_limit).unwrap()\n}\n\n/// Runs a series of IO tests, hammering especially on allocate and deallocate.\n/// This could be especially useful when run with some kind of leak detector.\n#[cfg(not(feature = \"default-enclave\"))]\npub fn test_io\u003cS: Storage + 'static, A: Api + 'static, Q: Querier + 'static\u003e(\n    instance: \u0026mut Instance\u003cS, A, Q\u003e,\n) {\n    let sizes: Vec\u003cusize\u003e = vec![0, 1, 3, 10, 200, 2000, 5 * 1024];\n    let bytes: Vec\u003cu8\u003e = vec![0x00, 0xA5, 0xFF];\n\n    for size in sizes.into_iter() {\n        for byte in bytes.iter() {\n            let original = vec![*byte; size];\n            let wasm_ptr = instance\n                .allocate(original.len())\n                .expect(\"Could not allocate memory\");\n            instance\n                .write_memory(wasm_ptr, \u0026original)\n                .expect(\"Could not write data\");\n            let wasm_data = instance.read_memory(wasm_ptr, size).expect(\"error reading\");\n            assert_eq!(\n                original, wasm_data,\n                \"failed for size {}; expected: {:?}; actual: {:?}\",\n                size, original, wasm_data\n            );\n            instance\n                .deallocate(wasm_ptr)\n                .expect(\"Could not deallocate memory\");\n        }\n    }\n}\n","traces":[{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","testing","mock.rs"],"content":"use cosmwasm_std::{\n    Binary, BlockInfo, CanonicalAddr, Coin, ContractInfo, Env, HumanAddr, MessageInfo,\n};\n\nuse super::querier::MockQuerier;\nuse super::storage::MockStorage;\nuse crate::{Api, Extern, FfiError, FfiResult, GasInfo};\n\npub const MOCK_CONTRACT_ADDR: \u0026str = \"cosmos2contract\";\nconst GAS_COST_HUMANIZE: u64 = 44;\nconst GAS_COST_CANONICALIZE: u64 = 55;\n\n/// All external requirements that can be injected for unit tests.\n/// It sets the given balance for the contract itself, nothing else\npub fn mock_dependencies(\n    canonical_length: usize,\n    contract_balance: \u0026[Coin],\n) -\u003e Extern\u003cMockStorage, MockApi, MockQuerier\u003e {\n    let contract_addr = HumanAddr::from(MOCK_CONTRACT_ADDR);\n    Extern {\n        storage: MockStorage::default(),\n        api: MockApi::new(canonical_length),\n        querier: MockQuerier::new(\u0026[(\u0026contract_addr, contract_balance)]),\n    }\n}\n\n/// Initializes the querier along with the mock_dependencies.\n/// Sets all balances provided (yoy must explicitly set contract balance if desired)\npub fn mock_dependencies_with_balances(\n    canonical_length: usize,\n    balances: \u0026[(\u0026HumanAddr, \u0026[Coin])],\n) -\u003e Extern\u003cMockStorage, MockApi, MockQuerier\u003e {\n    Extern {\n        storage: MockStorage::default(),\n        api: MockApi::new(canonical_length),\n        querier: MockQuerier::new(balances),\n    }\n}\n\n/// Zero-pads all human addresses to make them fit the canonical_length and\n/// trims off zeros for the reverse operation.\n/// This is not really smart, but allows us to see a difference (and consistent length for canonical adddresses).\n#[derive(Copy, Clone)]\npub struct MockApi {\n    canonical_length: usize,\n    /// When set, all calls to the API fail with FfiError::Unknown containing this message\n    backend_error: Option\u003c\u0026'static str\u003e,\n}\n\nimpl MockApi {\n    pub fn new(canonical_length: usize) -\u003e Self {\n        MockApi {\n            canonical_length,\n            backend_error: None,\n        }\n    }\n\n    pub fn new_failing(canonical_length: usize, backend_error: \u0026'static str) -\u003e Self {\n        MockApi {\n            canonical_length,\n            backend_error: Some(backend_error),\n        }\n    }\n}\n\nimpl Default for MockApi {\n    fn default() -\u003e Self {\n        Self::new(20)\n    }\n}\n\nimpl Api for MockApi {\n    fn canonical_address(\u0026self, human: \u0026HumanAddr) -\u003e FfiResult\u003cCanonicalAddr\u003e {\n        let gas_info = GasInfo::with_cost(GAS_COST_CANONICALIZE);\n\n        if let Some(backend_error) = self.backend_error {\n            return (Err(FfiError::unknown(backend_error)), gas_info);\n        }\n\n        // Dummy input validation. This is more sophisticated for formats like bech32, where format and checksum are validated.\n        if human.len() \u003c 3 {\n            return (\n                Err(FfiError::user_err(\"Invalid input: human address too short\")),\n                gas_info,\n            );\n        }\n        if human.len() \u003e self.canonical_length {\n            return (\n                Err(FfiError::user_err(\"Invalid input: human address too long\")),\n                gas_info,\n            );\n        }\n\n        let mut out = Vec::from(human.as_str());\n        let append = self.canonical_length - out.len();\n        if append \u003e 0 {\n            out.extend(vec![0u8; append]);\n        }\n\n        (Ok(CanonicalAddr(Binary(out))), gas_info)\n    }\n\n    fn human_address(\u0026self, canonical: \u0026CanonicalAddr) -\u003e FfiResult\u003cHumanAddr\u003e {\n        let gas_info = GasInfo::with_cost(GAS_COST_HUMANIZE);\n\n        if let Some(backend_error) = self.backend_error {\n            return (Err(FfiError::unknown(backend_error)), gas_info);\n        }\n\n        if canonical.len() != self.canonical_length {\n            return (\n                Err(FfiError::user_err(\n                    \"Invalid input: canonical address length not correct\",\n                )),\n                gas_info,\n            );\n        }\n\n        // remove trailing 0's (TODO: fix this - but fine for first tests)\n        let trimmed: Vec\u003cu8\u003e = canonical\n            .as_slice()\n            .iter()\n            .cloned()\n            .filter(|\u0026x| x != 0)\n            .collect();\n\n        let result = match String::from_utf8(trimmed) {\n            Ok(human) =\u003e Ok(HumanAddr(human)),\n            Err(err) =\u003e Err(err.into()),\n        };\n        (result, gas_info)\n    }\n}\n\n/// Just set sender and sent funds for the message. The rest uses defaults.\n/// The sender will be canonicalized internally to allow developers pasing in human readable senders.\n/// This is intended for use in test code only.\npub fn mock_env\u003cU: Into\u003cHumanAddr\u003e\u003e(sender: U, sent: \u0026[Coin]) -\u003e Env {\n    Env {\n        block: BlockInfo {\n            height: 12_345,\n            time: 1_571_797_419,\n            chain_id: \"cosmos-testnet-14002\".to_string(),\n        },\n        message: MessageInfo {\n            sender: sender.into(),\n            sent_funds: sent.to_vec(),\n        },\n        contract: ContractInfo {\n            address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n        },\n        contract_key: Some(\"\".to_string()),\n        contract_code_hash: \"\".to_string(),\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::FfiError;\n    use cosmwasm_std::coins;\n\n    #[test]\n    fn mock_env_arguments() {\n        let name = HumanAddr(\"my name\".to_string());\n\n        // make sure we can generate with \u0026str, \u0026HumanAddr, and HumanAddr\n        let a = mock_env(\"my name\", \u0026coins(100, \"atom\"));\n        let b = mock_env(\u0026name, \u0026coins(100, \"atom\"));\n        let c = mock_env(name, \u0026coins(100, \"atom\"));\n\n        // and the results are the same\n        assert_eq!(a, b);\n        assert_eq!(a, c);\n    }\n\n    #[test]\n    fn flip_addresses() {\n        let api = MockApi::new(20);\n        let human = HumanAddr(\"shorty\".to_string());\n        let canon = api.canonical_address(\u0026human).0.unwrap();\n        assert_eq!(canon.len(), 20);\n        assert_eq!(\u0026canon.as_slice()[0..6], human.as_str().as_bytes());\n        assert_eq!(\u0026canon.as_slice()[6..], \u0026[0u8; 14]);\n\n        let (recovered, _gas_cost) = api.human_address(\u0026canon);\n        assert_eq!(recovered.unwrap(), human);\n    }\n\n    #[test]\n    fn human_address_input_length() {\n        let api = MockApi::new(10);\n        let input = CanonicalAddr(Binary(vec![61; 11]));\n        let (result, _gas_info) = api.human_address(\u0026input);\n        match result.unwrap_err() {\n            FfiError::UserErr { .. } =\u003e {}\n            err =\u003e panic!(\"Unexpected error: {:?}\", err),\n        }\n    }\n\n    #[test]\n    fn canonical_address_min_input_length() {\n        let api = MockApi::new(10);\n        let human = HumanAddr(\"1\".to_string());\n        match api.canonical_address(\u0026human).0.unwrap_err() {\n            FfiError::UserErr { .. } =\u003e {}\n            err =\u003e panic!(\"Unexpected error: {:?}\", err),\n        }\n    }\n\n    #[test]\n    fn canonical_address_max_input_length() {\n        let api = MockApi::new(10);\n        let human = HumanAddr(\"longer-than-10\".to_string());\n        match api.canonical_address(\u0026human).0.unwrap_err() {\n            FfiError::UserErr { .. } =\u003e {}\n            err =\u003e panic!(\"Unexpected error: {:?}\", err),\n        }\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":36},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","testing","mod.rs"],"content":"// The external interface is `use cosmwasm_vm::testing::X` for all integration testing symbols, no matter where they live internally.\n\nmod calls;\nmod instance;\nmod mock;\nmod querier;\nmod storage;\n\n/*\npub use calls::{handle, init, migrate, query};\n*/\npub use instance::{\n    mock_instance, mock_instance_with_balances, mock_instance_with_failing_api,\n    mock_instance_with_gas_limit, mock_instance_with_options, MockInstanceOptions,\n};\npub use mock::{\n    mock_dependencies, mock_dependencies_with_balances, mock_env, MockApi, MOCK_CONTRACT_ADDR,\n};\npub use querier::MockQuerier;\n#[cfg(feature = \"iterator\")]\npub use storage::MockIterator;\npub use storage::MockStorage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","testing","querier.rs"],"content":"use serde::{de::DeserializeOwned, Serialize};\n\nuse cosmwasm_std::testing::{MockQuerier as StdMockQuerier, MockQuerierCustomHandlerResult};\nuse cosmwasm_std::{\n    to_binary, to_vec, Binary, Coin, Empty, HumanAddr, Querier as _, QueryRequest, StdResult,\n    SystemError, SystemResult,\n};\n\nuse crate::{FfiError, FfiResult, GasInfo, Querier};\n\nconst GAS_COST_QUERY_FLAT: u64 = 100_000;\n/// Gas per request byte\nconst GAS_COST_QUERY_REQUEST_MULTIPLIER: u64 = 0;\n/// Gas per reponse byte\nconst GAS_COST_QUERY_RESPONSE_MULTIPLIER: u64 = 100;\n\n/// MockQuerier holds an immutable table of bank balances\n/// TODO: also allow querying contracts\npub struct MockQuerier\u003cC: DeserializeOwned = Empty\u003e {\n    querier: StdMockQuerier\u003cC\u003e,\n}\n\nimpl\u003cC: DeserializeOwned\u003e MockQuerier\u003cC\u003e {\n    pub fn new(balances: \u0026[(\u0026HumanAddr, \u0026[Coin])]) -\u003e Self {\n        MockQuerier {\n            querier: StdMockQuerier::new(balances),\n        }\n    }\n\n    // set a new balance for the given address and return the old balance\n    pub fn update_balance\u003cU: Into\u003cHumanAddr\u003e\u003e(\n        \u0026mut self,\n        addr: U,\n        balance: Vec\u003cCoin\u003e,\n    ) -\u003e Option\u003cVec\u003cCoin\u003e\u003e {\n        self.querier.update_balance(addr, balance)\n    }\n\n    #[cfg(feature = \"staking\")]\n    pub fn update_staking(\n        \u0026mut self,\n        denom: \u0026str,\n        validators: \u0026[cosmwasm_std::Validator],\n        delegations: \u0026[cosmwasm_std::FullDelegation],\n    ) {\n        self.querier.update_staking(denom, validators, delegations);\n    }\n\n    pub fn with_custom_handler\u003cCH: 'static\u003e(mut self, handler: CH) -\u003e Self\n    where\n        CH: Fn(\u0026C) -\u003e MockQuerierCustomHandlerResult,\n    {\n        self.querier = self.querier.with_custom_handler(handler);\n        self\n    }\n}\n\nimpl\u003cC: DeserializeOwned\u003e Querier for MockQuerier\u003cC\u003e {\n    fn query_raw(\n        \u0026self,\n        bin_request: \u0026[u8],\n        gas_limit: u64,\n    ) -\u003e FfiResult\u003cSystemResult\u003cStdResult\u003cBinary\u003e\u003e\u003e {\n        let response = self.querier.raw_query(bin_request);\n        let gas_info = GasInfo::with_externally_used(\n            GAS_COST_QUERY_FLAT\n                + (GAS_COST_QUERY_REQUEST_MULTIPLIER * (bin_request.len() as u64))\n                + (GAS_COST_QUERY_RESPONSE_MULTIPLIER\n                    * (to_binary(\u0026response).unwrap().len() as u64)),\n        );\n\n        // In a production implementation, this should stop the query execution in the middle of the computation.\n        // Thus no query response is returned to the caller.\n        if gas_info.externally_used \u003e gas_limit {\n            return (Err(FfiError::out_of_gas()), gas_info);\n        }\n\n        // We don't use FFI in the mock implementation, so FfiResult is always Ok() regardless of error on other levels\n        (Ok(response), gas_info)\n    }\n}\n\nimpl MockQuerier {\n    pub fn query\u003cT: Serialize\u003e(\n        \u0026self,\n        request: \u0026QueryRequest\u003cT\u003e,\n        gas_limit: u64,\n    ) -\u003e FfiResult\u003cSystemResult\u003cStdResult\u003cBinary\u003e\u003e\u003e {\n        // encode the request, then call raw_query\n        let request_binary = match to_vec(request) {\n            Ok(raw) =\u003e raw,\n            Err(err) =\u003e {\n                let gas_info = GasInfo::with_externally_used(err.to_string().len() as u64);\n                return (\n                    Ok(Err(SystemError::InvalidRequest {\n                        error: format!(\"Serializing query request: {}\", err),\n                        request: b\"N/A\".into(),\n                    })),\n                    gas_info,\n                );\n            }\n        };\n        self.query_raw(\u0026request_binary, gas_limit)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::{coin, from_binary, AllBalanceResponse, BalanceResponse, BankQuery, Empty};\n\n    const DEFAULT_QUERY_GAS_LIMIT: u64 = 300_000;\n\n    #[test]\n    fn query_raw_fails_when_out_of_gas() {\n        let addr = HumanAddr::from(\"foobar\");\n        let balance = vec![coin(123, \"ELF\"), coin(777, \"FLY\")];\n        let querier: MockQuerier\u003cEmpty\u003e = MockQuerier::new(\u0026[(\u0026addr, \u0026balance)]);\n\n        let gas_limit = 20;\n        let (result, _gas_info) = querier.query_raw(b\"broken request\", gas_limit);\n        match result.unwrap_err() {\n            FfiError::OutOfGas {} =\u003e {}\n            err =\u003e panic!(\"Unexpected error: {:?}\", err),\n        }\n    }\n\n    #[test]\n    fn bank_querier_all_balances() {\n        let addr = HumanAddr::from(\"foobar\");\n        let balance = vec![coin(123, \"ELF\"), coin(777, \"FLY\")];\n        let querier = MockQuerier::new(\u0026[(\u0026addr, \u0026balance)]);\n\n        // all\n        let all = querier\n            .query::\u003cEmpty\u003e(\n                \u0026BankQuery::AllBalances {\n                    address: addr.clone(),\n                }\n                .into(),\n                DEFAULT_QUERY_GAS_LIMIT,\n            )\n            .0\n            .unwrap()\n            .unwrap()\n            .unwrap();\n        let res: AllBalanceResponse = from_binary(\u0026all).unwrap();\n        assert_eq!(\u0026res.amount, \u0026balance);\n    }\n\n    #[test]\n    fn bank_querier_one_balance() {\n        let addr = HumanAddr::from(\"foobar\");\n        let balance = vec![coin(123, \"ELF\"), coin(777, \"FLY\")];\n        let querier = MockQuerier::new(\u0026[(\u0026addr, \u0026balance)]);\n\n        // one match\n        let fly = querier\n            .query::\u003cEmpty\u003e(\n                \u0026BankQuery::Balance {\n                    address: addr.clone(),\n                    denom: \"FLY\".to_string(),\n                }\n                .into(),\n                DEFAULT_QUERY_GAS_LIMIT,\n            )\n            .0\n            .unwrap()\n            .unwrap()\n            .unwrap();\n        let res: BalanceResponse = from_binary(\u0026fly).unwrap();\n        assert_eq!(res.amount, coin(777, \"FLY\"));\n\n        // missing denom\n        let miss = querier\n            .query::\u003cEmpty\u003e(\n                \u0026BankQuery::Balance {\n                    address: addr.clone(),\n                    denom: \"MISS\".to_string(),\n                }\n                .into(),\n                DEFAULT_QUERY_GAS_LIMIT,\n            )\n            .0\n            .unwrap()\n            .unwrap()\n            .unwrap();\n        let res: BalanceResponse = from_binary(\u0026miss).unwrap();\n        assert_eq!(res.amount, coin(0, \"MISS\"));\n    }\n\n    #[test]\n    fn bank_querier_missing_account() {\n        let addr = HumanAddr::from(\"foobar\");\n        let balance = vec![coin(123, \"ELF\"), coin(777, \"FLY\")];\n        let querier = MockQuerier::new(\u0026[(\u0026addr, \u0026balance)]);\n\n        // all balances on empty account is empty vec\n        let all = querier\n            .query::\u003cEmpty\u003e(\n                \u0026BankQuery::AllBalances {\n                    address: HumanAddr::from(\"elsewhere\"),\n                }\n                .into(),\n                DEFAULT_QUERY_GAS_LIMIT,\n            )\n            .0\n            .unwrap()\n            .unwrap()\n            .unwrap();\n        let res: AllBalanceResponse = from_binary(\u0026all).unwrap();\n        assert_eq!(res.amount, vec![]);\n\n        // any denom on balances on empty account is empty coin\n        let miss = querier\n            .query::\u003cEmpty\u003e(\n                \u0026BankQuery::Balance {\n                    address: HumanAddr::from(\"elsewhere\"),\n                    denom: \"ELF\".to_string(),\n                }\n                .into(),\n                DEFAULT_QUERY_GAS_LIMIT,\n            )\n            .0\n            .unwrap()\n            .unwrap()\n            .unwrap();\n        let res: BalanceResponse = from_binary(\u0026miss).unwrap();\n        assert_eq!(res.amount, coin(0, \"ELF\"));\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","testing","storage.rs"],"content":"use std::collections::BTreeMap;\n#[cfg(feature = \"iterator\")]\nuse std::ops::{Bound, RangeBounds};\n\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::{Order, KV};\n\n#[cfg(feature = \"iterator\")]\nuse crate::traits::StorageIterator;\nuse crate::{FfiResult, GasInfo, Storage};\n\n#[cfg(feature = \"iterator\")]\nconst GAS_COST_LAST_ITERATION: u64 = 37;\n\n#[cfg(feature = \"iterator\")]\nconst GAS_COST_RANGE: u64 = 11;\n\n/// A storage iterator for testing only. This type uses a Rust iterator\n/// as a data source, which does not provide a gas value for the last iteration.\n#[cfg(feature = \"iterator\")]\npub struct MockIterator\u003c'a\u003e {\n    source: Box\u003cdyn Iterator\u003cItem = (KV, u64)\u003e + 'a\u003e,\n}\n\n#[cfg(feature = \"iterator\")]\nimpl MockIterator\u003c'_\u003e {\n    pub fn empty() -\u003e Self {\n        MockIterator {\n            source: Box::new(std::iter::empty()),\n        }\n    }\n}\n\n#[cfg(feature = \"iterator\")]\nimpl StorageIterator for MockIterator\u003c'_\u003e {\n    fn next(\u0026mut self) -\u003e FfiResult\u003cOption\u003cKV\u003e\u003e {\n        match self.source.next() {\n            Some((kv, gas_used)) =\u003e (Ok(Some(kv)), GasInfo::with_externally_used(gas_used)),\n            None =\u003e (\n                Ok(None),\n                GasInfo::with_externally_used(GAS_COST_LAST_ITERATION),\n            ),\n        }\n    }\n}\n\n#[derive(Default, Debug)]\npub struct MockStorage {\n    data: BTreeMap\u003cVec\u003cu8\u003e, Vec\u003cu8\u003e\u003e,\n}\n\nimpl MockStorage {\n    pub fn new() -\u003e Self {\n        MockStorage::default()\n    }\n}\n\nimpl Storage for MockStorage {\n    fn get(\u0026self, key: \u0026[u8]) -\u003e FfiResult\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e {\n        let gas_info = GasInfo::with_externally_used(key.len() as u64);\n        (Ok(self.data.get(key).cloned()), gas_info)\n    }\n\n    #[cfg(feature = \"iterator\")]\n    /// range allows iteration over a set of keys, either forwards or backwards\n    /// uses standard rust range notation, and eg db.range(b\"foo\"..b\"bar\") also works reverse\n    fn range\u003c'a\u003e(\n        \u0026'a self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e FfiResult\u003cBox\u003cdyn StorageIterator + 'a\u003e\u003e {\n        let gas_info = GasInfo::with_externally_used(GAS_COST_RANGE);\n        let bounds = range_bounds(start, end);\n\n        // BTreeMap.range panics if range is start \u003e end.\n        // However, this cases represent just empty range and we treat it as such.\n        match (bounds.start_bound(), bounds.end_bound()) {\n            (Bound::Included(start), Bound::Excluded(end)) if start \u003e end =\u003e {\n                return (Ok(Box::new(MockIterator::empty())), gas_info);\n            }\n            _ =\u003e {}\n        }\n\n        let original_iter = self.data.range(bounds);\n        let iter: Box\u003cdyn Iterator\u003cItem = (KV, u64)\u003e\u003e = match order {\n            Order::Ascending =\u003e Box::new(original_iter.map(clone_item).map(|item| {\n                let gas_cost = (item.0.len() + item.1.len()) as u64;\n                (item, gas_cost)\n            })),\n            Order::Descending =\u003e Box::new(original_iter.rev().map(clone_item).map(|item| {\n                let gas_cost = (item.0.len() + item.1.len()) as u64;\n                (item, gas_cost)\n            })),\n        };\n        (Ok(Box::new(MockIterator { source: iter })), gas_info)\n    }\n\n    fn set(\u0026mut self, key: \u0026[u8], value: \u0026[u8]) -\u003e FfiResult\u003c()\u003e {\n        self.data.insert(key.to_vec(), value.to_vec());\n        let gas_info = GasInfo::with_externally_used((key.len() + value.len()) as u64);\n        (Ok(()), gas_info)\n    }\n\n    fn remove(\u0026mut self, key: \u0026[u8]) -\u003e FfiResult\u003c()\u003e {\n        self.data.remove(key);\n        let gas_info = GasInfo::with_externally_used(key.len() as u64);\n        (Ok(()), gas_info)\n    }\n}\n\n#[cfg(feature = \"iterator\")]\nfn range_bounds(start: Option\u003c\u0026[u8]\u003e, end: Option\u003c\u0026[u8]\u003e) -\u003e impl RangeBounds\u003cVec\u003cu8\u003e\u003e {\n    (\n        start.map_or(Bound::Unbounded, |x| Bound::Included(x.to_vec())),\n        end.map_or(Bound::Unbounded, |x| Bound::Excluded(x.to_vec())),\n    )\n}\n\n#[cfg(feature = \"iterator\")]\n/// The BTreeMap specific key-value pair reference type, as returned by BTreeMap\u003cVec\u003cu8\u003e, T\u003e::range.\n/// This is internal as it can change any time if the map implementation is swapped out.\ntype BTreeMapPairRef\u003c'a, T = Vec\u003cu8\u003e\u003e = (\u0026'a Vec\u003cu8\u003e, \u0026'a T);\n\n#[cfg(feature = \"iterator\")]\nfn clone_item\u003cT: Clone\u003e(item_ref: BTreeMapPairRef\u003cT\u003e) -\u003e KV\u003cT\u003e {\n    let (key, value) = item_ref;\n    (key.clone(), value.clone())\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn get_and_set() {\n        let mut store = MockStorage::new();\n        assert_eq!(None, store.get(b\"foo\").0.unwrap());\n        store.set(b\"foo\", b\"bar\").0.unwrap();\n        assert_eq!(Some(b\"bar\".to_vec()), store.get(b\"foo\").0.unwrap());\n        assert_eq!(None, store.get(b\"food\").0.unwrap());\n    }\n\n    #[test]\n    fn delete() {\n        let mut store = MockStorage::new();\n        store.set(b\"foo\", b\"bar\").0.unwrap();\n        store.set(b\"food\", b\"bank\").0.unwrap();\n        store.remove(b\"foo\").0.unwrap();\n\n        assert_eq!(None, store.get(b\"foo\").0.unwrap());\n        assert_eq!(Some(b\"bank\".to_vec()), store.get(b\"food\").0.unwrap());\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn iterator() {\n        let mut store = MockStorage::new();\n        store.set(b\"foo\", b\"bar\").0.expect(\"error setting value\");\n\n        // ensure we had previously set \"foo\" = \"bar\"\n        assert_eq!(store.get(b\"foo\").0.unwrap(), Some(b\"bar\".to_vec()));\n        assert_eq!(\n            store\n                .range(None, None, Order::Ascending)\n                .0\n                .unwrap()\n                .elements()\n                .unwrap()\n                .len(),\n            1\n        );\n\n        // setup - add some data, and delete part of it as well\n        store.set(b\"ant\", b\"hill\").0.expect(\"error setting value\");\n        store.set(b\"ze\", b\"bra\").0.expect(\"error setting value\");\n\n        // noise that should be ignored\n        store.set(b\"bye\", b\"bye\").0.expect(\"error setting value\");\n        store.remove(b\"bye\").0.expect(\"error removing key\");\n\n        // unbounded\n        {\n            let iter = store.range(None, None, Order::Ascending).0.unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                ]\n            );\n        }\n\n        // unbounded (descending)\n        {\n            let iter = store.range(None, None, Order::Descending).0.unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                ]\n            );\n        }\n\n        // bounded\n        {\n            let iter = store\n                .range(Some(b\"f\"), Some(b\"n\"), Order::Ascending)\n                .0\n                .unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(elements, vec![(b\"foo\".to_vec(), b\"bar\".to_vec())]);\n        }\n\n        // bounded (descending)\n        {\n            let iter = store\n                .range(Some(b\"air\"), Some(b\"loop\"), Order::Descending)\n                .0\n                .unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                ]\n            );\n        }\n\n        // bounded empty [a, a)\n        {\n            let iter = store\n                .range(Some(b\"foo\"), Some(b\"foo\"), Order::Ascending)\n                .0\n                .unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(elements, vec![]);\n        }\n\n        // bounded empty [a, a) (descending)\n        {\n            let iter = store\n                .range(Some(b\"foo\"), Some(b\"foo\"), Order::Descending)\n                .0\n                .unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(elements, vec![]);\n        }\n\n        // bounded empty [a, b) with b \u003c a\n        {\n            let iter = store\n                .range(Some(b\"z\"), Some(b\"a\"), Order::Ascending)\n                .0\n                .unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(elements, vec![]);\n        }\n\n        // bounded empty [a, b) with b \u003c a (descending)\n        {\n            let iter = store\n                .range(Some(b\"z\"), Some(b\"a\"), Order::Descending)\n                .0\n                .unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(elements, vec![]);\n        }\n\n        // right unbounded\n        {\n            let iter = store.range(Some(b\"f\"), None, Order::Ascending).0.unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                ]\n            );\n        }\n\n        // right unbounded (descending)\n        {\n            let iter = store.range(Some(b\"f\"), None, Order::Descending).0.unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                ]\n            );\n        }\n\n        // left unbounded\n        {\n            let iter = store.range(None, Some(b\"f\"), Order::Ascending).0.unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(elements, vec![(b\"ant\".to_vec(), b\"hill\".to_vec()),]);\n        }\n\n        // left unbounded (descending)\n        {\n            let iter = store.range(None, Some(b\"no\"), Order::Descending).0.unwrap();\n            let elements = iter.elements().unwrap();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                ]\n            );\n        }\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":37},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","traits.rs"],"content":"use cosmwasm_std::{Binary, CanonicalAddr, HumanAddr, StdResult, SystemResult};\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::{Order, KV};\n\n#[cfg(feature = \"iterator\")]\nuse crate::ffi::FfiError;\nuse crate::ffi::FfiResult;\n\n/// Holds all external dependencies of the contract.\n/// Designed to allow easy dependency injection at runtime.\n/// This cannot be copied or cloned since it would behave differently\n/// for mock storages and a bridge storage in the VM.\npub struct Extern\u003cS: Storage, A: Api, Q: Querier\u003e {\n    pub storage: S,\n    pub api: A,\n    pub querier: Q,\n}\n\nimpl\u003cS: Storage, A: Api, Q: Querier\u003e Extern\u003cS, A, Q\u003e {\n    /// change_querier is a helper mainly for test code when swapping out the Querier\n    /// from the auto-generated one from mock_dependencies. This changes the type of\n    /// Extern so replaces requires some boilerplate.\n    pub fn change_querier\u003cT: Querier, F: Fn(Q) -\u003e T\u003e(self, transform: F) -\u003e Extern\u003cS, A, T\u003e {\n        Extern {\n            storage: self.storage,\n            api: self.api,\n            querier: transform(self.querier),\n        }\n    }\n}\n\n#[cfg(feature = \"iterator\")]\npub trait StorageIterator {\n    fn next(\u0026mut self) -\u003e FfiResult\u003cOption\u003cKV\u003e\u003e;\n\n    /// Collects all elements, ignoring gas costs\n    fn elements(mut self) -\u003e Result\u003cVec\u003cKV\u003e, FfiError\u003e\n    where\n        Self: Sized,\n    {\n        let mut out: Vec\u003cKV\u003e = Vec::new();\n        loop {\n            let (result, _gas_info) = self.next();\n            match result {\n                Ok(Some(kv)) =\u003e out.push(kv),\n                Ok(None) =\u003e break,\n                Err(err) =\u003e return Err(err),\n            }\n        }\n        Ok(out)\n    }\n}\n\n#[cfg(feature = \"iterator\")]\nimpl\u003cI: StorageIterator + ?Sized\u003e StorageIterator for Box\u003cI\u003e {\n    fn next(\u0026mut self) -\u003e FfiResult\u003cOption\u003cKV\u003e\u003e {\n        (**self).next()\n    }\n}\n\n/// Access to the VM's backend storage, i.e. the chain\npub trait Storage\nwhere\n    Self: 'static,\n{\n    /// Returns Err on error.\n    /// Returns Ok(None) when key does not exist.\n    /// Returns Ok(Some(Vec\u003cu8\u003e)) when key exists.\n    ///\n    /// Note: Support for differentiating between a non-existent key and a key with empty value\n    /// is not great yet and might not be possible in all backends. But we're trying to get there.\n    fn get(\u0026self, key: \u0026[u8]) -\u003e FfiResult\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e;\n\n    #[cfg(feature = \"iterator\")]\n    /// Allows iteration over a set of key/value pairs, either forwards or backwards.\n    ///\n    /// The bound `start` is inclusive and `end` is exclusive.\n    ///\n    /// If `start` is lexicographically greater than or equal to `end`, an empty range is described, mo matter of the order.\n    fn range\u003c'a\u003e(\n        \u0026'a self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e FfiResult\u003cBox\u003cdyn StorageIterator + 'a\u003e\u003e;\n\n    fn set(\u0026mut self, key: \u0026[u8], value: \u0026[u8]) -\u003e FfiResult\u003c()\u003e;\n\n    /// Removes a database entry at `key`.\n    ///\n    /// The current interface does not allow to differentiate between a key that existed\n    /// before and one that didn't exist. See https://github.com/CosmWasm/cosmwasm/issues/290\n    fn remove(\u0026mut self, key: \u0026[u8]) -\u003e FfiResult\u003c()\u003e;\n}\n\n/// Api are callbacks to system functions defined outside of the wasm modules.\n/// This is a trait to allow Mocks in the test code.\n///\n/// Currently it just supports address conversion, we could add eg. crypto functions here.\n/// These should all be pure (stateless) functions. If you need state, you probably want\n/// to use the Querier.\n///\n/// We can use feature flags to opt-in to non-essential methods\n/// for backwards compatibility in systems that don't have them all.\npub trait Api: Copy + Clone + Send {\n    fn canonical_address(\u0026self, human: \u0026HumanAddr) -\u003e FfiResult\u003cCanonicalAddr\u003e;\n    fn human_address(\u0026self, canonical: \u0026CanonicalAddr) -\u003e FfiResult\u003cHumanAddr\u003e;\n}\n\npub trait Querier {\n    /// This is all that must be implemented for the Querier.\n    /// This allows us to pass through binary queries from one level to another without\n    /// knowing the custom format, or we can decode it, with the knowledge of the allowed\n    /// types.\n    ///\n    /// The gas limit describes how much VM gas this particular query is allowed\n    /// to comsume when measured separately from the rest of the contract.\n    /// The returned gas info (in FfiResult) can exceed the gas limit in cases\n    /// where the query could not be aborted exactly at the limit.\n    fn query_raw(\n        \u0026self,\n        request: \u0026[u8],\n        gas_limit: u64,\n    ) -\u003e FfiResult\u003cSystemResult\u003cStdResult\u003cBinary\u003e\u003e\u003e;\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","wasmi","exports.rs"],"content":"use enclave_ffi_types::{Ctx, EnclaveBuffer, OcallReturn, UntrustedVmError, UserSpaceBuffer};\nuse std::ffi::c_void;\n\nuse crate::context::{with_querier_from_context, with_storage_from_context};\nuse crate::{Querier, Storage, VmError, VmResult};\nuse cosmwasm_std::{Binary, StdResult, SystemResult};\n\n/// Copy a buffer from the enclave memory space, and return an opaque pointer to it.\n#[no_mangle]\npub extern \"C\" fn ocall_allocate(buffer: *const u8, length: usize) -\u003e UserSpaceBuffer {\n    let slice = unsafe { std::slice::from_raw_parts(buffer, length) };\n    let vector_copy = slice.to_vec();\n    let boxed_vector = Box::new(vector_copy);\n    let heap_pointer = Box::into_raw(boxed_vector);\n    UserSpaceBuffer {\n        ptr: heap_pointer as *mut c_void,\n    }\n}\n\n/// Take a pointer as returned by `ocall_allocate` and recover the Vec\u003cu8\u003e inside of it.\npub unsafe fn recover_buffer(ptr: UserSpaceBuffer) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n    if ptr.ptr.is_null() {\n        return None;\n    }\n    let boxed_vector = Box::from_raw(ptr.ptr as *mut Vec\u003cu8\u003e);\n    Some(*boxed_vector)\n}\n\n/// Read a key from the contracts key-value store.\n#[no_mangle]\npub extern \"C\" fn ocall_read_db(\n    context: Ctx,\n    vm_error: *mut UntrustedVmError,\n    gas_used: *mut u64,\n    value: *mut EnclaveBuffer,\n    key: *const u8,\n    key_len: usize,\n) -\u003e OcallReturn {\n    let key = unsafe { std::slice::from_raw_parts(key, key_len) };\n\n    let implementation = unsafe { get_implementations_from_context(\u0026context).read_db };\n\n    std::panic::catch_unwind(|| implementation(context, key))\n        // Get either an error(`OcallReturn`), or a response(`EnclaveBuffer`)\n        // which will be converted to a success status.\n        .map(|result| -\u003e Result\u003cEnclaveBuffer, OcallReturn\u003e {\n            match result {\n                Ok((value, gas_cost)) =\u003e {\n                    unsafe { *gas_used = gas_cost };\n                    value\n                        .map(|val| {\n                            super::allocate_enclave_buffer(\u0026val).map_err(|_| OcallReturn::Failure)\n                        })\n                        .unwrap_or_else(|| Ok(EnclaveBuffer::default()))\n                }\n                Err(err) =\u003e {\n                    unsafe { store_vm_error(err, vm_error) };\n                    Err(OcallReturn::Failure)\n                }\n            }\n        })\n        // Return the result or report the error\n        .map(|result| match result {\n            Ok(enclave_buffer) =\u003e {\n                unsafe { *value = enclave_buffer };\n                OcallReturn::Success\n            }\n            Err(err) =\u003e err,\n        })\n        // This will happen only when `catch_unwind` returns `Err`, which indicates a caught panic\n        .unwrap_or(OcallReturn::Panic)\n}\n\n/// Read a key from the contracts key-value store.\n#[no_mangle]\npub extern \"C\" fn ocall_query_chain(\n    context: Ctx,\n    vm_error: *mut UntrustedVmError,\n    gas_used: *mut u64,\n    gas_limit: u64,\n    value: *mut EnclaveBuffer,\n    query: *const u8,\n    query_len: usize,\n) -\u003e OcallReturn {\n    let query = unsafe { std::slice::from_raw_parts(query, query_len) };\n\n    let implementation = unsafe { get_implementations_from_context(\u0026context).query_chain };\n\n    std::panic::catch_unwind(|| implementation(context, query, gas_limit))\n        // Get either an error(`OcallReturn`), or a response(`EnclaveBuffer`)\n        // which will be converted to a success status.\n        .map(|answer| -\u003e Result\u003cEnclaveBuffer, OcallReturn\u003e {\n            match answer {\n                Ok((system_result, gas_cost)) =\u003e {\n                    unsafe { *gas_used = gas_cost };\n\n                    // wasm code expects to get this as Result\u003cResult\u003cBinary, StdError\u003e, SystemError\u003e which is called SystemResult\n                    // see CosmWasm's implementation https://github.com/enigmampc/SecretNetwork/blob/508e99c990dd656eb61f456584dab054487ba178/cosmwasm/packages/sgx-vm/src/imports.rs#L124\n\n                    crate::serde::to_vec(\u0026system_result)\n                        .map(|val| {\n                            super::allocate_enclave_buffer(\u0026val).map_err(|_| OcallReturn::Failure)\n                        })\n                        .unwrap_or_else(|_| Ok(EnclaveBuffer::default()))\n                }\n                Err(err) =\u003e {\n                    unsafe { store_vm_error(err, vm_error) };\n                    Err(OcallReturn::Failure)\n                }\n            }\n        })\n        // Return the result or report the error\n        .map(|result| match result {\n            Ok(enclave_buffer) =\u003e {\n                unsafe { *value = enclave_buffer };\n                OcallReturn::Success\n            }\n            Err(err) =\u003e err,\n        })\n        // This will happen only when `catch_unwind` returns `Err`, which indicates a caught panic\n        .unwrap_or(OcallReturn::Panic)\n}\n\n/// Remove a key from the contracts key-value store.\n#[no_mangle]\npub extern \"C\" fn ocall_remove_db(\n    context: Ctx,\n    vm_error: *mut UntrustedVmError,\n    gas_used: *mut u64,\n    key: *const u8,\n    key_len: usize,\n) -\u003e OcallReturn {\n    let key = unsafe { std::slice::from_raw_parts(key, key_len) };\n\n    let implementation = unsafe { get_implementations_from_context(\u0026context).remove_db };\n\n    // We explicitly ignore this potential panic here because we have no way of handling it at the moment.\n    // In the future, if we see that panics do occur here, we should add a way to report this to the enclave.\n    // TODO add logging if we fail to write\n    std::panic::catch_unwind(|| match implementation(context, key) {\n        Ok(gas_cost) =\u003e {\n            unsafe { *gas_used = gas_cost };\n            OcallReturn::Success\n        }\n        Err(err) =\u003e {\n            unsafe { store_vm_error(err, vm_error) };\n            OcallReturn::Failure\n        }\n    })\n    // This will happen only when `catch_unwind` returns `Err`, which indicates a caught panic\n    .unwrap_or(OcallReturn::Panic)\n}\n\n/// Write a value to the contracts key-value store.\n#[no_mangle]\npub extern \"C\" fn ocall_write_db(\n    context: Ctx,\n    vm_error: *mut UntrustedVmError,\n    gas_used: *mut u64,\n    key: *const u8,\n    key_len: usize,\n    value: *const u8,\n    value_len: usize,\n) -\u003e OcallReturn {\n    let key = unsafe { std::slice::from_raw_parts(key, key_len) };\n    let value = unsafe { std::slice::from_raw_parts(value, value_len) };\n\n    let implementation = unsafe { get_implementations_from_context(\u0026context).write_db };\n\n    // We explicitly ignore this potential panic here because we have no way of handling it at the moment.\n    // In the future, if we see that panics do occur here, we should add a way to report this to the enclave.\n    // TODO add logging if we fail to write\n    std::panic::catch_unwind(|| match implementation(context, key, value) {\n        Ok(gas_cost) =\u003e {\n            unsafe { *gas_used = gas_cost };\n            OcallReturn::Success\n        }\n        Err(err) =\u003e {\n            unsafe { store_vm_error(err, vm_error) };\n            OcallReturn::Failure\n        }\n    })\n    // This will happen only when `catch_unwind` returns `Err`, which indicates a caught panic\n    .unwrap_or(OcallReturn::Panic)\n}\n\n/// Box the error and return a pointer to it.\n/// This box will be recovered on the side that called the enclave.\n///\n/// # Safety\n/// Make sure that the pointer is valid\nunsafe fn store_vm_error(vm_err: VmError, location: *mut UntrustedVmError) {\n    let boxed_err = Box::new(vm_err);\n    let err_ptr = Box::leak(boxed_err) as *mut _ as *mut c_void;\n    *location = UntrustedVmError::new(err_ptr);\n}\n\n/// This type allows us to dynamically dispatch on the ocall side based on the generic implementation that the\n/// original caller requested, without any downcasting magic.\n/// The side that calls into the enclave will call the `new()` method with the Generic arguments that are\n/// appropriate for it.\n#[allow(clippy::type_complexity)]\nstruct ExportImplementations {\n    read_db: fn(context: Ctx, key: \u0026[u8]) -\u003e VmResult\u003c(Option\u003cVec\u003cu8\u003e\u003e, u64)\u003e,\n    query_chain: fn(\n        context: Ctx,\n        query: \u0026[u8],\n        gas_limit: u64,\n    ) -\u003e VmResult\u003c(SystemResult\u003cStdResult\u003cBinary\u003e\u003e, u64)\u003e,\n    remove_db: fn(context: Ctx, key: \u0026[u8]) -\u003e VmResult\u003cu64\u003e,\n    write_db: fn(context: Ctx, key: \u0026[u8], value: \u0026[u8]) -\u003e VmResult\u003cu64\u003e,\n}\n\nimpl ExportImplementations {\n    fn new\u003cS, Q\u003e() -\u003e Self\n    where\n        S: Storage,\n        Q: Querier,\n    {\n        Self {\n            read_db: ocall_read_db_impl::\u003cS, Q\u003e,\n            query_chain: ocall_query_chain_impl::\u003cS, Q\u003e,\n            remove_db: ocall_remove_db_impl::\u003cS, Q\u003e,\n            write_db: ocall_write_db_impl::\u003cS, Q\u003e,\n        }\n    }\n}\n\n/// This type is a wrapper for the `*mut c_void` that the original `cosmwasm_vm` implementation used to provide to\n/// the wasmer context object. It's a pointer to the `ContextData` type.\n/// We also add pointers to the concrete monomorphization of the generic implementation of the imports.\n/// This allows us to keep a minimal diff from the original codebase, by using most of their infrastructure,\n/// and allowing us to pull in future changes.\npub(crate) struct FullContext {\n    pub(crate) context_data: *mut c_void,\n    implementation: ExportImplementations,\n}\n\nimpl FullContext {\n    pub(crate) fn new\u003cS, Q\u003e(context_data: *mut c_void) -\u003e Self\n    where\n        S: Storage,\n        Q: Querier,\n    {\n        Self {\n            context_data,\n            implementation: ExportImplementations::new::\u003cS, Q\u003e(),\n        }\n    }\n}\n\n/// This function assumes all pointers in the `Ctx` are valid\nunsafe fn get_implementations_from_context(context: \u0026Ctx) -\u003e \u0026ExportImplementations {\n    \u0026(*(context.data as *mut FullContext)).implementation\n}\n\nfn ocall_read_db_impl\u003cS, Q\u003e(mut context: Ctx, key: \u0026[u8]) -\u003e VmResult\u003c(Option\u003cVec\u003cu8\u003e\u003e, u64)\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n{\n    with_storage_from_context::\u003cS, Q, _, _\u003e(\u0026mut context, |storage: \u0026mut S| {\n        let (ffi_result, gas_info) = storage.get(key);\n        ffi_result\n            .map(|value| (value, gas_info.externally_used))\n            .map_err(Into::into)\n    })\n}\n\nfn ocall_query_chain_impl\u003cS, Q\u003e(\n    mut context: Ctx,\n    query: \u0026[u8],\n    gas_limit: u64,\n) -\u003e VmResult\u003c(SystemResult\u003cStdResult\u003cBinary\u003e\u003e, u64)\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n{\n    with_querier_from_context::\u003cS, Q, _, _\u003e(\u0026mut context, |querier: \u0026mut Q| {\n        let (ffi_result, gas_info) = querier.query_raw(query, gas_limit);\n        ffi_result\n            .map(|system_result| (system_result, gas_info.externally_used))\n            .map_err(Into::into)\n    })\n}\n\nfn ocall_remove_db_impl\u003cS, Q\u003e(mut context: Ctx, key: \u0026[u8]) -\u003e VmResult\u003cu64\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n{\n    with_storage_from_context::\u003cS, Q, _, _\u003e(\u0026mut context, |storage: \u0026mut S| {\n        let (ffi_result, gas_info) = storage.remove(key);\n        ffi_result\n            .and(Ok(gas_info.externally_used))\n            .map_err(Into::into)\n    })\n}\n\nfn ocall_write_db_impl\u003cS, Q\u003e(mut context: Ctx, key: \u0026[u8], value: \u0026[u8]) -\u003e VmResult\u003cu64\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n{\n    with_storage_from_context::\u003cS, Q, _, _\u003e(\u0026mut context, |storage: \u0026mut S| {\n        let (ffi_result, gas_info) = storage.set(key, value);\n        ffi_result\n            .and(Ok(gas_info.externally_used))\n            .map_err(Into::into)\n    })\n}\n","traces":[{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","wasmi","imports.rs"],"content":"//! This file should be autogenerated based on the headers created from the .edl file.\n\nuse enclave_ffi_types::{Ctx, EnclaveBuffer, HandleResult, InitResult, QueryResult};\nuse sgx_types::{sgx_enclave_id_t, sgx_status_t};\n\nextern \"C\" {\n    /// Copy a buffer into the enclave memory space, and receive an opaque pointer to it.\n    pub fn ecall_allocate(\n        eid: sgx_enclave_id_t,\n        retval: *mut EnclaveBuffer,\n        buffer: *const u8,\n        length: usize,\n    ) -\u003e sgx_status_t;\n\n    /// Trigger the init method in a wasm contract\n    pub fn ecall_init(\n        eid: sgx_enclave_id_t,\n        retval: *mut InitResult,\n        context: Ctx,\n        gas_limit: u64,\n        used_gas: *mut u64,\n        contract: *const u8,\n        contract_len: usize,\n        env: *const u8,\n        env_len: usize,\n        msg: *const u8,\n        msg_len: usize,\n        sig_info: *const u8,\n        sig_info_len: usize,\n    ) -\u003e sgx_status_t;\n\n    /// Trigger a handle method in a wasm contract\n    pub fn ecall_handle(\n        eid: sgx_enclave_id_t,\n        retval: *mut HandleResult,\n        context: Ctx,\n        gas_limit: u64,\n        used_gas: *mut u64,\n        contract: *const u8,\n        contract_len: usize,\n        env: *const u8,\n        env_len: usize,\n        msg: *const u8,\n        msg_len: usize,\n        sig_info: *const u8,\n        sig_info_len: usize,\n    ) -\u003e sgx_status_t;\n\n    /// Trigger a query method in a wasm contract\n    pub fn ecall_query(\n        eid: sgx_enclave_id_t,\n        retval: *mut QueryResult,\n        context: Ctx,\n        gas_limit: u64,\n        used_gas: *mut u64,\n        contract: *const u8,\n        contract_len: usize,\n        msg: *const u8,\n        msg_len: usize,\n    ) -\u003e sgx_status_t;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","wasmi","mod.rs"],"content":"mod exports;\nmod imports;\nmod results;\nmod utils;\nmod wrapper;\n\npub(crate) use exports::FullContext;\npub use imports::*;\npub use wrapper::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","wasmi","results.rs"],"content":"use super::exports;\nuse crate::VmResult;\nuse enclave_ffi_types::{HandleResult, InitResult, QueryResult};\n\n/// This struct is returned from module initialization.\npub struct InitSuccess {\n    /// A pointer to the output of the execution\n    output: Vec\u003cu8\u003e,\n    /// The contract_key for this contract.\n    contract_key: [u8; 64],\n}\n\nimpl InitSuccess {\n    pub fn into_output(self) -\u003e Vec\u003cu8\u003e {\n        let mut out_vec = self.contract_key.to_vec();\n        out_vec.extend_from_slice(\u0026self.output);\n        out_vec\n    }\n}\n\npub fn init_result_to_vm_result(other: InitResult) -\u003e VmResult\u003cInitSuccess\u003e {\n    match other {\n        InitResult::Success {\n            output,\n            contract_key,\n        } =\u003e Ok(InitSuccess {\n            output: unsafe { exports::recover_buffer(output) }.unwrap_or_else(Vec::new),\n            contract_key,\n        }),\n        InitResult::Failure { err } =\u003e Err(err.into()),\n    }\n}\n\n/// This struct is returned from a handle method.\npub struct HandleSuccess {\n    /// A pointer to the output of the execution\n    output: Vec\u003cu8\u003e,\n}\n\nimpl HandleSuccess {\n    pub fn into_output(self) -\u003e Vec\u003cu8\u003e {\n        self.output\n    }\n}\n\npub fn handle_result_to_vm_result(other: HandleResult) -\u003e VmResult\u003cHandleSuccess\u003e {\n    match other {\n        HandleResult::Success { output } =\u003e Ok(HandleSuccess {\n            output: unsafe { exports::recover_buffer(output) }.unwrap_or_else(Vec::new),\n        }),\n        HandleResult::Failure { err } =\u003e Err(err.into()),\n    }\n}\n\n/// This struct is returned from a query method.\npub struct QuerySuccess {\n    /// A pointer to the output of the execution\n    output: Vec\u003cu8\u003e,\n}\n\nimpl QuerySuccess {\n    pub fn into_output(self) -\u003e Vec\u003cu8\u003e {\n        self.output\n    }\n}\n\npub fn query_result_to_vm_result(other: QueryResult) -\u003e VmResult\u003cQuerySuccess\u003e {\n    match other {\n        QueryResult::Success { output } =\u003e Ok(QuerySuccess {\n            output: unsafe { exports::recover_buffer(output) }.unwrap_or_else(Vec::new),\n        }),\n        QueryResult::Failure { err } =\u003e Err(err.into()),\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","wasmi","utils.rs"],"content":"//\n// pub fn retry_quote(eid: sgx_enclave_id_t, spid: \u0026str, times: usize) -\u003e Result\u003cString, Error\u003e {\n//     let mut quote = String::new();\n//     for _ in 0..times {\n//         quote = match produce_quote(eid, spid) {\n//             Ok(q) =\u003e q,\n//             Err(e) =\u003e {\n//                 println!(\"problem with quote, trying again: {:?}\", e);\n//                 continue;\n//             }\n//         };\n//\n//         if !quote.chars().all(|cur_c| cur_c == 'A') {\n//             return Ok(quote);\n//         } else {\n//             sleep(time::Duration::new(5, 0));\n//         }\n//     }\n//     Err(Error::SdkErr { inner: sgx_status_t::SGX_ERROR_SERVICE_UNAVAILABLE }.into())\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","sgx-vm","src","wasmi","wrapper.rs"],"content":"//! This module provides safe wrappers for the calls into the enclave running WASMI.\n\nuse std::ffi::c_void;\nuse std::marker::PhantomData;\nuse std::mem::MaybeUninit;\n\nuse crate::errors::{EnclaveError, VmResult};\nuse crate::{Querier, Storage};\n\nuse enclave_ffi_types::{Ctx, EnclaveBuffer, HandleResult, InitResult, QueryResult};\n\nuse sgx_types::{sgx_status_t, SgxResult};\nuse sgx_urts::SgxEnclave;\n\nuse log::*;\n\nuse super::exports::FullContext;\nuse super::imports;\nuse super::results::{\n    handle_result_to_vm_result, init_result_to_vm_result, query_result_to_vm_result, HandleSuccess,\n    InitSuccess, QuerySuccess,\n};\n\n/// This is a safe wrapper for allocating buffers inside the enclave.\npub(super) fn allocate_enclave_buffer(buffer: \u0026[u8]) -\u003e SgxResult\u003cEnclaveBuffer\u003e {\n    let ptr = buffer.as_ptr();\n    let len = buffer.len();\n    let mut enclave_buffer = EnclaveBuffer::default();\n\n    let enclave_id = crate::enclave::get_enclave()\n        .expect(\"If we got here, surely the enclave has been loaded\")\n        .geteid();\n\n    trace!(\n        target: module_path!(),\n        \"allocate_enclave_buffer() called with len: {:?} enclave_id: {:?}\",\n        len,\n        enclave_id,\n    );\n\n    match unsafe { imports::ecall_allocate(enclave_id, \u0026mut enclave_buffer, ptr, len) } {\n        sgx_status_t::SGX_SUCCESS =\u003e Ok(enclave_buffer),\n        failure_status =\u003e Err(failure_status),\n    }\n}\n\npub struct Module\u003cS, Q\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n{\n    bytecode: Vec\u003cu8\u003e,\n    gas_limit: u64,\n    used_gas: u64,\n    enclave: \u0026'static SgxEnclave,\n    ctx: Ctx,\n    finalizer: fn(*mut c_void),\n\n    // This does not store data but only fixes type information\n    type_storage: PhantomData\u003cS\u003e,\n    type_querier: PhantomData\u003cQ\u003e,\n}\n\nimpl\u003cS, Q\u003e Module\u003cS, Q\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n{\n    pub fn new(\n        bytecode: Vec\u003cu8\u003e,\n        gas_limit: u64,\n        enclave: \u0026'static SgxEnclave,\n        (data, finalizer): (*mut c_void, fn(*mut c_void)),\n    ) -\u003e Self {\n        // TODO add validation of this bytecode?\n\n        let data =\n            Box::leak(Box::new(FullContext::new::\u003cS, Q\u003e(data))) as *mut FullContext as *mut c_void;\n        let ctx = Ctx { data };\n        Self {\n            bytecode,\n            gas_limit,\n            used_gas: 0,\n            enclave,\n            ctx,\n            finalizer,\n            type_storage: Default::default(),\n            type_querier: Default::default(),\n        }\n    }\n\n    #[allow(unused)]\n    pub fn context(\u0026self) -\u003e \u0026Ctx {\n        \u0026self.ctx\n    }\n\n    pub fn context_mut(\u0026mut self) -\u003e \u0026mut Ctx {\n        \u0026mut self.ctx\n    }\n\n    pub fn gas_limit(\u0026self) -\u003e u64 {\n        self.gas_limit\n    }\n\n    pub fn gas_left(\u0026self) -\u003e u64 {\n        self.gas_limit.saturating_sub(self.used_gas)\n    }\n\n    pub fn gas_used(\u0026self) -\u003e u64 {\n        self.used_gas\n    }\n\n    pub fn init(\u0026mut self, env: \u0026[u8], msg: \u0026[u8], sig_info: \u0026[u8]) -\u003e VmResult\u003cInitSuccess\u003e {\n        trace!(\n            \"init() called with env: {:?} msg: {:?} enclave_id: {:?} gas_left: {}\",\n            String::from_utf8_lossy(env),\n            String::from_utf8_lossy(msg),\n            self.enclave.geteid(),\n            self.gas_left()\n        );\n\n        let mut init_result = MaybeUninit::\u003cInitResult\u003e::uninit();\n        let mut used_gas = 0_u64;\n\n        let status = unsafe {\n            imports::ecall_init(\n                self.enclave.geteid(),\n                init_result.as_mut_ptr(),\n                self.ctx.unsafe_clone(),\n                self.gas_left(),\n                \u0026mut used_gas,\n                self.bytecode.as_ptr(),\n                self.bytecode.len(),\n                env.as_ptr(),\n                env.len(),\n                msg.as_ptr(),\n                msg.len(),\n                sig_info.as_ptr(),\n                sig_info.len(),\n            )\n        };\n\n        trace!(\n            \"init() returned with gas_used: {} (gas_limit: {})\",\n            used_gas,\n            self.gas_limit\n        );\n        self.consume_gas(used_gas);\n\n        match status {\n            sgx_status_t::SGX_SUCCESS =\u003e {\n                let init_result = unsafe { init_result.assume_init() };\n                init_result_to_vm_result(init_result)\n            }\n            failure_status =\u003e Err(EnclaveError::sdk_err(failure_status).into()),\n        }\n    }\n\n    pub fn handle(\u0026mut self, env: \u0026[u8], msg: \u0026[u8], sig_info: \u0026[u8]) -\u003e VmResult\u003cHandleSuccess\u003e {\n        trace!(\n            \"handle() called with env: {:?} msg: {:?} enclave_id: {:?} gas_left: {}\",\n            String::from_utf8_lossy(env),\n            String::from_utf8_lossy(msg),\n            self.enclave.geteid(),\n            self.gas_left()\n        );\n\n        let mut handle_result = MaybeUninit::\u003cHandleResult\u003e::uninit();\n        let mut used_gas = 0_u64;\n\n        let status = unsafe {\n            imports::ecall_handle(\n                self.enclave.geteid(),\n                handle_result.as_mut_ptr(),\n                self.ctx.unsafe_clone(),\n                self.gas_left(),\n                \u0026mut used_gas,\n                self.bytecode.as_ptr(),\n                self.bytecode.len(),\n                env.as_ptr(),\n                env.len(),\n                msg.as_ptr(),\n                msg.len(),\n                sig_info.as_ptr(),\n                sig_info.len(),\n            )\n        };\n\n        trace!(\n            \"handle() returned with gas_used: {} (gas_limit: {})\",\n            used_gas,\n            self.gas_limit\n        );\n        self.consume_gas(used_gas);\n\n        match status {\n            sgx_status_t::SGX_SUCCESS =\u003e {\n                let handle_result = unsafe { handle_result.assume_init() };\n                handle_result_to_vm_result(handle_result)\n            }\n            failure_status =\u003e Err(EnclaveError::sdk_err(failure_status).into()),\n        }\n    }\n\n    pub fn query(\u0026mut self, msg: \u0026[u8]) -\u003e VmResult\u003cQuerySuccess\u003e {\n        trace!(\n            \"query() called with msg: {:?} enclave_id: {:?}\",\n            String::from_utf8_lossy(msg),\n            self.enclave.geteid()\n        );\n\n        let mut query_result = MaybeUninit::\u003cQueryResult\u003e::uninit();\n        let mut used_gas = 0_u64;\n\n        let status = unsafe {\n            imports::ecall_query(\n                self.enclave.geteid(),\n                query_result.as_mut_ptr(),\n                self.ctx.unsafe_clone(),\n                self.gas_left(),\n                \u0026mut used_gas,\n                self.bytecode.as_ptr(),\n                self.bytecode.len(),\n                msg.as_ptr(),\n                msg.len(),\n            )\n        };\n\n        trace!(\n            \"query() returned with gas_used: {} (gas_limit: {})\",\n            used_gas,\n            self.gas_limit\n        );\n        self.consume_gas(used_gas);\n\n        match status {\n            sgx_status_t::SGX_SUCCESS =\u003e {\n                let query_result = unsafe { query_result.assume_init() };\n                query_result_to_vm_result(query_result)\n            }\n            failure_status =\u003e Err(EnclaveError::sdk_err(failure_status).into()),\n        }\n    }\n\n    fn consume_gas(\u0026mut self, used_gas: u64) {\n        self.used_gas = self.used_gas.saturating_add(used_gas);\n    }\n}\n\nimpl\u003cS, Q\u003e Drop for Module\u003cS, Q\u003e\nwhere\n    S: Storage,\n    Q: Querier,\n{\n    fn drop(\u0026mut self) {\n        let context_data = unsafe { (*(self.ctx.data as *mut FullContext)).context_data };\n        (self.finalizer)(context_data);\n    }\n}\n","traces":[{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":105},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, export_schema_with_title, remove_schemas, schema_for};\nuse cosmwasm_std::{CosmosMsg, Env, HandleResult, InitResult, MigrateResult, QueryResult};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(Env), \u0026out_dir);\n    export_schema(\u0026schema_for!(CosmosMsg), \u0026out_dir);\n    export_schema_with_title(\u0026mut schema_for!(InitResult), \u0026out_dir, \"InitResult\");\n    export_schema_with_title(\u0026mut schema_for!(HandleResult), \u0026out_dir, \"HandleResult\");\n    export_schema_with_title(\u0026mut schema_for!(MigrateResult), \u0026out_dir, \"MigrateResult\");\n    export_schema_with_title(\u0026mut schema_for!(QueryResult), \u0026out_dir, \"QueryResult\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","addresses.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\nuse crate::encoding::Binary;\n\n// Added Eq and Hash to allow this to be a key in a HashMap (MockQuerier)\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq, JsonSchema, Hash)]\npub struct HumanAddr(pub String);\n\nimpl HumanAddr {\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        \u0026self.0\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.0.len()\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.0.is_empty()\n    }\n}\n\nimpl fmt::Display for HumanAddr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", \u0026self.0)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for HumanAddr {\n    fn from(addr: \u0026str) -\u003e Self {\n        HumanAddr(addr.to_string())\n    }\n}\n\nimpl From\u003c\u0026HumanAddr\u003e for HumanAddr {\n    fn from(addr: \u0026HumanAddr) -\u003e Self {\n        HumanAddr(addr.0.to_string())\n    }\n}\n\nimpl From\u003c\u0026\u0026HumanAddr\u003e for HumanAddr {\n    fn from(addr: \u0026\u0026HumanAddr) -\u003e Self {\n        HumanAddr(addr.0.to_string())\n    }\n}\n\nimpl From\u003cString\u003e for HumanAddr {\n    fn from(addr: String) -\u003e Self {\n        HumanAddr(addr)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, JsonSchema)]\npub struct CanonicalAddr(pub Binary);\n\nimpl From\u003c\u0026[u8]\u003e for CanonicalAddr {\n    fn from(source: \u0026[u8]) -\u003e Self {\n        Self(source.into())\n    }\n}\n\nimpl From\u003cVec\u003cu8\u003e\u003e for CanonicalAddr {\n    fn from(source: Vec\u003cu8\u003e) -\u003e Self {\n        Self(source.into())\n    }\n}\n\nimpl CanonicalAddr {\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.0.as_slice()\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.0.len()\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.0.is_empty()\n    }\n}\n\nimpl fmt::Display for CanonicalAddr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        self.0.fmt(f)\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","coins.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::math::Uint128;\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, JsonSchema)]\npub struct Coin {\n    pub denom: String,\n    pub amount: Uint128,\n}\n\nimpl Coin {\n    pub fn new(amount: u128, denom: \u0026str) -\u003e Self {\n        Coin {\n            amount: Uint128(amount),\n            denom: denom.to_string(),\n        }\n    }\n}\n\n// coins is a shortcut constructor for a set of one denomination of coins\npub fn coins(amount: u128, denom: \u0026str) -\u003e Vec\u003cCoin\u003e {\n    vec![coin(amount, denom)]\n}\n\n// coin is a shorthand constructor for Coin\npub fn coin(amount: u128, denom: \u0026str) -\u003e Coin {\n    Coin::new(amount, denom)\n}\n\n/// has_coins returns true if the list of coins has at least the required amount\npub fn has_coins(coins: \u0026[Coin], required: \u0026Coin) -\u003e bool {\n    coins\n        .iter()\n        .find(|c| c.denom == required.denom)\n        .map(|m| m.amount \u003e= required.amount)\n        .unwrap_or(false)\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn has_coins_matches() {\n        let wallet = vec![coin(12345, \"ETH\"), coin(555, \"BTC\")];\n\n        // less than same type\n        assert!(has_coins(\u0026wallet, \u0026coin(777, \"ETH\")));\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","encoding.rs"],"content":"use std::fmt;\n\nuse schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\n\nuse crate::errors::{StdError, StdResult};\n\n/// Binary is a wrapper around Vec\u003cu8\u003e to add base64 de/serialization\n/// with serde. It also adds some helper methods to help encode inline.\n///\n/// This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec\u003cu8\u003e\n#[derive(Clone, Default, Debug, PartialEq, JsonSchema)]\npub struct Binary(#[schemars(with = \"String\")] pub Vec\u003cu8\u003e);\n\nimpl Binary {\n    /// take an (untrusted) string and decode it into bytes.\n    /// fails if it is not valid base64\n    pub fn from_base64(encoded: \u0026str) -\u003e StdResult\u003cSelf\u003e {\n        let binary = base64::decode(\u0026encoded).map_err(StdError::invalid_base64)?;\n        Ok(Binary(binary))\n    }\n\n    /// encode to base64 string (guaranteed to be success as we control the data inside).\n    /// this returns normalized form (with trailing = if needed)\n    pub fn to_base64(\u0026self) -\u003e String {\n        base64::encode(\u0026self.0)\n    }\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        self.0.as_slice()\n    }\n    pub fn len(\u0026self) -\u003e usize {\n        self.0.len()\n    }\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.0.is_empty()\n    }\n}\n\nimpl fmt::Display for Binary {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.to_base64())\n    }\n}\n\nimpl From\u003c\u0026[u8]\u003e for Binary {\n    fn from(binary: \u0026[u8]) -\u003e Self {\n        Self(binary.to_vec())\n    }\n}\n\n// Macro needed until https://rust-lang.github.io/rfcs/2000-const-generics.html is stable.\n// See https://users.rust-lang.org/t/how-to-implement-trait-for-fixed-size-array-of-any-size/31494\nmacro_rules! implement_from_for_fixed_length_arrays {\n    ($($N:literal)+) =\u003e {\n        $(\n            // Reference\n            impl From\u003c\u0026[u8; $N]\u003e for Binary {\n                fn from(source: \u0026[u8; $N]) -\u003e Self {\n                    Self(source.to_vec())\n                }\n            }\n\n            // Owned\n            impl From\u003c[u8; $N]\u003e for Binary {\n                fn from(source: [u8; $N]) -\u003e Self {\n                    // Implementation available for $N \u003c= 32.\n                    // Requires https://caniuse.rs/features/vec_from_array, avaiable since Rust 1.44.0.\n                    Self(source.into())\n                }\n            }\n        )+\n    }\n}\n\nimplement_from_for_fixed_length_arrays! {\n     0  1  2  3  4  5  6  7  8  9\n    10 11 12 13 14 15 16 17 18 19\n    20 21 22 23 24 25 26 27 28 29\n    30 31 32\n}\n\nimpl From\u003cVec\u003cu8\u003e\u003e for Binary {\n    fn from(vec: Vec\u003cu8\u003e) -\u003e Self {\n        Self(vec)\n    }\n}\n\nimpl Into\u003cVec\u003cu8\u003e\u003e for Binary {\n    fn into(self) -\u003e Vec\u003cu8\u003e {\n        self.0\n    }\n}\n\n/// Serializes as a base64 string\nimpl Serialize for Binary {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_base64())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Binary {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cBinary, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Base64Visitor)\n    }\n}\n\nstruct Base64Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Base64Visitor {\n    type Value = Binary;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"valid base64 encoded string\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match Binary::from_base64(v) {\n            Ok(binary) =\u003e Ok(binary),\n            Err(_) =\u003e Err(E::custom(format!(\"invalid base64: {}\", v))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::errors::StdError;\n    use crate::serde::{from_slice, to_vec};\n\n    #[test]\n    fn encode_decode() {\n        let binary: \u0026[u8] = b\"hello\";\n        let encoded = Binary::from(binary).to_base64();\n        assert_eq!(8, encoded.len());\n        let decoded = Binary::from_base64(\u0026encoded).unwrap();\n        assert_eq!(binary, decoded.as_slice());\n    }\n\n    #[test]\n    fn encode_decode_non_ascii() {\n        let binary = vec![12u8, 187, 0, 17, 250, 1];\n        let encoded = Binary(binary.clone()).to_base64();\n        assert_eq!(8, encoded.len());\n        let decoded = Binary::from_base64(\u0026encoded).unwrap();\n        assert_eq!(binary.as_slice(), decoded.as_slice());\n    }\n\n    #[test]\n    fn from_valid_string() {\n        let valid_base64 = \"cmFuZG9taVo=\";\n        let binary = Binary::from_base64(valid_base64).unwrap();\n        assert_eq!(b\"randomiZ\", binary.as_slice());\n    }\n\n    // this accepts input without a trailing = but outputs normal form\n    #[test]\n    fn from_shortened_string() {\n        let short = \"cmFuZG9taVo\";\n        let long = \"cmFuZG9taVo=\";\n        let binary = Binary::from_base64(short).unwrap();\n        assert_eq!(b\"randomiZ\", binary.as_slice());\n        assert_eq!(long, binary.to_base64());\n    }\n\n    #[test]\n    fn from_invalid_string() {\n        let invalid_base64 = \"cm%uZG9taVo\";\n        let res = Binary::from_base64(invalid_base64);\n        match res.unwrap_err() {\n            StdError::InvalidBase64 { msg, .. } =\u003e assert_eq!(msg, \"Invalid byte 37, offset 2.\"),\n            _ =\u003e panic!(\"Unexpected error type\"),\n        }\n    }\n\n    #[test]\n    fn from_slice_works() {\n        let original: \u0026[u8] = \u0026[0u8, 187, 61, 11, 250, 0];\n        let binary: Binary = original.into();\n        assert_eq!(binary.as_slice(), [0u8, 187, 61, 11, 250, 0]);\n    }\n\n    #[test]\n    fn from_fixed_length_array_works() {\n        let original = \u0026[];\n        let binary: Binary = original.into();\n        assert_eq!(binary.len(), 0);\n\n        let original = \u0026[0u8];\n        let binary: Binary = original.into();\n        assert_eq!(binary.as_slice(), [0u8]);\n\n        let original = \u0026[0u8, 187, 61, 11, 250, 0];\n        let binary: Binary = original.into();\n        assert_eq!(binary.as_slice(), [0u8, 187, 61, 11, 250, 0]);\n\n        let original = \u0026[\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1,\n        ];\n        let binary: Binary = original.into();\n        assert_eq!(\n            binary.as_slice(),\n            [\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                1, 1, 1, 1,\n            ]\n        );\n    }\n\n    #[test]\n    fn from_owned_fixed_length_array_works() {\n        let original = [];\n        let binary: Binary = original.into();\n        assert_eq!(binary.len(), 0);\n\n        let original = [0u8];\n        let binary: Binary = original.into();\n        assert_eq!(binary.as_slice(), [0u8]);\n\n        let original = [0u8, 187, 61, 11, 250, 0];\n        let binary: Binary = original.into();\n        assert_eq!(binary.as_slice(), [0u8, 187, 61, 11, 250, 0]);\n\n        let original = [\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1,\n        ];\n        let binary: Binary = original.into();\n        assert_eq!(\n            binary.as_slice(),\n            [\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                1, 1, 1, 1,\n            ]\n        );\n    }\n\n    #[test]\n    fn from_literal_works() {\n        let a: Binary = b\"\".into();\n        assert_eq!(a.len(), 0);\n\n        let a: Binary = b\".\".into();\n        assert_eq!(a.len(), 1);\n\n        let a: Binary = b\"...\".into();\n        assert_eq!(a.len(), 3);\n\n        let a: Binary = b\"...............................\".into();\n        assert_eq!(a.len(), 31);\n\n        let a: Binary = b\"................................\".into();\n        assert_eq!(a.len(), 32);\n\n        // for length \u003e 32 we need to cast\n        let a: Binary = (b\".................................\" as \u0026[u8]).into();\n        assert_eq!(a.len(), 33);\n    }\n\n    #[test]\n    fn from_vec_works() {\n        let original = vec![0u8, 187, 61, 11, 250, 0];\n        let original_ptr = original.as_ptr();\n        let binary: Binary = original.into();\n        assert_eq!(binary.as_slice(), [0u8, 187, 61, 11, 250, 0]);\n        assert_eq!(binary.0.as_ptr(), original_ptr, \"vector must not be copied\");\n    }\n\n    #[test]\n    fn into_vec_works() {\n        let original = Binary(vec![0u8, 187, 61, 11, 250, 0]);\n        let original_ptr = original.0.as_ptr();\n        let vec: Vec\u003cu8\u003e = original.into();\n        assert_eq!(vec.as_slice(), [0u8, 187, 61, 11, 250, 0]);\n        assert_eq!(vec.as_ptr(), original_ptr, \"vector must not be copied\");\n    }\n\n    #[test]\n    fn serialization_works() {\n        let binary = Binary(vec![0u8, 187, 61, 11, 250, 0]);\n\n        let json = to_vec(\u0026binary).unwrap();\n        let deserialized: Binary = from_slice(\u0026json).unwrap();\n\n        assert_eq!(binary, deserialized);\n    }\n\n    #[test]\n    fn deserialize_from_valid_string() {\n        let b64_str = \"ALs9C/oA\";\n        // this is the binary behind above string\n        let expected = vec![0u8, 187, 61, 11, 250, 0];\n\n        let serialized = to_vec(\u0026b64_str).unwrap();\n        let deserialized: Binary = from_slice(\u0026serialized).unwrap();\n        assert_eq!(expected, deserialized.as_slice());\n    }\n\n    #[test]\n    fn deserialize_from_invalid_string() {\n        let invalid_str = \"**BAD!**\";\n        let serialized = to_vec(\u0026invalid_str).unwrap();\n        let res = from_slice::\u003cBinary\u003e(\u0026serialized);\n        assert!(res.is_err());\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":26},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","entry_points.rs"],"content":"/// This macro generates the boilerplate required to call into the\n/// contract-specific logic from the entry-points to the Wasm module.\n///\n/// It should be invoked in a module scope(that is, not inside a function), and the argument to the macro\n/// should be the name of a second rust module that is imported in the invocation scope.\n/// The second module should export three functions with the following signatures:\n/// ```\n/// # use cosmwasm_std::{\n/// #     Storage, Api, Querier, Extern, Env, StdResult, Binary,\n/// #     InitResult, HandleResult, QueryResult,\n/// # };\n/// #\n/// # type InitMsg = ();\n/// pub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n///     deps: \u0026mut Extern\u003cS, A, Q\u003e,\n///     env: Env,\n///     msg: InitMsg,\n/// ) -\u003e InitResult {\n/// #   Ok(Default::default())\n/// }\n///\n/// # type HandleMsg = ();\n/// pub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n///     deps: \u0026mut Extern\u003cS, A, Q\u003e,\n///     env: Env,\n///     msg: HandleMsg,\n/// ) -\u003e HandleResult {\n/// #   Ok(Default::default())\n/// }\n///\n/// # type QueryMsg = ();\n/// pub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n///     deps: \u0026Extern\u003cS, A, Q\u003e,\n///     msg: QueryMsg,\n/// ) -\u003e QueryResult {\n/// #   Ok(Binary(Vec::new()))\n/// }\n/// ```\n/// Where `InitMsg`, `HandleMsg`, and `QueryMsg` are types that implement `DeserializeOwned + JsonSchema`\n///\n/// # Example\n///\n/// ```ignore\n/// use contract; // The contract module\n///\n/// cosmwasm_std::create_entry_points!(contract);\n/// ```\n#[macro_export]\nmacro_rules! create_entry_points {\n    (@migration; $contract:ident, true) =\u003e {\n        #[no_mangle]\n        extern \"C\" fn migrate(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n            do_migrate(\n                \u0026$contract::migrate::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n                env_ptr,\n                msg_ptr,\n            )\n        }\n    };\n\n    (@migration; $contract:ident, false) =\u003e {};\n\n    (@inner; $contract:ident, migration = $migration:tt) =\u003e {\n        mod wasm {\n            use super::$contract;\n            use cosmwasm_std::{\n                do_handle, do_init, do_migrate, do_query, ExternalApi, ExternalQuerier,\n                ExternalStorage,\n            };\n\n            #[no_mangle]\n            extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n                do_init(\n                    \u0026$contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n                    env_ptr,\n                    msg_ptr,\n                )\n            }\n\n            #[no_mangle]\n            extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n                do_handle(\n                    \u0026$contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n                    env_ptr,\n                    msg_ptr,\n                )\n            }\n\n            #[no_mangle]\n            extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n                do_query(\n                    \u0026$contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n                    msg_ptr,\n                )\n            }\n\n            $crate::create_entry_points!(@migration; $contract, $migration);\n\n            // Other C externs like cosmwasm_vm_version_3, allocate, deallocate are available\n            // automatically because we `use cosmwasm_std`.\n        }\n    };\n\n    ($contract:ident) =\u003e {\n        $crate::create_entry_points!(@inner; $contract, migration = false);\n    };\n}\n\n/// This macro is very similar to the `create_entry_points` macro, except it also requires the `migrate` method:\n/// ```\n/// # use cosmwasm_std::{\n/// #     Storage, Api, Querier, Extern, Env, StdResult, Binary, MigrateResult,\n/// # };\n/// # type MigrateMsg = ();\n/// pub fn migrate\u003cS: Storage, A: Api, Q: Querier\u003e(\n///     deps: \u0026mut Extern\u003cS, A, Q\u003e,\n///     _env: Env,\n///     msg: MigrateMsg,\n/// ) -\u003e MigrateResult {\n/// #   Ok(Default::default())\n/// }\n/// ```\n/// Where `MigrateMsg` is a type that implements `DeserializeOwned + JsonSchema`\n///\n/// # Example\n///\n/// ```ignore\n/// use contract; // The contract module\n///\n/// cosmwasm_std::create_entry_points_with_migration!(contract);\n/// ```\n#[macro_export]\nmacro_rules! create_entry_points_with_migration {\n    ($contract:ident) =\u003e {\n        $crate::create_entry_points!(@inner; $contract, migration = true);\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","errors","mod.rs"],"content":"mod std_error;\nmod system_error;\n\npub use std_error::{StdError, StdResult};\npub use system_error::{SystemError, SystemResult};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","errors","std_error.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse snafu::Snafu;\n\n/// Structured error type for init, handle and query.\n///\n/// This can be serialized and passed over the Wasm/VM boundary, which allows us to use structured\n/// error types in e.g. integration tests. In that process backtraces are stripped off.\n///\n/// The prefix \"Std\" means \"the standard error within the standard library\". This is not the only\n/// result/error type in cosmwasm-std.\n///\n/// When new cases are added, they should describe the problem rather than what was attempted (e.g.\n/// InvalidBase64 is preferred over Base64DecodingErr). In the long run this allows us to get rid of\n/// the duplication in \"StdError::FooErr\".\n///\n/// Checklist for adding a new error:\n/// - Add enum case\n/// - Add to PartialEq implementation\n/// - Add serialize/deserialize test\n/// - Add creator function in std_error_helpers.rs\n/// - Regenerate schemas\n#[derive(Debug, Serialize, Deserialize, Snafu, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\n#[non_exhaustive]\npub enum StdError {\n    /// Whenever there is no specific error type available\n    #[snafu(display(\"Generic error: {}\", msg))]\n    GenericErr {\n        msg: String,\n        #[serde(skip)]\n        backtrace: Option\u003csnafu::Backtrace\u003e,\n    },\n    #[snafu(display(\"Invalid Base64 string: {}\", msg))]\n    InvalidBase64 {\n        msg: String,\n        #[serde(skip)]\n        backtrace: Option\u003csnafu::Backtrace\u003e,\n    },\n    /// Whenever UTF-8 bytes cannot be decoded into a unicode string, e.g. in String::from_utf8 or str::from_utf8.\n    #[snafu(display(\"Cannot decode UTF8 bytes into string: {}\", msg))]\n    InvalidUtf8 {\n        msg: String,\n        #[serde(skip)]\n        backtrace: Option\u003csnafu::Backtrace\u003e,\n    },\n    #[snafu(display(\"{} not found\", kind))]\n    NotFound {\n        kind: String,\n        #[serde(skip)]\n        backtrace: Option\u003csnafu::Backtrace\u003e,\n    },\n    #[snafu(display(\"Error parsing into type {}: {}\", target, msg))]\n    ParseErr {\n        /// the target type that was attempted\n        target: String,\n        msg: String,\n        #[serde(skip)]\n        backtrace: Option\u003csnafu::Backtrace\u003e,\n    },\n    #[snafu(display(\"Error serializing type {}: {}\", source, msg))]\n    SerializeErr {\n        /// the source type that was attempted\n        #[snafu(source(false))]\n        source: String,\n        msg: String,\n        #[serde(skip)]\n        backtrace: Option\u003csnafu::Backtrace\u003e,\n    },\n    #[snafu(display(\"Unauthorized\"))]\n    Unauthorized {\n        #[serde(skip)]\n        backtrace: Option\u003csnafu::Backtrace\u003e,\n    },\n    #[snafu(display(\"Cannot subtract {} from {}\", subtrahend, minuend))]\n    Underflow {\n        minuend: String,\n        subtrahend: String,\n        #[serde(skip)]\n        backtrace: Option\u003csnafu::Backtrace\u003e,\n    },\n}\n\nimpl StdError {\n    pub fn generic_err\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self {\n        GenericErr { msg: msg.into() }.build()\n    }\n\n    pub fn invalid_base64\u003cS: ToString\u003e(msg: S) -\u003e Self {\n        InvalidBase64 {\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n\n    pub fn invalid_utf8\u003cS: ToString\u003e(msg: S) -\u003e Self {\n        InvalidUtf8 {\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n\n    pub fn not_found\u003cS: Into\u003cString\u003e\u003e(kind: S) -\u003e Self {\n        NotFound { kind: kind.into() }.build()\n    }\n\n    pub fn parse_err\u003cT: Into\u003cString\u003e, M: ToString\u003e(target: T, msg: M) -\u003e Self {\n        ParseErr {\n            target: target.into(),\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n\n    pub fn serialize_err\u003cS: Into\u003cString\u003e, M: ToString\u003e(source: S, msg: M) -\u003e Self {\n        SerializeErr {\n            source: source.into(),\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n\n    pub fn underflow\u003cU: ToString\u003e(minuend: U, subtrahend: U) -\u003e Self {\n        Underflow {\n            minuend: minuend.to_string(),\n            subtrahend: subtrahend.to_string(),\n        }\n        .build()\n    }\n\n    pub fn unauthorized() -\u003e Self {\n        Unauthorized {}.build()\n    }\n}\n\nimpl PartialEq for StdError {\n    /// Two errors are considered equal if and only if their payloads (i.e. all fields other than backtrace) are equal.\n    ///\n    /// The origin of the error (expressed by its backtrace) is ignored, which allows equality checks on errors and\n    /// results in tests. This is a property that might not always be desired depending on the use case and something\n    /// you should be aware of.\n    ///\n    /// Note: We destruct the unused backtrace as _ to avoid the use of `..` which silently ignores newly added fields.\n    #[allow(clippy::unneeded_field_pattern)]\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (\n                StdError::GenericErr { msg, backtrace: _ },\n                StdError::GenericErr {\n                    msg: msg2,\n                    backtrace: _,\n                },\n            ) =\u003e msg == msg2,\n            (\n                StdError::InvalidBase64 { msg, backtrace: _ },\n                StdError::InvalidBase64 {\n                    msg: msg2,\n                    backtrace: _,\n                },\n            ) =\u003e msg == msg2,\n            (\n                StdError::InvalidUtf8 { msg, backtrace: _ },\n                StdError::InvalidUtf8 {\n                    msg: msg2,\n                    backtrace: _,\n                },\n            ) =\u003e msg == msg2,\n            (\n                StdError::NotFound { kind, backtrace: _ },\n                StdError::NotFound {\n                    kind: kind2,\n                    backtrace: _,\n                },\n            ) =\u003e kind == kind2,\n            (\n                StdError::ParseErr {\n                    target,\n                    msg,\n                    backtrace: _,\n                },\n                StdError::ParseErr {\n                    target: target2,\n                    msg: msg2,\n                    backtrace: _,\n                },\n            ) =\u003e target == target2 \u0026\u0026 msg == msg2,\n            (\n                StdError::SerializeErr {\n                    source,\n                    msg,\n                    backtrace: _,\n                },\n                StdError::SerializeErr {\n                    source: source2,\n                    msg: msg2,\n                    backtrace: _,\n                },\n            ) =\u003e source == source2 \u0026\u0026 msg == msg2,\n            (StdError::Unauthorized { backtrace: _ }, StdError::Unauthorized { backtrace: _ }) =\u003e {\n                true\n            }\n            (\n                StdError::Underflow {\n                    minuend,\n                    subtrahend,\n                    backtrace: _,\n                },\n                StdError::Underflow {\n                    minuend: minued2,\n                    subtrahend: subtrahend2,\n                    backtrace: _,\n                },\n            ) =\u003e minuend == minued2 \u0026\u0026 subtrahend == subtrahend2,\n            _ =\u003e false,\n        }\n    }\n}\n\n/// The return type for init, handle and query. Since the error type cannot be serialized to JSON,\n/// this is only available within the contract and its unit tests.\n///\n/// The prefix \"Std\" means \"the standard result within the standard library\". This is not the only\n/// result/error type in cosmwasm-std.\npub type StdResult\u003cT\u003e = core::result::Result\u003cT, StdError\u003e;\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::serde::{from_slice, to_vec};\n\n    // constructors\n\n    // example of reporting contract errors with format!\n    #[test]\n    fn generic_err_owned() {\n        let guess = 7;\n        let error = StdError::generic_err(format!(\"{} is too low\", guess));\n        match error {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, String::from(\"7 is too low\"));\n            }\n            e =\u003e panic!(\"unexpected error, {:?}\", e),\n        }\n    }\n\n    // example of reporting static contract errors\n    #[test]\n    fn generic_err_ref() {\n        let error = StdError::generic_err(\"not implemented\");\n        match error {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"not implemented\"),\n            e =\u003e panic!(\"unexpected error, {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn invalid_base64_works_for_strings() {\n        let error = StdError::invalid_base64(\"my text\");\n        match error {\n            StdError::InvalidBase64 { msg, .. } =\u003e {\n                assert_eq!(msg, \"my text\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn invalid_base64_works_for_errors() {\n        let original = base64::DecodeError::InvalidLength;\n        let error = StdError::invalid_base64(original);\n        match error {\n            StdError::InvalidBase64 { msg, .. } =\u003e {\n                assert_eq!(msg, \"Encoded text cannot have a 6-bit remainder.\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn invalid_utf8_works_for_strings() {\n        let error = StdError::invalid_utf8(\"my text\");\n        match error {\n            StdError::InvalidUtf8 { msg, .. } =\u003e {\n                assert_eq!(msg, \"my text\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn invalid_utf8_works_for_errors() {\n        let original = String::from_utf8(vec![0x80]).unwrap_err();\n        let error = StdError::invalid_utf8(original);\n        match error {\n            StdError::InvalidUtf8 { msg, .. } =\u003e {\n                assert_eq!(msg, \"invalid utf-8 sequence of 1 bytes from index 0\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn not_found_works() {\n        let error = StdError::not_found(\"gold\");\n        match error {\n            StdError::NotFound { kind, .. } =\u003e assert_eq!(kind, \"gold\"),\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn parse_err_works() {\n        let error = StdError::parse_err(\"Book\", \"Missing field: title\");\n        match error {\n            StdError::ParseErr { target, msg, .. } =\u003e {\n                assert_eq!(target, \"Book\");\n                assert_eq!(msg, \"Missing field: title\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn serialize_err_works() {\n        let error = StdError::serialize_err(\"Book\", \"Content too long\");\n        match error {\n            StdError::SerializeErr { source, msg, .. } =\u003e {\n                assert_eq!(source, \"Book\");\n                assert_eq!(msg, \"Content too long\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn underflow_works_for_u128() {\n        let error = StdError::underflow(123u128, 456u128);\n        match error {\n            StdError::Underflow {\n                minuend,\n                subtrahend,\n                ..\n            } =\u003e {\n                assert_eq!(minuend, \"123\");\n                assert_eq!(subtrahend, \"456\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn underflow_works_for_i64() {\n        let error = StdError::underflow(777i64, 1234i64);\n        match error {\n            StdError::Underflow {\n                minuend,\n                subtrahend,\n                ..\n            } =\u003e {\n                assert_eq!(minuend, \"777\");\n                assert_eq!(subtrahend, \"1234\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn unauthorized_works() {\n        let error = StdError::unauthorized();\n        match error {\n            StdError::Unauthorized { .. } =\u003e {}\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn can_serialize() {\n        let error = InvalidBase64 {\n            msg: \"invalid length\".to_string(),\n        }\n        .build();\n        assert_eq!(\n            to_vec(\u0026error).unwrap(),\n            br#\"{\"invalid_base64\":{\"msg\":\"invalid length\"}}\"#.to_vec()\n        );\n    }\n\n    #[test]\n    fn can_deserialize() {\n        let error: StdError =\n            from_slice(br#\"{\"invalid_base64\":{\"msg\":\"invalid length\"}}\"#).unwrap();\n        match error {\n            StdError::InvalidBase64 { msg, backtrace } =\u003e {\n                assert_eq!(msg, \"invalid length\");\n                assert!(backtrace.is_none());\n            }\n            _ =\u003e panic!(\"invalid type\"),\n        };\n    }\n\n    /// The deseralizer in from_slice can perform zero-copy deserializations (https://serde.rs/lifetimes.html).\n    /// So it is possible to have `\u0026'static str` fields as long as all source data is always static.\n    /// This is an unrealistic assumption for our use case. This test case ensures we can deseralize\n    /// errors from limited liefetime sources.\n    #[test]\n    fn can_deserialize_from_non_static_source() {\n        let source = (br#\"{\"not_found\":{\"kind\":\"bugs\"}}\"#).to_vec();\n        let error: StdError = from_slice(\u0026source).unwrap();\n        match error {\n            StdError::NotFound { kind, backtrace } =\u003e {\n                assert_eq!(kind, \"bugs\");\n                assert!(backtrace.is_none());\n            }\n            _ =\u003e panic!(\"invalid type\"),\n        };\n    }\n\n    #[test]\n    fn eq_works() {\n        let error1 = StdError::InvalidBase64 {\n            msg: \"invalid length\".to_string(),\n            backtrace: None,\n        };\n        let error2 = StdError::InvalidBase64 {\n            msg: \"invalid length\".to_string(),\n            backtrace: None,\n        };\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn ne_works() {\n        let error1 = StdError::InvalidBase64 {\n            msg: \"invalid length\".to_string(),\n            backtrace: None,\n        };\n        let error2 = StdError::InvalidBase64 {\n            msg: \"other bla\".to_string(),\n            backtrace: None,\n        };\n        assert_ne!(error1, error2);\n    }\n\n    fn assert_conversion(original: StdError) {\n        let seralized = to_vec(\u0026original).unwrap();\n        let restored: StdError = from_slice(\u0026seralized).unwrap();\n        assert_eq!(restored, original);\n    }\n\n    #[test]\n    fn generic_err_conversion() {\n        assert_conversion(GenericErr { msg: \"something\" }.build());\n    }\n\n    #[test]\n    fn invalid_base64_conversion() {\n        assert_conversion(\n            InvalidBase64 {\n                msg: \"invalid length\".to_string(),\n            }\n            .build(),\n        );\n    }\n\n    #[test]\n    fn unauthorized_conversion() {\n        assert_conversion(Unauthorized {}.build());\n    }\n\n    #[test]\n    fn not_found_conversion() {\n        assert_conversion(NotFound { kind: \"State\" }.build());\n    }\n\n    #[test]\n    fn parse_err_conversion() {\n        let err = from_slice::\u003cString\u003e(b\"123\").unwrap_err();\n        assert_conversion(err);\n    }\n\n    #[test]\n    fn serialize_err_conversion() {\n        assert_conversion(\n            SerializeErr {\n                source: \"Person\",\n                msg: \"buffer is full\",\n            }\n            .build(),\n        );\n    }\n}\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":70},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","errors","system_error.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{Binary, HumanAddr};\n\n/// SystemError is used for errors inside the VM and is API friendly (i.e. serializable).\n///\n/// This is used on return values for Querier as a nested result: Result\u003cStdResult\u003cT\u003e, SystemError\u003e\n/// The first wrap (SystemError) will trigger if the contract address doesn't exist,\n/// the QueryRequest is malformated, etc. The second wrap will be an error message from\n/// the contract itself.\n///\n/// Such errors are only created by the VM. The error type is defined in the standard library, to ensure\n/// the contract understands the error format without creating a dependency on cosmwasm-vm.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\n#[non_exhaustive]\npub enum SystemError {\n    InvalidRequest { error: String, request: Binary },\n    InvalidResponse { error: String, response: Binary },\n    NoSuchContract { addr: HumanAddr },\n    Unknown {},\n    UnsupportedRequest { kind: String },\n    ExceededRecursionLimit {},\n}\n\nimpl std::error::Error for SystemError {}\n\nimpl std::fmt::Display for SystemError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            SystemError::InvalidRequest { error, request } =\u003e write!(\n                f,\n                \"Cannot parse request: {} in: {}\",\n                error,\n                String::from_utf8_lossy(request.as_slice())\n            ),\n            SystemError::InvalidResponse { error, response } =\u003e write!(\n                f,\n                \"Cannot parse response: {} in: {}\",\n                error,\n                String::from_utf8_lossy(response.as_slice())\n            ),\n            SystemError::NoSuchContract { addr } =\u003e write!(f, \"No such contract: {}\", addr),\n            SystemError::Unknown {} =\u003e write!(f, \"Unknown system error\"),\n            SystemError::UnsupportedRequest { kind } =\u003e {\n                write!(f, \"Unsupported query type: {}\", kind)\n            }\n            SystemError::ExceededRecursionLimit {} =\u003e write!(f, \"Query recursion limit exceeded\"),\n        }\n    }\n}\n\npub type SystemResult\u003cT\u003e = Result\u003cT, SystemError\u003e;\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":15},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","exports.rs"],"content":"//! exports exposes the public wasm API\n//!\n//! cosmwasm_vm_version_3, allocate and deallocate turn into Wasm exports\n//! as soon as cosmwasm_std is `use`d in the contract, even privately.\n//!\n//! do_init and do_wrapper should be wrapped with a extern \"C\" entry point\n//! including the contract-specific init/handle function pointer.\nuse std::fmt;\nuse std::vec::Vec;\n\nuse schemars::JsonSchema;\nuse serde::{de::DeserializeOwned, Serialize};\n\nuse crate::errors::StdResult;\nuse crate::imports::{ExternalApi, ExternalQuerier, ExternalStorage};\nuse crate::memory::{alloc, consume_region, release_buffer, Region};\nuse crate::serde::{from_slice, to_vec};\nuse crate::traits::Extern;\nuse crate::{Env, HandleResult, InitResult, MigrateResult, QueryResponse, QueryResult};\n\n#[cfg(feature = \"staking\")]\n#[no_mangle]\nextern \"C\" fn requires_staking() -\u003e () {}\n\n/// cosmwasm_vm_version_* exports mark which Wasm VM interface level this contract is compiled for.\n/// They can be checked by cosmwasm_vm.\n/// Update this whenever the Wasm VM interface breaks.\n#[no_mangle]\nextern \"C\" fn cosmwasm_vm_version_3() -\u003e () {}\n\n/// allocate reserves the given number of bytes in wasm memory and returns a pointer\n/// to a Region defining this data. This space is managed by the calling process\n/// and should be accompanied by a corresponding deallocate\n#[no_mangle]\nextern \"C\" fn allocate(size: usize) -\u003e u32 {\n    alloc(size) as u32\n}\n\n/// deallocate expects a pointer to a Region created with allocate.\n/// It will free both the Region and the memory referenced by the Region.\n#[no_mangle]\nextern \"C\" fn deallocate(pointer: u32) {\n    // auto-drop Region on function end\n    let _ = unsafe { consume_region(pointer as *mut Region) };\n}\n\n/// do_init should be wrapped in an external \"C\" export, containing a contract-specific function as arg\npub fn do_init\u003cT, U\u003e(\n    init_fn: \u0026dyn Fn(\n        \u0026mut Extern\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        Env,\n        T,\n    ) -\u003e InitResult\u003cU\u003e,\n    env_ptr: u32,\n    msg_ptr: u32,\n) -\u003e u32\nwhere\n    T: DeserializeOwned + JsonSchema,\n    U: Serialize + Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    let res: InitResult\u003cU\u003e = _do_init(init_fn, env_ptr as *mut Region, msg_ptr as *mut Region);\n    let v = to_vec(\u0026res).unwrap();\n    release_buffer(v) as u32\n}\n\n/// do_handle should be wrapped in an external \"C\" export, containing a contract-specific function as arg\npub fn do_handle\u003cT, U\u003e(\n    handle_fn: \u0026dyn Fn(\n        \u0026mut Extern\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        Env,\n        T,\n    ) -\u003e HandleResult\u003cU\u003e,\n    env_ptr: u32,\n    msg_ptr: u32,\n) -\u003e u32\nwhere\n    T: DeserializeOwned + JsonSchema,\n    U: Serialize + Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    let res: HandleResult\u003cU\u003e =\n        _do_handle(handle_fn, env_ptr as *mut Region, msg_ptr as *mut Region);\n    let v = to_vec(\u0026res).unwrap();\n    release_buffer(v) as u32\n}\n\n/// do_query should be wrapped in an external \"C\" export, containing a contract-specific function as arg\npub fn do_query\u003cT: DeserializeOwned + JsonSchema\u003e(\n    query_fn: \u0026dyn Fn(\n        \u0026Extern\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        T,\n    ) -\u003e StdResult\u003cQueryResponse\u003e,\n    msg_ptr: u32,\n) -\u003e u32 {\n    let res: QueryResult = _do_query(query_fn, msg_ptr as *mut Region);\n    let v = to_vec(\u0026res).unwrap();\n    release_buffer(v) as u32\n}\n\n/// do_migrate should be wrapped in an external \"C\" export, containing a contract-specific function as arg\npub fn do_migrate\u003cT, U\u003e(\n    migrate_fn: \u0026dyn Fn(\n        \u0026mut Extern\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        Env,\n        T,\n    ) -\u003e MigrateResult\u003cU\u003e,\n    env_ptr: u32,\n    msg_ptr: u32,\n) -\u003e u32\nwhere\n    T: DeserializeOwned + JsonSchema,\n    U: Serialize + Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    let res: MigrateResult\u003cU\u003e =\n        _do_migrate(migrate_fn, env_ptr as *mut Region, msg_ptr as *mut Region);\n    let v = to_vec(\u0026res).unwrap();\n    release_buffer(v) as u32\n}\n\nfn _do_init\u003cT, U\u003e(\n    init_fn: \u0026dyn Fn(\n        \u0026mut Extern\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        Env,\n        T,\n    ) -\u003e InitResult\u003cU\u003e,\n    env_ptr: *mut Region,\n    msg_ptr: *mut Region,\n) -\u003e InitResult\u003cU\u003e\nwhere\n    T: DeserializeOwned + JsonSchema,\n    U: Serialize + Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    let env: Vec\u003cu8\u003e = unsafe { consume_region(env_ptr) };\n    let msg: Vec\u003cu8\u003e = unsafe { consume_region(msg_ptr) };\n    let env: Env = from_slice(\u0026env)?;\n    let msg: T = from_slice(\u0026msg)?;\n    let mut deps = make_dependencies();\n    init_fn(\u0026mut deps, env, msg)\n}\n\nfn _do_handle\u003cT, U\u003e(\n    handle_fn: \u0026dyn Fn(\n        \u0026mut Extern\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        Env,\n        T,\n    ) -\u003e HandleResult\u003cU\u003e,\n    env_ptr: *mut Region,\n    msg_ptr: *mut Region,\n) -\u003e HandleResult\u003cU\u003e\nwhere\n    T: DeserializeOwned + JsonSchema,\n    U: Serialize + Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    let env: Vec\u003cu8\u003e = unsafe { consume_region(env_ptr) };\n    let msg: Vec\u003cu8\u003e = unsafe { consume_region(msg_ptr) };\n\n    let env: Env = from_slice(\u0026env)?;\n    let msg: T = from_slice(\u0026msg)?;\n    let mut deps = make_dependencies();\n    handle_fn(\u0026mut deps, env, msg)\n}\n\nfn _do_query\u003cT: DeserializeOwned + JsonSchema\u003e(\n    query_fn: \u0026dyn Fn(\n        \u0026Extern\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        T,\n    ) -\u003e StdResult\u003cQueryResponse\u003e,\n    msg_ptr: *mut Region,\n) -\u003e StdResult\u003cQueryResponse\u003e {\n    let msg: Vec\u003cu8\u003e = unsafe { consume_region(msg_ptr) };\n\n    let msg: T = from_slice(\u0026msg)?;\n    let deps = make_dependencies();\n    query_fn(\u0026deps, msg)\n}\n\nfn _do_migrate\u003cT, U\u003e(\n    migrate_fn: \u0026dyn Fn(\n        \u0026mut Extern\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n        Env,\n        T,\n    ) -\u003e MigrateResult\u003cU\u003e,\n    env_ptr: *mut Region,\n    msg_ptr: *mut Region,\n) -\u003e MigrateResult\u003cU\u003e\nwhere\n    T: DeserializeOwned + JsonSchema,\n    U: Serialize + Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    let env: Vec\u003cu8\u003e = unsafe { consume_region(env_ptr) };\n    let msg: Vec\u003cu8\u003e = unsafe { consume_region(msg_ptr) };\n    let env: Env = from_slice(\u0026env)?;\n    let msg: T = from_slice(\u0026msg)?;\n    let mut deps = make_dependencies();\n    migrate_fn(\u0026mut deps, env, msg)\n}\n\n/// Makes all bridges to external dependencies (i.e. Wasm imports) that are injected by the VM\nfn make_dependencies() -\u003e Extern\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e {\n    Extern {\n        storage: ExternalStorage::new(),\n        api: ExternalApi::new(),\n        querier: ExternalQuerier::new(),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","imports.rs"],"content":"use std::vec::Vec;\n\nuse crate::addresses::{CanonicalAddr, HumanAddr};\nuse crate::encoding::Binary;\nuse crate::errors::{StdError, StdResult};\n#[cfg(feature = \"iterator\")]\nuse crate::iterator::{Order, KV};\nuse crate::memory::{alloc, build_region, consume_region, Region};\nuse crate::serde::from_slice;\nuse crate::traits::{Api, Querier, QuerierResult, ReadonlyStorage, Storage};\n\n/// An upper bound for typical canonical address lengths (e.g. 20 in Cosmos SDK/Ethereum or 32 in Nano/Substrate)\nconst CANONICAL_ADDRESS_BUFFER_LENGTH: usize = 32;\n/// An upper bound for typical human readable address formats (e.g. 42 for Ethereum hex addresses or 90 for bech32)\nconst HUMAN_ADDRESS_BUFFER_LENGTH: usize = 90;\n\n// This interface will compile into required Wasm imports.\n// A complete documentation those functions is available in the VM that provides them:\n// https://github.com/confio/cosmwasm/blob/0.7/lib/vm/src/instance.rs#L43\nextern \"C\" {\n    fn db_read(key: u32) -\u003e u32;\n    fn db_write(key: u32, value: u32);\n    fn db_remove(key: u32);\n\n    // scan creates an iterator, which can be read by consecutive next() calls\n    #[cfg(feature = \"iterator\")]\n    fn db_scan(start_ptr: u32, end_ptr: u32, order: i32) -\u003e u32;\n    #[cfg(feature = \"iterator\")]\n    fn db_next(iterator_id: u32) -\u003e u32;\n\n    fn canonicalize_address(source: u32, destination: u32) -\u003e u32;\n    fn humanize_address(source: u32, destination: u32) -\u003e u32;\n\n    /// Executes a query on the chain (import). Not to be confused with the\n    /// query export, which queries the state of the contract.\n    fn query_chain(request: u32) -\u003e u32;\n}\n\n/// A stateless convenience wrapper around database imports provided by the VM.\n/// This cannot be cloned as it would not copy any data. If you need to clone this, it indicates a flaw in your logic.\npub struct ExternalStorage {}\n\nimpl ExternalStorage {\n    pub fn new() -\u003e ExternalStorage {\n        ExternalStorage {}\n    }\n}\n\nimpl ReadonlyStorage for ExternalStorage {\n    fn get(\u0026self, key: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        let key = build_region(key);\n        let key_ptr = \u0026*key as *const Region as u32;\n\n        let read = unsafe { db_read(key_ptr) };\n        if read == 0 {\n            // key does not exist in external storage\n            return None;\n        }\n\n        let value_ptr = read as *mut Region;\n        let data = unsafe { consume_region(value_ptr) };\n        Some(data)\n    }\n\n    #[cfg(feature = \"iterator\")]\n    fn range(\n        \u0026self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = KV\u003e\u003e {\n        // start and end (Regions) must remain in scope as long as the start_ptr / end_ptr do\n        // thus they are not inside a block\n        let start = start.map(|s| build_region(s));\n        let start_ptr = match start {\n            Some(reg) =\u003e \u0026*reg as *const Region as u32,\n            None =\u003e 0,\n        };\n        let end = end.map(|e| build_region(e));\n        let end_ptr = match end {\n            Some(reg) =\u003e \u0026*reg as *const Region as u32,\n            None =\u003e 0,\n        };\n        let order = order as i32;\n\n        let iterator_id = unsafe { db_scan(start_ptr, end_ptr, order) };\n        let iter = ExternalIterator { iterator_id };\n        Box::new(iter)\n    }\n}\n\nimpl Storage for ExternalStorage {\n    fn set(\u0026mut self, key: \u0026[u8], value: \u0026[u8]) {\n        // keep the boxes in scope, so we free it at the end (don't cast to pointers same line as build_region)\n        let key = build_region(key);\n        let key_ptr = \u0026*key as *const Region as u32;\n        let mut value = build_region(value);\n        let value_ptr = \u0026mut *value as *mut Region as u32;\n        unsafe { db_write(key_ptr, value_ptr) };\n    }\n\n    fn remove(\u0026mut self, key: \u0026[u8]) {\n        // keep the boxes in scope, so we free it at the end (don't cast to pointers same line as build_region)\n        let key = build_region(key);\n        let key_ptr = \u0026*key as *const Region as u32;\n        unsafe { db_remove(key_ptr) };\n    }\n}\n\n#[cfg(feature = \"iterator\")]\n/// ExternalIterator makes a call out to next.\n/// We use the pointer to differentiate between multiple open iterators.\nstruct ExternalIterator {\n    iterator_id: u32,\n}\n\n#[cfg(feature = \"iterator\")]\nimpl Iterator for ExternalIterator {\n    type Item = KV;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let next_result = unsafe { db_next(self.iterator_id) };\n        let kv_region_ptr = next_result as *mut Region;\n        let mut kv = unsafe { consume_region(kv_region_ptr) };\n\n        // The KV region uses the format value || key || keylen, where keylen is a fixed size big endian u32 value\n        let keylen = u32::from_be_bytes([\n            kv[kv.len() - 4],\n            kv[kv.len() - 3],\n            kv[kv.len() - 2],\n            kv[kv.len() - 1],\n        ]) as usize;\n        if keylen == 0 {\n            return None;\n        }\n\n        kv.truncate(kv.len() - 4);\n        let key = kv.split_off(kv.len() - keylen);\n        let value = kv;\n        Some((key, value))\n    }\n}\n\n/// A stateless convenience wrapper around imports provided by the VM\n#[derive(Copy, Clone)]\npub struct ExternalApi {}\n\nimpl ExternalApi {\n    pub fn new() -\u003e ExternalApi {\n        ExternalApi {}\n    }\n}\n\nimpl Api for ExternalApi {\n    fn canonical_address(\u0026self, human: \u0026HumanAddr) -\u003e StdResult\u003cCanonicalAddr\u003e {\n        let send = build_region(human.as_str().as_bytes());\n        let send_ptr = \u0026*send as *const Region as u32;\n        let canon = alloc(CANONICAL_ADDRESS_BUFFER_LENGTH);\n\n        let result = unsafe { canonicalize_address(send_ptr, canon as u32) };\n        if result != 0 {\n            let error = unsafe { consume_string_region_written_by_vm(result as *mut Region) };\n            return Err(StdError::generic_err(format!(\n                \"canonicalize_address errored: {}\",\n                error\n            )));\n        }\n\n        let out = unsafe { consume_region(canon) };\n        Ok(CanonicalAddr(Binary(out)))\n    }\n\n    fn human_address(\u0026self, canonical: \u0026CanonicalAddr) -\u003e StdResult\u003cHumanAddr\u003e {\n        let send = build_region(canonical.as_slice());\n        let send_ptr = \u0026*send as *const Region as u32;\n        let human = alloc(HUMAN_ADDRESS_BUFFER_LENGTH);\n\n        let result = unsafe { humanize_address(send_ptr, human as u32) };\n        if result != 0 {\n            let error = unsafe { consume_string_region_written_by_vm(result as *mut Region) };\n            return Err(StdError::generic_err(format!(\n                \"humanize_address errored: {}\",\n                error\n            )));\n        }\n\n        let address = unsafe { consume_string_region_written_by_vm(human) };\n        Ok(address.into())\n    }\n}\n\n/// Takes a pointer to a Region and reads the data into a String.\n/// This is for trusted string sources only.\nunsafe fn consume_string_region_written_by_vm(from: *mut Region) -\u003e String {\n    let data = consume_region(from);\n    // We trust the VM/chain to return correct UTF-8, so let's save some gas\n    String::from_utf8_unchecked(data)\n}\n\n/// A stateless convenience wrapper around imports provided by the VM\npub struct ExternalQuerier {}\n\nimpl ExternalQuerier {\n    pub fn new() -\u003e ExternalQuerier {\n        ExternalQuerier {}\n    }\n}\n\nimpl Querier for ExternalQuerier {\n    fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n        let req = build_region(bin_request);\n        let request_ptr = \u0026*req as *const Region as u32;\n\n        let response_ptr = unsafe { query_chain(request_ptr) };\n\n        let response = unsafe { consume_region(response_ptr as *mut Region) };\n        from_slice(\u0026response).unwrap_or_else(|err| Ok(Err(err)))\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":81},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","init_handle.rs"],"content":"//! Types and helpers for init and handle\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::convert::TryFrom;\nuse std::fmt;\n\nuse crate::addresses::HumanAddr;\nuse crate::coins::Coin;\nuse crate::encoding::Binary;\nuse crate::errors::{StdError, StdResult};\nuse crate::types::Empty;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\n// See https://github.com/serde-rs/serde/issues/1296 why we cannot add De-Serialize trait bounds to T\npub enum CosmosMsg\u003cT = Empty\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    Bank(BankMsg),\n    // by default we use RawMsg, but a contract can override that\n    // to call into more app-specific code (whatever they define)\n    Custom(T),\n    Staking(StakingMsg),\n    Wasm(WasmMsg),\n    Gov(GovMsg),\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum GovMsg {\n    // Let contract vote on a governance proposal\n    Vote {\n        proposal: u64,\n        vote_option: VoteOption,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n// don't use rename_all here or you will break this\npub enum VoteOption {\n    Yes,\n    No,\n    Abstain,\n    NoWithVeto,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum BankMsg {\n    // this moves tokens in the underlying sdk\n    Send {\n        from_address: HumanAddr,\n        to_address: HumanAddr,\n        amount: Vec\u003cCoin\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum StakingMsg {\n    Delegate {\n        // delegator is automatically set to address of the calling contract\n        validator: HumanAddr,\n        amount: Coin,\n    },\n    Undelegate {\n        // delegator is automatically set to address of the calling contract\n        validator: HumanAddr,\n        amount: Coin,\n    },\n    Withdraw {\n        // delegator is automatically set to address of the calling contract\n        validator: HumanAddr,\n        /// this is the \"withdraw address\", the one that should receive the rewards\n        /// if None, then use delegator address\n        recipient: Option\u003cHumanAddr\u003e,\n    },\n    Redelegate {\n        // delegator is automatically set to address of the calling contract\n        src_validator: HumanAddr,\n        dst_validator: HumanAddr,\n        amount: Coin,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum WasmMsg {\n    /// this dispatches a call to another contract at a known address (with known ABI)\n    Execute {\n        contract_addr: HumanAddr,\n        /// callback_code_hash is the hex encoded hash of the code. This is used by Secret Network to harden against replaying the contract\n        /// It is used to bind the request to a destination contract in a stronger way than just the contract address which can be faked\n        callback_code_hash: String,\n        /// msg is the json-encoded HandleMsg struct (as raw Binary)\n        msg: Binary,\n        send: Vec\u003cCoin\u003e,\n    },\n    /// this instantiates a new contracts from previously uploaded wasm code\n    Instantiate {\n        code_id: u64,\n        /// callback_code_hash is the hex encoded hash of the code. This is used by Secret Network to harden against replaying the contract\n        /// It is used to bind the request to a destination contract in a stronger way than just the contract address which can be faked\n        callback_code_hash: String,\n        /// msg is the json-encoded InitMsg struct (as raw Binary)\n        msg: Binary,\n        send: Vec\u003cCoin\u003e,\n        /// mandatory human-readbale label for the contract\n        label: String,\n    },\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq + JsonSchema\u003e From\u003cGovMsg\u003e for CosmosMsg\u003cT\u003e {\n    fn from(msg: GovMsg) -\u003e Self {\n        CosmosMsg::Gov(msg)\n    }\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq + JsonSchema\u003e From\u003cBankMsg\u003e for CosmosMsg\u003cT\u003e {\n    fn from(msg: BankMsg) -\u003e Self {\n        CosmosMsg::Bank(msg)\n    }\n}\n\n#[cfg(feature = \"staking\")]\nimpl\u003cT: Clone + fmt::Debug + PartialEq + JsonSchema\u003e From\u003cStakingMsg\u003e for CosmosMsg\u003cT\u003e {\n    fn from(msg: StakingMsg) -\u003e Self {\n        CosmosMsg::Staking(msg)\n    }\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq + JsonSchema\u003e From\u003cWasmMsg\u003e for CosmosMsg\u003cT\u003e {\n    fn from(msg: WasmMsg) -\u003e Self {\n        CosmosMsg::Wasm(msg)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, JsonSchema)]\npub struct LogAttribute {\n    pub key: String,\n    pub value: String,\n}\n\n/// A shorthand to produce a log attribute\npub fn log\u003cK: ToString, V: ToString\u003e(key: K, value: V) -\u003e LogAttribute {\n    LogAttribute {\n        key: key.to_string(),\n        value: value.to_string(),\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitResponse\u003cT = Empty\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    pub messages: Vec\u003cCosmosMsg\u003cT\u003e\u003e,\n    pub log: Vec\u003cLogAttribute\u003e,\n}\n\npub type InitResult\u003cU = Empty\u003e = StdResult\u003cInitResponse\u003cU\u003e\u003e;\n\nimpl\u003cT\u003e Default for InitResponse\u003cT\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    fn default() -\u003e Self {\n        InitResponse {\n            messages: vec![],\n            log: vec![],\n        }\n    }\n}\n\nimpl\u003cT\u003e TryFrom\u003cContext\u003cT\u003e\u003e for InitResponse\u003cT\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    type Error = StdError;\n\n    fn try_from(ctx: Context\u003cT\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if ctx.data.is_some() {\n            Err(StdError::generic_err(\n                \"cannot convert Context with data to InitResponse\",\n            ))\n        } else {\n            Ok(InitResponse {\n                messages: ctx.messages,\n                log: ctx.log,\n            })\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct HandleResponse\u003cT = Empty\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    pub messages: Vec\u003cCosmosMsg\u003cT\u003e\u003e,\n    pub log: Vec\u003cLogAttribute\u003e,\n    pub data: Option\u003cBinary\u003e,\n}\n\npub type HandleResult\u003cU = Empty\u003e = StdResult\u003cHandleResponse\u003cU\u003e\u003e;\n\nimpl\u003cT\u003e Default for HandleResponse\u003cT\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    fn default() -\u003e Self {\n        HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: None,\n        }\n    }\n}\n\nimpl\u003cT\u003e From\u003cContext\u003cT\u003e\u003e for HandleResponse\u003cT\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    fn from(ctx: Context\u003cT\u003e) -\u003e Self {\n        HandleResponse {\n            messages: ctx.messages,\n            log: ctx.log,\n            data: ctx.data,\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct MigrateResponse\u003cT = Empty\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    pub messages: Vec\u003cCosmosMsg\u003cT\u003e\u003e,\n    pub log: Vec\u003cLogAttribute\u003e,\n    pub data: Option\u003cBinary\u003e,\n}\n\npub type MigrateResult\u003cU = Empty\u003e = StdResult\u003cMigrateResponse\u003cU\u003e\u003e;\n\nimpl\u003cT\u003e Default for MigrateResponse\u003cT\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    fn default() -\u003e Self {\n        MigrateResponse {\n            messages: vec![],\n            log: vec![],\n            data: None,\n        }\n    }\n}\n\nimpl\u003cT\u003e From\u003cContext\u003cT\u003e\u003e for MigrateResponse\u003cT\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    fn from(ctx: Context\u003cT\u003e) -\u003e Self {\n        MigrateResponse {\n            messages: ctx.messages,\n            log: ctx.log,\n            data: ctx.data,\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub struct Context\u003cT = Empty\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    messages: Vec\u003cCosmosMsg\u003cT\u003e\u003e,\n    log: Vec\u003cLogAttribute\u003e,\n    data: Option\u003cBinary\u003e,\n}\n\nimpl\u003cT\u003e Default for Context\u003cT\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    fn default() -\u003e Self {\n        Context {\n            messages: vec![],\n            log: vec![],\n            data: None,\n        }\n    }\n}\n\nimpl\u003cT\u003e Context\u003cT\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq + JsonSchema,\n{\n    pub fn new() -\u003e Self {\n        Context::default()\n    }\n\n    pub fn add_log\u003cK: ToString, V: ToString\u003e(\u0026mut self, key: K, value: V) {\n        self.log.push(log(key, value));\n    }\n\n    pub fn add_message\u003cU: Into\u003cCosmosMsg\u003cT\u003e\u003e\u003e(\u0026mut self, msg: U) {\n        self.messages.push(msg.into());\n    }\n\n    pub fn set_data\u003cU: Into\u003cBinary\u003e\u003e(\u0026mut self, data: U) {\n        self.data = Some(data.into());\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::errors::StdError;\n    use crate::{coins, from_slice, to_vec, Uint128};\n    use std::convert::TryInto;\n\n    #[test]\n    fn log_works_for_different_types() {\n        let expeceted = LogAttribute {\n            key: \"foo\".to_string(),\n            value: \"42\".to_string(),\n        };\n\n        assert_eq!(log(\"foo\", \"42\"), expeceted);\n        assert_eq!(log(\"foo\".to_string(), \"42\"), expeceted);\n        assert_eq!(log(\"foo\", \"42\".to_string()), expeceted);\n        assert_eq!(log(\"foo\", HumanAddr::from(\"42\")), expeceted);\n        assert_eq!(log(\"foo\", Uint128(42)), expeceted);\n        assert_eq!(log(\"foo\", 42), expeceted);\n    }\n\n    #[test]\n    fn can_deser_error_result() {\n        let fail = InitResult::Err(StdError::Unauthorized { backtrace: None });\n        let bin = to_vec(\u0026fail).expect(\"encode contract result\");\n        println!(\"error: {}\", std::str::from_utf8(\u0026bin).unwrap());\n        let back: InitResult = from_slice(\u0026bin).expect(\"decode contract result\");\n        assert_eq!(fail, back);\n    }\n\n    #[test]\n    fn can_deser_ok_result() {\n        let send = InitResult::Ok(InitResponse {\n            messages: vec![BankMsg::Send {\n                from_address: HumanAddr(\"me\".to_string()),\n                to_address: HumanAddr(\"you\".to_string()),\n                amount: coins(1015, \"earth\"),\n            }\n            .into()],\n            log: vec![LogAttribute {\n                key: \"action\".to_string(),\n                value: \"release\".to_string(),\n            }],\n        });\n        let bin = to_vec(\u0026send).expect(\"encode contract result\");\n        println!(\"ok: {}\", std::str::from_utf8(\u0026bin).unwrap());\n        let back: InitResult = from_slice(\u0026bin).expect(\"decode contract result\");\n        assert_eq!(send, back);\n    }\n\n    #[test]\n    fn msg_from_works() {\n        let from_address = HumanAddr(\"me\".to_string());\n        let to_address = HumanAddr(\"you\".to_string());\n        let amount = coins(1015, \"earth\");\n        let bank = BankMsg::Send {\n            from_address,\n            to_address,\n            amount,\n        };\n        let msg: CosmosMsg = bank.clone().into();\n        match msg {\n            CosmosMsg::Bank(msg) =\u003e assert_eq!(bank, msg),\n            _ =\u003e panic!(\"must encode in Bank variant\"),\n        }\n    }\n\n    #[test]\n    fn empty_context() {\n        let ctx = Context::new();\n\n        let init: InitResponse = ctx.clone().try_into().unwrap();\n        assert_eq!(init, InitResponse::default());\n\n        let init: HandleResponse = ctx.clone().try_into().unwrap();\n        assert_eq!(init, HandleResponse::default());\n\n        let init: MigrateResponse = ctx.clone().try_into().unwrap();\n        assert_eq!(init, MigrateResponse::default());\n    }\n\n    #[test]\n    fn full_context() {\n        let mut ctx = Context::new();\n\n        // build it up with the builder commands\n        ctx.add_log(\"sender\", \u0026HumanAddr::from(\"john\"));\n        ctx.add_log(\"action\", \"test\");\n        ctx.add_message(BankMsg::Send {\n            from_address: HumanAddr::from(\"goo\"),\n            to_address: HumanAddr::from(\"foo\"),\n            amount: coins(128, \"uint\"),\n        });\n\n        // and this is what is should return\n        let expected_log = vec![log(\"sender\", \"john\"), log(\"action\", \"test\")];\n        let expected_msgs = vec![CosmosMsg::Bank(BankMsg::Send {\n            from_address: HumanAddr::from(\"goo\"),\n            to_address: HumanAddr::from(\"foo\"),\n            amount: coins(128, \"uint\"),\n        })];\n        let expected_data = Some(Binary::from(b\"banana\"));\n\n        // try InitResponse before setting data\n        let init: InitResponse = ctx.clone().try_into().unwrap();\n        assert_eq!(\u0026init.messages, \u0026expected_msgs);\n        assert_eq!(\u0026init.log, \u0026expected_log);\n\n        ctx.set_data(b\"banana\");\n        // should fail with data set\n        let init_err: StdResult\u003cInitResponse\u003e = ctx.clone().try_into();\n        match init_err.unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"cannot convert Context with data to InitResponse\")\n            }\n            e =\u003e panic!(\"Unexpected error: {}\", e),\n        }\n\n        // try Handle with everything set\n        let handle: HandleResponse = ctx.clone().try_into().unwrap();\n        assert_eq!(\u0026handle.messages, \u0026expected_msgs);\n        assert_eq!(\u0026handle.log, \u0026expected_log);\n        assert_eq!(\u0026handle.data, \u0026expected_data);\n\n        // try Migrate with everything set\n        let migrate: MigrateResponse = ctx.clone().try_into().unwrap();\n        assert_eq!(\u0026migrate.messages, \u0026expected_msgs);\n        assert_eq!(\u0026migrate.log, \u0026expected_log);\n        assert_eq!(\u0026migrate.data, \u0026expected_data);\n    }\n}\n","traces":[{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":43},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","iterator.rs"],"content":"use crate::errors::StdError;\nuse std::convert::TryFrom;\n\n/// KV is a Key-Value pair, returned from our iterators\npub type KV\u003cT = Vec\u003cu8\u003e\u003e = (Vec\u003cu8\u003e, T);\n\n#[derive(Copy, Clone)]\n// We assign these to integers to provide a stable API for passing over FFI (to wasm and Go)\npub enum Order {\n    Ascending = 1,\n    Descending = 2,\n}\n\nimpl TryFrom\u003ci32\u003e for Order {\n    type Error = StdError;\n\n    fn try_from(value: i32) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            1 =\u003e Ok(Order::Ascending),\n            2 =\u003e Ok(Order::Descending),\n            _ =\u003e Err(StdError::generic_err(\"Order must be 1 or 2\")),\n        }\n    }\n}\n\nimpl Into\u003ci32\u003e for Order {\n    fn into(self) -\u003e i32 {\n        self as i32\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","lib.rs"],"content":"// Exposed on all platforms\n\nmod addresses;\nmod coins;\nmod encoding;\nmod entry_points;\nmod errors;\nmod init_handle;\n#[cfg(feature = \"iterator\")]\nmod iterator;\nmod math;\nmod query;\nmod serde;\nmod storage;\nmod traits;\nmod types;\n\npub use crate::addresses::{CanonicalAddr, HumanAddr};\npub use crate::coins::{coin, coins, has_coins, Coin};\npub use crate::encoding::Binary;\npub use crate::errors::{StdError, StdResult, SystemError, SystemResult};\npub use crate::init_handle::{\n    log, BankMsg, Context, CosmosMsg, GovMsg, HandleResponse, HandleResult, InitResponse,\n    InitResult, LogAttribute, MigrateResponse, MigrateResult, StakingMsg, VoteOption, WasmMsg,\n};\n#[cfg(feature = \"iterator\")]\npub use crate::iterator::{Order, KV};\npub use crate::math::{Decimal, Uint128};\npub use crate::query::{\n    AllBalanceResponse, AllDelegationsResponse, BalanceResponse, BankQuery, BondedDenomResponse,\n    BondedRatioResponse, Delegation, DistQuery, FullDelegation, GovQuery, InflationResponse,\n    MintQuery, ProposalsResponse, QueryRequest, QueryResponse, QueryResult, RewardsResponse,\n    StakingQuery, UnbondingDelegationsResponse, Validator, ValidatorsResponse, WasmQuery,\n};\npub use crate::serde::{from_binary, from_slice, to_binary, to_vec};\npub use crate::storage::MemoryStorage;\npub use crate::traits::{Api, Extern, Querier, QuerierResult, ReadonlyStorage, Storage};\npub use crate::types::{BlockInfo, ContractInfo, Empty, Env, MessageInfo};\n\n// Exposed in wasm build only\n\n#[cfg(target_arch = \"wasm32\")]\nmod exports;\n#[cfg(target_arch = \"wasm32\")]\nmod imports;\n#[cfg(target_arch = \"wasm32\")]\nmod memory; // Used by exports and imports only. This assumes pointers are 32 bit long, which makes it untestable on dev machines.\n\n#[cfg(target_arch = \"wasm32\")]\npub use crate::exports::{do_handle, do_init, do_migrate, do_query};\n#[cfg(target_arch = \"wasm32\")]\npub use crate::imports::{ExternalApi, ExternalQuerier, ExternalStorage};\n\n// Exposed for testing only\n// Both unit tests and integration tests are compiled to native code, so everything in here does not need to compile to Wasm.\n\n#[cfg(not(target_arch = \"wasm32\"))]\nmod mock;\n#[cfg(not(target_arch = \"wasm32\"))]\npub mod testing {\n    pub use crate::mock::{\n        mock_dependencies, mock_dependencies_with_balances, mock_env, BankQuerier, MockApi,\n        MockQuerier, MockQuerierCustomHandlerResult, MockStorage, StakingQuerier,\n        MOCK_CONTRACT_ADDR,\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","math.rs"],"content":"use schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::convert::{TryFrom, TryInto};\nuse std::fmt::{self, Write};\nuse std::ops;\nuse std::str::FromStr;\n\nuse crate::errors::{StdError, StdResult};\n\n/// A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n///\n/// The greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Decimal(#[schemars(with = \"String\")] u128);\n\nconst DECIMAL_FRACTIONAL: u128 = 1_000_000_000_000_000_000;\n\nimpl Decimal {\n    pub const MAX: Decimal = Decimal(u128::MAX);\n\n    /// Create a 1.0 Decimal\n    pub const fn one() -\u003e Decimal {\n        Decimal(DECIMAL_FRACTIONAL)\n    }\n\n    /// Create a 0.0 Decimal\n    pub const fn zero() -\u003e Decimal {\n        Decimal(0)\n    }\n\n    /// Convert x% into Decimal\n    pub fn percent(x: u64) -\u003e Decimal {\n        Decimal((x as u128) * 10_000_000_000_000_000)\n    }\n\n    /// Convert permille (x/1000) into Decimal\n    pub fn permille(x: u64) -\u003e Decimal {\n        Decimal((x as u128) * 1_000_000_000_000_000)\n    }\n\n    /// Returns the ratio (nominator / denominator) as a Decimal\n    pub fn from_ratio\u003cA: Into\u003cu128\u003e, B: Into\u003cu128\u003e\u003e(nominator: A, denominator: B) -\u003e Decimal {\n        let nominator: u128 = nominator.into();\n        let denominator: u128 = denominator.into();\n        if denominator == 0 {\n            panic!(\"Denominator must not be zero\");\n        }\n        // TODO: better algorithm with less rounding potential?\n        Decimal(nominator * DECIMAL_FRACTIONAL / denominator)\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0 == 0\n    }\n}\n\nimpl FromStr for Decimal {\n    type Err = StdError;\n\n    /// Converts the decimal string to a Decimal\n    /// Possible inputs: \"1.23\", \"1\", \"000012\", \"1.123000000\"\n    /// Disallowed: \"\", \".23\"\n    ///\n    /// This never performs any kind of rounding.\n    /// More than 18 fractional digits, even zeros, result in an error.\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let parts: Vec\u003c\u0026str\u003e = input.split('.').collect();\n        match parts.len() {\n            1 =\u003e {\n                let whole = parts[0]\n                    .parse::\u003cu128\u003e()\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n\n                let whole_as_atomics = whole\n                    .checked_mul(DECIMAL_FRACTIONAL)\n                    .ok_or_else(|| StdError::generic_err(\"Value too big\"))?;\n                Ok(Decimal(whole_as_atomics))\n            }\n            2 =\u003e {\n                let whole = parts[0]\n                    .parse::\u003cu128\u003e()\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n                let fractional = parts[1]\n                    .parse::\u003cu128\u003e()\n                    .map_err(|_| StdError::generic_err(\"Error parsing fractional\"))?;\n                let exp = (18usize.checked_sub(parts[1].len())).ok_or_else(|| {\n                    StdError::generic_err(\"Cannot parse more than 18 fractional digits\")\n                })?;\n                let fractional_factor = 10u128\n                    .checked_pow(exp.try_into().unwrap())\n                    .ok_or_else(|| StdError::generic_err(\"Cannot compute fractional factor\"))?;\n\n                let whole_as_atomics = whole\n                    .checked_mul(DECIMAL_FRACTIONAL)\n                    .ok_or_else(|| StdError::generic_err(\"Value too big\"))?;\n                let atomics = whole_as_atomics\n                    .checked_add(fractional * fractional_factor)\n                    .ok_or_else(|| StdError::generic_err(\"Value too big\"))?;\n                Ok(Decimal(atomics))\n            }\n            _ =\u003e Err(StdError::generic_err(\"Unexpected number of dots\")),\n        }\n    }\n}\n\nimpl fmt::Display for Decimal {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let whole = (self.0) / DECIMAL_FRACTIONAL;\n        let fractional = (self.0) % DECIMAL_FRACTIONAL;\n\n        if fractional == 0 {\n            write!(f, \"{}\", whole)\n        } else {\n            let fractional_string = format!(\"{:018}\", fractional);\n            f.write_str(\u0026whole.to_string())?;\n            f.write_char('.')?;\n            f.write_str(fractional_string.trim_end_matches('0'))?;\n            Ok(())\n        }\n    }\n}\n\nimpl ops::Add for Decimal {\n    type Output = Self;\n\n    fn add(self, other: Self) -\u003e Self {\n        Decimal(self.0 + other.0)\n    }\n}\n\n/// Serializes as a decimal string\nimpl Serialize for Decimal {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Decimal {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cDecimal, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(DecimalVisitor)\n    }\n}\n\nstruct DecimalVisitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for DecimalVisitor {\n    type Value = Decimal;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded decimal\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match Decimal::from_str(v) {\n            Ok(d) =\u003e Ok(d),\n            Err(e) =\u003e Err(E::custom(format!(\"Error parsing decimal '{}': {}\", v, e))),\n        }\n    }\n}\n\n//*** Uint128 ***/\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Uint128(#[schemars(with = \"String\")] pub u128);\n\nimpl Uint128 {\n    /// Creates a Uint128(0)\n    pub const fn zero() -\u003e Self {\n        Uint128(0)\n    }\n\n    /// Returns a copy of the internal data\n    pub fn u128(\u0026self) -\u003e u128 {\n        self.0\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0 == 0\n    }\n}\n\nimpl From\u003cu128\u003e for Uint128 {\n    fn from(val: u128) -\u003e Self {\n        Uint128(val)\n    }\n}\n\nimpl From\u003cu64\u003e for Uint128 {\n    fn from(val: u64) -\u003e Self {\n        Uint128(val.into())\n    }\n}\n\nimpl TryFrom\u003c\u0026str\u003e for Uint128 {\n    type Error = StdError;\n\n    fn try_from(val: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match val.parse::\u003cu128\u003e() {\n            Ok(u) =\u003e Ok(Uint128(u)),\n            Err(e) =\u003e Err(StdError::generic_err(format!(\"Parsing coin: {}\", e))),\n        }\n    }\n}\n\nimpl Into\u003cString\u003e for Uint128 {\n    fn into(self) -\u003e String {\n        self.0.to_string()\n    }\n}\n\nimpl Into\u003cu128\u003e for Uint128 {\n    fn into(self) -\u003e u128 {\n        self.0\n    }\n}\n\nimpl fmt::Display for Uint128 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl ops::Add for Uint128 {\n    type Output = Self;\n\n    fn add(self, other: Self) -\u003e Self {\n        Uint128(self.u128() + other.u128())\n    }\n}\n\nimpl ops::AddAssign for Uint128 {\n    fn add_assign(\u0026mut self, other: Self) {\n        self.0 += other.u128();\n    }\n}\n\nimpl ops::Sub for Uint128 {\n    type Output = StdResult\u003cSelf\u003e;\n\n    fn sub(self, other: Self) -\u003e StdResult\u003cSelf\u003e {\n        let (min, sub) = (self.u128(), other.u128());\n        if sub \u003e min {\n            Err(StdError::underflow(min, sub))\n        } else {\n            Ok(Uint128(min - sub))\n        }\n    }\n}\n\n/// Both d*u and u*d with d: Decimal and u: Uint128 returns an Uint128. There is no\n/// specific reason for this decision other than the initial use cases we have. If you\n/// need a Decimal result for the same calculation, use Decimal(d*u) or Decimal(u*d).\nimpl ops::Mul\u003cDecimal\u003e for Uint128 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Decimal) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint128::zero();\n        }\n        self.multiply_ratio(rhs.0, DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Mul\u003cUint128\u003e for Decimal {\n    type Output = Uint128;\n\n    fn mul(self, rhs: Uint128) -\u003e Self::Output {\n        rhs * self\n    }\n}\n\nimpl Uint128 {\n    /// returns self * nom / denom\n    pub fn multiply_ratio\u003cA: Into\u003cu128\u003e, B: Into\u003cu128\u003e\u003e(\u0026self, nom: A, denom: B) -\u003e Uint128 {\n        let nominator: u128 = nom.into();\n        let denominator: u128 = denom.into();\n        if denominator == 0 {\n            panic!(\"Denominator must not be zero\");\n        }\n        // TODO: minimize rounding that takes place (using gcd algorithm)\n        let val = self.u128() * nominator / denominator;\n        Uint128::from(val)\n    }\n}\n\n/// Serializes as a base64 string\nimpl Serialize for Uint128 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Uint128 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cUint128, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Uint128Visitor)\n    }\n}\n\nstruct Uint128Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Uint128Visitor {\n    type Value = Uint128;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded integer\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match v.parse::\u003cu128\u003e() {\n            Ok(u) =\u003e Ok(Uint128(u)),\n            Err(e) =\u003e Err(E::custom(format!(\"invalid Uint128 '{}' - {}\", v, e))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::errors::{StdError, StdResult};\n    use crate::{from_slice, to_vec};\n    use std::convert::TryInto;\n\n    #[test]\n    fn decimal_one() {\n        let value = Decimal::one();\n        assert_eq!(value.0, DECIMAL_FRACTIONAL);\n    }\n\n    #[test]\n    fn decimal_zero() {\n        let value = Decimal::zero();\n        assert_eq!(value.0, 0);\n    }\n\n    #[test]\n    fn decimal_percent() {\n        let value = Decimal::percent(50);\n        assert_eq!(value.0, DECIMAL_FRACTIONAL / 2);\n    }\n\n    #[test]\n    fn decimal_permille() {\n        let value = Decimal::permille(125);\n        assert_eq!(value.0, DECIMAL_FRACTIONAL / 8);\n    }\n\n    #[test]\n    fn decimal_from_ratio_works() {\n        // 1.0\n        assert_eq!(Decimal::from_ratio(1u128, 1u128), Decimal::one());\n        assert_eq!(Decimal::from_ratio(53u128, 53u128), Decimal::one());\n        assert_eq!(Decimal::from_ratio(125u128, 125u128), Decimal::one());\n\n        // 1.5\n        assert_eq!(Decimal::from_ratio(3u128, 2u128), Decimal::percent(150));\n        assert_eq!(Decimal::from_ratio(150u128, 100u128), Decimal::percent(150));\n        assert_eq!(Decimal::from_ratio(333u128, 222u128), Decimal::percent(150));\n\n        // 0.125\n        assert_eq!(Decimal::from_ratio(1u64, 8u64), Decimal::permille(125));\n        assert_eq!(Decimal::from_ratio(125u64, 1000u64), Decimal::permille(125));\n\n        // 1/3 (result floored)\n        assert_eq!(\n            Decimal::from_ratio(1u64, 3u64),\n            Decimal(0_333_333_333_333_333_333)\n        );\n\n        // 2/3 (result floored)\n        assert_eq!(\n            Decimal::from_ratio(2u64, 3u64),\n            Decimal(0_666_666_666_666_666_666)\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn decimal_from_ratio_panics_for_zero_denominator() {\n        Decimal::from_ratio(1u128, 0u128);\n    }\n\n    #[test]\n    fn decimal_from_str_works() {\n        // Integers\n        assert_eq!(Decimal::from_str(\"0\").unwrap(), Decimal::percent(0));\n        assert_eq!(Decimal::from_str(\"1\").unwrap(), Decimal::percent(100));\n        assert_eq!(Decimal::from_str(\"5\").unwrap(), Decimal::percent(500));\n        assert_eq!(Decimal::from_str(\"42\").unwrap(), Decimal::percent(4200));\n        assert_eq!(Decimal::from_str(\"000\").unwrap(), Decimal::percent(0));\n        assert_eq!(Decimal::from_str(\"001\").unwrap(), Decimal::percent(100));\n        assert_eq!(Decimal::from_str(\"005\").unwrap(), Decimal::percent(500));\n        assert_eq!(Decimal::from_str(\"0042\").unwrap(), Decimal::percent(4200));\n\n        // Decimals\n        assert_eq!(Decimal::from_str(\"1.0\").unwrap(), Decimal::percent(100));\n        assert_eq!(Decimal::from_str(\"1.5\").unwrap(), Decimal::percent(150));\n        assert_eq!(Decimal::from_str(\"0.5\").unwrap(), Decimal::percent(50));\n        assert_eq!(Decimal::from_str(\"0.123\").unwrap(), Decimal::permille(123));\n\n        assert_eq!(Decimal::from_str(\"40.00\").unwrap(), Decimal::percent(4000));\n        assert_eq!(Decimal::from_str(\"04.00\").unwrap(), Decimal::percent(0400));\n        assert_eq!(Decimal::from_str(\"00.40\").unwrap(), Decimal::percent(0040));\n        assert_eq!(Decimal::from_str(\"00.04\").unwrap(), Decimal::percent(0004));\n\n        // Can handle 18 fractional digits\n        assert_eq!(\n            Decimal::from_str(\"7.123456789012345678\").unwrap(),\n            Decimal(7123456789012345678)\n        );\n        assert_eq!(\n            Decimal::from_str(\"7.999999999999999999\").unwrap(),\n            Decimal(7999999999999999999)\n        );\n\n        // Works for documented max value\n        assert_eq!(\n            Decimal::from_str(\"340282366920938463463.374607431768211455\").unwrap(),\n            Decimal::MAX\n        );\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_whole_part() {\n        match Decimal::from_str(\"\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal::from_str(\" \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal::from_str(\"-1\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_fractinal_part() {\n        match Decimal::from_str(\"1.\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal::from_str(\"1. \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal::from_str(\"1.e\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal::from_str(\"1.2e3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_more_than_18_fractional_digits() {\n        match Decimal::from_str(\"7.1234567890123456789\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        // No special rules for trailing zeros. This could be changed but adds gas cost for the happy path.\n        match Decimal::from_str(\"7.1230000000000000000\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_invalid_number_of_dots() {\n        match Decimal::from_str(\"1.2.3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal::from_str(\"1.2.3.4\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_more_than_max_value() {\n        // Integer\n        match Decimal::from_str(\"340282366920938463464\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Value too big\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        // Decimal\n        match Decimal::from_str(\"340282366920938463464.0\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Value too big\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n        match Decimal::from_str(\"340282366920938463463.374607431768211456\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Value too big\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_is_zero_works() {\n        assert_eq!(Decimal::zero().is_zero(), true);\n        assert_eq!(Decimal::percent(0).is_zero(), true);\n        assert_eq!(Decimal::permille(0).is_zero(), true);\n\n        assert_eq!(Decimal::one().is_zero(), false);\n        assert_eq!(Decimal::percent(123).is_zero(), false);\n        assert_eq!(Decimal::permille(1234).is_zero(), false);\n    }\n\n    #[test]\n    fn decimal_add() {\n        let value = Decimal::one() + Decimal::percent(50); // 1.5\n        assert_eq!(value.0, DECIMAL_FRACTIONAL * 3 / 2);\n    }\n\n    #[test]\n    fn decimal_to_string() {\n        // Integers\n        assert_eq!(Decimal::zero().to_string(), \"0\");\n        assert_eq!(Decimal::one().to_string(), \"1\");\n        assert_eq!(Decimal::percent(500).to_string(), \"5\");\n\n        // Decimals\n        assert_eq!(Decimal::percent(125).to_string(), \"1.25\");\n        assert_eq!(Decimal::percent(42638).to_string(), \"426.38\");\n        assert_eq!(Decimal::percent(1).to_string(), \"0.01\");\n        assert_eq!(Decimal::permille(987).to_string(), \"0.987\");\n\n        assert_eq!(Decimal(1).to_string(), \"0.000000000000000001\");\n        assert_eq!(Decimal(10).to_string(), \"0.00000000000000001\");\n        assert_eq!(Decimal(100).to_string(), \"0.0000000000000001\");\n        assert_eq!(Decimal(1000).to_string(), \"0.000000000000001\");\n        assert_eq!(Decimal(10000).to_string(), \"0.00000000000001\");\n        assert_eq!(Decimal(100000).to_string(), \"0.0000000000001\");\n        assert_eq!(Decimal(1000000).to_string(), \"0.000000000001\");\n        assert_eq!(Decimal(10000000).to_string(), \"0.00000000001\");\n        assert_eq!(Decimal(100000000).to_string(), \"0.0000000001\");\n        assert_eq!(Decimal(1000000000).to_string(), \"0.000000001\");\n        assert_eq!(Decimal(10000000000).to_string(), \"0.00000001\");\n        assert_eq!(Decimal(100000000000).to_string(), \"0.0000001\");\n        assert_eq!(Decimal(10000000000000).to_string(), \"0.00001\");\n        assert_eq!(Decimal(100000000000000).to_string(), \"0.0001\");\n        assert_eq!(Decimal(1000000000000000).to_string(), \"0.001\");\n        assert_eq!(Decimal(10000000000000000).to_string(), \"0.01\");\n        assert_eq!(Decimal(100000000000000000).to_string(), \"0.1\");\n    }\n\n    #[test]\n    fn decimal_serialize() {\n        assert_eq!(to_vec(\u0026Decimal::zero()).unwrap(), br#\"\"0\"\"#);\n        assert_eq!(to_vec(\u0026Decimal::one()).unwrap(), br#\"\"1\"\"#);\n        assert_eq!(to_vec(\u0026Decimal::percent(8)).unwrap(), br#\"\"0.08\"\"#);\n        assert_eq!(to_vec(\u0026Decimal::percent(87)).unwrap(), br#\"\"0.87\"\"#);\n        assert_eq!(to_vec(\u0026Decimal::percent(876)).unwrap(), br#\"\"8.76\"\"#);\n        assert_eq!(to_vec(\u0026Decimal::percent(8765)).unwrap(), br#\"\"87.65\"\"#);\n    }\n\n    #[test]\n    fn decimal_deserialize() {\n        assert_eq!(from_slice::\u003cDecimal\u003e(br#\"\"0\"\"#).unwrap(), Decimal::zero());\n        assert_eq!(from_slice::\u003cDecimal\u003e(br#\"\"1\"\"#).unwrap(), Decimal::one());\n        assert_eq!(from_slice::\u003cDecimal\u003e(br#\"\"000\"\"#).unwrap(), Decimal::zero());\n        assert_eq!(from_slice::\u003cDecimal\u003e(br#\"\"001\"\"#).unwrap(), Decimal::one());\n\n        assert_eq!(\n            from_slice::\u003cDecimal\u003e(br#\"\"0.08\"\"#).unwrap(),\n            Decimal::percent(8)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal\u003e(br#\"\"0.87\"\"#).unwrap(),\n            Decimal::percent(87)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal\u003e(br#\"\"8.76\"\"#).unwrap(),\n            Decimal::percent(876)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal\u003e(br#\"\"87.65\"\"#).unwrap(),\n            Decimal::percent(8765)\n        );\n    }\n\n    #[test]\n    fn to_and_from_uint128() {\n        let a: Uint128 = 12345u64.into();\n        assert_eq!(12345, a.u128());\n        assert_eq!(\"12345\", a.to_string());\n\n        let a: Uint128 = \"34567\".try_into().unwrap();\n        assert_eq!(34567, a.u128());\n        assert_eq!(\"34567\", a.to_string());\n\n        let a: StdResult\u003cUint128\u003e = \"1.23\".try_into();\n        assert!(a.is_err());\n    }\n\n    #[test]\n    fn uint128_is_zero_works() {\n        assert_eq!(Uint128::zero().is_zero(), true);\n        assert_eq!(Uint128(0).is_zero(), true);\n\n        assert_eq!(Uint128(1).is_zero(), false);\n        assert_eq!(Uint128(123).is_zero(), false);\n    }\n\n    #[test]\n    fn uint128_json() {\n        let orig = Uint128(1234567890987654321);\n        let serialized = to_vec(\u0026orig).unwrap();\n        assert_eq!(serialized.as_slice(), b\"\\\"1234567890987654321\\\"\");\n        let parsed: Uint128 = from_slice(\u0026serialized).unwrap();\n        assert_eq!(parsed, orig);\n    }\n\n    #[test]\n    fn uint128_compare() {\n        let a = Uint128(12345);\n        let b = Uint128(23456);\n\n        assert!(a \u003c b);\n        assert!(b \u003e a);\n        assert_eq!(a, Uint128(12345));\n    }\n\n    #[test]\n    fn uint128_math() {\n        let a = Uint128(12345);\n        let b = Uint128(23456);\n\n        // test + and - for valid values\n        assert_eq!(a + b, Uint128(35801));\n        assert_eq!((b - a).unwrap(), Uint128(11111));\n\n        // test +=\n        let mut c = Uint128(300000);\n        c += b;\n        assert_eq!(c, Uint128(323456));\n\n        // error result on underflow (- would produce negative result)\n        let underflow = a - b;\n        match underflow {\n            Ok(_) =\u003e panic!(\"should error\"),\n            Err(StdError::Underflow {\n                minuend,\n                subtrahend,\n                ..\n            }) =\u003e assert_eq!((minuend, subtrahend), (a.to_string(), b.to_string())),\n            _ =\u003e panic!(\"expected underflow error\"),\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn uint128_math_overflow_panics() {\n        // almost_max is 2^128 - 10\n        let almost_max = Uint128(340282366920938463463374607431768211446);\n        let _ = almost_max + Uint128(12);\n    }\n\n    #[test]\n    // in this test the Decimal is on the right\n    fn uint128_decimal_multiply() {\n        // a*b\n        let left = Uint128(300);\n        let right = Decimal::one() + Decimal::percent(50); // 1.5\n        assert_eq!(left * right, Uint128(450));\n\n        // a*0\n        let left = Uint128(300);\n        let right = Decimal::zero();\n        assert_eq!(left * right, Uint128(0));\n\n        // 0*a\n        let left = Uint128(0);\n        let right = Decimal::one() + Decimal::percent(50); // 1.5\n        assert_eq!(left * right, Uint128(0));\n    }\n\n    #[test]\n    fn u128_multiply_ratio_works() {\n        let base = Uint128(500);\n\n        // factor 1/1\n        assert_eq!(base.multiply_ratio(1u128, 1u128), Uint128(500));\n        assert_eq!(base.multiply_ratio(3u128, 3u128), Uint128(500));\n        assert_eq!(base.multiply_ratio(654321u128, 654321u128), Uint128(500));\n\n        // factor 3/2\n        assert_eq!(base.multiply_ratio(3u128, 2u128), Uint128(750));\n        assert_eq!(base.multiply_ratio(333333u128, 222222u128), Uint128(750));\n\n        // factor 2/3 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(2u128, 3u128), Uint128(333));\n        assert_eq!(base.multiply_ratio(222222u128, 333333u128), Uint128(333));\n\n        // factor 5/6 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(5u128, 6u128), Uint128(416));\n        assert_eq!(base.multiply_ratio(100u128, 120u128), Uint128(416));\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn u128_multiply_ratio_panics_for_zero_denominator() {\n        Uint128(500).multiply_ratio(1u128, 0u128);\n    }\n\n    #[test]\n    // in this test the Decimal is on the left\n    fn decimal_uint128_multiply() {\n        // a*b\n        let left = Decimal::one() + Decimal::percent(50); // 1.5\n        let right = Uint128(300);\n        assert_eq!(left * right, Uint128(450));\n\n        // 0*a\n        let left = Decimal::zero();\n        let right = Uint128(300);\n        assert_eq!(left * right, Uint128(0));\n\n        // a*0\n        let left = Decimal::one() + Decimal::percent(50); // 1.5\n        let right = Uint128(0);\n        assert_eq!(left * right, Uint128(0));\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":110},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","memory.rs"],"content":"use std::convert::TryFrom;\nuse std::mem;\nuse std::vec::Vec;\n\n/// Refers to some heap allocated data in Wasm.\n/// A pointer to an instance of this can be returned over FFI boundaries.\n///\n/// This struct is crate internal since the VM defined the same type independently.\n#[repr(C)]\npub struct Region {\n    pub offset: u32,\n    /// The number of bytes available in this region\n    pub capacity: u32,\n    /// The number of bytes used in this region\n    pub length: u32,\n}\n\n/// Creates a memory region of capacity `size` and length 0. Returns a pointer to the Region.\n/// This is the same as the `allocate` export, but designed to be called internally.\npub fn alloc(size: usize) -\u003e *mut Region {\n    let data: Vec\u003cu8\u003e = Vec::with_capacity(size);\n    let data_ptr = data.as_ptr() as usize;\n\n    let region = build_region_from_components(\n        u32::try_from(data_ptr).expect(\"pointer doesn't fit in u32\"),\n        u32::try_from(data.capacity()).expect(\"capacity doesn't fit in u32\"),\n        0,\n    );\n    mem::forget(data);\n    Box::into_raw(region)\n}\n\n/// Similar to alloc, but instead of creating a new vector it consumes an existing one and returns\n/// a pointer to the Region (preventing the memory from being freed until explicitly called later).\n///\n/// The resulting Region has capacity = length, i.e. the buffer's capacity is ignored.\npub fn release_buffer(buffer: Vec\u003cu8\u003e) -\u003e *mut Region {\n    let region = build_region(\u0026buffer);\n    mem::forget(buffer);\n    Box::into_raw(region)\n}\n\n/// Return the data referenced by the Region and\n/// deallocates the Region (and the vector when finished).\n/// Warning: only use this when you are sure the caller will never use (or free) the Region later\n///\n/// # Safety\n///\n/// The ptr must refer to a valid Region, which was previously returned by alloc,\n/// and not yet deallocated. This call will deallocate the Region and return an owner vector\n/// to the caller containing the referenced data.\n///\n/// Naturally, calling this function twice on the same pointer will double deallocate data\n/// and lead to a crash. Make sure to call it exactly once (either consuming the input in\n/// the wasm code OR deallocating the buffer from the caller).\npub unsafe fn consume_region(ptr: *mut Region) -\u003e Vec\u003cu8\u003e {\n    assert!(!ptr.is_null(), \"Region pointer is null\");\n    let region = Box::from_raw(ptr);\n\n    let region_start = region.offset as *mut u8;\n    // This case is explicitely disallowed by Vec\n    // \"The pointer will never be null, so this type is null-pointer-optimized.\"\n    assert!(!region_start.is_null(), \"Region starts at null pointer\");\n\n    Vec::from_raw_parts(\n        region_start,\n        region.length as usize,\n        region.capacity as usize,\n    )\n}\n\n/// Returns a box of a Region, which can be sent over a call to extern\n/// note that this DOES NOT take ownership of the data, and we MUST NOT consume_region\n/// the resulting data.\n/// The Box must be dropped (with scope), but not the data\npub fn build_region(data: \u0026[u8]) -\u003e Box\u003cRegion\u003e {\n    let data_ptr = data.as_ptr() as usize;\n    build_region_from_components(\n        u32::try_from(data_ptr).expect(\"pointer doesn't fit in u32\"),\n        u32::try_from(data.len()).expect(\"length doesn't fit in u32\"),\n        u32::try_from(data.len()).expect(\"length doesn't fit in u32\"),\n    )\n}\n\nfn build_region_from_components(offset: u32, capacity: u32, length: u32) -\u003e Box\u003cRegion\u003e {\n    Box::new(Region {\n        offset: offset,\n        capacity: capacity,\n        length: length,\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","mock.rs"],"content":"use serde::de::DeserializeOwned;\nuse std::collections::HashMap;\n\nuse crate::addresses::{CanonicalAddr, HumanAddr};\nuse crate::coins::Coin;\nuse crate::encoding::Binary;\nuse crate::errors::{StdError, StdResult, SystemError, SystemResult};\nuse crate::query::{\n    AllBalanceResponse, AllDelegationsResponse, BalanceResponse, BankQuery, BondedDenomResponse,\n    DelegationResponse, DistQuery, FullDelegation, GovQuery, MintQuery, QueryRequest, StakingQuery,\n    Validator, ValidatorsResponse, WasmQuery,\n};\nuse crate::serde::{from_slice, to_binary};\nuse crate::storage::MemoryStorage;\nuse crate::traits::{Api, Extern, Querier, QuerierResult};\nuse crate::types::{BlockInfo, ContractInfo, Empty, Env, MessageInfo};\nuse crate::{RewardsResponse, UnbondingDelegationsResponse};\n\npub const MOCK_CONTRACT_ADDR: \u0026str = \"cosmos2contract\";\n\n/// All external requirements that can be injected for unit tests.\n/// It sets the given balance for the contract itself, nothing else\npub fn mock_dependencies(\n    canonical_length: usize,\n    contract_balance: \u0026[Coin],\n) -\u003e Extern\u003cMockStorage, MockApi, MockQuerier\u003e {\n    let contract_addr = HumanAddr::from(MOCK_CONTRACT_ADDR);\n    Extern {\n        storage: MockStorage::default(),\n        api: MockApi::new(canonical_length),\n        querier: MockQuerier::new(\u0026[(\u0026contract_addr, contract_balance)]),\n    }\n}\n\n/// Initializes the querier along with the mock_dependencies.\n/// Sets all balances provided (yoy must explicitly set contract balance if desired)\npub fn mock_dependencies_with_balances(\n    canonical_length: usize,\n    balances: \u0026[(\u0026HumanAddr, \u0026[Coin])],\n) -\u003e Extern\u003cMockStorage, MockApi, MockQuerier\u003e {\n    Extern {\n        storage: MockStorage::default(),\n        api: MockApi::new(canonical_length),\n        querier: MockQuerier::new(balances),\n    }\n}\n\n// Use MemoryStorage implementation (which is valid in non-testcode)\n// We can later make simplifications here if needed\npub type MockStorage = MemoryStorage;\n\n// MockPrecompiles zero pads all human addresses to make them fit the canonical_length\n// it trims off zeros for the reverse operation.\n// not really smart, but allows us to see a difference (and consistent length for canonical adddresses)\n#[derive(Copy, Clone)]\npub struct MockApi {\n    canonical_length: usize,\n}\n\nimpl MockApi {\n    pub fn new(canonical_length: usize) -\u003e Self {\n        MockApi { canonical_length }\n    }\n}\n\nimpl Default for MockApi {\n    fn default() -\u003e Self {\n        Self::new(20)\n    }\n}\n\nimpl Api for MockApi {\n    fn canonical_address(\u0026self, human: \u0026HumanAddr) -\u003e StdResult\u003cCanonicalAddr\u003e {\n        // Dummy input validation. This is more sophisticated for formats like bech32, where format and checksum are validated.\n        if human.len() \u003c 3 {\n            return Err(StdError::generic_err(\n                \"Invalid input: human address too short\",\n            ));\n        }\n        if human.len() \u003e self.canonical_length {\n            return Err(StdError::generic_err(\n                \"Invalid input: human address too long\",\n            ));\n        }\n\n        let mut out = Vec::from(human.as_str());\n        let append = self.canonical_length - out.len();\n        if append \u003e 0 {\n            out.extend(vec![0u8; append]);\n        }\n        Ok(CanonicalAddr(Binary(out)))\n    }\n\n    fn human_address(\u0026self, canonical: \u0026CanonicalAddr) -\u003e StdResult\u003cHumanAddr\u003e {\n        if canonical.len() != self.canonical_length {\n            return Err(StdError::generic_err(\n                \"Invalid input: canonical address length not correct\",\n            ));\n        }\n\n        // remove trailing 0's (TODO: fix this - but fine for first tests)\n        let trimmed: Vec\u003cu8\u003e = canonical\n            .as_slice()\n            .iter()\n            .cloned()\n            .filter(|\u0026x| x != 0)\n            .collect();\n        // decode UTF-8 bytes into string\n        let human = String::from_utf8(trimmed).map_err(StdError::invalid_utf8)?;\n        Ok(HumanAddr(human))\n    }\n}\n\n/// Just set sender and sent funds for the message. The rest uses defaults.\n/// The sender will be canonicalized internally to allow developers pasing in human readable senders.\n/// This is intended for use in test code only.\npub fn mock_env\u003cU: Into\u003cHumanAddr\u003e\u003e(sender: U, sent: \u0026[Coin]) -\u003e Env {\n    Env {\n        block: BlockInfo {\n            height: 12_345,\n            time: 1_571_797_419,\n            chain_id: \"cosmos-testnet-14002\".to_string(),\n        },\n        message: MessageInfo {\n            sender: sender.into(),\n            sent_funds: sent.to_vec(),\n        },\n        contract: ContractInfo {\n            address: HumanAddr::from(MOCK_CONTRACT_ADDR),\n        },\n        contract_key: Some(\"\".to_string()),\n        contract_code_hash: \"\".to_string(),\n    }\n}\n\n/// The same type as cosmwasm-std's QuerierResult, but easier to reuse in\n/// cosmwasm-vm. It might diverge from QuerierResult at some point.\npub type MockQuerierCustomHandlerResult = SystemResult\u003cStdResult\u003cBinary\u003e\u003e;\n\n/// MockQuerier holds an immutable table of bank balances\n/// TODO: also allow querying contracts\npub struct MockQuerier\u003cC: DeserializeOwned = Empty\u003e {\n    bank: BankQuerier,\n    staking: StakingQuerier,\n    // placeholder to add support later\n    wasm: NoWasmQuerier,\n    dist: DistQuerier,\n    mint: MintQuerier,\n    gov: GovQuerier,\n    /// A handler to handle custom queries. This is set to a dummy handler that\n    /// always errors by default. Update it via `with_custom_handler`.\n    ///\n    /// Use box to avoid the need of another generic type\n    custom_handler: Box\u003cdyn for\u003c'a\u003e Fn(\u0026'a C) -\u003e MockQuerierCustomHandlerResult\u003e,\n}\n\nimpl\u003cC: DeserializeOwned\u003e MockQuerier\u003cC\u003e {\n    pub fn new(balances: \u0026[(\u0026HumanAddr, \u0026[Coin])]) -\u003e Self {\n        MockQuerier {\n            bank: BankQuerier::new(balances),\n            staking: StakingQuerier::default(),\n            wasm: NoWasmQuerier {},\n            dist: DistQuerier {},\n            mint: MintQuerier {},\n            gov: GovQuerier {},\n            // strange argument notation suggested as a workaround here: https://github.com/rust-lang/rust/issues/41078#issuecomment-294296365\n            custom_handler: Box::from(|_: \u0026_| -\u003e MockQuerierCustomHandlerResult {\n                Err(SystemError::UnsupportedRequest {\n                    kind: \"custom\".to_string(),\n                })\n            }),\n        }\n    }\n\n    // set a new balance for the given address and return the old balance\n    pub fn update_balance\u003cU: Into\u003cHumanAddr\u003e\u003e(\n        \u0026mut self,\n        addr: U,\n        balance: Vec\u003cCoin\u003e,\n    ) -\u003e Option\u003cVec\u003cCoin\u003e\u003e {\n        self.bank.balances.insert(addr.into(), balance)\n    }\n\n    #[cfg(feature = \"staking\")]\n    pub fn update_staking(\n        \u0026mut self,\n        denom: \u0026str,\n        validators: \u0026[crate::query::Validator],\n        delegations: \u0026[crate::query::FullDelegation],\n    ) {\n        self.staking = StakingQuerier::new(denom, validators, delegations);\n    }\n\n    pub fn with_custom_handler\u003cCH: 'static\u003e(mut self, handler: CH) -\u003e Self\n    where\n        CH: Fn(\u0026C) -\u003e MockQuerierCustomHandlerResult,\n    {\n        self.custom_handler = Box::from(handler);\n        self\n    }\n}\n\nimpl\u003cC: DeserializeOwned\u003e Querier for MockQuerier\u003cC\u003e {\n    fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n        let request: QueryRequest\u003cC\u003e = match from_slice(bin_request) {\n            Ok(v) =\u003e v,\n            Err(e) =\u003e {\n                return Err(SystemError::InvalidRequest {\n                    error: format!(\"Parsing query request: {}\", e),\n                    request: bin_request.into(),\n                })\n            }\n        };\n        self.handle_query(\u0026request)\n    }\n}\n\nimpl\u003cC: DeserializeOwned\u003e MockQuerier\u003cC\u003e {\n    pub fn handle_query(\u0026self, request: \u0026QueryRequest\u003cC\u003e) -\u003e QuerierResult {\n        match \u0026request {\n            QueryRequest::Bank(bank_query) =\u003e self.bank.query(bank_query),\n            QueryRequest::Custom(custom_query) =\u003e (*self.custom_handler)(custom_query),\n            QueryRequest::Staking(staking_query) =\u003e self.staking.query(staking_query),\n            QueryRequest::Wasm(msg) =\u003e self.wasm.query(msg),\n            QueryRequest::Dist(msg) =\u003e self.dist.query(msg),\n            QueryRequest::Mint(msg) =\u003e self.mint.query(msg),\n            QueryRequest::Gov(msg) =\u003e self.gov.query(msg),\n        }\n    }\n}\n\n#[derive(Clone, Default)]\nstruct NoWasmQuerier {\n    // FIXME: actually provide a way to call out\n}\n\nimpl NoWasmQuerier {\n    fn query(\u0026self, request: \u0026WasmQuery) -\u003e QuerierResult {\n        let addr = match request {\n            WasmQuery::Smart { contract_addr, .. } =\u003e contract_addr,\n            WasmQuery::Raw { contract_addr, .. } =\u003e contract_addr,\n        }\n        .clone();\n        Err(SystemError::NoSuchContract { addr })\n    }\n}\n\n#[derive(Clone, Default)]\npub struct GovQuerier {}\n\nimpl GovQuerier {\n    pub fn query(\u0026self, _request: \u0026GovQuery) -\u003e QuerierResult {\n        QuerierResult::Ok(Ok(Binary::default()))\n    }\n}\n\n#[derive(Clone, Default)]\npub struct MintQuerier {}\n\nimpl MintQuerier {\n    pub fn query(\u0026self, _request: \u0026MintQuery) -\u003e QuerierResult {\n        QuerierResult::Ok(Ok(Binary::default()))\n    }\n}\n\n#[derive(Clone, Default)]\npub struct DistQuerier {}\n\nimpl DistQuerier {\n    pub fn query(\u0026self, request: \u0026DistQuery) -\u003e QuerierResult {\n        match request {\n            DistQuery::Rewards { .. } =\u003e {\n                // proper error on not found, serialize result on found\n                let resp = RewardsResponse {\n                    rewards: vec![],\n                    total: vec![],\n                };\n                Ok(to_binary(\u0026resp))\n            }\n        }\n    }\n}\n\n#[derive(Clone, Default)]\npub struct BankQuerier {\n    balances: HashMap\u003cHumanAddr, Vec\u003cCoin\u003e\u003e,\n}\n\nimpl BankQuerier {\n    pub fn new(balances: \u0026[(\u0026HumanAddr, \u0026[Coin])]) -\u003e Self {\n        let mut map = HashMap::new();\n        for (addr, coins) in balances.iter() {\n            map.insert(HumanAddr::from(addr), coins.to_vec());\n        }\n        BankQuerier { balances: map }\n    }\n\n    pub fn query(\u0026self, request: \u0026BankQuery) -\u003e QuerierResult {\n        match request {\n            BankQuery::Balance { address, denom } =\u003e {\n                // proper error on not found, serialize result on found\n                let amount = self\n                    .balances\n                    .get(address)\n                    .and_then(|v| v.iter().find(|c| \u0026c.denom == denom).map(|c| c.amount))\n                    .unwrap_or_default();\n                let bank_res = BalanceResponse {\n                    amount: Coin {\n                        amount,\n                        denom: denom.to_string(),\n                    },\n                };\n                Ok(to_binary(\u0026bank_res))\n            }\n            BankQuery::AllBalances { address } =\u003e {\n                // proper error on not found, serialize result on found\n                let bank_res = AllBalanceResponse {\n                    amount: self.balances.get(address).cloned().unwrap_or_default(),\n                };\n                Ok(to_binary(\u0026bank_res))\n            }\n        }\n    }\n}\n\n#[derive(Clone, Default)]\npub struct StakingQuerier {\n    denom: String,\n    validators: Vec\u003cValidator\u003e,\n    delegations: Vec\u003cFullDelegation\u003e,\n}\n\nimpl StakingQuerier {\n    pub fn new(denom: \u0026str, validators: \u0026[Validator], delegations: \u0026[FullDelegation]) -\u003e Self {\n        StakingQuerier {\n            denom: denom.to_string(),\n            validators: validators.to_vec(),\n            delegations: delegations.to_vec(),\n        }\n    }\n\n    pub fn query(\u0026self, request: \u0026StakingQuery) -\u003e QuerierResult {\n        match request {\n            StakingQuery::BondedDenom {} =\u003e {\n                let res = BondedDenomResponse {\n                    denom: self.denom.clone(),\n                };\n                Ok(to_binary(\u0026res))\n            }\n            StakingQuery::Validators {} =\u003e {\n                let res = ValidatorsResponse {\n                    validators: self.validators.clone(),\n                };\n                Ok(to_binary(\u0026res))\n            }\n            StakingQuery::AllDelegations { delegator } =\u003e {\n                let delegations: Vec\u003c_\u003e = self\n                    .delegations\n                    .iter()\n                    .filter(|d| \u0026d.delegator == delegator)\n                    .cloned()\n                    .map(|d| d.into())\n                    .collect();\n                let res = AllDelegationsResponse { delegations };\n                Ok(to_binary(\u0026res))\n            }\n            StakingQuery::Delegation {\n                delegator,\n                validator,\n            } =\u003e {\n                let delegation = self\n                    .delegations\n                    .iter()\n                    .find(|d| \u0026d.delegator == delegator \u0026\u0026 \u0026d.validator == validator);\n                let res = DelegationResponse {\n                    delegation: delegation.cloned(),\n                };\n                Ok(to_binary(\u0026res))\n            }\n            StakingQuery::UnbondingDelegations { delegator } =\u003e {\n                let delegations: Vec\u003c_\u003e = self\n                    .delegations\n                    .iter()\n                    .filter(|d| \u0026d.delegator == delegator)\n                    .cloned()\n                    .map(|d| d.into())\n                    .collect();\n                let res = UnbondingDelegationsResponse { delegations };\n                Ok(to_binary(\u0026res))\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::query::Delegation;\n    use crate::{coin, coins, from_binary, Decimal, HumanAddr};\n\n    #[test]\n    fn mock_env_arguments() {\n        let name = HumanAddr(\"my name\".to_string());\n\n        // make sure we can generate with \u0026str, \u0026HumanAddr, and HumanAddr\n        let a = mock_env(\"my name\", \u0026coins(100, \"atom\"));\n        let b = mock_env(\u0026name, \u0026coins(100, \"atom\"));\n        let c = mock_env(name, \u0026coins(100, \"atom\"));\n\n        // and the results are the same\n        assert_eq!(a, b);\n        assert_eq!(a, c);\n    }\n\n    #[test]\n    fn flip_addresses() {\n        let api = MockApi::new(20);\n        let human = HumanAddr(\"shorty\".to_string());\n        let canon = api.canonical_address(\u0026human).unwrap();\n        assert_eq!(canon.len(), 20);\n        assert_eq!(\u0026canon.as_slice()[0..6], human.as_str().as_bytes());\n        assert_eq!(\u0026canon.as_slice()[6..], \u0026[0u8; 14]);\n\n        let recovered = api.human_address(\u0026canon).unwrap();\n        assert_eq!(human, recovered);\n    }\n\n    #[test]\n    #[should_panic(expected = \"length not correct\")]\n    fn human_address_input_length() {\n        let api = MockApi::new(10);\n        let input = CanonicalAddr(Binary(vec![61; 11]));\n        api.human_address(\u0026input).unwrap();\n    }\n\n    #[test]\n    #[should_panic(expected = \"address too short\")]\n    fn canonical_address_min_input_length() {\n        let api = MockApi::new(10);\n        let human = HumanAddr(\"1\".to_string());\n        let _ = api.canonical_address(\u0026human).unwrap();\n    }\n\n    #[test]\n    #[should_panic(expected = \"address too long\")]\n    fn canonical_address_max_input_length() {\n        let api = MockApi::new(10);\n        let human = HumanAddr(\"longer-than-10\".to_string());\n        let _ = api.canonical_address(\u0026human).unwrap();\n    }\n\n    #[test]\n    fn bank_querier_all_balances() {\n        let addr = HumanAddr::from(\"foobar\");\n        let balance = vec![coin(123, \"ELF\"), coin(777, \"FLY\")];\n        let bank = BankQuerier::new(\u0026[(\u0026addr, \u0026balance)]);\n\n        // all\n        let all = bank\n            .query(\u0026BankQuery::AllBalances {\n                address: addr.clone(),\n            })\n            .unwrap()\n            .unwrap();\n        let res: AllBalanceResponse = from_binary(\u0026all).unwrap();\n        assert_eq!(\u0026res.amount, \u0026balance);\n    }\n\n    #[test]\n    fn bank_querier_one_balance() {\n        let addr = HumanAddr::from(\"foobar\");\n        let balance = vec![coin(123, \"ELF\"), coin(777, \"FLY\")];\n        let bank = BankQuerier::new(\u0026[(\u0026addr, \u0026balance)]);\n\n        // one match\n        let fly = bank\n            .query(\u0026BankQuery::Balance {\n                address: addr.clone(),\n                denom: \"FLY\".to_string(),\n            })\n            .unwrap()\n            .unwrap();\n        let res: BalanceResponse = from_binary(\u0026fly).unwrap();\n        assert_eq!(res.amount, coin(777, \"FLY\"));\n\n        // missing denom\n        let miss = bank\n            .query(\u0026BankQuery::Balance {\n                address: addr.clone(),\n                denom: \"MISS\".to_string(),\n            })\n            .unwrap()\n            .unwrap();\n        let res: BalanceResponse = from_binary(\u0026miss).unwrap();\n        assert_eq!(res.amount, coin(0, \"MISS\"));\n    }\n\n    #[test]\n    fn bank_querier_missing_account() {\n        let addr = HumanAddr::from(\"foobar\");\n        let balance = vec![coin(123, \"ELF\"), coin(777, \"FLY\")];\n        let bank = BankQuerier::new(\u0026[(\u0026addr, \u0026balance)]);\n\n        // all balances on empty account is empty vec\n        let all = bank\n            .query(\u0026BankQuery::AllBalances {\n                address: HumanAddr::from(\"elsewhere\"),\n            })\n            .unwrap()\n            .unwrap();\n        let res: AllBalanceResponse = from_binary(\u0026all).unwrap();\n        assert_eq!(res.amount, vec![]);\n\n        // any denom on balances on empty account is empty coin\n        let miss = bank\n            .query(\u0026BankQuery::Balance {\n                address: HumanAddr::from(\"elsewhere\"),\n                denom: \"ELF\".to_string(),\n            })\n            .unwrap()\n            .unwrap();\n        let res: BalanceResponse = from_binary(\u0026miss).unwrap();\n        assert_eq!(res.amount, coin(0, \"ELF\"));\n    }\n\n    #[test]\n    fn staking_querier_validators() {\n        let val1 = Validator {\n            address: HumanAddr::from(\"validator-one\"),\n            commission: Decimal::percent(1),\n            max_commission: Decimal::percent(3),\n            max_change_rate: Decimal::percent(1),\n        };\n        let val2 = Validator {\n            address: HumanAddr::from(\"validator-two\"),\n            commission: Decimal::permille(15),\n            max_commission: Decimal::permille(40),\n            max_change_rate: Decimal::permille(5),\n        };\n\n        let staking = StakingQuerier::new(\"ustake\", \u0026[val1.clone(), val2.clone()], \u0026[]);\n\n        // one match\n        let raw = staking\n            .query(\u0026StakingQuery::Validators {})\n            .unwrap()\n            .unwrap();\n        let vals: ValidatorsResponse = from_binary(\u0026raw).unwrap();\n        assert_eq!(vals.validators, vec![val1, val2]);\n    }\n\n    // gets delegators from query or panic\n    fn get_all_delegators(staking: \u0026StakingQuerier, delegator: HumanAddr) -\u003e Vec\u003cDelegation\u003e {\n        let raw = staking\n            .query(\u0026StakingQuery::AllDelegations { delegator })\n            .unwrap()\n            .unwrap();\n        let dels: AllDelegationsResponse = from_binary(\u0026raw).unwrap();\n        dels.delegations\n    }\n\n    // gets full delegators from query or panic\n    fn get_delegator(\n        staking: \u0026StakingQuerier,\n        delegator: HumanAddr,\n        validator: HumanAddr,\n    ) -\u003e Option\u003cFullDelegation\u003e {\n        let raw = staking\n            .query(\u0026StakingQuery::Delegation {\n                delegator,\n                validator,\n            })\n            .unwrap()\n            .unwrap();\n        let dels: DelegationResponse = from_binary(\u0026raw).unwrap();\n        dels.delegation\n    }\n\n    #[test]\n    fn staking_querier_delegations() {\n        let val1 = HumanAddr::from(\"validator-one\");\n        let val2 = HumanAddr::from(\"validator-two\");\n\n        let user_a = HumanAddr::from(\"investor\");\n        let user_b = HumanAddr::from(\"speculator\");\n        let user_c = HumanAddr::from(\"hodler\");\n\n        // we need multiple validators per delegator, so the queries provide different results\n        let del1a = FullDelegation {\n            delegator: user_a.clone(),\n            validator: val1.clone(),\n            amount: coin(100, \"ustake\"),\n            can_redelegate: coin(100, \"ustake\"),\n            accumulated_rewards: coin(5, \"ustake\"),\n        };\n        let del2a = FullDelegation {\n            delegator: user_a.clone(),\n            validator: val2.clone(),\n            amount: coin(500, \"ustake\"),\n            can_redelegate: coin(500, \"ustake\"),\n            accumulated_rewards: coin(20, \"ustake\"),\n        };\n\n        // note we cannot have multiple delegations on one validator, they are collapsed into one\n        let del1b = FullDelegation {\n            delegator: user_b.clone(),\n            validator: val1.clone(),\n            amount: coin(500, \"ustake\"),\n            can_redelegate: coin(0, \"ustake\"),\n            accumulated_rewards: coin(0, \"ustake\"),\n        };\n\n        // and another one on val2\n        let del2c = FullDelegation {\n            delegator: user_c.clone(),\n            validator: val2.clone(),\n            amount: coin(8888, \"ustake\"),\n            can_redelegate: coin(4567, \"ustake\"),\n            accumulated_rewards: coin(900, \"ustake\"),\n        };\n\n        let staking = StakingQuerier::new(\n            \"ustake\",\n            \u0026[],\n            \u0026[del1a.clone(), del1b.clone(), del2a.clone(), del2c.clone()],\n        );\n\n        // get all for user a\n        let dels = get_all_delegators(\u0026staking, user_a.clone());\n        assert_eq!(dels, vec![del1a.clone().into(), del2a.clone().into()]);\n\n        // get all for user b\n        let dels = get_all_delegators(\u0026staking, user_b.clone());\n        assert_eq!(dels, vec![del1b.clone().into()]);\n\n        // get all for user c\n        let dels = get_all_delegators(\u0026staking, user_c.clone());\n        assert_eq!(dels, vec![del2c.clone().into()]);\n\n        // for user with no delegations...\n        let dels = get_all_delegators(\u0026staking, HumanAddr::from(\"no one\"));\n        assert_eq!(dels, vec![]);\n\n        // filter a by validator (1 and 1)\n        let dels = get_delegator(\u0026staking, user_a.clone(), val1.clone());\n        assert_eq!(dels, Some(del1a.clone()));\n        let dels = get_delegator(\u0026staking, user_a.clone(), val2.clone());\n        assert_eq!(dels, Some(del2a.clone()));\n\n        // filter b by validator (2 and 0)\n        let dels = get_delegator(\u0026staking, user_b.clone(), val1.clone());\n        assert_eq!(dels, Some(del1b.clone()));\n        let dels = get_delegator(\u0026staking, user_b.clone(), val2.clone());\n        assert_eq!(dels, None);\n\n        // filter c by validator (0 and 1)\n        let dels = get_delegator(\u0026staking, user_c.clone(), val1.clone());\n        assert_eq!(dels, None);\n        let dels = get_delegator(\u0026staking, user_c.clone(), val2.clone());\n        assert_eq!(dels, Some(del2c.clone()));\n    }\n}\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":119},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","query.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\nuse crate::addresses::HumanAddr;\nuse crate::coins::Coin;\nuse crate::encoding::Binary;\nuse crate::errors::StdResult;\nuse crate::math::Decimal;\n\npub type QueryResponse = Binary;\n\npub type QueryResult = StdResult\u003cQueryResponse\u003e;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryRequest\u003cT\u003e {\n    Bank(BankQuery),\n    Custom(T),\n    Staking(StakingQuery),\n    Wasm(WasmQuery),\n    Dist(DistQuery),\n    Mint(MintQuery),\n    Gov(GovQuery),\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum BankQuery {\n    /// This calls into the native bank module for one denomination\n    /// Return value is BalanceResponse\n    Balance { address: HumanAddr, denom: String },\n    /// This calls into the native bank module for all denominations.\n    /// Note that this may be much more expensive than Balance and should be avoided if possible.\n    /// Return value is AllBalanceResponse.\n    AllBalances { address: HumanAddr },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum GovQuery {\n    /// Returns all the currently active proposals. Might be useful to filter out invalid votes, and trigger\n    /// in-contract voting periods\n    Proposals {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum DistQuery {\n    /// This calls into the native bank module for all denominations.\n    /// Note that this may be much more expensive than Balance and should be avoided if possible.\n    /// Return value is AllBalanceResponse.\n    Rewards { delegator: HumanAddr },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum MintQuery {\n    /// This calls into the native bank module for all denominations.\n    /// Note that this may be much more expensive than Balance and should be avoided if possible.\n    /// Return value is AllBalanceResponse.\n    Inflation {},\n    BondedRatio {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum WasmQuery {\n    /// this queries the public API of another contract at a known address (with known ABI)\n    /// return value is whatever the contract returns (caller should know)\n    Smart {\n        contract_addr: HumanAddr,\n        /// callback_code_hash is the hex encoded hash of the code. This is used by Secret Network to harden against replaying the contract\n        /// It is used to bind the request to a destination contract in a stronger way than just the contract address which can be faked\n        callback_code_hash: String,\n        /// msg is the json-encoded QueryMsg struct\n        msg: Binary,\n    },\n    /// this queries the raw kv-store of the contract.\n    /// returns the raw, unparsed data stored at that key (or `Ok(Err(StdError:NotFound{}))` if missing)\n    Raw {\n        contract_addr: HumanAddr,\n        /// Key is the raw key used in the contracts Storage\n        key: Binary,\n        /// callback_code_hash is the hex encoded hash of the code. This is used by Secret Network to harden against replaying the contract\n        /// It is used to bind the request to a destination contract in a stronger way than just the contract address which can be faked\n        callback_code_hash: String,\n    },\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq + JsonSchema\u003e From\u003cGovQuery\u003e for QueryRequest\u003cT\u003e {\n    fn from(msg: GovQuery) -\u003e Self {\n        QueryRequest::Gov(msg)\n    }\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq + JsonSchema\u003e From\u003cMintQuery\u003e for QueryRequest\u003cT\u003e {\n    fn from(msg: MintQuery) -\u003e Self {\n        QueryRequest::Mint(msg)\n    }\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq + JsonSchema\u003e From\u003cDistQuery\u003e for QueryRequest\u003cT\u003e {\n    fn from(msg: DistQuery) -\u003e Self {\n        QueryRequest::Dist(msg)\n    }\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq + JsonSchema\u003e From\u003cBankQuery\u003e for QueryRequest\u003cT\u003e {\n    fn from(msg: BankQuery) -\u003e Self {\n        QueryRequest::Bank(msg)\n    }\n}\n\n#[cfg(feature = \"staking\")]\nimpl\u003cT: Clone + fmt::Debug + PartialEq + JsonSchema\u003e From\u003cStakingQuery\u003e for QueryRequest\u003cT\u003e {\n    fn from(msg: StakingQuery) -\u003e Self {\n        QueryRequest::Staking(msg)\n    }\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq + JsonSchema\u003e From\u003cWasmQuery\u003e for QueryRequest\u003cT\u003e {\n    fn from(msg: WasmQuery) -\u003e Self {\n        QueryRequest::Wasm(msg)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct BalanceResponse {\n    /// Always returns a Coin with the requested denom.\n    /// This may be of 0 amount if no such funds.\n    pub amount: Coin,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct AllBalanceResponse {\n    /// Returns all non-zero coins held by this account.\n    pub amount: Vec\u003cCoin\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum StakingQuery {\n    /// Returns the denomination that can be bonded (if there are multiple native tokens on the chain)\n    BondedDenom {},\n    /// AllDelegations will return all delegations by the delegator\n    AllDelegations { delegator: HumanAddr },\n    /// Delegation will return more detailed info on a particular\n    /// delegation, defined by delegator/validator pair\n    Delegation {\n        delegator: HumanAddr,\n        validator: HumanAddr,\n    },\n    /// Returns all registered Validators on the system\n    Validators {},\n    /// Returns all the unbonding delegations by the delegator\n    UnbondingDelegations { delegator: HumanAddr },\n}\n\n/// ProposalsResponse is data format returned from GovQuery::Proposals query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct ProposalsResponse {\n    pub proposals: Vec\u003cProposal\u003e,\n}\n\n/// ProposalsResponse is data format returned from GovQuery::Proposals query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Proposal {\n    pub id: u64,\n    /// Time of the block where MinDeposit was reached. -1 if MinDeposit is not reached\n    pub voting_start_time: u64,\n    /// Time that the VotingPeriod for this proposal will end and votes will be tallied\n    pub voting_end_time: u64,\n}\n\n/// BondedDenomResponse is data format returned from StakingRequest::BondedDenom query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct BondedDenomResponse {\n    pub denom: String,\n}\n\n/// UnbondingDelegationsResponse is data format returned from StakingRequest::UnbondingDelegations query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct UnbondingDelegationsResponse {\n    pub delegations: Vec\u003cDelegation\u003e,\n}\n\n/// DelegationsResponse is data format returned from StakingRequest::AllDelegations query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct AllDelegationsResponse {\n    pub delegations: Vec\u003cDelegation\u003e,\n}\n\n/// Delegation is basic (cheap to query) data about a delegation\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Delegation {\n    pub delegator: HumanAddr,\n    pub validator: HumanAddr,\n    /// How much we have locked in the delegation\n    pub amount: Coin,\n}\n\nimpl From\u003cFullDelegation\u003e for Delegation {\n    fn from(full: FullDelegation) -\u003e Self {\n        Delegation {\n            delegator: full.delegator,\n            validator: full.validator,\n            amount: full.amount,\n        }\n    }\n}\n\n/// DelegationResponse is data format returned from StakingRequest::Delegation query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct DelegationResponse {\n    pub delegation: Option\u003cFullDelegation\u003e,\n}\n\n/// FullDelegation is all the info on the delegation, some (like accumulated_reward and can_redelegate)\n/// is expensive to query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct FullDelegation {\n    pub delegator: HumanAddr,\n    pub validator: HumanAddr,\n    /// How much we have locked in the delegation\n    pub amount: Coin,\n    /// can_redelegate captures how much can be immediately redelegated.\n    /// 0 is no redelegation and can_redelegate == amount is redelegate all\n    /// but there are many places between the two\n    pub can_redelegate: Coin,\n    /// How much we can currently withdraw\n    pub accumulated_rewards: Coin,\n}\n\n/// ValidatorsResponse is data format returned from StakingRequest::Validators query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct ValidatorsResponse {\n    pub validators: Vec\u003cValidator\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Validator {\n    pub address: HumanAddr,\n    pub commission: Decimal,\n    pub max_commission: Decimal,\n    /// TODO: what units are these (in terms of time)?\n    pub max_change_rate: Decimal,\n}\n\n/// Rewards response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct RewardsResponse {\n    pub rewards: Vec\u003cValidatorRewards\u003e,\n    pub total: Vec\u003cCoin\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct ValidatorRewards {\n    pub validator_address: HumanAddr,\n    pub reward: Vec\u003cCoin\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct RewardCoin {\n    pub coin: String,\n    pub demon: String,\n}\n\n/// Inflation response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InflationResponse {\n    pub inflation_rate: String,\n}\n\n/// Bonded Ratio response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct BondedRatioResponse {\n    pub bonded_ratio: String,\n}\n","traces":[{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","serde.rs"],"content":"// This file simply re-exports some methods from serde_json\n// The reason is two fold:\n// 1. To easily ensure that all calling libraries use the same version (minimize code size)\n// 2. To allow us to switch out to eg. serde-json-core more easily\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::any::type_name;\n\nuse crate::encoding::Binary;\nuse crate::errors::{StdError, StdResult};\n\npub fn from_slice\u003cT: DeserializeOwned\u003e(value: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n    serde_json_wasm::from_slice(value).map_err(|e| StdError::parse_err(type_name::\u003cT\u003e(), e))\n}\n\npub fn from_binary\u003cT: DeserializeOwned\u003e(value: \u0026Binary) -\u003e StdResult\u003cT\u003e {\n    from_slice(value.as_slice())\n}\n\npub fn to_vec\u003cT\u003e(data: \u0026T) -\u003e StdResult\u003cVec\u003cu8\u003e\u003e\nwhere\n    T: Serialize + ?Sized,\n{\n    serde_json_wasm::to_vec(data).map_err(|e| StdError::serialize_err(type_name::\u003cT\u003e(), e))\n}\n\npub fn to_binary\u003cT\u003e(data: \u0026T) -\u003e StdResult\u003cBinary\u003e\nwhere\n    T: Serialize + ?Sized,\n{\n    to_vec(data).map(Binary)\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use serde::Deserialize;\n\n    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n    #[serde(rename_all = \"snake_case\")]\n    enum SomeMsg {\n        Refund {},\n        ReleaseAll {\n            image: String,\n            amount: u32,\n            time: u64,\n            karma: i32,\n        },\n        Cowsay {\n            text: String,\n        },\n    }\n\n    #[test]\n    fn to_vec_works() {\n        let msg = SomeMsg::Refund {};\n        let serialized = to_vec(\u0026msg).unwrap();\n        assert_eq!(serialized, br#\"{\"refund\":{}}\"#);\n\n        let msg = SomeMsg::ReleaseAll {\n            image: \"foo\".to_string(),\n            amount: 42,\n            time: 9007199254740999, // Number.MAX_SAFE_INTEGER + 7\n            karma: -17,\n        };\n        let serialized = String::from_utf8(to_vec(\u0026msg).unwrap()).unwrap();\n        assert_eq!(\n            serialized,\n            r#\"{\"release_all\":{\"image\":\"foo\",\"amount\":42,\"time\":9007199254740999,\"karma\":-17}}\"#\n        );\n    }\n\n    #[test]\n    fn from_slice_works() {\n        let deserialized: SomeMsg = from_slice(br#\"{\"refund\":{}}\"#).unwrap();\n        assert_eq!(deserialized, SomeMsg::Refund {});\n\n        let deserialized: SomeMsg = from_slice(\n            br#\"{\"release_all\":{\"image\":\"foo\",\"amount\":42,\"time\":18446744073709551615,\"karma\":-17}}\"#,\n        )\n        .unwrap();\n        assert_eq!(\n            deserialized,\n            SomeMsg::ReleaseAll {\n                image: \"foo\".to_string(),\n                amount: 42,\n                time: 18446744073709551615,\n                karma: -17\n            }\n        );\n    }\n\n    #[test]\n    fn to_vec_works_for_special_chars() {\n        let msg = SomeMsg::Cowsay {\n            text: \"foo\\\"bar\\\\\\\"bla\".to_string(),\n        };\n        let serialized = String::from_utf8(to_vec(\u0026msg).unwrap()).unwrap();\n        assert_eq!(serialized, r#\"{\"cowsay\":{\"text\":\"foo\\\"bar\\\\\\\"bla\"}}\"#);\n    }\n\n    #[test]\n    fn from_slice_works_for_special_chars() {\n        let deserialized: SomeMsg =\n            from_slice(br#\"{\"cowsay\":{\"text\":\"foo\\\"bar\\\\\\\"bla\"}}\"#).unwrap();\n        assert_eq!(\n            deserialized,\n            SomeMsg::Cowsay {\n                text: \"foo\\\"bar\\\\\\\"bla\".to_string(),\n            }\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","storage.rs"],"content":"use std::collections::BTreeMap;\n#[cfg(feature = \"iterator\")]\nuse std::iter;\n#[cfg(feature = \"iterator\")]\nuse std::ops::{Bound, RangeBounds};\n\n#[cfg(feature = \"iterator\")]\nuse crate::iterator::{Order, KV};\nuse crate::traits::{ReadonlyStorage, Storage};\n\n#[derive(Default)]\npub struct MemoryStorage {\n    data: BTreeMap\u003cVec\u003cu8\u003e, Vec\u003cu8\u003e\u003e,\n}\n\nimpl MemoryStorage {\n    pub fn new() -\u003e Self {\n        MemoryStorage::default()\n    }\n}\n\nimpl ReadonlyStorage for MemoryStorage {\n    fn get(\u0026self, key: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        self.data.get(key).cloned()\n    }\n\n    #[cfg(feature = \"iterator\")]\n    /// range allows iteration over a set of keys, either forwards or backwards\n    /// uses standard rust range notation, and eg db.range(b\"foo\"..b\"bar\") also works reverse\n    fn range\u003c'a\u003e(\n        \u0026'a self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = KV\u003e + 'a\u003e {\n        let bounds = range_bounds(start, end);\n\n        // BTreeMap.range panics if range is start \u003e end.\n        // However, this cases represent just empty range and we treat it as such.\n        match (bounds.start_bound(), bounds.end_bound()) {\n            (Bound::Included(start), Bound::Excluded(end)) if start \u003e end =\u003e {\n                return Box::new(iter::empty());\n            }\n            _ =\u003e {}\n        }\n\n        let iter = self.data.range(bounds);\n        match order {\n            Order::Ascending =\u003e Box::new(iter.map(clone_item)),\n            Order::Descending =\u003e Box::new(iter.rev().map(clone_item)),\n        }\n    }\n}\n\n#[cfg(feature = \"iterator\")]\nfn range_bounds(start: Option\u003c\u0026[u8]\u003e, end: Option\u003c\u0026[u8]\u003e) -\u003e impl RangeBounds\u003cVec\u003cu8\u003e\u003e {\n    (\n        start.map_or(Bound::Unbounded, |x| Bound::Included(x.to_vec())),\n        end.map_or(Bound::Unbounded, |x| Bound::Excluded(x.to_vec())),\n    )\n}\n\n#[cfg(feature = \"iterator\")]\n/// The BTreeMap specific key-value pair reference type, as returned by BTreeMap\u003cVec\u003cu8\u003e, T\u003e::range.\n/// This is internal as it can change any time if the map implementation is swapped out.\ntype BTreeMapPairRef\u003c'a, T = Vec\u003cu8\u003e\u003e = (\u0026'a Vec\u003cu8\u003e, \u0026'a T);\n\n#[cfg(feature = \"iterator\")]\nfn clone_item\u003cT: Clone\u003e(item_ref: BTreeMapPairRef\u003cT\u003e) -\u003e KV\u003cT\u003e {\n    let (key, value) = item_ref;\n    (key.clone(), value.clone())\n}\n\nimpl Storage for MemoryStorage {\n    fn set(\u0026mut self, key: \u0026[u8], value: \u0026[u8]) {\n        self.data.insert(key.to_vec(), value.to_vec());\n    }\n\n    fn remove(\u0026mut self, key: \u0026[u8]) {\n        self.data.remove(key);\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn get_and_set() {\n        let mut store = MemoryStorage::new();\n        assert_eq!(store.get(b\"foo\"), None);\n        store.set(b\"foo\", b\"bar\");\n        assert_eq!(store.get(b\"foo\"), Some(b\"bar\".to_vec()));\n        assert_eq!(store.get(b\"food\"), None);\n    }\n\n    #[test]\n    fn delete() {\n        let mut store = MemoryStorage::new();\n        store.set(b\"foo\", b\"bar\");\n        store.set(b\"food\", b\"bank\");\n        store.remove(b\"foo\");\n\n        assert_eq!(store.get(b\"foo\"), None);\n        assert_eq!(store.get(b\"food\"), Some(b\"bank\".to_vec()));\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn iterator() {\n        let mut store = MemoryStorage::new();\n        store.set(b\"foo\", b\"bar\");\n\n        // ensure we had previously set \"foo\" = \"bar\"\n        assert_eq!(store.get(b\"foo\"), Some(b\"bar\".to_vec()));\n        assert_eq!(store.range(None, None, Order::Ascending).count(), 1);\n\n        // setup - add some data, and delete part of it as well\n        store.set(b\"ant\", b\"hill\");\n        store.set(b\"ze\", b\"bra\");\n\n        // noise that should be ignored\n        store.set(b\"bye\", b\"bye\");\n        store.remove(b\"bye\");\n\n        // unbounded\n        {\n            let iter = store.range(None, None, Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                ]\n            );\n        }\n\n        // unbounded (descending)\n        {\n            let iter = store.range(None, None, Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                ]\n            );\n        }\n\n        // bounded\n        {\n            let iter = store.range(Some(b\"f\"), Some(b\"n\"), Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![(b\"foo\".to_vec(), b\"bar\".to_vec())]);\n        }\n\n        // bounded (descending)\n        {\n            let iter = store.range(Some(b\"air\"), Some(b\"loop\"), Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                ]\n            );\n        }\n\n        // bounded empty [a, a)\n        {\n            let iter = store.range(Some(b\"foo\"), Some(b\"foo\"), Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![]);\n        }\n\n        // bounded empty [a, a) (descending)\n        {\n            let iter = store.range(Some(b\"foo\"), Some(b\"foo\"), Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![]);\n        }\n\n        // bounded empty [a, b) with b \u003c a\n        {\n            let iter = store.range(Some(b\"z\"), Some(b\"a\"), Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![]);\n        }\n\n        // bounded empty [a, b) with b \u003c a (descending)\n        {\n            let iter = store.range(Some(b\"z\"), Some(b\"a\"), Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![]);\n        }\n\n        // right unbounded\n        {\n            let iter = store.range(Some(b\"f\"), None, Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                ]\n            );\n        }\n\n        // right unbounded (descending)\n        {\n            let iter = store.range(Some(b\"f\"), None, Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                ]\n            );\n        }\n\n        // left unbounded\n        {\n            let iter = store.range(None, Some(b\"f\"), Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![(b\"ant\".to_vec(), b\"hill\".to_vec()),]);\n        }\n\n        // left unbounded (descending)\n        {\n            let iter = store.range(None, Some(b\"no\"), Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                ]\n            );\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":18},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","traits.rs"],"content":"use serde::{de::DeserializeOwned, Serialize};\n\nuse crate::addresses::{CanonicalAddr, HumanAddr};\nuse crate::coins::Coin;\nuse crate::encoding::Binary;\nuse crate::errors::{StdError, StdResult, SystemResult};\n#[cfg(feature = \"iterator\")]\nuse crate::iterator::{Order, KV};\nuse crate::query::{AllBalanceResponse, BalanceResponse, BankQuery, QueryRequest};\n#[cfg(feature = \"staking\")]\nuse crate::query::{\n    AllDelegationsResponse, BondedDenomResponse, Delegation, DelegationResponse, FullDelegation,\n    StakingQuery, Validator, ValidatorsResponse,\n};\nuse crate::serde::{from_binary, to_vec};\nuse crate::types::Empty;\n\n/// Holds all external dependencies of the contract.\n/// Designed to allow easy dependency injection at runtime.\n/// This cannot be copied or cloned since it would behave differently\n/// for mock storages and a bridge storage in the VM.\npub struct Extern\u003cS: Storage, A: Api, Q: Querier\u003e {\n    pub storage: S,\n    pub api: A,\n    pub querier: Q,\n}\n\nimpl\u003cS: Storage, A: Api, Q: Querier\u003e Extern\u003cS, A, Q\u003e {\n    /// change_querier is a helper mainly for test code when swapping out the Querier\n    /// from the auto-generated one from mock_dependencies. This changes the type of\n    /// Extern so replaces requires some boilerplate.\n    pub fn change_querier\u003cT: Querier, F: Fn(Q) -\u003e T\u003e(self, transform: F) -\u003e Extern\u003cS, A, T\u003e {\n        Extern {\n            storage: self.storage,\n            api: self.api,\n            querier: transform(self.querier),\n        }\n    }\n}\n\n/// ReadonlyStorage is access to the contracts persistent data store\npub trait ReadonlyStorage {\n    /// Returns None when key does not exist.\n    /// Returns Some(Vec\u003cu8\u003e) when key exists.\n    ///\n    /// Note: Support for differentiating between a non-existent key and a key with empty value\n    /// is not great yet and might not be possible in all backends. But we're trying to get there.\n    fn get(\u0026self, key: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e;\n\n    #[cfg(feature = \"iterator\")]\n    /// Allows iteration over a set of key/value pairs, either forwards or backwards.\n    ///\n    /// The bound `start` is inclusive and `end` is exclusive.\n    ///\n    /// If `start` is lexicographically greater than or equal to `end`, an empty range is described, mo matter of the order.\n    fn range\u003c'a\u003e(\n        \u0026'a self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = KV\u003e + 'a\u003e;\n}\n\n// Storage extends ReadonlyStorage to give mutable access\npub trait Storage: ReadonlyStorage {\n    fn set(\u0026mut self, key: \u0026[u8], value: \u0026[u8]);\n    /// Removes a database entry at `key`.\n    ///\n    /// The current interface does not allow to differentiate between a key that existed\n    /// before and one that didn't exist. See https://github.com/CosmWasm/cosmwasm/issues/290\n    fn remove(\u0026mut self, key: \u0026[u8]);\n}\n\n/// Api are callbacks to system functions defined outside of the wasm modules.\n/// This is a trait to allow Mocks in the test code.\n///\n/// Currently it just supports address conversion, we could add eg. crypto functions here.\n/// These should all be pure (stateless) functions. If you need state, you probably want\n/// to use the Querier.\n///\n/// We can use feature flags to opt-in to non-essential methods\n/// for backwards compatibility in systems that don't have them all.\npub trait Api: Copy + Clone + Send {\n    fn canonical_address(\u0026self, human: \u0026HumanAddr) -\u003e StdResult\u003cCanonicalAddr\u003e;\n    fn human_address(\u0026self, canonical: \u0026CanonicalAddr) -\u003e StdResult\u003cHumanAddr\u003e;\n}\n\n/// A short-hand alias for the two-level query result (1. accessing the contract, 2. executing query in the contract)\npub type QuerierResult = SystemResult\u003cStdResult\u003cBinary\u003e\u003e;\n\npub trait Querier {\n    /// raw_query is all that must be implemented for the Querier.\n    /// This allows us to pass through binary queries from one level to another without\n    /// knowing the custom format, or we can decode it, with the knowledge of the allowed\n    /// types. People using the querier probably want one of the simpler auto-generated\n    /// helper methods\n    fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult;\n\n    /// query is a shorthand for custom_query when we are not using a custom type,\n    /// this allows us to avoid specifying \"Empty\" in all the type definitions.\n    fn query\u003cT: DeserializeOwned\u003e(\u0026self, request: \u0026QueryRequest\u003cEmpty\u003e) -\u003e StdResult\u003cT\u003e {\n        self.custom_query(request)\n    }\n\n    /// Makes the query and parses the response. Also handles custom queries,\n    /// so you need to specify the custom query type in the function parameters.\n    /// If you are no using a custom query, just use `query` for easier interface.\n    ///\n    /// Any error (System Error, Error or called contract, or Parse Error) are flattened into\n    /// one level. Only use this if you don't need to check the SystemError\n    /// eg. If you don't differentiate between contract missing and contract returned error\n    fn custom_query\u003cT: Serialize, U: DeserializeOwned\u003e(\n        \u0026self,\n        request: \u0026QueryRequest\u003cT\u003e,\n    ) -\u003e StdResult\u003cU\u003e {\n        let raw = match to_vec(request) {\n            Ok(raw) =\u003e raw,\n            Err(e) =\u003e {\n                return Err(StdError::generic_err(format!(\n                    \"Serializing QueryRequest: {}\",\n                    e\n                )))\n            }\n        };\n        match self.raw_query(\u0026raw) {\n            Err(sys) =\u003e Err(StdError::generic_err(format!(\n                \"Querier system error: {}\",\n                sys\n            ))),\n            Ok(Err(err)) =\u003e Err(err),\n            // in theory we would process the response, but here it is the same type, so just pass through\n            Ok(Ok(res)) =\u003e from_binary(\u0026res),\n        }\n    }\n\n    fn query_balance\u003cU: Into\u003cHumanAddr\u003e\u003e(\u0026self, address: U, denom: \u0026str) -\u003e StdResult\u003cCoin\u003e {\n        let request = BankQuery::Balance {\n            address: address.into(),\n            denom: denom.to_string(),\n        }\n        .into();\n        let res: BalanceResponse = self.query(\u0026request)?;\n        Ok(res.amount)\n    }\n\n    fn query_all_balances\u003cU: Into\u003cHumanAddr\u003e\u003e(\u0026self, address: U) -\u003e StdResult\u003cVec\u003cCoin\u003e\u003e {\n        let request = BankQuery::AllBalances {\n            address: address.into(),\n        }\n        .into();\n        let res: AllBalanceResponse = self.query(\u0026request)?;\n        Ok(res.amount)\n    }\n\n    #[cfg(feature = \"staking\")]\n    fn query_validators(\u0026self) -\u003e StdResult\u003cVec\u003cValidator\u003e\u003e {\n        let request = StakingQuery::Validators {}.into();\n        let res: ValidatorsResponse = self.query(\u0026request)?;\n        Ok(res.validators)\n    }\n\n    #[cfg(feature = \"staking\")]\n    fn query_bonded_denom(\u0026self) -\u003e StdResult\u003cString\u003e {\n        let request = StakingQuery::BondedDenom {}.into();\n        let res: BondedDenomResponse = self.query(\u0026request)?;\n        Ok(res.denom)\n    }\n\n    #[cfg(feature = \"staking\")]\n    fn query_all_delegations\u003cU: Into\u003cHumanAddr\u003e\u003e(\n        \u0026self,\n        delegator: U,\n    ) -\u003e StdResult\u003cVec\u003cDelegation\u003e\u003e {\n        let request = StakingQuery::AllDelegations {\n            delegator: delegator.into(),\n        }\n        .into();\n        let res: AllDelegationsResponse = self.query(\u0026request)?;\n        Ok(res.delegations)\n    }\n\n    #[cfg(feature = \"staking\")]\n    fn query_delegation\u003cU: Into\u003cHumanAddr\u003e\u003e(\n        \u0026self,\n        delegator: U,\n        validator: U,\n    ) -\u003e StdResult\u003cOption\u003cFullDelegation\u003e\u003e {\n        let request = StakingQuery::Delegation {\n            delegator: delegator.into(),\n            validator: validator.into(),\n        }\n        .into();\n        let res: DelegationResponse = self.query(\u0026request)?;\n        Ok(res.delegation)\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":53},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","std","src","types.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::addresses::HumanAddr;\nuse crate::coins::Coin;\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, JsonSchema)]\npub struct Env {\n    pub block: BlockInfo,\n    pub message: MessageInfo,\n    pub contract: ContractInfo,\n    pub contract_key: Option\u003cString\u003e,\n    #[serde(default)]\n    pub contract_code_hash: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, JsonSchema)]\npub struct BlockInfo {\n    pub height: u64,\n    // time is seconds since epoch begin (Jan. 1, 1970)\n    pub time: u64,\n    pub chain_id: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, JsonSchema)]\npub struct MessageInfo {\n    /// The `sender` field from the wasm/MsgStoreCode, wasm/MsgInstantiateContract or wasm/MsgExecuteContract message.\n    /// You can think of this as the address that initiated the action (i.e. the message). What that\n    /// means exactly heavily depends on the application.\n    ///\n    /// The x/wasm module ensures that the sender address signed the transaction.\n    /// Additional signers of the transaction that are either needed for other messages or contain unnecessary\n    /// signatures are not propagated into the contract.\n    ///\n    /// There is a discussion to open up this field to multiple initiators, which you're welcome to join\n    /// if you have a specific need for that feature: https://github.com/CosmWasm/cosmwasm/issues/293\n    pub sender: HumanAddr,\n    pub sent_funds: Vec\u003cCoin\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, JsonSchema)]\npub struct ContractInfo {\n    pub address: HumanAddr,\n}\n\n/// An empty struct that serves as a placeholder in different places,\n/// such as contracts that don't set a custom message.\n///\n/// It is designed to be expressable in correct JSON and JSON Schema but\n/// contains no meaningful data. Previously we used enums without cases,\n/// but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Empty {}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    use crate::serde::{from_slice, to_vec};\n\n    #[test]\n    fn empty_can_be_instantiated_serialized_and_deserialized() {\n        let instance = Empty {};\n        let serialized = to_vec(\u0026instance).unwrap();\n        assert_eq!(serialized, b\"{}\");\n\n        let deserialized: Empty = from_slice(b\"{}\").unwrap();\n        assert_eq!(deserialized, instance);\n\n        let deserialized: Empty = from_slice(b\"{\\\"stray\\\":\\\"data\\\"}\").unwrap();\n        assert_eq!(deserialized, instance);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","storage","src","bucket.rs"],"content":"use serde::{de::DeserializeOwned, ser::Serialize};\nuse std::marker::PhantomData;\n\nuse cosmwasm_std::{to_vec, ReadonlyStorage, StdResult, Storage};\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::{Order, KV};\n\nuse crate::length_prefixed::{to_length_prefixed, to_length_prefixed_nested};\n#[cfg(feature = \"iterator\")]\nuse crate::namespace_helpers::range_with_prefix;\nuse crate::namespace_helpers::{get_with_prefix, remove_with_prefix, set_with_prefix};\n#[cfg(feature = \"iterator\")]\nuse crate::type_helpers::deserialize_kv;\nuse crate::type_helpers::{may_deserialize, must_deserialize};\n\npub fn bucket\u003c'a, S: Storage, T\u003e(namespace: \u0026[u8], storage: \u0026'a mut S) -\u003e Bucket\u003c'a, S, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    Bucket::new(namespace, storage)\n}\n\npub fn bucket_read\u003c'a, S: ReadonlyStorage, T\u003e(\n    namespace: \u0026[u8],\n    storage: \u0026'a S,\n) -\u003e ReadonlyBucket\u003c'a, S, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    ReadonlyBucket::new(namespace, storage)\n}\n\npub struct Bucket\u003c'a, S: Storage, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    storage: \u0026'a mut S,\n    // see https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters for why this is needed\n    data: PhantomData\u003c\u0026'a T\u003e,\n    prefix: Vec\u003cu8\u003e,\n}\n\nimpl\u003c'a, S: Storage, T\u003e Bucket\u003c'a, S, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    pub fn new(namespace: \u0026[u8], storage: \u0026'a mut S) -\u003e Self {\n        Bucket {\n            prefix: to_length_prefixed(namespace),\n            storage,\n            data: PhantomData,\n        }\n    }\n\n    pub fn multilevel(namespaces: \u0026[\u0026[u8]], storage: \u0026'a mut S) -\u003e Self {\n        Bucket {\n            prefix: to_length_prefixed_nested(namespaces),\n            storage,\n            data: PhantomData,\n        }\n    }\n\n    /// save will serialize the model and store, returns an error on serialization issues\n    pub fn save(\u0026mut self, key: \u0026[u8], data: \u0026T) -\u003e StdResult\u003c()\u003e {\n        set_with_prefix(self.storage, \u0026self.prefix, key, \u0026to_vec(data)?);\n        Ok(())\n    }\n\n    pub fn remove(\u0026mut self, key: \u0026[u8]) {\n        remove_with_prefix(self.storage, \u0026self.prefix, key)\n    }\n\n    /// load will return an error if no data is set at the given key, or on parse error\n    pub fn load(\u0026self, key: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n        let value = get_with_prefix(self.storage, \u0026self.prefix, key);\n        must_deserialize(\u0026value)\n    }\n\n    /// may_load will parse the data stored at the key if present, returns Ok(None) if no data there.\n    /// returns an error on issues parsing\n    pub fn may_load(\u0026self, key: \u0026[u8]) -\u003e StdResult\u003cOption\u003cT\u003e\u003e {\n        let value = get_with_prefix(self.storage, \u0026self.prefix, key);\n        may_deserialize(\u0026value)\n    }\n\n    #[cfg(feature = \"iterator\")]\n    pub fn range\u003c'b\u003e(\n        \u0026'b self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = StdResult\u003cKV\u003cT\u003e\u003e\u003e + 'b\u003e {\n        let mapped = range_with_prefix(self.storage, \u0026self.prefix, start, end, order)\n            .map(deserialize_kv::\u003cT\u003e);\n        Box::new(mapped)\n    }\n\n    /// update will load the data, perform the specified action, and store the result\n    /// in the database. This is shorthand for some common sequences, which may be useful.\n    /// Note that this only updates *pre-existing* values. If you want to modify possibly\n    /// non-existent values, please use `may_update`\n    ///\n    /// This is the least stable of the APIs, and definitely needs some usage\n    pub fn update\u003cA\u003e(\u0026mut self, key: \u0026[u8], action: A) -\u003e StdResult\u003cT\u003e\n    where\n        A: FnOnce(Option\u003cT\u003e) -\u003e StdResult\u003cT\u003e,\n    {\n        let input = self.may_load(key)?;\n        let output = action(input)?;\n        self.save(key, \u0026output)?;\n        Ok(output)\n    }\n}\n\npub struct ReadonlyBucket\u003c'a, S: ReadonlyStorage, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    storage: \u0026'a S,\n    // see https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters for why this is needed\n    data: PhantomData\u003c\u0026'a T\u003e,\n    prefix: Vec\u003cu8\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage, T\u003e ReadonlyBucket\u003c'a, S, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    pub fn new(namespace: \u0026[u8], storage: \u0026'a S) -\u003e Self {\n        ReadonlyBucket {\n            prefix: to_length_prefixed(namespace),\n            storage,\n            data: PhantomData,\n        }\n    }\n\n    pub fn multilevel(namespaces: \u0026[\u0026[u8]], storage: \u0026'a S) -\u003e Self {\n        ReadonlyBucket {\n            prefix: to_length_prefixed_nested(namespaces),\n            storage,\n            data: PhantomData,\n        }\n    }\n\n    /// load will return an error if no data is set at the given key, or on parse error\n    pub fn load(\u0026self, key: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n        let value = get_with_prefix(self.storage, \u0026self.prefix, key);\n        must_deserialize(\u0026value)\n    }\n\n    /// may_load will parse the data stored at the key if present, returns Ok(None) if no data there.\n    /// returns an error on issues parsing\n    pub fn may_load(\u0026self, key: \u0026[u8]) -\u003e StdResult\u003cOption\u003cT\u003e\u003e {\n        let value = get_with_prefix(self.storage, \u0026self.prefix, key);\n        may_deserialize(\u0026value)\n    }\n\n    #[cfg(feature = \"iterator\")]\n    pub fn range\u003c'b\u003e(\n        \u0026'b self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = StdResult\u003cKV\u003cT\u003e\u003e\u003e + 'b\u003e {\n        let mapped = range_with_prefix(self.storage, \u0026self.prefix, start, end, order)\n            .map(deserialize_kv::\u003cT\u003e);\n        Box::new(mapped)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::testing::MockStorage;\n    use cosmwasm_std::StdError;\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Data {\n        pub name: String,\n        pub age: i32,\n    }\n\n    #[test]\n    fn store_and_load() {\n        let mut store = MockStorage::new();\n        let mut bucket = bucket::\u003c_, Data\u003e(b\"data\", \u0026mut store);\n\n        // save data\n        let data = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026data).unwrap();\n\n        // load it properly\n        let loaded = bucket.load(b\"maria\").unwrap();\n        assert_eq!(data, loaded);\n    }\n\n    #[test]\n    fn remove_works() {\n        let mut store = MockStorage::new();\n        let mut bucket = bucket::\u003c_, Data\u003e(b\"data\", \u0026mut store);\n\n        // save data\n        let data = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026data).unwrap();\n        assert_eq!(data, bucket.load(b\"maria\").unwrap());\n\n        // deleting random key does nothing\n        bucket.remove(b\"foobar\");\n        assert_eq!(data, bucket.load(b\"maria\").unwrap());\n\n        // deleting maria removes the data\n        bucket.remove(b\"maria\");\n        assert_eq!(None, bucket.may_load(b\"maria\").unwrap());\n    }\n\n    #[test]\n    fn readonly_works() {\n        let mut store = MockStorage::new();\n        let mut bucket = bucket::\u003c_, Data\u003e(b\"data\", \u0026mut store);\n\n        // save data\n        let data = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026data).unwrap();\n\n        let reader = bucket_read::\u003c_, Data\u003e(b\"data\", \u0026mut store);\n\n        // check empty data handling\n        assert!(reader.load(b\"john\").is_err());\n        assert_eq!(reader.may_load(b\"john\").unwrap(), None);\n\n        // load it properly\n        let loaded = reader.load(b\"maria\").unwrap();\n        assert_eq!(data, loaded);\n    }\n\n    #[test]\n    fn buckets_isolated() {\n        let mut store = MockStorage::new();\n        let mut bucket1 = bucket::\u003c_, Data\u003e(b\"data\", \u0026mut store);\n\n        // save data\n        let data = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket1.save(b\"maria\", \u0026data).unwrap();\n\n        let mut bucket2 = bucket::\u003c_, Data\u003e(b\"dat\", \u0026mut store);\n\n        // save data (dat, amaria) vs (data, maria)\n        let data2 = Data {\n            name: \"Amen\".to_string(),\n            age: 67,\n        };\n        bucket2.save(b\"amaria\", \u0026data2).unwrap();\n\n        // load one\n        let reader = bucket_read::\u003c_, Data\u003e(b\"data\", \u0026store);\n        let loaded = reader.load(b\"maria\").unwrap();\n        assert_eq!(data, loaded);\n        // no cross load\n        assert_eq!(None, reader.may_load(b\"amaria\").unwrap());\n\n        // load the other\n        let reader2 = bucket_read::\u003c_, Data\u003e(b\"dat\", \u0026store);\n        let loaded2 = reader2.load(b\"amaria\").unwrap();\n        assert_eq!(data2, loaded2);\n        // no cross load\n        assert_eq!(None, reader2.may_load(b\"maria\").unwrap());\n    }\n\n    #[test]\n    fn update_success() {\n        let mut store = MockStorage::new();\n        let mut bucket = bucket::\u003c_, Data\u003e(b\"data\", \u0026mut store);\n\n        // initial data\n        let init = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026init).unwrap();\n\n        // it's my birthday\n        let birthday = |mayd: Option\u003cData\u003e| -\u003e StdResult\u003cData\u003e {\n            let mut d = mayd.ok_or(StdError::not_found(\"Data\"))?;\n            d.age += 1;\n            Ok(d)\n        };\n        let output = bucket.update(b\"maria\", \u0026birthday).unwrap();\n        let expected = Data {\n            name: \"Maria\".to_string(),\n            age: 43,\n        };\n        assert_eq!(output, expected);\n\n        // load it properly\n        let loaded = bucket.load(b\"maria\").unwrap();\n        assert_eq!(loaded, expected);\n    }\n\n    #[test]\n    fn update_can_change_variable_from_outer_scope() {\n        let mut store = MockStorage::new();\n        let mut bucket = bucket::\u003c_, Data\u003e(b\"data\", \u0026mut store);\n        let init = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026init).unwrap();\n\n        // show we can capture data from the closure\n        let mut old_age = 0i32;\n        bucket\n            .update(b\"maria\", |mayd: Option\u003cData\u003e| {\n                let mut d = mayd.ok_or(StdError::not_found(\"Data\"))?;\n                old_age = d.age;\n                d.age += 1;\n                Ok(d)\n            })\n            .unwrap();\n        assert_eq!(old_age, 42);\n    }\n\n    #[test]\n    fn update_fails_on_error() {\n        let mut store = MockStorage::new();\n        let mut bucket = bucket::\u003c_, Data\u003e(b\"data\", \u0026mut store);\n\n        // initial data\n        let init = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026init).unwrap();\n\n        // it's my birthday\n        let output = bucket.update(b\"maria\", |_d| {\n            Err(StdError::generic_err(\"cuz i feel like it\"))\n        });\n        assert!(output.is_err());\n\n        // load it properly\n        let loaded = bucket.load(b\"maria\").unwrap();\n        assert_eq!(loaded, init);\n    }\n\n    #[test]\n    fn update_handles_on_no_data() {\n        let mut store = MockStorage::new();\n        let mut bucket = bucket::\u003c_, Data\u003e(b\"data\", \u0026mut store);\n\n        let init_value = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n\n        // it's my birthday\n        let output = bucket\n            .update(b\"maria\", |d| match d {\n                Some(_) =\u003e Err(StdError::generic_err(\"Ensure this was empty\")),\n                None =\u003e Ok(init_value.clone()),\n            })\n            .unwrap();\n        assert_eq!(output, init_value);\n\n        // nothing stored\n        let loaded = bucket.load(b\"maria\").unwrap();\n        assert_eq!(loaded, init_value);\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn range_over_data() {\n        let mut store = MockStorage::new();\n        let mut bucket = bucket::\u003c_, Data\u003e(b\"data\", \u0026mut store);\n\n        let jose = Data {\n            name: \"Jose\".to_string(),\n            age: 42,\n        };\n        let maria = Data {\n            name: \"Maria\".to_string(),\n            age: 27,\n        };\n\n        bucket.save(b\"maria\", \u0026maria).unwrap();\n        bucket.save(b\"jose\", \u0026jose).unwrap();\n\n        let res_data: StdResult\u003cVec\u003cKV\u003cData\u003e\u003e\u003e =\n            bucket.range(None, None, Order::Ascending).collect();\n        let data = res_data.unwrap();\n        assert_eq!(data.len(), 2);\n        assert_eq!(data[0], (b\"jose\".to_vec(), jose.clone()));\n        assert_eq!(data[1], (b\"maria\".to_vec(), maria.clone()));\n\n        // also works for readonly\n        let read_bucket = bucket_read::\u003c_, Data\u003e(b\"data\", \u0026store);\n        let res_data: StdResult\u003cVec\u003cKV\u003cData\u003e\u003e\u003e =\n            read_bucket.range(None, None, Order::Ascending).collect();\n        let data = res_data.unwrap();\n        assert_eq!(data.len(), 2);\n        assert_eq!(data[0], (b\"jose\".to_vec(), jose));\n        assert_eq!(data[1], (b\"maria\".to_vec(), maria));\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":37},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","storage","src","length_prefixed.rs"],"content":"//! This module is an implemention of a namespacing scheme described\n//! in https://github.com/webmaster128/key-namespacing#length-prefixed-keys\n//!\n//! Everything in this file is only responsible for building such keys\n//! and is in no way specific to any kind of storage.\n\n/// Calculates the raw key prefix for a given namespace as documented\n/// in https://github.com/webmaster128/key-namespacing#length-prefixed-keys\npub fn to_length_prefixed(namespace: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n    let mut out = Vec::with_capacity(namespace.len() + 2);\n    out.extend_from_slice(\u0026encode_length(namespace));\n    out.extend_from_slice(namespace);\n    out\n}\n\n/// Calculates the raw key prefix for a given nested namespace\n/// as documented in https://github.com/webmaster128/key-namespacing#nesting\npub fn to_length_prefixed_nested(namespaces: \u0026[\u0026[u8]]) -\u003e Vec\u003cu8\u003e {\n    let mut size = 0;\n    for \u0026namespace in namespaces {\n        size += namespace.len() + 2;\n    }\n\n    let mut out = Vec::with_capacity(size);\n    for \u0026namespace in namespaces {\n        out.extend_from_slice(\u0026encode_length(namespace));\n        out.extend_from_slice(namespace);\n    }\n    out\n}\n\n/// Encodes the length of a given namespace as a 2 byte big endian encoded integer\nfn encode_length(namespace: \u0026[u8]) -\u003e [u8; 2] {\n    if namespace.len() \u003e 0xFFFF {\n        panic!(\"only supports namespaces up to length 0xFFFF\")\n    }\n    let length_bytes = (namespace.len() as u32).to_be_bytes();\n    [length_bytes[2], length_bytes[3]]\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn to_length_prefixed_works() {\n        assert_eq!(to_length_prefixed(b\"\"), b\"\\x00\\x00\");\n        assert_eq!(to_length_prefixed(b\"a\"), b\"\\x00\\x01a\");\n        assert_eq!(to_length_prefixed(b\"ab\"), b\"\\x00\\x02ab\");\n        assert_eq!(to_length_prefixed(b\"abc\"), b\"\\x00\\x03abc\");\n    }\n\n    #[test]\n    fn to_length_prefixed_works_for_long_prefix() {\n        let long_namespace1 = vec![0; 256];\n        let prefix1 = to_length_prefixed(\u0026long_namespace1);\n        assert_eq!(prefix1.len(), 256 + 2);\n        assert_eq!(\u0026prefix1[0..2], b\"\\x01\\x00\");\n\n        let long_namespace2 = vec![0; 30000];\n        let prefix2 = to_length_prefixed(\u0026long_namespace2);\n        assert_eq!(prefix2.len(), 30000 + 2);\n        assert_eq!(\u0026prefix2[0..2], b\"\\x75\\x30\");\n\n        let long_namespace3 = vec![0; 0xFFFF];\n        let prefix3 = to_length_prefixed(\u0026long_namespace3);\n        assert_eq!(prefix3.len(), 0xFFFF + 2);\n        assert_eq!(\u0026prefix3[0..2], b\"\\xFF\\xFF\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"only supports namespaces up to length 0xFFFF\")]\n    fn to_length_prefixed_panics_for_too_long_prefix() {\n        let limit = 0xFFFF;\n        let long_namespace = vec![0; limit + 1];\n        to_length_prefixed(\u0026long_namespace);\n    }\n\n    #[test]\n    fn to_length_prefixed_calculates_capacity_correctly() {\n        // Those tests cannot guarantee the required capacity was calculated correctly before\n        // the vector allocation but increase the likelyhood of a proper implementation.\n\n        let key = to_length_prefixed(b\"\");\n        assert_eq!(key.capacity(), key.len());\n\n        let key = to_length_prefixed(b\"h\");\n        assert_eq!(key.capacity(), key.len());\n\n        let key = to_length_prefixed(b\"hij\");\n        assert_eq!(key.capacity(), key.len());\n    }\n\n    #[test]\n    fn to_length_prefixed_nested_works() {\n        assert_eq!(to_length_prefixed_nested(\u0026[]), b\"\");\n        assert_eq!(to_length_prefixed_nested(\u0026[b\"\"]), b\"\\x00\\x00\");\n        assert_eq!(to_length_prefixed_nested(\u0026[b\"\", b\"\"]), b\"\\x00\\x00\\x00\\x00\");\n\n        assert_eq!(to_length_prefixed_nested(\u0026[b\"a\"]), b\"\\x00\\x01a\");\n        assert_eq!(\n            to_length_prefixed_nested(\u0026[b\"a\", b\"ab\"]),\n            b\"\\x00\\x01a\\x00\\x02ab\"\n        );\n        assert_eq!(\n            to_length_prefixed_nested(\u0026[b\"a\", b\"ab\", b\"abc\"]),\n            b\"\\x00\\x01a\\x00\\x02ab\\x00\\x03abc\"\n        );\n    }\n\n    #[test]\n    fn to_length_prefixed_nested_allows_many_long_namespaces() {\n        // The 0xFFFF limit is for each namespace, not for the combination of them\n\n        let long_namespace1 = vec![0xaa; 0xFFFD];\n        let long_namespace2 = vec![0xbb; 0xFFFE];\n        let long_namespace3 = vec![0xcc; 0xFFFF];\n\n        let prefix =\n            to_length_prefixed_nested(\u0026[\u0026long_namespace1, \u0026long_namespace2, \u0026long_namespace3]);\n        assert_eq!(\u0026prefix[0..2], b\"\\xFF\\xFD\");\n        assert_eq!(\u0026prefix[2..(2 + 0xFFFD)], long_namespace1.as_slice());\n        assert_eq!(\u0026prefix[(2 + 0xFFFD)..(2 + 0xFFFD + 2)], b\"\\xFF\\xFe\");\n        assert_eq!(\n            \u0026prefix[(2 + 0xFFFD + 2)..(2 + 0xFFFD + 2 + 0xFFFE)],\n            long_namespace2.as_slice()\n        );\n        assert_eq!(\n            \u0026prefix[(2 + 0xFFFD + 2 + 0xFFFE)..(2 + 0xFFFD + 2 + 0xFFFE + 2)],\n            b\"\\xFF\\xFf\"\n        );\n        assert_eq!(\n            \u0026prefix[(2 + 0xFFFD + 2 + 0xFFFE + 2)..(2 + 0xFFFD + 2 + 0xFFFE + 2 + 0xFFFF)],\n            long_namespace3.as_slice()\n        );\n    }\n\n    #[test]\n    fn to_length_prefixed_nested_calculates_capacity_correctly() {\n        // Those tests cannot guarantee the required capacity was calculated correctly before\n        // the vector allocation but increase the likelyhood of a proper implementation.\n\n        let key = to_length_prefixed_nested(\u0026[]);\n        assert_eq!(key.capacity(), key.len());\n\n        let key = to_length_prefixed_nested(\u0026[b\"\"]);\n        assert_eq!(key.capacity(), key.len());\n\n        let key = to_length_prefixed_nested(\u0026[b\"a\"]);\n        assert_eq!(key.capacity(), key.len());\n\n        let key = to_length_prefixed_nested(\u0026[b\"a\", b\"bc\"]);\n        assert_eq!(key.capacity(), key.len());\n\n        let key = to_length_prefixed_nested(\u0026[b\"a\", b\"bc\", b\"def\"]);\n        assert_eq!(key.capacity(), key.len());\n    }\n\n    #[test]\n    fn encode_length_works() {\n        assert_eq!(encode_length(b\"\"), *b\"\\x00\\x00\");\n        assert_eq!(encode_length(b\"a\"), *b\"\\x00\\x01\");\n        assert_eq!(encode_length(b\"aa\"), *b\"\\x00\\x02\");\n        assert_eq!(encode_length(b\"aaa\"), *b\"\\x00\\x03\");\n        assert_eq!(encode_length(\u0026vec![1; 255]), *b\"\\x00\\xff\");\n        assert_eq!(encode_length(\u0026vec![1; 256]), *b\"\\x01\\x00\");\n        assert_eq!(encode_length(\u0026vec![1; 12345]), *b\"\\x30\\x39\");\n        assert_eq!(encode_length(\u0026vec![1; 65535]), *b\"\\xff\\xff\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"only supports namespaces up to length 0xFFFF\")]\n    fn encode_length_panics_for_large_values() {\n        encode_length(\u0026vec![1; 65536]);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","storage","src","lib.rs"],"content":"mod bucket;\nmod length_prefixed;\nmod namespace_helpers;\nmod prefixed_storage;\nmod sequence;\nmod singleton;\nmod transactions;\nmod type_helpers;\nmod typed;\n\npub use bucket::{bucket, bucket_read, Bucket, ReadonlyBucket};\npub use length_prefixed::{to_length_prefixed, to_length_prefixed_nested};\npub use prefixed_storage::{prefixed, prefixed_read, PrefixedStorage, ReadonlyPrefixedStorage};\npub use sequence::{currval, nextval, sequence};\npub use singleton::{singleton, singleton_read, ReadonlySingleton, Singleton};\npub use transactions::{transactional, RepLog, StorageTransaction};\npub use typed::{typed, typed_read, ReadonlyTypedStorage, TypedStorage};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","storage","src","namespace_helpers.rs"],"content":"#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::{Order, KV};\nuse cosmwasm_std::{ReadonlyStorage, Storage};\n\npub(crate) fn get_with_prefix\u003cS: ReadonlyStorage\u003e(\n    storage: \u0026S,\n    namespace: \u0026[u8],\n    key: \u0026[u8],\n) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n    storage.get(\u0026concat(namespace, key))\n}\n\npub(crate) fn set_with_prefix\u003cS: Storage\u003e(\n    storage: \u0026mut S,\n    namespace: \u0026[u8],\n    key: \u0026[u8],\n    value: \u0026[u8],\n) {\n    storage.set(\u0026concat(namespace, key), value);\n}\n\npub(crate) fn remove_with_prefix\u003cS: Storage\u003e(storage: \u0026mut S, namespace: \u0026[u8], key: \u0026[u8]) {\n    storage.remove(\u0026concat(namespace, key));\n}\n\n#[inline]\nfn concat(namespace: \u0026[u8], key: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n    let mut k = namespace.to_vec();\n    k.extend_from_slice(key);\n    k\n}\n\n#[cfg(feature = \"iterator\")]\npub(crate) fn range_with_prefix\u003c'a, S: ReadonlyStorage\u003e(\n    storage: \u0026'a S,\n    namespace: \u0026[u8],\n    start: Option\u003c\u0026[u8]\u003e,\n    end: Option\u003c\u0026[u8]\u003e,\n    order: Order,\n) -\u003e Box\u003cdyn Iterator\u003cItem = KV\u003e + 'a\u003e {\n    // prepare start, end with prefix\n    let start = match start {\n        Some(s) =\u003e concat(namespace, s),\n        None =\u003e namespace.to_vec(),\n    };\n    let end = match end {\n        Some(e) =\u003e concat(namespace, e),\n        // end is updating last byte by one\n        None =\u003e namespace_upper_bound(namespace),\n    };\n\n    // get iterator from storage\n    let base_iterator = storage.range(Some(\u0026start), Some(\u0026end), order);\n\n    // make a copy for the closure to handle lifetimes safely\n    let prefix = namespace.to_vec();\n    let mapped = base_iterator.map(move |(k, v)| (trim(\u0026prefix, \u0026k), v));\n    Box::new(mapped)\n}\n\n#[cfg(feature = \"iterator\")]\n#[inline]\nfn trim(namespace: \u0026[u8], key: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n    key[namespace.len()..].to_vec()\n}\n\n/// Returns a new vec of same length and last byte incremented by one\n/// If last bytes are 255, we handle overflow up the chain.\n/// If all bytes are 255, this returns wrong data - but that is never possible as a namespace\n#[cfg(feature = \"iterator\")]\nfn namespace_upper_bound(input: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n    let mut copy = input.to_vec();\n    // zero out all trailing 255, increment first that is not such\n    for i in (0..input.len()).rev() {\n        if copy[i] == 255 {\n            copy[i] = 0;\n        } else {\n            copy[i] += 1;\n            break;\n        }\n    }\n    copy\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::length_prefixed::to_length_prefixed;\n    use cosmwasm_std::testing::MockStorage;\n\n    #[test]\n    fn prefix_get_set() {\n        let mut storage = MockStorage::new();\n        let prefix = to_length_prefixed(b\"foo\");\n\n        set_with_prefix(\u0026mut storage, \u0026prefix, b\"bar\", b\"gotcha\");\n        let rfoo = get_with_prefix(\u0026storage, \u0026prefix, b\"bar\");\n        assert_eq!(rfoo, Some(b\"gotcha\".to_vec()));\n\n        // no collisions with other prefixes\n        let other_prefix = to_length_prefixed(b\"fo\");\n        let collision = get_with_prefix(\u0026storage, \u0026other_prefix, b\"obar\");\n        assert_eq!(collision, None);\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn test_range() {\n        let mut storage = MockStorage::new();\n        let prefix = to_length_prefixed(b\"foo\");\n        let other_prefix = to_length_prefixed(b\"food\");\n\n        // set some values in this range\n        set_with_prefix(\u0026mut storage, \u0026prefix, b\"bar\", b\"none\");\n        set_with_prefix(\u0026mut storage, \u0026prefix, b\"snowy\", b\"day\");\n\n        // set some values outside this range\n        set_with_prefix(\u0026mut storage, \u0026other_prefix, b\"moon\", b\"buggy\");\n\n        // ensure we get proper result from prefixed_range iterator\n        let mut iter = range_with_prefix(\u0026storage, \u0026prefix, None, None, Order::Descending);\n        let first = iter.next().unwrap();\n        assert_eq!(first, (b\"snowy\".to_vec(), b\"day\".to_vec()));\n        let second = iter.next().unwrap();\n        assert_eq!(second, (b\"bar\".to_vec(), b\"none\".to_vec()));\n        assert!(iter.next().is_none());\n\n        // ensure we get raw result from base range\n        let iter = storage.range(None, None, Order::Ascending);\n        assert_eq!(3, iter.count());\n\n        // foo comes first\n        let mut iter = storage.range(None, None, Order::Ascending);\n        let first = iter.next().unwrap();\n        let expected_key = concat(\u0026prefix, b\"bar\");\n        assert_eq!(first, (expected_key, b\"none\".to_vec()));\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn test_range_with_prefix_wrapover() {\n        let mut storage = MockStorage::new();\n        // if we don't properly wrap over there will be issues here (note 255+1 is used to calculate end)\n        let prefix = to_length_prefixed(b\"f\\xff\\xff\");\n        let other_prefix = to_length_prefixed(b\"f\\xff\\x44\");\n\n        // set some values in this range\n        set_with_prefix(\u0026mut storage, \u0026prefix, b\"bar\", b\"none\");\n        set_with_prefix(\u0026mut storage, \u0026prefix, b\"snowy\", b\"day\");\n\n        // set some values outside this range\n        set_with_prefix(\u0026mut storage, \u0026other_prefix, b\"moon\", b\"buggy\");\n\n        // ensure we get proper result from prefixed_range iterator\n        let iter = range_with_prefix(\u0026storage, \u0026prefix, None, None, Order::Descending);\n        let elements: Vec\u003cKV\u003e = iter.collect();\n        assert_eq!(\n            elements,\n            vec![\n                (b\"snowy\".to_vec(), b\"day\".to_vec()),\n                (b\"bar\".to_vec(), b\"none\".to_vec()),\n            ]\n        );\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn test_range_with_start_end_set() {\n        let mut storage = MockStorage::new();\n        // if we don't properly wrap over there will be issues here (note 255+1 is used to calculate end)\n        let prefix = to_length_prefixed(b\"f\\xff\\xff\");\n        let other_prefix = to_length_prefixed(b\"f\\xff\\x44\");\n\n        // set some values in this range\n        set_with_prefix(\u0026mut storage, \u0026prefix, b\"bar\", b\"none\");\n        set_with_prefix(\u0026mut storage, \u0026prefix, b\"snowy\", b\"day\");\n\n        // set some values outside this range\n        set_with_prefix(\u0026mut storage, \u0026other_prefix, b\"moon\", b\"buggy\");\n\n        // make sure start and end are applied properly\n        let res: Vec\u003cKV\u003e =\n            range_with_prefix(\u0026storage, \u0026prefix, Some(b\"b\"), Some(b\"c\"), Order::Ascending)\n                .collect();\n        assert_eq!(res.len(), 1);\n        assert_eq!(res[0], (b\"bar\".to_vec(), b\"none\".to_vec()));\n\n        // make sure start and end are applied properly\n        let res: Vec\u003cKV\u003e = range_with_prefix(\n            \u0026storage,\n            \u0026prefix,\n            Some(b\"bas\"),\n            Some(b\"sno\"),\n            Order::Ascending,\n        )\n        .collect();\n        assert_eq!(res.len(), 0);\n\n        let res: Vec\u003cKV\u003e =\n            range_with_prefix(\u0026storage, \u0026prefix, Some(b\"ant\"), None, Order::Ascending).collect();\n        assert_eq!(res.len(), 2);\n        assert_eq!(res[0], (b\"bar\".to_vec(), b\"none\".to_vec()));\n        assert_eq!(res[1], (b\"snowy\".to_vec(), b\"day\".to_vec()));\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn test_namespace_upper_bound() {\n        assert_eq!(namespace_upper_bound(b\"bob\"), b\"boc\".to_vec());\n        assert_eq!(namespace_upper_bound(b\"fo\\xfe\"), b\"fo\\xff\".to_vec());\n        assert_eq!(namespace_upper_bound(b\"fo\\xff\"), b\"fp\\x00\".to_vec());\n        // multiple \\xff roll over\n        assert_eq!(\n            namespace_upper_bound(b\"fo\\xff\\xff\\xff\"),\n            b\"fp\\x00\\x00\\x00\".to_vec()\n        );\n        // \\xff not at the end are ignored\n        assert_eq!(namespace_upper_bound(b\"\\xffabc\"), b\"\\xffabd\".to_vec());\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","storage","src","prefixed_storage.rs"],"content":"#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::{Order, KV};\nuse cosmwasm_std::{ReadonlyStorage, Storage};\n\nuse crate::length_prefixed::{to_length_prefixed, to_length_prefixed_nested};\n#[cfg(feature = \"iterator\")]\nuse crate::namespace_helpers::range_with_prefix;\nuse crate::namespace_helpers::{get_with_prefix, remove_with_prefix, set_with_prefix};\n\n// prefixed_read is a helper function for less verbose usage\npub fn prefixed_read\u003c'a, T: ReadonlyStorage\u003e(\n    prefix: \u0026[u8],\n    storage: \u0026'a T,\n) -\u003e ReadonlyPrefixedStorage\u003c'a, T\u003e {\n    ReadonlyPrefixedStorage::new(prefix, storage)\n}\n\n// prefixed_rw is a helper function for less verbose usage\npub fn prefixed\u003c'a, T: Storage\u003e(prefix: \u0026[u8], storage: \u0026'a mut T) -\u003e PrefixedStorage\u003c'a, T\u003e {\n    PrefixedStorage::new(prefix, storage)\n}\n\npub struct ReadonlyPrefixedStorage\u003c'a, T: ReadonlyStorage\u003e {\n    prefix: Vec\u003cu8\u003e,\n    storage: \u0026'a T,\n}\n\nimpl\u003c'a, T: ReadonlyStorage\u003e ReadonlyPrefixedStorage\u003c'a, T\u003e {\n    pub fn new(namespace: \u0026[u8], storage: \u0026'a T) -\u003e Self {\n        ReadonlyPrefixedStorage {\n            prefix: to_length_prefixed(namespace),\n            storage,\n        }\n    }\n\n    // Nested namespaces as documented in\n    // https://github.com/webmaster128/key-namespacing#nesting\n    pub fn multilevel(namespaces: \u0026[\u0026[u8]], storage: \u0026'a T) -\u003e Self {\n        ReadonlyPrefixedStorage {\n            prefix: to_length_prefixed_nested(namespaces),\n            storage,\n        }\n    }\n}\n\nimpl\u003c'a, T: ReadonlyStorage\u003e ReadonlyStorage for ReadonlyPrefixedStorage\u003c'a, T\u003e {\n    fn get(\u0026self, key: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        get_with_prefix(self.storage, \u0026self.prefix, key)\n    }\n\n    #[cfg(feature = \"iterator\")]\n    /// range allows iteration over a set of keys, either forwards or backwards\n    fn range\u003c'b\u003e(\n        \u0026'b self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = KV\u003e + 'b\u003e {\n        range_with_prefix(self.storage, \u0026self.prefix, start, end, order)\n    }\n}\n\npub struct PrefixedStorage\u003c'a, T: Storage\u003e {\n    prefix: Vec\u003cu8\u003e,\n    storage: \u0026'a mut T,\n}\n\nimpl\u003c'a, T: Storage\u003e PrefixedStorage\u003c'a, T\u003e {\n    pub fn new(namespace: \u0026[u8], storage: \u0026'a mut T) -\u003e Self {\n        PrefixedStorage {\n            prefix: to_length_prefixed(namespace),\n            storage,\n        }\n    }\n\n    // Nested namespaces as documented in\n    // https://github.com/webmaster128/key-namespacing#nesting\n    pub fn multilevel(namespaces: \u0026[\u0026[u8]], storage: \u0026'a mut T) -\u003e Self {\n        PrefixedStorage {\n            prefix: to_length_prefixed_nested(namespaces),\n            storage,\n        }\n    }\n}\n\nimpl\u003c'a, T: Storage\u003e ReadonlyStorage for PrefixedStorage\u003c'a, T\u003e {\n    fn get(\u0026self, key: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        get_with_prefix(self.storage, \u0026self.prefix, key)\n    }\n\n    #[cfg(feature = \"iterator\")]\n    /// range allows iteration over a set of keys, either forwards or backwards\n    /// uses standard rust range notation, and eg db.range(b\"foo\"..b\"bar\") also works reverse\n    fn range\u003c'b\u003e(\n        \u0026'b self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = KV\u003e + 'b\u003e {\n        range_with_prefix(self.storage, \u0026self.prefix, start, end, order)\n    }\n}\n\nimpl\u003c'a, T: Storage\u003e Storage for PrefixedStorage\u003c'a, T\u003e {\n    fn set(\u0026mut self, key: \u0026[u8], value: \u0026[u8]) {\n        set_with_prefix(self.storage, \u0026self.prefix, key, value);\n    }\n\n    fn remove(\u0026mut self, key: \u0026[u8]) {\n        remove_with_prefix(self.storage, \u0026self.prefix, key);\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::testing::MockStorage;\n\n    #[test]\n    fn prefix_safe() {\n        let mut storage = MockStorage::new();\n\n        // we use a block scope here to release the \u0026mut before we use it in the next storage\n        let mut foo = PrefixedStorage::new(b\"foo\", \u0026mut storage);\n        foo.set(b\"bar\", b\"gotcha\");\n        assert_eq!(foo.get(b\"bar\"), Some(b\"gotcha\".to_vec()));\n\n        // try readonly correctly\n        let rfoo = ReadonlyPrefixedStorage::new(b\"foo\", \u0026storage);\n        assert_eq!(rfoo.get(b\"bar\"), Some(b\"gotcha\".to_vec()));\n\n        // no collisions with other prefixes\n        let fo = ReadonlyPrefixedStorage::new(b\"fo\", \u0026storage);\n        assert_eq!(fo.get(b\"obar\"), None);\n\n        // Note: explicit scoping is not required, but you must not refer to `foo` anytime after you\n        // initialize a different PrefixedStorage. Uncomment this to see errors:\n        //        assert_eq!(Some(b\"gotcha\".to_vec()), foo.get(b\"bar\"));\n    }\n\n    #[test]\n    fn multi_level() {\n        let mut storage = MockStorage::new();\n\n        // set with nested\n        let mut foo = PrefixedStorage::new(b\"foo\", \u0026mut storage);\n        let mut bar = PrefixedStorage::new(b\"bar\", \u0026mut foo);\n        bar.set(b\"baz\", b\"winner\");\n\n        // we can nest them the same encoding with one operation\n        let loader = ReadonlyPrefixedStorage::multilevel(\u0026[b\"foo\", b\"bar\"], \u0026storage);\n        assert_eq!(loader.get(b\"baz\"), Some(b\"winner\".to_vec()));\n\n        // set with multilevel\n        let mut foobar = PrefixedStorage::multilevel(\u0026[b\"foo\", b\"bar\"], \u0026mut storage);\n        foobar.set(b\"second\", b\"time\");\n\n        let a = ReadonlyPrefixedStorage::new(b\"foo\", \u0026storage);\n        let b = ReadonlyPrefixedStorage::new(b\"bar\", \u0026a);\n        assert_eq!(b.get(b\"second\"), Some(b\"time\".to_vec()));\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":20},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","storage","src","sequence.rs"],"content":"use cosmwasm_std::{StdResult, Storage};\n\nuse crate::Singleton;\n\n/// Sequence creates a custom Singleton to hold an empty sequence\npub fn sequence\u003c'a, S: Storage\u003e(storage: \u0026'a mut S, key: \u0026[u8]) -\u003e Singleton\u003c'a, S, u64\u003e {\n    Singleton::new(storage, key)\n}\n\n/// currval returns the last value returned by nextval. If the sequence has never been used,\n/// then it will return 0.\npub fn currval\u003cS: Storage\u003e(seq: \u0026Singleton\u003cS, u64\u003e) -\u003e StdResult\u003cu64\u003e {\n    Ok(seq.may_load()?.unwrap_or_default())\n}\n\n/// nextval increments the counter by 1 and returns the new value.\n/// On the first time it is called (no sequence info in db) it will return 1.\npub fn nextval\u003cS: Storage\u003e(seq: \u0026mut Singleton\u003cS, u64\u003e) -\u003e StdResult\u003cu64\u003e {\n    let val = currval(\u0026seq)? + 1;\n    seq.save(\u0026val)?;\n    Ok(val)\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::testing::MockStorage;\n\n    #[test]\n    fn walk_through_sequence() {\n        let mut store = MockStorage::new();\n        let mut seq = sequence(\u0026mut store, b\"seq\");\n\n        assert_eq!(currval(\u0026seq).unwrap(), 0);\n        assert_eq!(nextval(\u0026mut seq).unwrap(), 1);\n        assert_eq!(nextval(\u0026mut seq).unwrap(), 2);\n        assert_eq!(nextval(\u0026mut seq).unwrap(), 3);\n        assert_eq!(currval(\u0026seq).unwrap(), 3);\n        assert_eq!(currval(\u0026seq).unwrap(), 3);\n    }\n\n    #[test]\n    fn sequences_independent() {\n        let mut store = MockStorage::new();\n\n        let mut seq = sequence(\u0026mut store, b\"seq\");\n        assert_eq!(nextval(\u0026mut seq).unwrap(), 1);\n        assert_eq!(nextval(\u0026mut seq).unwrap(), 2);\n        assert_eq!(nextval(\u0026mut seq).unwrap(), 3);\n\n        let mut seq2 = sequence(\u0026mut store, b\"seq2\");\n        assert_eq!(nextval(\u0026mut seq2).unwrap(), 1);\n        assert_eq!(nextval(\u0026mut seq2).unwrap(), 2);\n\n        let mut seq3 = sequence(\u0026mut store, b\"seq\");\n        assert_eq!(nextval(\u0026mut seq3).unwrap(), 4);\n    }\n\n    #[test]\n    fn set_sequence() {\n        let mut store = MockStorage::new();\n        let mut seq = sequence(\u0026mut store, b\"seq\");\n\n        assert_eq!(nextval(\u0026mut seq).unwrap(), 1);\n        assert_eq!(nextval(\u0026mut seq).unwrap(), 2);\n\n        seq.save(\u002620).unwrap();\n\n        assert_eq!(currval(\u0026seq).unwrap(), 20);\n        assert_eq!(nextval(\u0026mut seq).unwrap(), 21);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","storage","src","singleton.rs"],"content":"use serde::{de::DeserializeOwned, ser::Serialize};\nuse std::marker::PhantomData;\n\nuse cosmwasm_std::{to_vec, ReadonlyStorage, StdResult, Storage};\n\nuse crate::length_prefixed::to_length_prefixed;\nuse crate::type_helpers::{may_deserialize, must_deserialize};\n\n// singleton is a helper function for less verbose usage\npub fn singleton\u003c'a, S: Storage, T\u003e(storage: \u0026'a mut S, key: \u0026[u8]) -\u003e Singleton\u003c'a, S, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    Singleton::new(storage, key)\n}\n\n// singleton_read is a helper function for less verbose usage\npub fn singleton_read\u003c'a, S: ReadonlyStorage, T\u003e(\n    storage: \u0026'a S,\n    key: \u0026[u8],\n) -\u003e ReadonlySingleton\u003c'a, S, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    ReadonlySingleton::new(storage, key)\n}\n\n/// Singleton effectively combines PrefixedStorage with TypedStorage to\n/// work on a single storage key. It performs the to_length_prefixed transformation\n/// on the given name to ensure no collisions, and then provides the standard\n/// TypedStorage accessors, without requiring a key (which is defined in the constructor)\npub struct Singleton\u003c'a, S: Storage, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    storage: \u0026'a mut S,\n    key: Vec\u003cu8\u003e,\n    // see https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters for why this is needed\n    data: PhantomData\u003c\u0026'a T\u003e,\n}\n\nimpl\u003c'a, S: Storage, T\u003e Singleton\u003c'a, S, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    pub fn new(storage: \u0026'a mut S, key: \u0026[u8]) -\u003e Self {\n        Singleton {\n            storage,\n            key: to_length_prefixed(key),\n            data: PhantomData,\n        }\n    }\n\n    /// save will serialize the model and store, returns an error on serialization issues\n    pub fn save(\u0026mut self, data: \u0026T) -\u003e StdResult\u003c()\u003e {\n        self.storage.set(\u0026self.key, \u0026to_vec(data)?);\n        Ok(())\n    }\n\n    pub fn remove(\u0026mut self) {\n        self.storage.remove(\u0026self.key)\n    }\n\n    /// load will return an error if no data is set at the given key, or on parse error\n    pub fn load(\u0026self) -\u003e StdResult\u003cT\u003e {\n        let value = self.storage.get(\u0026self.key);\n        must_deserialize(\u0026value)\n    }\n\n    /// may_load will parse the data stored at the key if present, returns Ok(None) if no data there.\n    /// returns an error on issues parsing\n    pub fn may_load(\u0026self) -\u003e StdResult\u003cOption\u003cT\u003e\u003e {\n        let value = self.storage.get(\u0026self.key);\n        may_deserialize(\u0026value)\n    }\n\n    /// update will load the data, perform the specified action, and store the result\n    /// in the database. This is shorthand for some common sequences, which may be useful\n    ///\n    /// This is the least stable of the APIs, and definitely needs some usage\n    pub fn update\u003cA\u003e(\u0026mut self, action: A) -\u003e StdResult\u003cT\u003e\n    where\n        A: FnOnce(T) -\u003e StdResult\u003cT\u003e,\n    {\n        let input = self.load()?;\n        let output = action(input)?;\n        self.save(\u0026output)?;\n        Ok(output)\n    }\n}\n\n/// ReadonlySingleton only requires a ReadonlyStorage and exposes only the\n/// methods of Singleton that don't modify state.\npub struct ReadonlySingleton\u003c'a, S: ReadonlyStorage, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    storage: \u0026'a S,\n    key: Vec\u003cu8\u003e,\n    // see https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters for why this is needed\n    data: PhantomData\u003c\u0026'a T\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage, T\u003e ReadonlySingleton\u003c'a, S, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    pub fn new(storage: \u0026'a S, key: \u0026[u8]) -\u003e Self {\n        ReadonlySingleton {\n            storage,\n            key: to_length_prefixed(key),\n            data: PhantomData,\n        }\n    }\n\n    /// load will return an error if no data is set at the given key, or on parse error\n    pub fn load(\u0026self) -\u003e StdResult\u003cT\u003e {\n        let value = self.storage.get(\u0026self.key);\n        must_deserialize(\u0026value)\n    }\n\n    /// may_load will parse the data stored at the key if present, returns Ok(None) if no data there.\n    /// returns an error on issues parsing\n    pub fn may_load(\u0026self) -\u003e StdResult\u003cOption\u003cT\u003e\u003e {\n        let value = self.storage.get(\u0026self.key);\n        may_deserialize(\u0026value)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::testing::MockStorage;\n    use serde::{Deserialize, Serialize};\n\n    use cosmwasm_std::StdError;\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Config {\n        pub owner: String,\n        pub max_tokens: i32,\n    }\n\n    #[test]\n    fn save_and_load() {\n        let mut store = MockStorage::new();\n        let mut single = Singleton::\u003c_, Config\u003e::new(\u0026mut store, b\"config\");\n\n        assert!(single.load().is_err());\n        assert_eq!(single.may_load().unwrap(), None);\n\n        let cfg = Config {\n            owner: \"admin\".to_string(),\n            max_tokens: 1234,\n        };\n        single.save(\u0026cfg).unwrap();\n\n        assert_eq!(cfg, single.load().unwrap());\n    }\n\n    #[test]\n    fn remove_works() {\n        let mut store = MockStorage::new();\n        let mut single = Singleton::\u003c_, Config\u003e::new(\u0026mut store, b\"config\");\n\n        // store data\n        let cfg = Config {\n            owner: \"admin\".to_string(),\n            max_tokens: 1234,\n        };\n        single.save(\u0026cfg).unwrap();\n        assert_eq!(cfg, single.load().unwrap());\n\n        // remove it and loads None\n        single.remove();\n        assert_eq!(None, single.may_load().unwrap());\n\n        // safe to remove 2 times\n        single.remove();\n        assert_eq!(None, single.may_load().unwrap());\n    }\n\n    #[test]\n    fn isolated_reads() {\n        let mut store = MockStorage::new();\n        let mut writer = singleton::\u003c_, Config\u003e(\u0026mut store, b\"config\");\n\n        let cfg = Config {\n            owner: \"admin\".to_string(),\n            max_tokens: 1234,\n        };\n        writer.save(\u0026cfg).unwrap();\n\n        let reader = singleton_read::\u003c_, Config\u003e(\u0026store, b\"config\");\n        assert_eq!(cfg, reader.load().unwrap());\n\n        let other_reader = singleton_read::\u003c_, Config\u003e(\u0026store, b\"config2\");\n        assert_eq!(other_reader.may_load().unwrap(), None);\n    }\n\n    #[test]\n    fn update_success() {\n        let mut store = MockStorage::new();\n        let mut writer = singleton::\u003c_, Config\u003e(\u0026mut store, b\"config\");\n\n        let cfg = Config {\n            owner: \"admin\".to_string(),\n            max_tokens: 1234,\n        };\n        writer.save(\u0026cfg).unwrap();\n\n        let output = writer.update(|mut c| {\n            c.max_tokens *= 2;\n            Ok(c)\n        });\n        let expected = Config {\n            owner: \"admin\".to_string(),\n            max_tokens: 2468,\n        };\n        assert_eq!(output.unwrap(), expected);\n        assert_eq!(writer.load().unwrap(), expected);\n    }\n\n    #[test]\n    fn update_can_change_variable_from_outer_scope() {\n        let mut store = MockStorage::new();\n        let mut writer = singleton::\u003c_, Config\u003e(\u0026mut store, b\"config\");\n        let cfg = Config {\n            owner: \"admin\".to_string(),\n            max_tokens: 1234,\n        };\n        writer.save(\u0026cfg).unwrap();\n\n        let mut old_max_tokens = 0i32;\n        writer\n            .update(|mut c| {\n                old_max_tokens = c.max_tokens;\n                c.max_tokens *= 2;\n                Ok(c)\n            })\n            .unwrap();\n        assert_eq!(old_max_tokens, 1234);\n    }\n\n    #[test]\n    fn update_failure() {\n        let mut store = MockStorage::new();\n        let mut writer = singleton::\u003c_, Config\u003e(\u0026mut store, b\"config\");\n\n        let cfg = Config {\n            owner: \"admin\".to_string(),\n            max_tokens: 1234,\n        };\n        writer.save(\u0026cfg).unwrap();\n\n        let output = writer.update(\u0026|_c| Err(StdError::unauthorized()));\n        match output {\n            Err(StdError::Unauthorized { .. }) =\u003e {}\n            _ =\u003e panic!(\"Unexpected output: {:?}\", output),\n        }\n        assert_eq!(writer.load().unwrap(), cfg);\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":25},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","storage","src","transactions.rs"],"content":"#[cfg(feature = \"iterator\")]\nuse std::cmp::Ordering;\nuse std::collections::BTreeMap;\n#[cfg(feature = \"iterator\")]\nuse std::iter;\n#[cfg(feature = \"iterator\")]\nuse std::iter::Peekable;\n#[cfg(feature = \"iterator\")]\nuse std::ops::{Bound, RangeBounds};\n\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::{Order, KV};\nuse cosmwasm_std::{ReadonlyStorage, StdResult, Storage};\n\n#[cfg(feature = \"iterator\")]\n/// The BTreeMap specific key-value pair reference type, as returned by BTreeMap\u003cVec\u003cu8\u003e, T\u003e::range.\n/// This is internal as it can change any time if the map implementation is swapped out.\ntype BTreeMapPairRef\u003c'a, T = Vec\u003cu8\u003e\u003e = (\u0026'a Vec\u003cu8\u003e, \u0026'a T);\n\npub struct StorageTransaction\u003c'a, S: ReadonlyStorage\u003e {\n    /// read-only access to backing storage\n    storage: \u0026'a S,\n    /// these are local changes not flushed to backing storage\n    local_state: BTreeMap\u003cVec\u003cu8\u003e, Delta\u003e,\n    /// a log of local changes not yet flushed to backing storage\n    rep_log: RepLog,\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e StorageTransaction\u003c'a, S\u003e {\n    pub fn new(storage: \u0026'a S) -\u003e Self {\n        StorageTransaction {\n            storage,\n            local_state: BTreeMap::new(),\n            rep_log: RepLog::new(),\n        }\n    }\n\n    /// prepares this transaction to be committed to storage\n    pub fn prepare(self) -\u003e RepLog {\n        self.rep_log\n    }\n\n    /// rollback will consume the checkpoint and drop all changes (no really needed, going out of scope does the same, but nice for clarity)\n    pub fn rollback(self) {}\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e ReadonlyStorage for StorageTransaction\u003c'a, S\u003e {\n    fn get(\u0026self, key: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        match self.local_state.get(key) {\n            Some(val) =\u003e match val {\n                Delta::Set { value } =\u003e Some(value.clone()),\n                Delta::Delete {} =\u003e None,\n            },\n            None =\u003e self.storage.get(key),\n        }\n    }\n\n    #[cfg(feature = \"iterator\")]\n    /// range allows iteration over a set of keys, either forwards or backwards\n    /// uses standard rust range notation, and eg db.range(b\"foo\"..b\"bar\") also works reverse\n    fn range\u003c'b\u003e(\n        \u0026'b self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = KV\u003e + 'b\u003e {\n        let bounds = range_bounds(start, end);\n\n        // BTreeMap.range panics if range is start \u003e end.\n        // However, this cases represent just empty range and we treat it as such.\n        let local: Box\u003cdyn Iterator\u003cItem = BTreeMapPairRef\u003cDelta\u003e\u003e\u003e =\n            match (bounds.start_bound(), bounds.end_bound()) {\n                (Bound::Included(start), Bound::Excluded(end)) if start \u003e end =\u003e {\n                    Box::new(iter::empty())\n                }\n                _ =\u003e {\n                    let local_raw = self.local_state.range(bounds);\n                    match order {\n                        Order::Ascending =\u003e Box::new(local_raw),\n                        Order::Descending =\u003e Box::new(local_raw.rev()),\n                    }\n                }\n            };\n\n        let base = self.storage.range(start, end, order);\n        let merged = MergeOverlay::new(local, base, order);\n        Box::new(merged)\n    }\n}\n\nimpl\u003c'a, S: ReadonlyStorage\u003e Storage for StorageTransaction\u003c'a, S\u003e {\n    fn set(\u0026mut self, key: \u0026[u8], value: \u0026[u8]) {\n        let op = Op::Set {\n            key: key.to_vec(),\n            value: value.to_vec(),\n        };\n        self.local_state.insert(key.to_vec(), op.to_delta());\n        self.rep_log.append(op);\n    }\n\n    fn remove(\u0026mut self, key: \u0026[u8]) {\n        let op = Op::Delete { key: key.to_vec() };\n        self.local_state.insert(key.to_vec(), op.to_delta());\n        self.rep_log.append(op);\n    }\n}\n\npub struct RepLog {\n    /// this is a list of changes to be written to backing storage upon commit\n    ops_log: Vec\u003cOp\u003e,\n}\n\nimpl RepLog {\n    fn new() -\u003e Self {\n        RepLog { ops_log: vec![] }\n    }\n\n    /// appends an op to the list of changes to be applied upon commit\n    fn append(\u0026mut self, op: Op) {\n        self.ops_log.push(op);\n    }\n\n    /// applies the stored list of `Op`s to the provided `Storage`\n    pub fn commit\u003cS: Storage\u003e(self, storage: \u0026mut S) {\n        for op in self.ops_log {\n            op.apply(storage);\n        }\n    }\n}\n\n/// Op is the user operation, which can be stored in the RepLog.\n/// Currently Set or Delete.\nenum Op {\n    /// represents the `Set` operation for setting a key-value pair in storage\n    Set {\n        key: Vec\u003cu8\u003e,\n        value: Vec\u003cu8\u003e,\n    },\n    Delete {\n        key: Vec\u003cu8\u003e,\n    },\n}\n\nimpl Op {\n    /// applies this `Op` to the provided storage\n    pub fn apply\u003cS: Storage\u003e(\u0026self, storage: \u0026mut S) {\n        match self {\n            Op::Set { key, value } =\u003e storage.set(\u0026key, \u0026value),\n            Op::Delete { key } =\u003e storage.remove(\u0026key),\n        }\n    }\n\n    /// converts the Op to a delta, which can be stored in a local cache\n    pub fn to_delta(\u0026self) -\u003e Delta {\n        match self {\n            Op::Set { value, .. } =\u003e Delta::Set {\n                value: value.clone(),\n            },\n            Op::Delete { .. } =\u003e Delta::Delete {},\n        }\n    }\n}\n\n/// Delta is the changes, stored in the local transaction cache.\n/// This is either Set{value} or Delete{}. Note that this is the \"value\"\n/// part of a BTree, so the Key (from the Op) is stored separately.\nenum Delta {\n    Set { value: Vec\u003cu8\u003e },\n    Delete {},\n}\n\n#[cfg(feature = \"iterator\")]\nstruct MergeOverlay\u003c'a, L, R\u003e\nwhere\n    L: Iterator\u003cItem = BTreeMapPairRef\u003c'a, Delta\u003e\u003e,\n    R: Iterator\u003cItem = KV\u003e,\n{\n    left: Peekable\u003cL\u003e,\n    right: Peekable\u003cR\u003e,\n    order: Order,\n}\n\n#[cfg(feature = \"iterator\")]\nimpl\u003c'a, L, R\u003e MergeOverlay\u003c'a, L, R\u003e\nwhere\n    L: Iterator\u003cItem = BTreeMapPairRef\u003c'a, Delta\u003e\u003e,\n    R: Iterator\u003cItem = KV\u003e,\n{\n    fn new(left: L, right: R, order: Order) -\u003e Self {\n        MergeOverlay {\n            left: left.peekable(),\n            right: right.peekable(),\n            order,\n        }\n    }\n\n    fn pick_match(\u0026mut self, lkey: Vec\u003cu8\u003e, rkey: Vec\u003cu8\u003e) -\u003e Option\u003cKV\u003e {\n        // compare keys - result is such that Ordering::Less =\u003e return left side\n        let order = match self.order {\n            Order::Ascending =\u003e lkey.cmp(\u0026rkey),\n            Order::Descending =\u003e rkey.cmp(\u0026lkey),\n        };\n\n        // left must be translated and filtered before return, not so with right\n        match order {\n            Ordering::Less =\u003e self.take_left(),\n            Ordering::Equal =\u003e {\n                //\n                let _ = self.right.next();\n                self.take_left()\n            }\n            Ordering::Greater =\u003e self.right.next(),\n        }\n    }\n\n    /// take_left must only be called when we know self.left.next() will return Some\n    fn take_left(\u0026mut self) -\u003e Option\u003cKV\u003e {\n        let (lkey, lval) = self.left.next().unwrap();\n        match lval {\n            Delta::Set { value } =\u003e Some((lkey.clone(), value.clone())),\n            Delta::Delete {} =\u003e self.next(),\n        }\n    }\n}\n\n#[cfg(feature = \"iterator\")]\nimpl\u003c'a, L, R\u003e Iterator for MergeOverlay\u003c'a, L, R\u003e\nwhere\n    L: Iterator\u003cItem = BTreeMapPairRef\u003c'a, Delta\u003e\u003e,\n    R: Iterator\u003cItem = KV\u003e,\n{\n    type Item = KV;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let (left, right) = (self.left.peek(), self.right.peek());\n        match (left, right) {\n            (Some(litem), Some(ritem)) =\u003e {\n                let (lkey, _) = litem;\n                let (rkey, _) = ritem;\n\n                // we just use cloned keys to avoid double mutable references\n                // (we must release the return value from peek, before beginning to call next or other mut methods\n                let (l, r) = (lkey.to_vec(), rkey.to_vec());\n                self.pick_match(l, r)\n            }\n            (Some(_), None) =\u003e self.take_left(),\n            (None, Some(_)) =\u003e self.right.next(),\n            (None, None) =\u003e None,\n        }\n    }\n}\n\npub fn transactional\u003cS, C, T\u003e(storage: \u0026mut S, callback: C) -\u003e StdResult\u003cT\u003e\nwhere\n    S: Storage,\n    C: FnOnce(\u0026mut StorageTransaction\u003cS\u003e) -\u003e StdResult\u003cT\u003e,\n{\n    let mut stx = StorageTransaction::new(storage);\n    let res = callback(\u0026mut stx)?;\n    stx.prepare().commit(storage);\n    Ok(res)\n}\n\n#[cfg(feature = \"iterator\")]\nfn range_bounds(start: Option\u003c\u0026[u8]\u003e, end: Option\u003c\u0026[u8]\u003e) -\u003e impl RangeBounds\u003cVec\u003cu8\u003e\u003e {\n    (\n        start.map_or(Bound::Unbounded, |x| Bound::Included(x.to_vec())),\n        end.map_or(Bound::Unbounded, |x| Bound::Excluded(x.to_vec())),\n    )\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::{MemoryStorage, StdError};\n\n    #[cfg(feature = \"iterator\")]\n    // iterator_test_suite takes a storage, adds data and runs iterator tests\n    // the storage must previously have exactly one key: \"foo\" = \"bar\"\n    // (this allows us to test StorageTransaction and other wrapped storage better)\n    fn iterator_test_suite\u003cS: Storage\u003e(store: \u0026mut S) {\n        // ensure we had previously set \"foo\" = \"bar\"\n        assert_eq!(store.get(b\"foo\"), Some(b\"bar\".to_vec()));\n        assert_eq!(store.range(None, None, Order::Ascending).count(), 1);\n\n        // setup - add some data, and delete part of it as well\n        store.set(b\"ant\", b\"hill\");\n        store.set(b\"ze\", b\"bra\");\n\n        // noise that should be ignored\n        store.set(b\"bye\", b\"bye\");\n        store.remove(b\"bye\");\n\n        // unbounded\n        {\n            let iter = store.range(None, None, Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                ]\n            );\n        }\n\n        // unbounded (descending)\n        {\n            let iter = store.range(None, None, Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                ]\n            );\n        }\n\n        // bounded\n        {\n            let iter = store.range(Some(b\"f\"), Some(b\"n\"), Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![(b\"foo\".to_vec(), b\"bar\".to_vec())]);\n        }\n\n        // bounded (descending)\n        {\n            let iter = store.range(Some(b\"air\"), Some(b\"loop\"), Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                ]\n            );\n        }\n\n        // bounded empty [a, a)\n        {\n            let iter = store.range(Some(b\"foo\"), Some(b\"foo\"), Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![]);\n        }\n\n        // bounded empty [a, a) (descending)\n        {\n            let iter = store.range(Some(b\"foo\"), Some(b\"foo\"), Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![]);\n        }\n\n        // bounded empty [a, b) with b \u003c a\n        {\n            let iter = store.range(Some(b\"z\"), Some(b\"a\"), Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![]);\n        }\n\n        // bounded empty [a, b) with b \u003c a (descending)\n        {\n            let iter = store.range(Some(b\"z\"), Some(b\"a\"), Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![]);\n        }\n\n        // right unbounded\n        {\n            let iter = store.range(Some(b\"f\"), None, Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                ]\n            );\n        }\n\n        // right unbounded (descending)\n        {\n            let iter = store.range(Some(b\"f\"), None, Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"ze\".to_vec(), b\"bra\".to_vec()),\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                ]\n            );\n        }\n\n        // left unbounded\n        {\n            let iter = store.range(None, Some(b\"f\"), Order::Ascending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(elements, vec![(b\"ant\".to_vec(), b\"hill\".to_vec()),]);\n        }\n\n        // left unbounded (descending)\n        {\n            let iter = store.range(None, Some(b\"no\"), Order::Descending);\n            let elements: Vec\u003cKV\u003e = iter.collect();\n            assert_eq!(\n                elements,\n                vec![\n                    (b\"foo\".to_vec(), b\"bar\".to_vec()),\n                    (b\"ant\".to_vec(), b\"hill\".to_vec()),\n                ]\n            );\n        }\n    }\n\n    #[test]\n    fn delete_local() {\n        let mut base = MemoryStorage::new();\n        let mut check = StorageTransaction::new(\u0026base);\n        check.set(b\"foo\", b\"bar\");\n        check.set(b\"food\", b\"bank\");\n        check.remove(b\"foo\");\n\n        assert_eq!(check.get(b\"foo\"), None);\n        assert_eq!(check.get(b\"food\"), Some(b\"bank\".to_vec()));\n\n        // now commit to base and query there\n        check.prepare().commit(\u0026mut base);\n        assert_eq!(base.get(b\"foo\"), None);\n        assert_eq!(base.get(b\"food\"), Some(b\"bank\".to_vec()));\n    }\n\n    #[test]\n    fn delete_from_base() {\n        let mut base = MemoryStorage::new();\n        base.set(b\"foo\", b\"bar\");\n        let mut check = StorageTransaction::new(\u0026base);\n        check.set(b\"food\", b\"bank\");\n        check.remove(b\"foo\");\n\n        assert_eq!(check.get(b\"foo\"), None);\n        assert_eq!(check.get(b\"food\"), Some(b\"bank\".to_vec()));\n\n        // now commit to base and query there\n        check.prepare().commit(\u0026mut base);\n        assert_eq!(base.get(b\"foo\"), None);\n        assert_eq!(base.get(b\"food\"), Some(b\"bank\".to_vec()));\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn storage_transaction_iterator_empty_base() {\n        let base = MemoryStorage::new();\n        let mut check = StorageTransaction::new(\u0026base);\n        check.set(b\"foo\", b\"bar\");\n        iterator_test_suite(\u0026mut check);\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn storage_transaction_iterator_with_base_data() {\n        let mut base = MemoryStorage::new();\n        base.set(b\"foo\", b\"bar\");\n        let mut check = StorageTransaction::new(\u0026base);\n        iterator_test_suite(\u0026mut check);\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn storage_transaction_iterator_removed_items_from_base() {\n        let mut base = MemoryStorage::new();\n        base.set(b\"foo\", b\"bar\");\n        base.set(b\"food\", b\"bank\");\n        let mut check = StorageTransaction::new(\u0026base);\n        check.remove(b\"food\");\n        iterator_test_suite(\u0026mut check);\n    }\n\n    #[test]\n    fn commit_writes_through() {\n        let mut base = MemoryStorage::new();\n        base.set(b\"foo\", b\"bar\");\n\n        let mut check = StorageTransaction::new(\u0026base);\n        assert_eq!(check.get(b\"foo\"), Some(b\"bar\".to_vec()));\n        check.set(b\"subtx\", b\"works\");\n        check.prepare().commit(\u0026mut base);\n\n        assert_eq!(base.get(b\"subtx\"), Some(b\"works\".to_vec()));\n    }\n\n    #[test]\n    fn storage_remains_readable() {\n        let mut base = MemoryStorage::new();\n        base.set(b\"foo\", b\"bar\");\n\n        let mut stxn1 = StorageTransaction::new(\u0026base);\n\n        assert_eq!(stxn1.get(b\"foo\"), Some(b\"bar\".to_vec()));\n\n        stxn1.set(b\"subtx\", b\"works\");\n        assert_eq!(stxn1.get(b\"subtx\"), Some(b\"works\".to_vec()));\n\n        // Can still read from base, txn is not yet committed\n        assert_eq!(base.get(b\"subtx\"), None);\n\n        stxn1.prepare().commit(\u0026mut base);\n        assert_eq!(base.get(b\"subtx\"), Some(b\"works\".to_vec()));\n    }\n\n    #[test]\n    fn rollback_has_no_effect() {\n        let mut base = MemoryStorage::new();\n        base.set(b\"foo\", b\"bar\");\n\n        let mut check = StorageTransaction::new(\u0026base);\n        assert_eq!(check.get(b\"foo\"), Some(b\"bar\".to_vec()));\n        check.set(b\"subtx\", b\"works\");\n        check.rollback();\n\n        assert_eq!(base.get(b\"subtx\"), None);\n    }\n\n    #[test]\n    fn ignore_same_as_rollback() {\n        let mut base = MemoryStorage::new();\n        base.set(b\"foo\", b\"bar\");\n\n        let mut check = StorageTransaction::new(\u0026base);\n        assert_eq!(check.get(b\"foo\"), Some(b\"bar\".to_vec()));\n        check.set(b\"subtx\", b\"works\");\n\n        assert_eq!(base.get(b\"subtx\"), None);\n    }\n\n    #[test]\n    fn transactional_works() {\n        let mut base = MemoryStorage::new();\n        base.set(b\"foo\", b\"bar\");\n\n        // writes on success\n        let res: StdResult\u003ci32\u003e = transactional(\u0026mut base, |store| {\n            // ensure we can read from the backing store\n            assert_eq!(store.get(b\"foo\"), Some(b\"bar\".to_vec()));\n            // we write in the Ok case\n            store.set(b\"good\", b\"one\");\n            Ok(5)\n        });\n        assert_eq!(res.unwrap(), 5);\n        assert_eq!(base.get(b\"good\"), Some(b\"one\".to_vec()));\n\n        // rejects on error\n        let res: StdResult\u003ci32\u003e = transactional(\u0026mut base, |store| {\n            // ensure we can read from the backing store\n            assert_eq!(store.get(b\"foo\"), Some(b\"bar\".to_vec()));\n            assert_eq!(store.get(b\"good\"), Some(b\"one\".to_vec()));\n            // we write in the Error case\n            store.set(b\"bad\", b\"value\");\n            Err(StdError::unauthorized())\n        });\n        assert!(res.is_err());\n        assert_eq!(base.get(b\"bad\"), None);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":77},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","storage","src","type_helpers.rs"],"content":"use serde::de::DeserializeOwned;\nuse std::any::type_name;\n\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::KV;\nuse cosmwasm_std::{from_slice, StdError, StdResult};\n\n/// may_deserialize parses json bytes from storage (Option), returning Ok(None) if no data present\n///\n/// value is an odd type, but this is meant to be easy to use with output from storage.get (Option\u003cVec\u003cu8\u003e\u003e)\n/// and value.map(|s| s.as_slice()) seems trickier than \u0026value\npub(crate) fn may_deserialize\u003cT: DeserializeOwned\u003e(\n    value: \u0026Option\u003cVec\u003cu8\u003e\u003e,\n) -\u003e StdResult\u003cOption\u003cT\u003e\u003e {\n    match value {\n        Some(vec) =\u003e Ok(Some(from_slice(\u0026vec)?)),\n        None =\u003e Ok(None),\n    }\n}\n\n/// must_deserialize parses json bytes from storage (Option), returning NotFound error if no data present\npub(crate) fn must_deserialize\u003cT: DeserializeOwned\u003e(value: \u0026Option\u003cVec\u003cu8\u003e\u003e) -\u003e StdResult\u003cT\u003e {\n    match value {\n        Some(vec) =\u003e from_slice(\u0026vec),\n        None =\u003e Err(StdError::not_found(type_name::\u003cT\u003e())),\n    }\n}\n\n#[cfg(feature = \"iterator\")]\npub(crate) fn deserialize_kv\u003cT: DeserializeOwned\u003e(kv: KV) -\u003e StdResult\u003cKV\u003cT\u003e\u003e {\n    let (k, v) = kv;\n    let t = from_slice::\u003cT\u003e(\u0026v)?;\n    Ok((k, t))\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::{to_vec, StdError};\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Person {\n        pub name: String,\n        pub age: i32,\n    }\n\n    #[test]\n    fn may_deserialize_handles_some() {\n        let person = Person {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        let value = to_vec(\u0026person).unwrap();\n\n        let may_parse: Option\u003cPerson\u003e = may_deserialize(\u0026Some(value)).unwrap();\n        assert_eq!(may_parse, Some(person));\n    }\n\n    #[test]\n    fn may_deserialize_handles_none() {\n        let may_parse = may_deserialize::\u003cPerson\u003e(\u0026None).unwrap();\n        assert_eq!(may_parse, None);\n    }\n\n    #[test]\n    fn must_deserialize_handles_some() {\n        let person = Person {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        let value = to_vec(\u0026person).unwrap();\n        let loaded = Some(value);\n\n        let parsed: Person = must_deserialize(\u0026loaded).unwrap();\n        assert_eq!(parsed, person);\n    }\n\n    #[test]\n    fn must_deserialize_handles_none() {\n        let parsed = must_deserialize::\u003cPerson\u003e(\u0026None);\n        match parsed.unwrap_err() {\n            StdError::NotFound { kind, .. } =\u003e {\n                assert_eq!(kind, \"cosmwasm_storage::type_helpers::test::Person\")\n            }\n            e =\u003e panic!(\"Unexpected error {}\", e),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","storage","src","typed.rs"],"content":"use serde::{de::DeserializeOwned, ser::Serialize};\nuse std::marker::PhantomData;\n\nuse cosmwasm_std::{to_vec, ReadonlyStorage, StdResult, Storage};\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::{Order, KV};\n\n#[cfg(feature = \"iterator\")]\nuse crate::type_helpers::deserialize_kv;\nuse crate::type_helpers::{may_deserialize, must_deserialize};\n\npub fn typed\u003cS: Storage, T\u003e(storage: \u0026mut S) -\u003e TypedStorage\u003cS, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    TypedStorage::new(storage)\n}\n\npub fn typed_read\u003cS: ReadonlyStorage, T\u003e(storage: \u0026S) -\u003e ReadonlyTypedStorage\u003cS, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    ReadonlyTypedStorage::new(storage)\n}\n\npub struct TypedStorage\u003c'a, S: Storage, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    storage: \u0026'a mut S,\n    // see https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters for why this is needed\n    data: PhantomData\u003c\u0026'a T\u003e,\n}\n\nimpl\u003c'a, S: Storage, T\u003e TypedStorage\u003c'a, S, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    pub fn new(storage: \u0026'a mut S) -\u003e Self {\n        TypedStorage {\n            storage,\n            data: PhantomData,\n        }\n    }\n\n    /// save will serialize the model and store, returns an error on serialization issues\n    pub fn save(\u0026mut self, key: \u0026[u8], data: \u0026T) -\u003e StdResult\u003c()\u003e {\n        self.storage.set(key, \u0026to_vec(data)?);\n        Ok(())\n    }\n\n    /// load will return an error if no data is set at the given key, or on parse error\n    pub fn load(\u0026self, key: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n        let value = self.storage.get(key);\n        must_deserialize(\u0026value)\n    }\n\n    /// may_load will parse the data stored at the key if present, returns Ok(None) if no data there.\n    /// returns an error on issues parsing\n    pub fn may_load(\u0026self, key: \u0026[u8]) -\u003e StdResult\u003cOption\u003cT\u003e\u003e {\n        let value = self.storage.get(key);\n        may_deserialize(\u0026value)\n    }\n\n    #[cfg(feature = \"iterator\")]\n    pub fn range\u003c'b\u003e(\n        \u0026'b self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = StdResult\u003cKV\u003cT\u003e\u003e\u003e + 'b\u003e {\n        let mapped = self\n            .storage\n            .range(start, end, order)\n            .map(deserialize_kv::\u003cT\u003e);\n        Box::new(mapped)\n    }\n\n    /// update will load the data, perform the specified action, and store the result\n    /// in the database. This is shorthand for some common sequences, which may be useful\n    ///\n    /// This is the least stable of the APIs, and definitely needs some usage\n    pub fn update\u003cA\u003e(\u0026mut self, key: \u0026[u8], action: A) -\u003e StdResult\u003cT\u003e\n    where\n        A: FnOnce(Option\u003cT\u003e) -\u003e StdResult\u003cT\u003e,\n    {\n        let input = self.may_load(key)?;\n        let output = action(input)?;\n        self.save(key, \u0026output)?;\n        Ok(output)\n    }\n}\n\npub struct ReadonlyTypedStorage\u003c'a, S: ReadonlyStorage, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    storage: \u0026'a S,\n    // see https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters for why this is needed\n    data: PhantomData\u003c\u0026'a T\u003e,\n}\n\nimpl\u003c'a, S: ReadonlyStorage, T\u003e ReadonlyTypedStorage\u003c'a, S, T\u003e\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    pub fn new(storage: \u0026'a S) -\u003e Self {\n        ReadonlyTypedStorage {\n            storage,\n            data: PhantomData,\n        }\n    }\n\n    /// load will return an error if no data is set at the given key, or on parse error\n    pub fn load(\u0026self, key: \u0026[u8]) -\u003e StdResult\u003cT\u003e {\n        let value = self.storage.get(key);\n        must_deserialize(\u0026value)\n    }\n\n    /// may_load will parse the data stored at the key if present, returns Ok(None) if no data there.\n    /// returns an error on issues parsing\n    pub fn may_load(\u0026self, key: \u0026[u8]) -\u003e StdResult\u003cOption\u003cT\u003e\u003e {\n        let value = self.storage.get(key);\n        may_deserialize(\u0026value)\n    }\n\n    #[cfg(feature = \"iterator\")]\n    pub fn range\u003c'b\u003e(\n        \u0026'b self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: Order,\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = StdResult\u003cKV\u003cT\u003e\u003e\u003e + 'b\u003e {\n        let mapped = self\n            .storage\n            .range(start, end, order)\n            .map(deserialize_kv::\u003cT\u003e);\n        Box::new(mapped)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::testing::MockStorage;\n    use cosmwasm_std::StdError;\n    use serde::{Deserialize, Serialize};\n\n    use crate::prefixed;\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\n    struct Data {\n        pub name: String,\n        pub age: i32,\n    }\n\n    #[test]\n    fn store_and_load() {\n        let mut store = MockStorage::new();\n        let mut bucket = TypedStorage::\u003c_, Data\u003e::new(\u0026mut store);\n\n        // check empty data handling\n        assert!(bucket.load(b\"maria\").is_err());\n        assert_eq!(bucket.may_load(b\"maria\").unwrap(), None);\n\n        // save data\n        let data = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026data).unwrap();\n\n        // load it properly\n        let loaded = bucket.load(b\"maria\").unwrap();\n        assert_eq!(data, loaded);\n    }\n\n    #[test]\n    fn store_with_prefix() {\n        let mut store = MockStorage::new();\n        let mut space = prefixed(b\"data\", \u0026mut store);\n        let mut bucket = typed::\u003c_, Data\u003e(\u0026mut space);\n\n        // save data\n        let data = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026data).unwrap();\n\n        // load it properly\n        let loaded = bucket.load(b\"maria\").unwrap();\n        assert_eq!(data, loaded);\n    }\n\n    #[test]\n    fn readonly_works() {\n        let mut store = MockStorage::new();\n        let mut bucket = typed::\u003c_, Data\u003e(\u0026mut store);\n\n        // save data\n        let data = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026data).unwrap();\n\n        let reader = typed_read::\u003c_, Data\u003e(\u0026mut store);\n\n        // check empty data handling\n        assert!(reader.load(b\"john\").is_err());\n        assert_eq!(reader.may_load(b\"john\").unwrap(), None);\n\n        // load it properly\n        let loaded = reader.load(b\"maria\").unwrap();\n        assert_eq!(data, loaded);\n    }\n\n    #[test]\n    fn update_success() {\n        let mut store = MockStorage::new();\n        let mut bucket = typed::\u003c_, Data\u003e(\u0026mut store);\n\n        // initial data\n        let init = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026init).unwrap();\n\n        // it's my birthday (fail if no data)\n        let birthday = |mayd: Option\u003cData\u003e| -\u003e StdResult\u003cData\u003e {\n            let mut d = mayd.ok_or(StdError::not_found(\"Data\"))?;\n            d.age += 1;\n            Ok(d)\n        };\n        let output = bucket.update(b\"maria\", \u0026birthday).unwrap();\n        let expected = Data {\n            name: \"Maria\".to_string(),\n            age: 43,\n        };\n        assert_eq!(output, expected);\n\n        // load it properly\n        let loaded = bucket.load(b\"maria\").unwrap();\n        assert_eq!(loaded, expected);\n    }\n\n    #[test]\n    fn update_fails_on_error() {\n        let mut store = MockStorage::new();\n        let mut bucket = typed::\u003c_, Data\u003e(\u0026mut store);\n\n        // initial data\n        let init = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n        bucket.save(b\"maria\", \u0026init).unwrap();\n\n        // it's my birthday\n        let output = bucket.update(b\"maria\", |_d| {\n            Err(StdError::generic_err(\"cuz i feel like it\"))\n        });\n        assert!(output.is_err());\n\n        // load it properly\n        let loaded = bucket.load(b\"maria\").unwrap();\n        assert_eq!(loaded, init);\n    }\n\n    #[test]\n    fn update_handles_on_no_data() {\n        let mut store = MockStorage::new();\n        let mut bucket = typed::\u003c_, Data\u003e(\u0026mut store);\n\n        let init_value = Data {\n            name: \"Maria\".to_string(),\n            age: 42,\n        };\n\n        // it's my birthday\n        let output = bucket\n            .update(b\"maria\", |d| match d {\n                Some(_) =\u003e Err(StdError::generic_err(\"Ensure this was empty\")),\n                None =\u003e Ok(init_value.clone()),\n            })\n            .unwrap();\n        assert_eq!(output, init_value);\n\n        // nothing stored\n        let loaded = bucket.load(b\"maria\").unwrap();\n        assert_eq!(loaded, init_value);\n    }\n\n    #[test]\n    #[cfg(feature = \"iterator\")]\n    fn range_over_data() {\n        let mut store = MockStorage::new();\n        let mut bucket = typed::\u003c_, Data\u003e(\u0026mut store);\n\n        let jose = Data {\n            name: \"Jose\".to_string(),\n            age: 42,\n        };\n        let maria = Data {\n            name: \"Maria\".to_string(),\n            age: 27,\n        };\n\n        bucket.save(b\"maria\", \u0026maria).unwrap();\n        bucket.save(b\"jose\", \u0026jose).unwrap();\n\n        let res_data: StdResult\u003cVec\u003cKV\u003cData\u003e\u003e\u003e =\n            bucket.range(None, None, Order::Ascending).collect();\n        let data = res_data.unwrap();\n        assert_eq!(data.len(), 2);\n        assert_eq!(data[0], (b\"jose\".to_vec(), jose.clone()));\n        assert_eq!(data[1], (b\"maria\".to_vec(), maria.clone()));\n\n        // also works for readonly\n        let read_bucket = typed_read::\u003c_, Data\u003e(\u0026store);\n        let res_data: StdResult\u003cVec\u003cKV\u003cData\u003e\u003e\u003e =\n            read_bucket.range(None, None, Order::Ascending).collect();\n        let data = res_data.unwrap();\n        assert_eq!(data.len(), 2);\n        assert_eq!(data[0], (b\"jose\".to_vec(), jose));\n        assert_eq!(data[1], (b\"maria\".to_vec(), maria));\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":33},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","consts.rs"],"content":"#![cfg_attr(not(feature = \"SGX_MODE_HW\"), allow(unused))]\n\nuse std::env;\n\npub use enclave_ffi_types::ENCRYPTED_SEED_SIZE;\nuse lazy_static::lazy_static;\n\npub const CERTEXPIRYDAYS: i64 = 90i64;\n\npub const BECH32_PREFIX_ACC_ADDR: \u0026str = \"secret\";\n\n#[allow(dead_code)]\n#[derive(PartialEq, Eq)]\npub enum SigningMethod {\n    MRSIGNER,\n    MRENCLAVE,\n    NONE,\n}\n\npub const ATTESTATION_CERTIFICATE_SAVE_PATH: \u0026str = \"attestation_cert.der\";\n\npub const SEED_EXCH_CERTIFICATE_SAVE_PATH: \u0026str = \"node-master-cert.der\";\npub const IO_CERTIFICATE_SAVE_PATH: \u0026str = \"io-master-cert.der\";\n\n//todo: set this to the real value\n#[cfg(feature = \"production\")]\npub const MRSIGNER: [u8; 32] = [\n    131, 215, 25, 231, 125, 234, 202, 20, 112, 246, 186, 246, 42, 77, 119, 67, 3, 200, 153, 219,\n    105, 2, 15, 156, 112, 238, 29, 252, 8, 199, 206, 158,\n];\n\n#[cfg(not(feature = \"production\"))]\npub const MRSIGNER: [u8; 32] = [\n    131, 215, 25, 231, 125, 234, 202, 20, 112, 246, 186, 246, 42, 77, 119, 67, 3, 200, 153, 219,\n    105, 2, 15, 156, 112, 238, 29, 252, 8, 199, 206, 158,\n];\n\n#[cfg(feature = \"production\")]\npub const SIGNING_METHOD: SigningMethod = SigningMethod::MRENCLAVE;\n\n#[cfg(all(not(feature = \"production\"), not(feature = \"test\")))]\npub const SIGNING_METHOD: SigningMethod = SigningMethod::MRENCLAVE;\n\n#[cfg(all(not(feature = \"production\"), feature = \"test\"))]\npub const SIGNING_METHOD: SigningMethod = SigningMethod::MRSIGNER;\n\nlazy_static! {\n    pub static ref CONSENSUS_SEED_SEALING_PATH: String = env::var(SCRT_SGX_STORAGE_ENV_VAR)\n        .unwrap_or_else(|_| \"./.sgx_secrets/\".to_string())\n        + \"consensus_seed.sealed\";\n    pub static ref REGISTRATION_KEY_SEALING_PATH: String = env::var(SCRT_SGX_STORAGE_ENV_VAR)\n        .unwrap_or_else(|_| \"./.sgx_secrets/\".to_string())\n        + \"new_node_seed_exchange_keypair.sealed\";\n}\n\npub const CONSENSUS_SEED_EXCHANGE_KEYPAIR_DERIVE_ORDER: u32 = 1;\npub const CONSENSUS_IO_EXCHANGE_KEYPAIR_DERIVE_ORDER: u32 = 2;\npub const CONSENSUS_STATE_IKM_DERIVE_ORDER: u32 = 3;\npub const CONSENSUS_CALLBACK_SECRET_DERIVE_ORDER: u32 = 4;\n\npub const LOG_LEVEL_ENV_VAR: \u0026str = \"LOG_LEVEL\";\npub const SCRT_SGX_STORAGE_ENV_VAR: \u0026str = \"SCRT_SGX_STORAGE\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","cosmwasm","coins.rs"],"content":"//! must keep this file in sync with cosmwasm/packages/std/src/coins.rs\n\nuse serde::{Deserialize, Serialize};\n\nuse crate::cosmwasm::math::Uint128;\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq)]\npub struct Coin {\n    pub denom: String,\n    pub amount: Uint128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","cosmwasm","encoding.rs"],"content":"#![allow(unused)]\n\nuse std::fmt;\n\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\n\nuse enclave_ffi_types::EnclaveError;\nuse log::*;\nuse sgx_types::*;\n\n// use crate::errors::{Base64Err, Result};\n\n/// Binary is a wrapper around Vec\u003cu8\u003e to add base64 de/serialization\n/// with serde. It also adds some helper methods to help encode inline.\n///\n/// This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec\u003cu8\u003e\n#[derive(Clone, Default, Debug, PartialEq)]\npub struct Binary(pub Vec\u003cu8\u003e);\n\nimpl Binary {\n    /// take an (untrusted) string and decode it into bytes.\n    /// fails if it is not valid base64\n    pub fn from_base64(encoded: \u0026str) -\u003e Result\u003cSelf, EnclaveError\u003e {\n        let binary = base64::decode(encoded).map_err(|err| {\n            warn!(\"Failed to decode base64 string: {:?}\", err.to_string());\n            EnclaveError::FailedToDeserialize\n        })?;\n        Ok(Binary(binary))\n    }\n\n    /// encode to base64 string (guaranteed to be success as we control the data inside).\n    /// this returns normalized form (with trailing = if needed)\n    pub fn to_base64(\u0026self) -\u003e String {\n        base64::encode(\u0026self.0)\n    }\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        self.0.as_slice()\n    }\n    pub fn len(\u0026self) -\u003e usize {\n        self.0.len()\n    }\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.0.is_empty()\n    }\n}\n\nimpl fmt::Display for Binary {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.to_base64())\n    }\n}\n\nimpl From\u003c\u0026[u8]\u003e for Binary {\n    fn from(binary: \u0026[u8]) -\u003e Self {\n        Self(binary.to_vec())\n    }\n}\n\n/// Serializes as a base64 string\nimpl Serialize for Binary {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_base64())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Binary {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cBinary, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Base64Visitor)\n    }\n}\n\nstruct Base64Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Base64Visitor {\n    type Value = Binary;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"valid base64 encoded string\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match Binary::from_base64(v) {\n            Ok(binary) =\u003e Ok(binary),\n            Err(_) =\u003e Err(E::custom(format!(\"invalid base64: {}\", v))),\n        }\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","cosmwasm","math.rs"],"content":"//! must keep this file in sync with cosmwasm/packages/std/src/math.rs\n\nuse derive_more::Display;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::convert::{TryFrom, TryInto};\nuse std::fmt::{self, Write};\nuse std::ops;\nuse std::str::FromStr;\n\n/// A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n///\n/// The greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Decimal(u128);\n\nconst DECIMAL_FRACTIONAL: u128 = 1_000_000_000_000_000_000;\n\nimpl Decimal {\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0 == 0\n    }\n}\n\n#[derive(Display)]\npub struct DecimalParseErr(\u0026'static str);\n\nimpl FromStr for Decimal {\n    type Err = DecimalParseErr;\n\n    /// Converts the decimal string to a Decimal\n    /// Possible inputs: \"1.23\", \"1\", \"000012\", \"1.123000000\"\n    /// Disallowed: \"\", \".23\"\n    ///\n    /// This never performs any kind of rounding.\n    /// More than 18 fractional digits, even zeros, result in an error.\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let parts: Vec\u003c\u0026str\u003e = input.split('.').collect();\n        match parts.len() {\n            1 =\u003e {\n                let whole = parts[0]\n                    .parse::\u003cu128\u003e()\n                    .map_err(|_| DecimalParseErr(\"Error parsing whole\"))?;\n\n                let whole_as_atomics = whole\n                    .checked_mul(DECIMAL_FRACTIONAL)\n                    .ok_or(DecimalParseErr(\"Value too big\"))?;\n                Ok(Decimal(whole_as_atomics))\n            }\n            2 =\u003e {\n                let whole = parts[0]\n                    .parse::\u003cu128\u003e()\n                    .map_err(|_| DecimalParseErr(\"Error parsing whole\"))?;\n                let fractional = parts[1]\n                    .parse::\u003cu128\u003e()\n                    .map_err(|_| DecimalParseErr(\"Error parsing fractional\"))?;\n                let exp = (18usize.checked_sub(parts[1].len())).ok_or(DecimalParseErr(\n                    \"Cannot parse more than 18 fractional digits\",\n                ))?;\n                let fractional_factor = 10u128\n                    .checked_pow(exp.try_into().unwrap())\n                    .ok_or(DecimalParseErr(\"Cannot compute fractional factor\"))?;\n\n                let whole_as_atomics = whole\n                    .checked_mul(DECIMAL_FRACTIONAL)\n                    .ok_or(DecimalParseErr(\"Value too big\"))?;\n                let atomics = whole_as_atomics\n                    .checked_add(fractional * fractional_factor)\n                    .ok_or(DecimalParseErr(\"Value too big\"))?;\n                Ok(Decimal(atomics))\n            }\n            _ =\u003e Err(DecimalParseErr(\"Unexpected number of dots\")),\n        }\n    }\n}\n\nimpl fmt::Display for Decimal {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let whole = (self.0) / DECIMAL_FRACTIONAL;\n        let fractional = (self.0) % DECIMAL_FRACTIONAL;\n\n        if fractional == 0 {\n            write!(f, \"{}\", whole)\n        } else {\n            let fractional_string = format!(\"{:018}\", fractional);\n            f.write_str(\u0026whole.to_string())?;\n            f.write_char('.')?;\n            f.write_str(fractional_string.trim_end_matches('0'))?;\n            Ok(())\n        }\n    }\n}\n\nimpl ops::Add for Decimal {\n    type Output = Self;\n\n    fn add(self, other: Self) -\u003e Self {\n        Decimal(self.0 + other.0)\n    }\n}\n\n/// Serializes as a decimal string\nimpl Serialize for Decimal {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Decimal {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cDecimal, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(DecimalVisitor)\n    }\n}\n\nstruct DecimalVisitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for DecimalVisitor {\n    type Value = Decimal;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded decimal\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match Decimal::from_str(v) {\n            Ok(d) =\u003e Ok(d),\n            Err(e) =\u003e Err(E::custom(format!(\"Error parsing decimal '{}': {}\", v, e))),\n        }\n    }\n}\n\n//*** Uint128 ***/\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Uint128(pub u128);\n\nimpl Uint128 {\n    /// Creates a Uint128(0)\n    pub const fn zero() -\u003e Self {\n        Uint128(0)\n    }\n\n    /// Returns a copy of the internal data\n    pub fn u128(\u0026self) -\u003e u128 {\n        self.0\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0 == 0\n    }\n}\n\nimpl From\u003cu128\u003e for Uint128 {\n    fn from(val: u128) -\u003e Self {\n        Uint128(val)\n    }\n}\n\nimpl From\u003cu64\u003e for Uint128 {\n    fn from(val: u64) -\u003e Self {\n        Uint128(val.into())\n    }\n}\n\n#[derive(Display)]\npub struct Uint128ParseErr(String);\n\nimpl TryFrom\u003c\u0026str\u003e for Uint128 {\n    type Error = Uint128ParseErr;\n\n    fn try_from(val: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match val.parse::\u003cu128\u003e() {\n            Ok(u) =\u003e Ok(Uint128(u)),\n            Err(e) =\u003e Err(Uint128ParseErr(format!(\"Parsing coin: {}\", e))),\n        }\n    }\n}\n\nimpl Into\u003cString\u003e for Uint128 {\n    fn into(self) -\u003e String {\n        self.0.to_string()\n    }\n}\n\nimpl Into\u003cu128\u003e for Uint128 {\n    fn into(self) -\u003e u128 {\n        self.0\n    }\n}\n\nimpl fmt::Display for Uint128 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Both d*u and u*d with d: Decimal and u: Uint128 returns an Uint128. There is no\n/// specific reason for this decision other than the initial use cases we have. If you\n/// need a Decimal result for the same calculation, use Decimal(d*u) or Decimal(u*d).\nimpl ops::Mul\u003cDecimal\u003e for Uint128 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Decimal) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint128::zero();\n        }\n        self.multiply_ratio(rhs.0, DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Mul\u003cUint128\u003e for Decimal {\n    type Output = Uint128;\n\n    fn mul(self, rhs: Uint128) -\u003e Self::Output {\n        rhs * self\n    }\n}\n\nimpl Uint128 {\n    /// returns self * nom / denom\n    pub fn multiply_ratio\u003cA: Into\u003cu128\u003e, B: Into\u003cu128\u003e\u003e(\u0026self, nom: A, denom: B) -\u003e Uint128 {\n        let nominator: u128 = nom.into();\n        let denominator: u128 = denom.into();\n        if denominator == 0 {\n            panic!(\"Denominator must not be zero\");\n        }\n        // TODO: minimize rounding that takes place (using gcd algorithm)\n        let val = self.u128() * nominator / denominator;\n        Uint128::from(val)\n    }\n}\n\n/// Serializes as a base64 string\nimpl Serialize for Uint128 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Uint128 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cUint128, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Uint128Visitor)\n    }\n}\n\nstruct Uint128Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Uint128Visitor {\n    type Value = Uint128;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded integer\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match v.parse::\u003cu128\u003e() {\n            Ok(u) =\u003e Ok(Uint128(u)),\n            Err(e) =\u003e Err(E::custom(format!(\"invalid Uint128 '{}' - {}\", v, e))),\n        }\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":88},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","cosmwasm","mod.rs"],"content":"pub mod coins;\npub mod encoding;\npub mod math;\npub mod query;\npub mod std_error;\npub mod system_error;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","cosmwasm","query.rs"],"content":"//! must keep this file in sync with cosmwasm/packages/std/src/query.rs\n\nuse serde::{Deserialize, Serialize};\n\nuse super::coins::Coin;\nuse super::encoding::Binary;\nuse super::math::Decimal;\nuse super::types::HumanAddr;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryRequest {\n    Bank(BankQuery),\n    Custom(serde_json::Value),\n    Staking(StakingQuery),\n    Wasm(WasmQuery),\n    Dist(DistQuery),\n    Mint(MintQuery),\n    Gov(GovQuery),\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum MintQuery {\n    /// This calls into the native bank module for all denominations.\n    /// Note that this may be much more expensive than Balance and should be avoided if possible.\n    /// Return value is AllBalanceResponse.\n    Inflation {},\n    BondedRatio {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum BankQuery {\n    /// This calls into the native bank module for one denomination\n    /// Return value is BalanceResponse\n    Balance { address: HumanAddr, denom: String },\n    /// This calls into the native bank module for all denominations.\n    /// Note that this may be much more expensive than Balance and should be avoided if possible.\n    /// Return value is AllBalanceResponse.\n    AllBalances { address: HumanAddr },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum GovQuery {\n    /// Returns all the currently active proposals. Might be useful to filter out invalid votes, and trigger\n    /// in-contract voting periods\n    Proposals {},\n}\n\n/// ProposalsResponse is data format returned from GovQuery::Proposals query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub struct ProposalsResponse {\n    pub proposals: Vec\u003cProposal\u003e,\n}\n\n/// ProposalsResponse is data format returned from GovQuery::Proposals query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub struct Proposal {\n    pub id: u64,\n    /// Time of the block where MinDeposit was reached. -1 if MinDeposit is not reached\n    pub voting_start_time: u64,\n    /// Time that the VotingPeriod for this proposal will end and votes will be tallied\n    pub voting_end_time: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum DistQuery {\n    /// This calls into the native bank module for all denominations.\n    /// Note that this may be much more expensive than Balance and should be avoided if possible.\n    /// Return value is AllBalanceResponse.\n    Rewards { delegator: HumanAddr },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum WasmQuery {\n    /// this queries the public API of another contract at a known address (with known ABI)\n    /// return value is whatever the contract returns (caller should know)\n    Smart {\n        contract_addr: HumanAddr,\n        /// This field is used to construct a callback message to another contract\n        callback_code_hash: String,\n        /// msg is the json-encoded QueryMsg struct\n        msg: Binary,\n    },\n    /// this queries the raw kv-store of the contract.\n    /// returns the raw, unparsed data stored at that key (or `Ok(Err(StdError:NotFound{}))` if missing)\n    Raw {\n        contract_addr: HumanAddr,\n        /// This field is used to construct a callback message to another contract\n        callback_code_hash: String,\n        /// Key is the raw key used in the contracts Storage\n        key: Binary,\n    },\n}\n\nimpl From\u003cGovQuery\u003e for QueryRequest {\n    fn from(msg: GovQuery) -\u003e Self {\n        QueryRequest::Gov(msg)\n    }\n}\n\nimpl From\u003cMintQuery\u003e for QueryRequest {\n    fn from(msg: MintQuery) -\u003e Self {\n        QueryRequest::Mint(msg)\n    }\n}\n\nimpl From\u003cDistQuery\u003e for QueryRequest {\n    fn from(msg: DistQuery) -\u003e Self {\n        QueryRequest::Dist(msg)\n    }\n}\n\nimpl From\u003cBankQuery\u003e for QueryRequest {\n    fn from(msg: BankQuery) -\u003e Self {\n        QueryRequest::Bank(msg)\n    }\n}\n\n#[cfg(feature = \"staking\")]\nimpl From\u003cStakingQuery\u003e for QueryRequest {\n    fn from(msg: StakingQuery) -\u003e Self {\n        QueryRequest::Staking(msg)\n    }\n}\n\nimpl From\u003cWasmQuery\u003e for QueryRequest {\n    fn from(msg: WasmQuery) -\u003e Self {\n        QueryRequest::Wasm(msg)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum StakingQuery {\n    /// Returns the denomination that can be bonded (if there are multiple native tokens on the chain)\n    BondedDenom {},\n    /// AllDelegations will return all delegations by the delegator\n    AllDelegations { delegator: HumanAddr },\n    /// Delegation will return more detailed info on a particular\n    /// delegation, defined by delegator/validator pair\n    Delegation {\n        delegator: HumanAddr,\n        validator: HumanAddr,\n    },\n    /// Returns all registered Validators on the system\n    Validators {},\n    /// Returns all the unbonding delegations by the delegator\n    UnbondingDelegations { delegator: HumanAddr },\n}\n\n/// Delegation is basic (cheap to query) data about a delegation\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct Delegation {\n    pub delegator: HumanAddr,\n    pub validator: HumanAddr,\n    /// How much we have locked in the delegation\n    pub amount: Coin,\n}\n\nimpl From\u003cFullDelegation\u003e for Delegation {\n    fn from(full: FullDelegation) -\u003e Self {\n        Delegation {\n            delegator: full.delegator,\n            validator: full.validator,\n            amount: full.amount,\n        }\n    }\n}\n\n/// UnbondingDelegationsResponse is data format returned from StakingRequest::UnbondingDelegations query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub struct UnbondingDelegationsResponse {\n    pub delegations: Vec\u003cDelegation\u003e,\n}\n\n/// FullDelegation is all the info on the delegation, some (like accumulated_reward and can_redelegate)\n/// is expensive to query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct FullDelegation {\n    pub delegator: HumanAddr,\n    pub validator: HumanAddr,\n    /// How much we have locked in the delegation\n    pub amount: Coin,\n    /// can_redelegate captures how much can be immediately redelegated.\n    /// 0 is no redelegation and can_redelegate == amount is redelegate all\n    /// but there are many places between the two\n    pub can_redelegate: Coin,\n    /// How much we can currently withdraw\n    pub accumulated_rewards: Coin,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct Validator {\n    pub address: HumanAddr,\n    pub commission: Decimal,\n    pub max_commission: Decimal,\n    /// TODO: what units are these (in terms of time)?\n    pub max_change_rate: Decimal,\n}\n\n/// Delegation is basic (cheap to query) data about a delegation\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct RewardsResponse {\n    pub rewards: Vec\u003cValidatorRewards\u003e,\n    pub total: Vec\u003cCoin\u003e,\n}\n\n/// Delegation is basic (cheap to query) data about a delegation\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct ValidatorRewards {\n    pub validator_address: HumanAddr,\n    pub reward: Vec\u003cCoin\u003e,\n}\n\n/// Inflation response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct InflationResponse {\n    pub inflation_rate: String,\n}\n\n/// Bonded Ratio response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct BondedRatioResponse {\n    pub bonded_ratio: String,\n}\n","traces":[{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","cosmwasm","std_error.rs"],"content":"//! must keep this file in sync with cosmwasm/packages/std/src/errors/std_error.rs\n\nuse serde::{Deserialize, Serialize};\n\n/// Structured error type for init, handle and query.\n///\n/// This can be serialized and passed over the Wasm/VM boundary, which allows us to use structured\n/// error types in e.g. integration tests. In that process backtraces are stripped off.\n///\n/// The prefix \"Std\" means \"the standard error within the standard library\". This is not the only\n/// result/error type in cosmwasm-std.\n///\n/// When new cases are added, they should describe the problem rather than what was attempted (e.g.\n/// InvalidBase64 is preferred over Base64DecodingErr). In the long run this allows us to get rid of\n/// the duplication in \"StdError::FooErr\".\n///\n/// Checklist for adding a new error:\n/// - Add enum case\n/// - Add to PartialEq implementation\n/// - Add serialize/deserialize test\n/// - Add creator function in std_error_helpers.rs\n/// - Regenerate schemas\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\n#[non_exhaustive]\npub enum StdError {\n    /// Whenever there is no specific error type available\n    GenericErr {\n        msg: String,\n    },\n    InvalidBase64 {\n        msg: String,\n    },\n    /// Whenever UTF-8 bytes cannot be decoded into a unicode string, e.g. in String::from_utf8 or str::from_utf8.\n    InvalidUtf8 {\n        msg: String,\n    },\n    NotFound {\n        kind: String,\n    },\n    NullPointer {},\n    ParseErr {\n        /// the target type that was attempted\n        target: String,\n        msg: String,\n    },\n    SerializeErr {\n        /// the source type that was attempted\n        source: String,\n        msg: String,\n    },\n    Unauthorized {},\n    Underflow {\n        minuend: String,\n        subtrahend: String,\n    },\n}\n\n/// The return type for init, handle and query. Since the error type cannot be serialized to JSON,\n/// this is only available within the contract and its unit tests.\n///\n/// The prefix \"Std\" means \"the standard result within the standard library\". This is not the only\n/// result/error type in cosmwasm-std.\npub type StdResult\u003cT\u003e = core::result::Result\u003cT, StdError\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","cosmwasm","system_error.rs"],"content":"//! must keep this file in sync with cosmwasm/packages/std/src/errors/system_error.rs\n\nuse serde::{Deserialize, Serialize};\n\nuse super::encoding::Binary;\nuse super::types::HumanAddr;\n\n/// SystemError is used for errors inside the VM and is API friendly (i.e. serializable).\n///\n/// This is used on return values for Querier as a nested result: Result\u003cStdResult\u003cT\u003e, SystemError\u003e\n/// The first wrap (SystemError) will trigger if the contract address doesn't exist,\n/// the QueryRequest is malformated, etc. The second wrap will be an error message from\n/// the contract itself.\n///\n/// Such errors are only created by the VM. The error type is defined in the standard library, to ensure\n/// the contract understands the error format without creating a dependency on cosmwasm-vm.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\n#[non_exhaustive]\npub enum SystemError {\n    InvalidRequest { error: String, request: Binary },\n    InvalidResponse { error: String, response: Binary },\n    NoSuchContract { addr: HumanAddr },\n    Unknown {},\n    UnsupportedRequest { kind: String },\n    ExceededRecursionLimit {},\n}\n\npub type SystemResult\u003cT\u003e = Result\u003cT, SystemError\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","cosmwasm","types.rs"],"content":"//! must keep this file in sync with cosmwasm/packages/std/src/types.rs and cosmwasm/packages/std/src/init_handle.rs\n\n#![allow(unused)]\n\n/// These types are are copied over from the cosmwasm_std package, and must be kept in sync with it.\n///\n/// We copy these types instead of directly depending on them, because we require special versions of serde\n/// inside the enclave, which are different from the versions that cosmwasm_std uses.\n/// For some reason patching the dependencies didn't work, so we are forced to maintain this copy, for now :(\nuse std::fmt;\n\nuse serde::{Deserialize, Serialize};\n\nuse super::encoding::Binary;\nuse crate::consts::BECH32_PREFIX_ACC_ADDR;\nuse crate::crypto::multisig::MultisigThresholdPubKey;\nuse crate::crypto::secp256k1::Secp256k1PubKey;\nuse crate::crypto::traits::PubKey;\nuse crate::crypto::CryptoError;\nuse bech32::{FromBase32, ToBase32};\nuse serde_json::Value;\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq)]\npub struct HumanAddr(pub String);\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq)]\npub struct CanonicalAddr(pub Binary);\n\nimpl HumanAddr {\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        \u0026self.0\n    }\n    pub fn len(\u0026self) -\u003e usize {\n        self.0.len()\n    }\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.0.is_empty()\n    }\n    pub fn from_canonical(canonical_addr: \u0026CanonicalAddr) -\u003e Result\u003cSelf, bech32::Error\u003e {\n        let human_addr_str = bech32::encode(\n            BECH32_PREFIX_ACC_ADDR,\n            canonical_addr.as_slice().to_base32(),\n        )?;\n\n        Ok(HumanAddr(human_addr_str))\n    }\n}\n\nimpl fmt::Display for HumanAddr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", \u0026self.0)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for HumanAddr {\n    fn from(addr: \u0026str) -\u003e Self {\n        HumanAddr(addr.to_string())\n    }\n}\n\nimpl From\u003c\u0026HumanAddr\u003e for HumanAddr {\n    fn from(addr: \u0026HumanAddr) -\u003e Self {\n        HumanAddr(addr.0.to_string())\n    }\n}\n\nimpl CanonicalAddr {\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.0.as_slice()\n    }\n    pub fn len(\u0026self) -\u003e usize {\n        self.0.len()\n    }\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.0.is_empty()\n    }\n    pub fn from_human(human_addr: \u0026HumanAddr) -\u003e Result\u003cSelf, bech32::Error\u003e {\n        let (decoded_prefix, data) = bech32::decode(human_addr.as_str())?;\n        let canonical = Vec::\u003cu8\u003e::from_base32(\u0026data)?;\n\n        Ok(CanonicalAddr(Binary(canonical)))\n    }\n}\n\nimpl fmt::Display for CanonicalAddr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct Env {\n    pub block: BlockInfo,\n    pub message: MessageInfo,\n    pub contract: ContractInfo,\n    pub contract_key: Option\u003cString\u003e,\n    #[serde(default)]\n    pub contract_code_hash: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq)]\npub struct BlockInfo {\n    pub height: u64,\n    // time is seconds since epoch begin (Jan. 1, 1970)\n    pub time: u64,\n    pub chain_id: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq)]\npub struct MessageInfo {\n    /// The `sender` field from the wasm/MsgStoreCode, wasm/MsgInstantiateContract or wasm/MsgExecuteContract message.\n    /// You can think of this as the address that initiated the action (i.e. the message). What that\n    /// means exactly heavily depends on the application.\n    ///\n    /// The x/wasm module ensures that the sender address signed the transaction.\n    /// Additional signers of the transaction that are either needed for other messages or contain unnecessary\n    /// signatures are not propagated into the contract.\n    ///\n    /// There is a discussion to open up this field to multiple initiators, which you're welcome to join\n    /// if you have a specific need for that feature: https://github.com/CosmWasm/cosmwasm/issues/293\n    pub sender: HumanAddr,\n    pub sent_funds: Vec\u003cCoin\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq)]\npub struct ContractInfo {\n    pub address: HumanAddr,\n}\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq)]\npub struct Coin {\n    pub denom: String,\n    pub amount: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(untagged)]\npub enum WasmOutput {\n    ErrObject {\n        #[serde(rename = \"Err\")]\n        err: Value,\n    },\n    OkString {\n        #[serde(rename = \"Ok\")]\n        ok: String,\n    },\n    OkObject {\n        #[serde(rename = \"Ok\")]\n        ok: ContractResult,\n    },\n}\n\n// This should be in correlation with cosmwasm-std/init_handle's InitResponse and HandleResponse\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct ContractResult {\n    pub messages: Vec\u003cCosmosMsg\u003e,\n    pub log: Vec\u003cLogAttribute\u003e,\n    pub data: Option\u003cBinary\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\n// This should be in correlation with cosmwasm-std/init_handle's CosmosMsg\n// See https://github.com/serde-rs/serde/issues/1296 why we cannot add De-Serialize trait bounds to T\npub enum CosmosMsg\u003cT = CustomMsg\u003e\nwhere\n    T: Clone + fmt::Debug + PartialEq,\n{\n    Bank(BankMsg),\n    // by default we use RawMsg, but a contract can override that\n    // to call into more app-specific code (whatever they define)\n    Custom(T),\n    Staking(StakingMsg),\n    Wasm(WasmMsg),\n    Gov(GovMsg),\n}\n\n/// Added this here for reflect tests....\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\n/// CustomMsg is an override of CosmosMsg::Custom to show this works and can be extended in the contract\npub enum CustomMsg {\n    Debug(String),\n    Raw(Binary),\n}\n\nimpl Into\u003cCosmosMsg\u003cCustomMsg\u003e\u003e for CustomMsg {\n    fn into(self) -\u003e CosmosMsg\u003cCustomMsg\u003e {\n        CosmosMsg::Custom(self)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum GovMsg {\n    // Let contract vote on a governance proposal\n    Vote {\n        proposal: u64,\n        vote_option: VoteOption,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub enum VoteOption {\n    Yes,\n    No,\n    Abstain,\n    NoWithVeto,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum BankMsg {\n    // this moves tokens in the underlying sdk\n    Send {\n        from_address: HumanAddr,\n        to_address: HumanAddr,\n        amount: Vec\u003cCoin\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum StakingMsg {\n    Delegate {\n        // delegator is automatically set to address of the calling contract\n        validator: HumanAddr,\n        amount: Coin,\n    },\n    Undelegate {\n        // delegator is automatically set to address of the calling contract\n        validator: HumanAddr,\n        amount: Coin,\n    },\n    Withdraw {\n        // delegator is automatically set to address of the calling contract\n        validator: HumanAddr,\n        /// this is the \"withdraw address\", the one that should receive the rewards\n        /// if None, then use delegator address\n        recipient: Option\u003cHumanAddr\u003e,\n    },\n    Redelegate {\n        // delegator is automatically set to address of the calling contract\n        src_validator: HumanAddr,\n        dst_validator: HumanAddr,\n        amount: Coin,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum WasmMsg {\n    /// this dispatches a call to another contract at a known address (with known ABI)\n    Execute {\n        contract_addr: HumanAddr,\n        /// callback_code_hash is the hex encoded hash of the code. This is used by Secret Network to harden against replaying the contract\n        /// It is used to bind the request to a destination contract in a stronger way than just the contract address which can be faked\n        callback_code_hash: String,\n        /// msg is the json-encoded HandleMsg struct (as raw Binary)\n        msg: Binary,\n        send: Vec\u003cCoin\u003e,\n        callback_sig: Option\u003cVec\u003cu8\u003e\u003e,\n    },\n    /// this instantiates a new contracts from previously uploaded wasm code\n    Instantiate {\n        code_id: u64,\n        /// callback_code_hash is the hex encoded hash of the code. This is used by Secret Network to harden against replaying the contract\n        /// It is used to bind the request to a destination contract in a stronger way than just the contract address which can be faked\n        callback_code_hash: String,\n        /// msg is the json-encoded InitMsg struct (as raw Binary)\n        msg: Binary,\n        send: Vec\u003cCoin\u003e,\n        /// Human-readable label for the contract\n        #[serde(default)]\n        label: String,\n        callback_sig: Option\u003cVec\u003cu8\u003e\u003e,\n    },\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq\u003e From\u003cGovMsg\u003e for CosmosMsg\u003cT\u003e {\n    fn from(msg: GovMsg) -\u003e Self {\n        CosmosMsg::Gov(msg)\n    }\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq\u003e From\u003cBankMsg\u003e for CosmosMsg\u003cT\u003e {\n    fn from(msg: BankMsg) -\u003e Self {\n        CosmosMsg::Bank(msg)\n    }\n}\n\n#[cfg(feature = \"staking\")]\nimpl\u003cT: Clone + fmt::Debug + PartialEq\u003e From\u003cStakingMsg\u003e for CosmosMsg\u003cT\u003e {\n    fn from(msg: StakingMsg) -\u003e Self {\n        CosmosMsg::Staking(msg)\n    }\n}\n\nimpl\u003cT: Clone + fmt::Debug + PartialEq\u003e From\u003cWasmMsg\u003e for CosmosMsg\u003cT\u003e {\n    fn from(msg: WasmMsg) -\u003e Self {\n        CosmosMsg::Wasm(msg)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq)]\npub struct LogAttribute {\n    pub key: String,\n    pub value: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum QueryResult {\n    Ok(Binary),\n    Err(String),\n}\n\nimpl QueryResult {\n    // unwrap will panic on err, or give us the real data useful for tests\n    pub fn unwrap(self) -\u003e Binary {\n        match self {\n            QueryResult::Err(msg) =\u003e panic!(\"Unexpected error: {}\", msg),\n            QueryResult::Ok(res) =\u003e res,\n        }\n    }\n\n    pub fn is_err(\u0026self) -\u003e bool {\n        matches!(self, QueryResult::Err(_))\n    }\n}\n\n// coin is a shortcut constructor for a set of one denomination of coins\npub fn coin(amount: \u0026str, denom: \u0026str) -\u003e Vec\u003cCoin\u003e {\n    vec![Coin {\n        amount: amount.to_string(),\n        denom: denom.to_string(),\n    }]\n}\n\n// log is shorthand to produce log messages\npub fn log(key: \u0026str, value: \u0026str) -\u003e LogAttribute {\n    LogAttribute {\n        key: key.to_string(),\n        value: value.to_string(),\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct CosmosSignature {\n    // pub_key is an enum, because it can't be a boxed trait object (or something similar)\n    // because it has to be Sized\n    pub_key: PubKeyKind,\n    signature: Binary,\n}\n\nimpl CosmosSignature {\n    pub fn get_public_key(\u0026self) -\u003e PubKeyKind {\n        self.pub_key.clone()\n    }\n\n    pub fn get_signature(\u0026self) -\u003e Binary {\n        self.signature.clone()\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(untagged)]\npub enum PubKeyKind {\n    Secp256k1(Secp256k1PubKey),\n    Multisig(MultisigThresholdPubKey),\n}\n\nimpl PubKey for PubKeyKind {\n    fn get_address(\u0026self) -\u003e CanonicalAddr {\n        match self {\n            PubKeyKind::Secp256k1(pubkey) =\u003e pubkey.get_address(),\n            PubKeyKind::Multisig(pubkey) =\u003e pubkey.get_address(),\n        }\n    }\n\n    fn bytes(\u0026self) -\u003e Vec\u003cu8\u003e {\n        match self {\n            PubKeyKind::Secp256k1(pubkey) =\u003e pubkey.bytes(),\n            PubKeyKind::Multisig(pubkey) =\u003e pubkey.bytes(),\n        }\n    }\n\n    fn verify_bytes(\u0026self, bytes: \u0026[u8], sig: \u0026[u8]) -\u003e Result\u003c(), CryptoError\u003e {\n        match self {\n            PubKeyKind::Secp256k1(pubkey) =\u003e pubkey.verify_bytes(bytes, sig),\n            PubKeyKind::Multisig(pubkey) =\u003e pubkey.verify_bytes(bytes, sig),\n        }\n    }\n}\n\n// Should be in sync with https://github.com/cosmos/cosmos-sdk/blob/v0.38.3/x/auth/types/stdtx.go#L216\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq)]\npub struct SignDoc {\n    pub account_number: String,\n    pub chain_id: String,\n    pub fee: Value,\n    pub memo: String,\n    pub msgs: Vec\u003cSignDocWasmMsg\u003e,\n    pub sequence: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct SigInfo {\n    pub sign_bytes: Binary,\n    pub signature: CosmosSignature,\n    pub callback_sig: Option\u003cBinary\u003e,\n}\n\n// This struct is basically the smae as WasmMsg, but serializes/deserializes differently\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"snake_case\", tag = \"type\", content = \"value\")]\npub enum SignDocWasmMsg {\n    #[serde(alias = \"wasm/MsgExecuteContract\")]\n    Execute {\n        contract: HumanAddr,\n        /// msg is the json-encoded HandleMsg struct (as raw Binary)\n        msg: String,\n        sent_funds: Vec\u003cCoin\u003e,\n        callback_sig: Option\u003cVec\u003cu8\u003e\u003e,\n    },\n    #[serde(alias = \"wasm/MsgInstantiateContract\")]\n    Instantiate {\n        code_id: String,\n        init_msg: String,\n        init_funds: Vec\u003cCoin\u003e,\n        label: Option\u003cString\u003e,\n        callback_sig: Option\u003cVec\u003cu8\u003e\u003e,\n    },\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":60},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","aes_gcm.rs"],"content":"// use crate::crypto::keys::{AESKey, SymmetricKey};\n// use crate::crypto::traits::Encryptable;\n// use crate::crypto::CryptoError;\n// use ring::aead::{self, Aad, LessSafeKey, Nonce, UnboundKey};\n//\n// static AES_MODE: \u0026aead::Algorithm = \u0026aead::AES_256_GCM;\n//\n// // /// The IV key byte size\n// // const IV_SIZE: usize = 96 / 8;\n// // /// Type alias for the IV byte array\n// // type IV = [u8; IV_SIZE];\n//\n// impl Encryptable for AESKey {\n//     fn encrypt(\u0026self, plaintext: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n//         encrypt(plaintext, self.get())\n//     }\n//\n//     fn decrypt(\u0026self, ciphertext: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n//         decrypt(ciphertext, self.get())\n//     }\n// }\n//\n// /// This function will encrypt a plaintext message and append the tag\n// /// The cyphertext can be decrypted with the `decrypt` function below.\n// fn encrypt(plaintext: \u0026[u8], key: \u0026SymmetricKey) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n//     let key =\n//         LessSafeKey::new(UnboundKey::new(\u0026AES_MODE, key).map_err(|_| CryptoError::KeyError {})?);\n//\n//     let mut in_out_buffer = plaintext.to_owned();\n//     let nonce = Nonce::assume_unique_for_key([0_u8; 12]); // TODO fix\n//\n//     key.seal_in_place_append_tag(nonce, Aad::empty(), \u0026mut in_out_buffer)\n//         .map_err(|_| CryptoError::EncryptionError)?;\n//\n//     Ok(in_out_buffer.to_vec())\n// }\n//\n// /// This function will decrypt a cipher text only if it was encrypted with the `encrypt` function above.\n// /// (data must be encrypted with `seal_in_place_append_tag`)\n// fn decrypt(ciphertext: \u0026[u8], key: \u0026SymmetricKey) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n//     let key =\n//         LessSafeKey::new(UnboundKey::new(\u0026AES_MODE, key).map_err(|_| CryptoError::KeyError {})?);\n//\n//     let mut ciphertext = ciphertext.to_owned();\n//     let nonce = Nonce::assume_unique_for_key([0_u8; 12]); // TODO fix\n//\n//     let plaintext = key\n//         .open_in_place(nonce, Aad::empty(), \u0026mut ciphertext)\n//         .map_err(|_| CryptoError::DecryptionError)?;\n//\n//     Ok(plaintext.to_vec())\n// }\n//\n// // #[cfg(feature = \"test\")]\n// // pub mod tests {\n// //\n// //     use super::{decrypt, encrypt};\n// //\n// //     // todo: fix test vectors to actually work\n// //     fn test_aes_encrypt() {\n// //         let key = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n// //         let aad: Vec\u003c\u0026[u8]\u003e = vec![\n// //             b\"00112233445566778899aabbccddeeffdeaddadadeaddadaffeeddccbbaa99887766554433221100\",\n// //             b\"102030405060708090a0\",\n// //             b\"09f911029d74e35bd84156c5635688c0\",\n// //         ];\n// //         let plaintext = b\"7468697320697320736f6d6520706c61696e7465787420746f20656e6372797074207573696e67205349562d414553\";\n// //         let ciphertext = b\"7bdb6e3b432667eb06f4d14bff2fbd0fcb900f2fddbe404326601965c889bf17dba77ceb094fa663b7a3f748ba8af829ea64ad544a272e9c485b62a3fd5c0d\";\n// //\n// //         let result = aes_siv_encrypt(plaintext, \u0026aad, \u0026key).unwrap();\n// //\n// //         assert_eq!(result.as_slice(), \u0026ciphertext)\n// //\n// //     }\n// //\n// //     // todo: fix test vectors to actually work\n// //     fn test_aes_decrypt() {\n// //         let key = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n// //         let aad: Vec\u003c\u0026[u8]\u003e = vec![\n// //             b\"00112233445566778899aabbccddeeffdeaddadadeaddadaffeeddccbbaa99887766554433221100\",\n// //             b\"102030405060708090a0\",\n// //             b\"09f911029d74e35bd84156c5635688c0\",\n// //         ];\n// //         let plaintext = b\"7468697320697320736f6d6520706c61696e7465787420746f20656e6372797074207573696e67205349562d414553\";\n// //         let ciphertext = b\"7bdb6e3b432667eb06f4d14bff2fbd0fcb900f2fddbe404326601965c889bf17dba77ceb094fa663b7a3f748ba8af829ea64ad544a272e9c485b62a3fd5c0d\";\n// //\n// //         let result = aes_siv_decrypt(ciphertext, \u0026aad, \u0026key).unwrap();\n// //\n// //         assert_eq!(result.as_slice(), \u0026plaintext)\n// //\n// //     }\n// //\n// //     // todo: fix test vectors to actually work\n// //     fn test_aes_encrypt_empty_aad() {\n// //         let key = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n// //         let aad: Vec\u003c\u0026[u8]\u003e = vec![];\n// //         let plaintext = b\"7468697320697320736f6d6520706c61696e7465787420746f20656e6372797074207573696e67205349562d414553\";\n// //         let ciphertext = b\"7bdb6e3b432667eb06f4d14bff2fbd0fcb900f2fddbe404326601965c889bf17dba77ceb094fa663b7a3f748ba8af829ea64ad544a272e9c485b62a3fd5c0d\";\n// //\n// //         let result = aes_siv_encrypt(plaintext, \u0026aad, \u0026key).unwrap();\n// //\n// //         assert_eq!(result.as_slice(), \u0026ciphertext)\n// //\n// //     }\n// // }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","aes_siv.rs"],"content":"/// AES-SIV encryption in rust - https://tools.ietf.org/html/rfc5297\n///\n/// This is a unique AES mode for deterministic encryption, where it is difficult to generate random\n/// values. The risks of reusing a nonce are only such that encrypting the same data with the same nonce\n/// and ad (additional-data - similar to AAD) is that it will give the same result. For this reason we\n/// can use a best-effort to modify the AD, but misusing it somehow will not cause all hell to break loose.\n///\n/// Uses aes_siv crate, which has not been constant-time audited and other good stuff, but we assume\n/// that the risk of using it is much lesser than the risk of using AES-GCM, or other nonce-collision\n/// sensitive ciphers.\n///\n/// In SIV mode, the key is split in 2 - the upper half of the bits is taken into a PRF, while the\n/// bottom (LSB) is taken as the private key. This is why the private key will be twice the length you\n/// would expect it to be. 256/512 bit for Aes128/256 respectively.\n///\n/// The result of encrypted data will be the size of the data + 16 bytes, same as in GCM mode\nuse crate::crypto::keys::{AESKey, SymmetricKey};\nuse crate::crypto::traits::SIVEncryptable;\nuse crate::crypto::CryptoError;\nuse aes_siv::aead::generic_array::GenericArray;\nuse aes_siv::siv::Aes128Siv;\nuse log::*;\n\nimpl SIVEncryptable for AESKey {\n    fn encrypt_siv(\u0026self, plaintext: \u0026[u8], ad: Option\u003c\u0026[\u0026[u8]]\u003e) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n        aes_siv_encrypt(plaintext, ad, self.get())\n    }\n\n    fn decrypt_siv(\u0026self, plaintext: \u0026[u8], ad: Option\u003c\u0026[\u0026[u8]]\u003e) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n        aes_siv_decrypt(plaintext, ad, self.get())\n    }\n}\n\nfn aes_siv_encrypt(\n    plaintext: \u0026[u8],\n    ad: Option\u003c\u0026[\u0026[u8]]\u003e,\n    key: \u0026SymmetricKey,\n) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n    let ad = ad.unwrap_or(\u0026[\u0026[]]);\n\n    let mut cipher = Aes128Siv::new(GenericArray::clone_from_slice(key));\n    cipher.encrypt(ad, plaintext).map_err(|e| {\n        warn!(\"aes_siv_encrypt error: {:?}\", e);\n        CryptoError::EncryptionError\n    })\n}\n\nfn aes_siv_decrypt(\n    ciphertext: \u0026[u8],\n    ad: Option\u003c\u0026[\u0026[u8]]\u003e,\n    key: \u0026SymmetricKey,\n) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n    let ad = ad.unwrap_or(\u0026[\u0026[]]);\n\n    let mut cipher = Aes128Siv::new(GenericArray::clone_from_slice(key));\n    cipher.decrypt(ad, ciphertext).map_err(|e| {\n        warn!(\"aes_siv_decrypt error: {:?}\", e);\n        CryptoError::DecryptionError\n    })\n}\n\n#[cfg(feature = \"test\")]\npub mod tests {\n\n    use super::{aes_siv_decrypt, aes_siv_encrypt};\n\n    // todo: fix test vectors to actually work\n    fn test_aes_encrypt() {\n        let key = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n        let aad: Vec\u003c\u0026[u8]\u003e = vec![\n            b\"00112233445566778899aabbccddeeffdeaddadadeaddadaffeeddccbbaa99887766554433221100\",\n            b\"102030405060708090a0\",\n            b\"09f911029d74e35bd84156c5635688c0\",\n        ];\n        let plaintext = b\"7468697320697320736f6d6520706c61696e7465787420746f20656e6372797074207573696e67205349562d414553\";\n        let ciphertext = b\"7bdb6e3b432667eb06f4d14bff2fbd0fcb900f2fddbe404326601965c889bf17dba77ceb094fa663b7a3f748ba8af829ea64ad544a272e9c485b62a3fd5c0d\";\n\n        let result = aes_siv_encrypt(plaintext, Some(\u0026aad), \u0026key).unwrap();\n\n        assert_eq!(result.as_slice(), \u0026ciphertext[..])\n    }\n\n    // todo: fix test vectors to actually work\n    fn test_aes_decrypt() {\n        let key = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n        let aad: Vec\u003c\u0026[u8]\u003e = vec![\n            b\"00112233445566778899aabbccddeeffdeaddadadeaddadaffeeddccbbaa99887766554433221100\",\n            b\"102030405060708090a0\",\n            b\"09f911029d74e35bd84156c5635688c0\",\n        ];\n        let plaintext = b\"7468697320697320736f6d6520706c61696e7465787420746f20656e6372797074207573696e67205349562d414553\";\n        let ciphertext = b\"7bdb6e3b432667eb06f4d14bff2fbd0fcb900f2fddbe404326601965c889bf17dba77ceb094fa663b7a3f748ba8af829ea64ad544a272e9c485b62a3fd5c0d\";\n\n        let result = aes_siv_decrypt(ciphertext, Some(\u0026aad), \u0026key).unwrap();\n\n        assert_eq!(result.as_slice(), \u0026plaintext[..])\n    }\n\n    // todo: fix test vectors to actually work\n    fn test_aes_encrypt_empty_aad() {\n        let key = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n        let aad: Vec\u003c\u0026[u8]\u003e = vec![];\n        let plaintext = b\"7468697320697320736f6d6520706c61696e7465787420746f20656e6372797074207573696e67205349562d414553\";\n        let ciphertext = b\"7bdb6e3b432667eb06f4d14bff2fbd0fcb900f2fddbe404326601965c889bf17dba77ceb094fa663b7a3f748ba8af829ea64ad544a272e9c485b62a3fd5c0d\";\n\n        let result = aes_siv_encrypt(plaintext, Some(\u0026aad), \u0026key).unwrap();\n\n        assert_eq!(result.as_slice(), \u0026ciphertext[..])\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","ed25519.rs"],"content":"use super::keys::DhKey;\n\nuse super::traits::{AlignedMemory, ExportECKey, EC_256_PRIVATE_KEY_SIZE};\nuse sgx_types::sgx_align_ec256_private_t;\n\n// use x25519_dalek;\n\nuse crate::crypto::CryptoError;\n\nuse super::rng::rand_slice;\n\npub const SECRET_KEY_SIZE: usize = 32;\npub const PUBLIC_KEY_SIZE: usize = 32;\n\ntype AlignedEc256PrivateKey = sgx_align_ec256_private_t;\n\npub type Ed25519PublicKey = [u8; 32];\n\n#[repr(C, align(64))]\n#[derive(Clone, Copy, Default)]\npub struct Ed25519PrivateKey {\n    pub key: AlignedEc256PrivateKey,\n}\n\nimpl Ed25519PrivateKey {\n    pub fn to_owned(\u0026self) -\u003e AlignedEc256PrivateKey {\n        self.key\n    }\n\n    pub fn as_mut(\u0026mut self) -\u003e \u0026mut [u8; SECRET_KEY_SIZE] {\n        \u0026mut self.key.key.r as \u0026mut [u8; SECRET_KEY_SIZE]\n    }\n}\n\nimpl ExportECKey for Ed25519PrivateKey {\n    fn key_ref(\u0026self) -\u003e \u0026[u8; EC_256_PRIVATE_KEY_SIZE] {\n        \u0026self.key.key.r as \u0026[u8; EC_256_PRIVATE_KEY_SIZE]\n    }\n}\n\n#[derive(Clone, Copy, Default)]\npub struct KeyPair {\n    secret_key: Ed25519PrivateKey,\n    public_key: Ed25519PublicKey,\n}\n\nimpl KeyPair {\n    pub fn new() -\u003e Result\u003cSelf, CryptoError\u003e {\n        let mut secret_key = Ed25519PrivateKey::default();\n        rand_slice(secret_key.as_mut())?;\n\n        let sk = x25519_dalek::StaticSecret::from(secret_key.to_owned().key.r as [u8; 32]);\n        let pk = x25519_dalek::PublicKey::from(\u0026sk);\n\n        Ok(Self {\n            secret_key,\n            public_key: *pk.as_bytes(),\n        })\n    }\n\n    pub fn diffie_hellman(\u0026self, your_public: \u0026[u8; SECRET_KEY_SIZE]) -\u003e DhKey {\n        let my_secret =\n            x25519_dalek::StaticSecret::from(self.secret_key.to_owned().key.r as [u8; 32]);\n        let pk = x25519_dalek::PublicKey::from(*your_public);\n        let ss = my_secret.diffie_hellman(\u0026pk);\n\n        *ss.as_bytes()\n    }\n    pub fn get_privkey(\u0026self) -\u003e \u0026[u8; SECRET_KEY_SIZE] {\n        self.secret_key.key_ref()\n    }\n\n    // This will return the raw 64 bytes public key.\n    pub fn get_pubkey(\u0026self) -\u003e [u8; PUBLIC_KEY_SIZE] {\n        self.public_key\n    }\n}\n\n// struct AlignedEcKey\u003cT: AlignedMemory + ExportECKey\u003e(T);\n\nimpl AlignedMemory for Ed25519PrivateKey {}\n\nimpl\u003cT: AlignedMemory + ExportECKey\u003e From\u003cT\u003e for KeyPair {\n    fn from(value: T) -\u003e Self {\n        let mut secret_key = Ed25519PrivateKey::default();\n        secret_key.as_mut().copy_from_slice(value.key_ref());\n\n        let my_secret = x25519_dalek::StaticSecret::from(secret_key.to_owned().key.r as [u8; 32]);\n        let pk = x25519_dalek::PublicKey::from(\u0026my_secret);\n        Self {\n            secret_key,\n            public_key: *pk.as_bytes(),\n        }\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":30},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","errors.rs"],"content":"use derive_more::Display;\n\n#[derive(Debug, Display)]\npub enum CryptoError {\n    /// The ECDH process failed.\n    DerivingKeyError,\n    /// A key was missing.\n    MissingKeyError,\n    /// The symmetric decryption has failed for some reason.\n    DecryptionError,\n    /// The ciphertext provided was improper.\n    /// e.g. MAC wasn't valid, missing IV etc.\n    ImproperEncryption,\n    /// The symmetric encryption has failed for some reason.\n    EncryptionError,\n    /// The signing process has failed for some reason.\n    SigningError,\n    /// The signature couldn't be parsed correctly.\n    ParsingError,\n    /// The public key can't be recovered from a message \u0026 signature.\n    RecoveryError,\n    /// A key wasn't valid.\n    /// e.g. PrivateKey, PublicKey, SharedSecret.\n    KeyError,\n    /// The random function had failed generating randomness\n    RandomError,\n    /// An error related to signature verification\n    VerificationError,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","hmac.rs"],"content":"use super::{AESKey, Hmac, HMAC_SIGNATURE_SIZE};\nuse ring::hmac;\n\nimpl Hmac for AESKey {\n    fn sign_sha_256(\u0026self, to_sign: \u0026[u8]) -\u003e [u8; HMAC_SIGNATURE_SIZE] {\n        // let mut input_bytes: Vec\u003cu8\u003e = self.get().to_vec();\n        // input_bytes.extend_from_slice(extra_key_info);\n\n        let key = hmac::Key::new(hmac::HMAC_SHA256, self.get());\n        let tag = hmac::sign(\u0026key, to_sign);\n\n        let mut result: [u8; HMAC_SIGNATURE_SIZE] = [0u8; HMAC_SIGNATURE_SIZE];\n\n        result.copy_from_slice(tag.as_ref());\n\n        result\n    }\n}\n\n// #[cfg(feature = \"test\")]\n// pub mod tests {\n//     use super::{\n//         Keychain, CONSENSUS_SEED_SEALING_PATH, KEY_MANAGER, REGISTRATION_KEY_SEALING_PATH,\n//     };\n//     use crate::crypto::{Kdf, KeyPair, Seed};\n//     use crate::crypto::CryptoError;\n//\n//     // todo: fix test vectors to actually work\n//     fn test_derive_key() {\n//         let seed = Seed::new_from_slice(\u0026[10u8; 32]);\n//\n//         let kdf1 = seed.derive_key_from_this(\u00261.to_be_bytes());\n//         let kdf2 = seed.derive_key_from_this(\u00262.to_be_bytes());\n//\n//         assert_eq!(kdf1, b\"SOME VALUE\");\n//         assert_eq!(kdf2, b\"SOME VALUE\");\n//     }\n// }\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","kdf.rs"],"content":"use crate::crypto::traits::Kdf;\nuse crate::crypto::{AESKey, Seed, SECRET_KEY_SIZE};\n\nuse ring::hkdf;\n\n// Bitcoin halving block hash https://www.blockchain.com/btc/block/000000000000000000024bead8df69990852c202db0e0097c1a12ea637d7e96d\nconst KDF_SALT: [u8; 32] = [\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x4b, 0xea, 0xd8, 0xdf, 0x69, 0x99,\n    0x08, 0x52, 0xc2, 0x02, 0xdb, 0x0e, 0x00, 0x97, 0xc1, 0xa1, 0x2e, 0xa6, 0x37, 0xd7, 0xe9, 0x6d,\n];\n\nimpl Kdf\u003cAESKey\u003e for AESKey {\n    fn derive_key_from_this(\u0026self, data: \u0026[u8]) -\u003e Self {\n        let mut input_bytes: Vec\u003cu8\u003e = self.get().to_vec();\n        input_bytes.extend_from_slice(data);\n\n        derive_key(\u0026input_bytes, \u0026[])\n    }\n}\n\nimpl Kdf\u003cAESKey\u003e for Seed {\n    //\n    fn derive_key_from_this(\u0026self, data: \u0026[u8]) -\u003e AESKey {\n        let mut input_bytes: Vec\u003cu8\u003e = self.as_slice().to_vec();\n        input_bytes.extend_from_slice(data);\n\n        derive_key(\u0026input_bytes, \u0026[b\"seed\"])\n    }\n}\n\nfn derive_key(input_bytes: \u0026[u8], info: \u0026[\u0026[u8]]) -\u003e AESKey {\n    let salt = hkdf::Salt::new(hkdf::HKDF_SHA256, \u0026KDF_SALT);\n\n    let prk = salt.extract(input_bytes);\n\n    let okm = prk.expand(info, My(SECRET_KEY_SIZE)).unwrap();\n\n    let mut result: AESKey = AESKey::default();\n\n    let _ = okm.fill(result.as_mut());\n\n    result\n}\n\n/// https://github.com/briansmith/ring/blob/master/tests/hkdf_tests.rs\n/// Generic newtype wrapper that lets us implement traits for externally-defined\n/// types.\n#[derive(Debug, PartialEq)]\nstruct My\u003cT: core::fmt::Debug + PartialEq\u003e(T);\n\nimpl hkdf::KeyType for My\u003cusize\u003e {\n    fn len(\u0026self) -\u003e usize {\n        self.0\n    }\n}\n\nimpl From\u003chkdf::Okm\u003c'_, My\u003cusize\u003e\u003e\u003e for My\u003cVec\u003cu8\u003e\u003e {\n    fn from(okm: hkdf::Okm\u003cMy\u003cusize\u003e\u003e) -\u003e Self {\n        let mut r = vec![0u8; okm.len().0];\n        okm.fill(\u0026mut r).unwrap();\n        My(r)\n    }\n}\n\n#[cfg(feature = \"test\")]\npub mod tests {\n    use crate::crypto::CryptoError;\n    use crate::crypto::{Kdf, KeyPair, Seed};\n\n    // commented since this is all outdated\n    // // todo: fix test vectors to actually work\n    // pub fn test_derive_key() {\n    //     let seed = Seed::new_from_slice(\u0026[10u8; 32]);\n    //\n    //     let kdf1 = seed.derive_key_from_this(\u00261.to_be_bytes());\n    //     let kdf2 = seed.derive_key_from_this(\u00262.to_be_bytes());\n    //\n    //     assert_eq!(kdf1, b\"SOME VALUE\");\n    //     assert_eq!(kdf2, b\"SOME VALUE\");\n    // }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","key_manager.rs"],"content":"use crate::consts::*;\nuse crate::crypto::traits::*;\nuse crate::crypto::CryptoError;\nuse crate::crypto::{AESKey, KeyPair, Seed};\nuse enclave_ffi_types::EnclaveError;\nuse lazy_static::lazy_static;\nuse log::*;\n\npub struct Keychain {\n    consensus_seed: Option\u003cSeed\u003e,\n    consensus_state_ikm: Option\u003cAESKey\u003e,\n    consensus_seed_exchange_keypair: Option\u003cKeyPair\u003e,\n    consensus_io_exchange_keypair: Option\u003cKeyPair\u003e,\n    consensus_callback_secret: Option\u003cAESKey\u003e,\n    registration_key: Option\u003cKeyPair\u003e,\n}\n\nlazy_static! {\n    pub static ref KEY_MANAGER: Keychain = Keychain::new();\n}\n\nimpl Keychain {\n    pub fn new() -\u003e Self {\n        let consensus_seed = match Seed::unseal(\u0026CONSENSUS_SEED_SEALING_PATH) {\n            Ok(k) =\u003e Some(k),\n            Err(_e) =\u003e None,\n        };\n\n        let registration_key = match KeyPair::unseal(\u0026REGISTRATION_KEY_SEALING_PATH) {\n            Ok(k) =\u003e Some(k),\n            Err(_e) =\u003e None,\n        };\n\n        let mut x = Keychain {\n            consensus_seed,\n            registration_key,\n            consensus_state_ikm: None,\n            consensus_seed_exchange_keypair: None,\n            consensus_io_exchange_keypair: None,\n            consensus_callback_secret: None,\n        };\n\n        let _ = x.generate_consensus_master_keys();\n\n        x\n    }\n\n    pub fn create_consensus_seed(\u0026mut self) -\u003e Result\u003c(), CryptoError\u003e {\n        match Seed::new() {\n            Ok(seed) =\u003e {\n                if let Err(_e) = self.set_consensus_seed(seed) {\n                    return Err(CryptoError::KeyError);\n                }\n            }\n            Err(err) =\u003e return Err(err),\n        };\n        Ok(())\n    }\n\n    pub fn create_registration_key(\u0026mut self) -\u003e Result\u003c(), CryptoError\u003e {\n        match KeyPair::new() {\n            Ok(key) =\u003e {\n                if let Err(_e) = self.set_registration_key(key) {\n                    return Err(CryptoError::KeyError);\n                }\n            }\n            Err(err) =\u003e return Err(err),\n        };\n        Ok(())\n    }\n\n    pub fn is_consensus_seed_set(\u0026self) -\u003e bool {\n        self.consensus_seed.is_some()\n    }\n\n    pub fn get_consensus_state_ikm(\u0026self) -\u003e Result\u003cAESKey, CryptoError\u003e {\n        self.consensus_state_ikm.ok_or_else(|| {\n            error!(\"Error accessing base_state_key (does not exist, or was not initialized)\");\n            CryptoError::ParsingError\n        })\n    }\n\n    pub fn get_consensus_seed(\u0026self) -\u003e Result\u003cSeed, CryptoError\u003e {\n        self.consensus_seed.ok_or_else(|| {\n            error!(\"Error accessing consensus_seed (does not exist, or was not initialized)\");\n            CryptoError::ParsingError\n        })\n    }\n\n    pub fn seed_exchange_key(\u0026self) -\u003e Result\u003cKeyPair, CryptoError\u003e {\n        self.consensus_seed_exchange_keypair.ok_or_else(|| {\n            error!(\"Error accessing consensus_seed_exchange_keypair (does not exist, or was not initialized)\");\n            CryptoError::ParsingError\n        })\n    }\n\n    pub fn get_consensus_io_exchange_keypair(\u0026self) -\u003e Result\u003cKeyPair, CryptoError\u003e {\n        self.consensus_io_exchange_keypair.ok_or_else(|| {\n            error!(\"Error accessing consensus_io_exchange_keypair (does not exist, or was not initialized)\");\n            CryptoError::ParsingError\n        })\n    }\n\n    pub fn get_consensus_callback_secret(\u0026self) -\u003e Result\u003cAESKey, CryptoError\u003e {\n        self.consensus_callback_secret.ok_or_else(|| {\n            error!(\"Error accessing consensus_callback_secret (does not exist, or was not initialized)\");\n            CryptoError::ParsingError\n        })\n    }\n\n    pub fn get_registration_key(\u0026self) -\u003e Result\u003cKeyPair, CryptoError\u003e {\n        self.registration_key.ok_or_else(|| {\n            error!(\"Error accessing registration_key (does not exist, or was not initialized)\");\n            CryptoError::ParsingError\n        })\n    }\n\n    pub fn set_registration_key(\u0026mut self, kp: KeyPair) -\u003e Result\u003c(), EnclaveError\u003e {\n        if let Err(e) = kp.seal(\u0026REGISTRATION_KEY_SEALING_PATH) {\n            error!(\"Error sealing registration key\");\n            return Err(e);\n        }\n        self.registration_key = Some(kp);\n        Ok(())\n    }\n\n    pub fn set_consensus_seed_exchange_keypair(\u0026mut self, kp: KeyPair) {\n        self.consensus_seed_exchange_keypair = Some(kp)\n    }\n\n    pub fn set_consensus_io_exchange_keypair(\u0026mut self, kp: KeyPair) {\n        self.consensus_io_exchange_keypair = Some(kp)\n    }\n\n    pub fn set_consensus_state_ikm(\u0026mut self, consensus_state_ikm: AESKey) {\n        self.consensus_state_ikm = Some(consensus_state_ikm);\n    }\n\n    pub fn set_consensus_callback_secret(\u0026mut self, consensus_callback_secret: AESKey) {\n        self.consensus_callback_secret = Some(consensus_callback_secret);\n    }\n\n    pub fn set_consensus_seed(\u0026mut self, consensus_seed: Seed) -\u003e Result\u003c(), EnclaveError\u003e {\n        if let Err(e) = consensus_seed.seal(\u0026CONSENSUS_SEED_SEALING_PATH) {\n            error!(\"Error sealing consensus_seed\");\n            return Err(e);\n        }\n        self.consensus_seed = Some(consensus_seed);\n        Ok(())\n    }\n\n    pub fn generate_consensus_master_keys(\u0026mut self) -\u003e Result\u003c(), EnclaveError\u003e {\n        if !self.is_consensus_seed_set() {\n            trace!(\"Seed not initialized, skipping derivation of enclave keys\");\n            return Ok(());\n        }\n\n        // consensus_seed_exchange_keypair\n\n        let consensus_seed_exchange_keypair_bytes = self\n            .consensus_seed\n            .unwrap()\n            .derive_key_from_this(\u0026CONSENSUS_SEED_EXCHANGE_KEYPAIR_DERIVE_ORDER.to_be_bytes());\n        let consensus_seed_exchange_keypair = KeyPair::from(consensus_seed_exchange_keypair_bytes);\n        trace!(\n            \"consensus_seed_exchange_keypair: {:?}\",\n            consensus_seed_exchange_keypair.get_pubkey()\n        );\n        self.set_consensus_seed_exchange_keypair(consensus_seed_exchange_keypair);\n\n        // consensus_io_exchange_keypair\n\n        let consensus_io_exchange_keypair_bytes = self\n            .consensus_seed\n            .unwrap()\n            .derive_key_from_this(\u0026CONSENSUS_IO_EXCHANGE_KEYPAIR_DERIVE_ORDER.to_be_bytes());\n        let consensus_io_exchange_keypair = KeyPair::from(consensus_io_exchange_keypair_bytes);\n        trace!(\n            \"consensus_io_exchange_keypair: {:?}\",\n            consensus_io_exchange_keypair.get_pubkey()\n        );\n        self.set_consensus_io_exchange_keypair(consensus_io_exchange_keypair);\n\n        // consensus_state_ikm\n\n        let consensus_state_ikm = self\n            .consensus_seed\n            .unwrap()\n            .derive_key_from_this(\u0026CONSENSUS_STATE_IKM_DERIVE_ORDER.to_be_bytes());\n\n        trace!(\"consensus_state_ikm: {:?}\", consensus_state_ikm.get());\n        self.set_consensus_state_ikm(consensus_state_ikm);\n\n        let consensus_callback_secret = self\n            .consensus_seed\n            .unwrap()\n            .derive_key_from_this(\u0026CONSENSUS_CALLBACK_SECRET_DERIVE_ORDER.to_be_bytes());\n\n        trace!(\"consensus_state_ikm: {:?}\", consensus_state_ikm.get());\n        self.set_consensus_callback_secret(consensus_callback_secret);\n\n        Ok(())\n    }\n}\n\n#[cfg(feature = \"test\")]\npub mod tests {\n\n    use super::{\n        Keychain, CONSENSUS_SEED_SEALING_PATH, KEY_MANAGER, REGISTRATION_KEY_SEALING_PATH,\n    };\n    use crate::crypto::CryptoError;\n    use crate::crypto::{KeyPair, Seed};\n\n    // todo: fix test vectors to actually work\n    fn test_initial_keychain_state() {\n        // clear previous data (if any)\n        std::sgxfs::remove(\u0026*CONSENSUS_SEED_SEALING_PATH);\n        std::sgxfs::remove(\u0026*REGISTRATION_KEY_SEALING_PATH);\n\n        let keys = Keychain::new();\n\n        // todo: replace with actual checks\n        // assert_eq!(keys.get_registration_key(), Err(CryptoError));\n        // assert_eq!(keys.get_consensus_seed(), Err(CryptoError));\n        // assert_eq!(keys.get_consensus_io_exchange_keypair(), Err(CryptoError));\n        // assert_eq!(keys.get_consensus_state_ikm(), Err(CryptoError));\n    }\n\n    // commented out since it uses outdated methods\n    // // todo: fix test vectors to actually work\n    // fn test_initialize_keychain_seed() {\n    //     // clear previous data (if any)\n    //     std::sgxfs::remove(\u0026*CONSENSUS_SEED_SEALING_PATH);\n    //     std::sgxfs::remove(\u0026*REGISTRATION_KEY_SEALING_PATH);\n    //\n    //     let mut keys = Keychain::new();\n    //\n    //     let seed = Seed::new_from_slice(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n    //\n    //     keys.set_consensus_seed(seed);\n    //     keys.generate_consensus_master_keys();\n    //     // todo: replace with actual checks\n    //     // assert_eq!(keys.get_registration_key(), Err(CryptoError));\n    //     assert_eq!(keys.get_consensus_seed().unwrap(), seed);\n    // }\n\n    // // todo: fix test vectors to actually work\n    // fn test_initialize_keychain_registration() {\n    //     // clear previous data (if any)\n    //     std::sgxfs::remove(\u0026*CONSENSUS_SEED_SEALING_PATH);\n    //     std::sgxfs::remove(\u0026*REGISTRATION_KEY_SEALING_PATH);\n    //\n    //     let mut keys = Keychain::new();\n    //\n    //     let kp = KeyPair::new_from_slice(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\").unwrap();\n    //\n    //     keys.set_registration_key(kp);\n    //     // todo: replace with actual checks\n    //     assert_eq!(keys.get_registration_key().unwrap(), kp);\n    // }\n    //\n    // // todo: fix test vectors to actually work\n    // fn test_initialize_keys() {\n    //     // clear previous data (if any)\n    //     std::sgxfs::remove(\u0026*CONSENSUS_SEED_SEALING_PATH);\n    //     std::sgxfs::remove(\u0026*REGISTRATION_KEY_SEALING_PATH);\n    //\n    //     let mut keys = Keychain::new();\n    //\n    //     let seed = Seed::new_from_slice(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n    //\n    //     keys.set_consensus_seed(seed);\n    //     keys.generate_consensus_master_keys();\n    //     // todo: replace with actual checks\n    //     assert_eq!(keys.get_consensus_io_exchange_keypair().unwrap(), seed);\n    //     assert_eq!(keys.get_consensus_state_ikm().unwrap(), seed);\n    // }\n    //\n    // // todo: fix test vectors to actually work\n    // fn test_key_manager() {\n    //     // clear previous data (if any)\n    //     std::sgxfs::remove(\u0026*CONSENSUS_SEED_SEALING_PATH);\n    //     std::sgxfs::remove(\u0026*REGISTRATION_KEY_SEALING_PATH);\n    //\n    //     let seed = Seed::new_from_slice(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n    //     let mut keys = Keychain::new();\n    //     keys.set_consensus_seed(seed);\n    //     keys.generate_consensus_master_keys();\n    //\n    //     // todo: replace with actual checks\n    //     assert_eq!(\n    //         KEY_MANAGER.get_consensus_io_exchange_keypair().unwrap(),\n    //         seed\n    //     );\n    //     assert_eq!(KEY_MANAGER.get_consensus_state_ikm().unwrap(), seed);\n    // }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":98},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","keys.rs"],"content":"use super::rng::rand_slice;\nuse super::traits::{AlignedMemory, ExportECKey, EC_256_PRIVATE_KEY_SIZE};\n\nuse crate::crypto::CryptoError;\n\nuse crate::crypto::ed25519::Ed25519PrivateKey;\nuse sgx_types::sgx_align_ec256_private_t;\n\npub const SEED_KEY_SIZE: usize = 32;\n\n/// The size of the symmetric 256 bit key we use for encryption (in bytes).\npub const SYMMETRIC_KEY_SIZE: usize = 256 / 8;\n/// The size of the master seed\n//pub const SEED_SIZE: usize = 32;\n/// The size of secret keys\n\ntype AlignedKey = sgx_align_ec256_private_t;\ntype AlignedSeed = sgx_align_ec256_private_t;\n\n/// symmetric key we use for encryption.\npub type SymmetricKey = [u8; SYMMETRIC_KEY_SIZE];\n/// StateKey is the key used for state encryption.\n// pub type StateKey = SymmetricKey;\n/// DHKey is the key that results from the ECDH [`enigma_crypto::KeyPair::derive_key`](../replace_me)\npub type DhKey = SymmetricKey;\n\n// pub type PubKey = [u8; COMPRESSED_PUBLIC_KEY_SIZE];\n\n// #[derive(Debug, Clone, Copy)]\n// pub struct AESKey(SymmetricKey);\n\n#[repr(C, align(64))]\n#[derive(Clone, Copy, Default)]\npub struct AESKey {\n    pub key: AlignedKey,\n}\n\nimpl AESKey {\n    #[allow(dead_code)]\n    fn key_len() -\u003e usize {\n        SYMMETRIC_KEY_SIZE\n    }\n\n    pub fn get(\u0026self) -\u003e \u0026[u8; SYMMETRIC_KEY_SIZE] {\n        \u0026self.key.key.r as \u0026[u8; 32]\n    }\n\n    pub fn as_mut(\u0026mut self) -\u003e \u0026mut [u8; 32] {\n        \u0026mut self.key.key.r as \u0026mut [u8; 32]\n    }\n\n    pub fn new_from_slice(privkey: \u0026[u8; SYMMETRIC_KEY_SIZE]) -\u003e Self {\n        let mut key = AESKey::default();\n\n        key.as_mut().copy_from_slice(privkey);\n\n        key\n    }\n}\n\nimpl AlignedMemory for AESKey {}\nimpl ExportECKey for AESKey {\n    fn key_ref(\u0026self) -\u003e \u0026[u8; EC_256_PRIVATE_KEY_SIZE] {\n        self.get()\n    }\n}\n\nimpl From\u003cEd25519PrivateKey\u003e for AESKey {\n    fn from(value: Ed25519PrivateKey) -\u003e Self {\n        let mut secret_key = AESKey::default();\n        secret_key.as_mut().copy_from_slice(value.key_ref());\n\n        secret_key\n    }\n}\n\n#[repr(C, align(64))]\n#[derive(Clone, Copy, Default)]\npub struct Seed {\n    pub key: AlignedSeed,\n}\n\nimpl Seed {\n    #[allow(dead_code)]\n    fn key_len() -\u003e usize {\n        SEED_KEY_SIZE\n    }\n\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8; SEED_KEY_SIZE] {\n        \u0026self.key.key.r as \u0026[u8; SEED_KEY_SIZE]\n    }\n\n    pub fn as_mut(\u0026mut self) -\u003e \u0026mut [u8; SEED_KEY_SIZE] {\n        \u0026mut self.key.key.r as \u0026mut [u8; SEED_KEY_SIZE]\n    }\n\n    pub fn new() -\u003e Result\u003cSelf, CryptoError\u003e {\n        let mut seed = Seed::default();\n\n        rand_slice(seed.as_mut())?;\n        Ok(seed)\n    }\n}\n\nimpl From\u003cEd25519PrivateKey\u003e for Seed {\n    fn from(value: Ed25519PrivateKey) -\u003e Self {\n        let mut secret_key = Seed::default();\n        secret_key.as_mut().copy_from_slice(value.key_ref());\n\n        secret_key\n    }\n}\n\nimpl AlignedMemory for Seed {}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":30},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","mod.rs"],"content":"mod errors;\npub(crate) mod kdf;\npub mod key_manager;\nmod keys;\nmod storage;\npub mod traits;\n\n// mod aes_gcm;\nmod aes_siv;\nmod hmac;\nmod rng;\nmod sha;\n\nmod ed25519;\npub mod multisig;\npub mod secp256k1;\n\npub use errors::CryptoError;\npub use key_manager::Keychain;\npub use key_manager::KEY_MANAGER;\npub use keys::{AESKey, Seed, SymmetricKey, SEED_KEY_SIZE};\n\npub use ed25519::{Ed25519PublicKey, KeyPair, PUBLIC_KEY_SIZE, SECRET_KEY_SIZE};\n\npub use sha::{sha_256, HASH_SIZE};\npub use traits::{Encryptable, Hmac, Kdf, SIVEncryptable, SealedKey, HMAC_SIGNATURE_SIZE};\n\n#[cfg(feature = \"test\")]\npub mod tests {\n    use super::*;\n    use crate::count_failures;\n\n    pub fn run_tests() {\n        println!();\n        let mut failures = 0;\n\n        count_failures!(failures, {\n            // kdf::tests::test_derive_key();\n            // storage::tests::test_open();\n            // storage::tests::test_seal();\n            multisig::tests_decode_multisig_signature::test_decode_sig_sanity();\n            multisig::tests_decode_multisig_signature::test_decode_long_leb128();\n            multisig::tests_decode_multisig_signature::test_decode_wrong_long_leb128();\n            multisig::tests_decode_multisig_signature::test_decode_malformed_sig_only_prefix();\n            multisig::tests_decode_multisig_signature::test_decode_sig_length_zero();\n            multisig::tests_decode_multisig_signature::test_decode_malformed_sig_wrong_length();\n        });\n\n        if failures != 0 {\n            panic!(\"{}: {} tests failed\", file!(), failures);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","multisig.rs"],"content":"use log::*;\n\nuse crate::cosmwasm::encoding::Binary;\nuse crate::cosmwasm::types::{CanonicalAddr, PubKeyKind};\nuse crate::crypto::traits::PubKey;\nuse crate::crypto::CryptoError;\n\nuse serde::{Deserialize, Serialize};\nuse sha2::Digest;\n\nconst THRESHOLD_PREFIX: [u8; 5] = [34, 193, 247, 226, 8];\nconst GENERIC_PREFIX: u8 = 18;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct MultisigThresholdPubKey {\n    threshold: u8,\n    pubkeys: Vec\u003cPubKeyKind\u003e,\n}\n\nimpl PubKey for MultisigThresholdPubKey {\n    fn get_address(\u0026self) -\u003e CanonicalAddr {\n        // Spec: https://docs.tendermint.com/master/spec/core/encoding.html#key-types\n        // Multisig is undocumented, but we figured out it's the same as ed25519\n        let address_bytes = \u0026sha2::Sha256::digest(self.bytes().as_slice())[..20];\n\n        CanonicalAddr(Binary::from(address_bytes))\n    }\n\n    fn bytes(\u0026self) -\u003e Vec\u003cu8\u003e {\n        // Encoding for multisig is basically:\n        // threshold_prefix | threshold | generic_prefix | encoded_pubkey_length | ...encoded_pubkey... | generic_prefix | encoded_pubkey_length | ...encoded_pubkey...\n        let mut encoded: Vec\u003cu8\u003e = vec![];\n\n        encoded.extend_from_slice(\u0026THRESHOLD_PREFIX);\n        encoded.push(self.threshold);\n\n        for pubkey in \u0026self.pubkeys {\n            encoded.push(GENERIC_PREFIX);\n\n            // Length may be more than 1 byte and it is protobuf encoded\n            let mut length = Vec::\u003cu8\u003e::new();\n\n            let pubkey_bytes = pubkey.bytes();\n            // This line should never fail since it could only fail if `length` does not have sufficient capacity to encode\n            if prost::encode_length_delimiter(pubkey_bytes.len(), \u0026mut length).is_err() {\n                warn!(\n                    \"Could not encode length delimiter: {:?}. This should not happen\",\n                    pubkey_bytes.len()\n                );\n                return vec![];\n            }\n            encoded.extend_from_slice(\u0026length);\n            encoded.extend_from_slice(\u0026pubkey_bytes);\n        }\n\n        trace!(\"pubkey bytes are: {:?}\", encoded);\n        encoded\n    }\n\n    fn verify_bytes(\u0026self, bytes: \u0026[u8], sig: \u0026[u8]) -\u003e Result\u003c(), CryptoError\u003e {\n        debug!(\"verifying multisig\");\n        trace!(\"Sign bytes are: {:?}\", bytes);\n        let signatures = decode_multisig_signature(sig)?;\n\n        if signatures.len() \u003c (self.threshold as usize) || signatures.len() \u003e self.pubkeys.len() {\n            warn!(\n                \"Wrong number of signatures! min expected: {:?}, max expected: {:?}, provided: {:?}\",\n                self.threshold,\n                self.pubkeys.len(),\n                signatures.len()\n            );\n            return Err(CryptoError::VerificationError);\n        }\n\n        let mut verified_counter = 0;\n\n        for current_sig in \u0026signatures {\n            trace!(\"Checking sig: {:?}\", current_sig);\n            // TODO: can we somehow easily skip already verified signatures?\n            for current_pubkey in \u0026self.pubkeys {\n                trace!(\"Checking pubkey: {:?}\", current_pubkey);\n                // This technically support that one of the multisig signers is a multisig itself\n                let result = current_pubkey.verify_bytes(bytes, \u0026current_sig);\n\n                if result.is_ok() {\n                    verified_counter += 1;\n                    break;\n                }\n            }\n        }\n\n        if verified_counter \u003c signatures.len() {\n            warn!(\"Failed to verify some or all signatures\");\n            Err(CryptoError::VerificationError)\n        } else {\n            debug!(\"Miltusig verified successfully\");\n            Ok(())\n        }\n    }\n}\n\ntype MultisigSignature = Vec\u003cVec\u003cu8\u003e\u003e;\n\nfn decode_multisig_signature(raw_blob: \u0026[u8]) -\u003e Result\u003cMultisigSignature, CryptoError\u003e {\n    trace!(\"decoding blob: {:?}\", raw_blob);\n    let blob_size = raw_blob.len();\n    if blob_size \u003c 8 {\n        warn!(\"Multisig signature too short. decoding failed!\");\n        return Err(CryptoError::ParsingError);\n    }\n\n    let mut signatures: MultisigSignature = vec![];\n\n    let mut idx: usize = 7;\n    while let Some(curr_blob_window) = raw_blob.get(idx..) {\n        if curr_blob_window.is_empty() {\n            break;\n        }\n\n        trace!(\"while letting with {:?}\", curr_blob_window);\n        trace!(\"blob len is {:?} idx is: {:?}\", raw_blob.len(), idx);\n        let current_sig_prefix = curr_blob_window[0];\n\n        if current_sig_prefix != 0x12 {\n            warn!(\"Multisig signature wrong prefix. decoding failed!\");\n            return Err(CryptoError::ParsingError);\n        // The condition below can't fail because:\n        // (1) curr_blob_window.get(1..) will return a Some(empty_slice) if curr_blob_window.len()=1\n        // (2) At the beginning of the while loop we make sure curr_blob_window isn't empty, thus curr_blob_window.len() \u003e 0\n        // Therefore, no need for an else clause\n        } else if let Some(sig_including_len) = curr_blob_window.get(1..) {\n            // The condition below will take care of a case where `sig_including_len` is empty due\n            // to curr_blob_window.get(), so no explicit check is needed here\n            if let Ok(current_sig_len) = prost::decode_length_delimiter(sig_including_len) {\n                let len_size = prost::length_delimiter_len(current_sig_len);\n\n                trace!(\"sig len is: {:?}\", current_sig_len);\n                if let Some(raw_signature) =\n                    sig_including_len.get(len_size..current_sig_len + len_size)\n                {\n                    signatures.push((\u0026raw_signature).to_vec());\n                    idx += 1 + len_size + current_sig_len; // prefix_byte + length_byte + len(sig)\n                } else {\n                    warn!(\"Multisig signature malformed. decoding failed!\");\n                    return Err(CryptoError::ParsingError);\n                }\n            } else {\n                warn!(\"Multisig signature malformed. decoding failed!\");\n                return Err(CryptoError::ParsingError);\n            }\n        }\n    }\n\n    if signatures.is_empty() {\n        warn!(\"Multisig signature empty. decoding failed!\");\n        return Err(CryptoError::ParsingError);\n    }\n\n    Ok(signatures)\n}\n\n#[cfg(feature = \"test\")]\npub mod tests_decode_multisig_signature {\n    use crate::crypto::multisig::{decode_multisig_signature, MultisigSignature};\n\n    pub fn test_decode_sig_sanity() {\n        let sig: Vec\u003cu8\u003e = vec![\n            0, 0, 0, 0, 0, 0, 0, 0x12, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0x12, 4, 1, 2, 3, 4,\n        ];\n\n        let result = decode_multisig_signature(sig.as_slice()).unwrap();\n        assert_eq!(\n            result,\n            vec![vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], vec![1, 2, 3, 4]],\n            \"Signature is: {:?} and result is: {:?}\",\n            sig,\n            result\n        )\n    }\n\n    pub fn test_decode_long_leb128() {\n        let sig: Vec\u003cu8\u003e = vec![\n            0, 0, 0, 0, 0, 0, 0, 0x12, 200, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n\n        let result = decode_multisig_signature(sig.as_slice()).unwrap();\n        assert_eq!(\n            result,\n            vec![vec![\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0,\n            ]],\n            \"Signature is: {:?} and result is: {:?}\",\n            sig,\n            result\n        )\n    }\n\n    pub fn test_decode_wrong_long_leb128() {\n        let malformed_sig: Vec\u003cu8\u003e = vec![\n            0, 0, 0, 0, 0, 0, 0, 0x12, 205, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n        ];\n\n        let result = decode_multisig_signature(malformed_sig.as_slice());\n        assert!(\n            result.is_err(),\n            \"Signature is: {:?} and result is: {:?}\",\n            malformed_sig,\n            result\n        );\n    }\n\n    pub fn test_decode_malformed_sig_only_prefix() {\n        let malformed_sig: Vec\u003cu8\u003e = vec![0, 0, 0, 0, 0, 0, 0, 0x12];\n\n        let result = decode_multisig_signature(malformed_sig.as_slice());\n        assert!(\n            result.is_err(),\n            \"Signature is: {:?} and result is: {:?}\",\n            malformed_sig,\n            result\n        );\n    }\n\n    pub fn test_decode_sig_length_zero() {\n        let sig: Vec\u003cu8\u003e = vec![0, 0, 0, 0, 0, 0, 0, 0x12, 0];\n\n        let result = decode_multisig_signature(sig.as_slice()).unwrap();\n        let expected: Vec\u003cVec\u003cu8\u003e\u003e = vec![vec![]];\n        assert_eq!(\n            result, expected,\n            \"Signature is: {:?} and result is: {:?}\",\n            sig, result\n        )\n    }\n\n    pub fn test_decode_malformed_sig_wrong_length() {\n        let malformed_sig: Vec\u003cu8\u003e = vec![0, 0, 0, 0, 0, 0, 0, 0x12, 10, 0, 0];\n\n        let result = decode_multisig_signature(malformed_sig.as_slice());\n        assert!(\n            result.is_err(),\n            \"Signature is: {:?} and result is: {:?}\",\n            malformed_sig,\n            result\n        );\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":43},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","rng.rs"],"content":"use crate::crypto::CryptoError;\nuse sgx_trts::trts::rsgx_read_rand;\n\npub fn rand_slice(rand: \u0026mut [u8]) -\u003e Result\u003c(), CryptoError\u003e {\n    rsgx_read_rand(rand).map_err(|_e| CryptoError::RandomError {})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","secp256k1.rs"],"content":"use log::*;\n\nuse crate::cosmwasm::encoding::Binary;\nuse crate::cosmwasm::types::CanonicalAddr;\nuse crate::crypto::traits::PubKey;\nuse crate::crypto::CryptoError;\nuse ripemd160::{Digest, Ripemd160};\nuse secp256k1::Secp256k1;\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest as Sha2Digest, Sha256};\n\nconst SECP256K1_PREFIX: [u8; 4] = [235, 90, 233, 135];\n\n// TODO: Find a way to implement this better. secp256k1 is not ported to sgx, thus does not implement mesalock's serde and cannot be used\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct Secp256k1PubKey(Vec\u003cu8\u003e);\n\nimpl PubKey for Secp256k1PubKey {\n    fn get_address(\u0026self) -\u003e CanonicalAddr {\n        // Ref: https://github.com/tendermint/spec/blob/master/spec/blockchain/encoding.md#secp256k1\n        let mut hasher = Ripemd160::new();\n        hasher.update(Sha256::digest(\u0026self.0));\n        CanonicalAddr(Binary(hasher.finalize().to_vec()))\n    }\n\n    fn bytes(\u0026self) -\u003e Vec\u003cu8\u003e {\n        // Amino encoding here is basically: prefix | leb128 encoded length | ..bytes..\n        let mut encoded = Vec::\u003cu8\u003e::new();\n        encoded.extend_from_slice(\u0026SECP256K1_PREFIX);\n\n        // Length may be more than 1 byte and it is protobuf encoded\n        let mut length = Vec::\u003cu8\u003e::new();\n\n        // This line can't fail since it could only fail if `length` does not have sufficient capacity to encode\n        if prost::encode_length_delimiter(self.0.len(), \u0026mut length).is_err() {\n            warn!(\n                \"Could not encode length delimiter: {:?}. This should not happen\",\n                self.0.len()\n            );\n            return vec![];\n        }\n\n        encoded.extend_from_slice(\u0026length);\n        encoded.extend_from_slice(\u0026self.0);\n\n        encoded\n    }\n\n    fn verify_bytes(\u0026self, bytes: \u0026[u8], sig: \u0026[u8]) -\u003e Result\u003c(), CryptoError\u003e {\n        // Signing ref: https://docs.cosmos.network/master/spec/_ics/ics-030-signed-messages.html#preliminary\n        let sign_bytes_hash = Sha256::digest(bytes);\n        let msg = secp256k1::Message::from_slice(sign_bytes_hash.as_slice()).map_err(|err| {\n            warn!(\"Failed to create a secp256k1 message from tx: {:?}\", err);\n            CryptoError::VerificationError\n        })?;\n\n        let verifier = Secp256k1::verification_only();\n\n        // Create `secp256k1`'s types\n        let sec_signature = secp256k1::Signature::from_compact(sig).map_err(|err| {\n            warn!(\"Malformed signature: {:?}\", err);\n            CryptoError::VerificationError\n        })?;\n        let sec_public_key =\n            secp256k1::PublicKey::from_slice(self.0.as_slice()).map_err(|err| {\n                warn!(\"Malformed public key: {:?}\", err);\n                CryptoError::VerificationError\n            })?;\n\n        verifier\n            .verify(\u0026msg, \u0026sec_signature, \u0026sec_public_key)\n            .map_err(|err| {\n                warn!(\n                    \"Failed to verify signatures for the given transaction: {:?}\",\n                    err\n                );\n                CryptoError::VerificationError\n            })?;\n\n        Ok(())\n    }\n}\n\n// TODO: Can we get rid of this comment below?\n\n// use super::keys::SECRET_KEY_SIZE;\n// use super::KeyPair;\n// use crate::crypto::CryptoError;\n//\n// use secp256k1::ecdh::SharedSecret;\n// use secp256k1::key::{PublicKey, SecretKey};\n// use secp256k1::{All, Secp256k1};\n//\n// /// PubKey is a public key that is used for ECDSA signing.\n// pub type PubKey = [u8; UNCOMPRESSED_PUBLIC_KEY_SIZE];\n//\n// pub const SECRET_KEY_SIZE: usize = secp256k1::constants::SECRET_KEY_SIZE;\n// /// The size of uncomressed public keys\n// pub const UNCOMPRESSED_PUBLIC_KEY_SIZE: usize = secp256k1::constants::UNCOMPRESSED_PUBLIC_KEY_SIZE;\n// pub const COMPRESSED_PUBLIC_KEY_SIZE: usize = 33;\n//\n// #[derive(Debug, Clone)]\n// pub struct KeyPair {\n//     context: Secp256k1\u003cAll\u003e,\n//     pubkey: PublicKey,\n//     privkey: SecretKey,\n// }\n//\n// impl KeyPair {\n//     /// This will generate a fresh pair of Public and Private keys.\n//     /// it will use the available randomness from [crate::rand]\n//     pub fn new() -\u003e Result\u003cSelf, CryptoError\u003e {\n//         // This loop is important to make sure that the resulting public key isn't a point in infinity(at the curve).\n//         // So if the Resulting public key is bad we need to generate a new random private key and try again until it succeeds.\n//         loop {\n//             let context = Secp256k1::new();\n//             let mut sk_slice = [0; SECRET_KEY_SIZE];\n//             rand_slice(\u0026mut sk_slice)?;\n//             if let Ok(privkey) = SecretKey::from_slice(\u0026sk_slice) {\n//                 let pubkey = PublicKey::from_secret_key(\u0026context, \u0026privkey);\n//                 return Ok(KeyPair {\n//                     context,\n//                     privkey,\n//                     pubkey,\n//                 });\n//             }\n//         }\n//     }\n//\n//     /// This function will create a Pair of keys from an array of 32 bytes.\n//     /// Please don't use it to generate a new key, if you want a new key use `KeyPair::new()`\n//     /// Because `KeyPair::new()` will make sure it uses a good random source and will loop private keys until it's a good key.\n//     /// (and it's best to isolate the generation of keys to one place)\n//     pub fn new_from_slice(privkey: \u0026[u8; SECRET_KEY_SIZE]) -\u003e Result\u003cSelf, CryptoError\u003e {\n//         let context = Secp256k1::new();\n//\n//         let privkey = SecretKey::from_slice(privkey).map_err(|e| CryptoError::KeyError {})?;\n//         let pubkey = PublicKey::from_secret_key(\u0026context, \u0026privkey);\n//\n//         Ok(KeyPair {\n//             context,\n//             privkey,\n//             pubkey,\n//         })\n//     }\n//\n//     /// This function does an ECDH(point multiplication) between one's private key and the other one's public key\n//     pub fn derive_key(\u0026self, pubarr: \u0026[u8]) -\u003e Result\u003cDhKey, CryptoError\u003e {\n//         if pubarr.len() != UNCOMPRESSED_PUBLIC_KEY_SIZE\n//             \u0026\u0026 pubarr.len() != COMPRESSED_PUBLIC_KEY_SIZE\n//         {\n//             error!(\"Public key invalid length - must be 65 or 33 bytes\");\n//             return Err(CryptoError::KeyError {});\n//         }\n//\n//         let pubkey = PublicKey::from_slice(pubarr).map_err(|e| {\n//             error!(\"Error creating public key {:?}\", e);\n//             CryptoError::KeyError {}\n//         })?;\n//\n//         info!(\n//             \"Derive key public: {:?}\",\n//             \u0026pubkey.serialize_uncompressed().to_vec().as_slice()\n//         );\n//         // SharedSecret::\n//         info!(\"Derive key private: {:?}\", \u0026self.privkey);\n//         let shared = SharedSecret::new(\u0026pubkey, \u0026self.privkey);\n//\n//         if shared.len() != SYMMETRIC_KEY_SIZE {\n//             error!(\n//                 \"Error creating shared secret. Size mismatch {:?}\",\n//                 shared.len()\n//             );\n//             return Err(CryptoError::KeyError {});\n//         }\n//\n//         let mut result = [0u8; SYMMETRIC_KEY_SIZE];\n//         result.copy_from_slice(shared.as_ref());\n//         Ok(result)\n//     }\n//\n//     /// This will return the raw 32 bytes private key. use carefully.\n//     pub fn get_privkey(\u0026self) -\u003e \u0026[u8] {\n//         \u0026self.privkey[..]\n//     }\n//\n//     // This will return the raw 64 bytes public key.\n//     pub fn get_pubkey(\u0026self) -\u003e PubKey {\n//         self.pubkey.serialize_uncompressed()\n//     }\n// }\n//\n// #[cfg(feature = \"test\")]\n// pub mod tests {\n//\n//     use super::{KeyPair, Seed, SymmetricKey, SEED_SIZE};\n//     use crate::crypto::{PUBLIC_KEY_SIZE, UNCOMPRESSED_PUBLIC_KEY_SIZE};\n//     use crate::crypto::CryptoError;\n//\n//     fn test_seed_from_slice() {\n//         let seed = Seed::new_from_slice(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n//\n//         assert_eq!(seed.0, b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n//         assert_eq!(seed.get(), b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n//     }\n//\n//     fn test_seed_new() {\n//         let seed = Seed::new();\n//         let zero_slice = [0u8; SEED_SIZE];\n//         assert_ne!(seed.0, zero_slice)\n//     }\n//\n//     // todo: replace public key with real value\n//     fn test_keypair_from_slice() {\n//         let kp = KeyPair::new_from_slice(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\").unwrap();\n//\n//         assert_eq!(kp.get_privkey(), b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n//         assert_eq!(\n//             kp.get_pubkey(),\n//             b\"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\"\n//         );\n//     }\n//\n//     // this obviously isn't a cryptanalysis, but hey, at least make sure the random doesn't generate all zeros\n//     fn test_keypair_new() {\n//         let kp = KeyPair::new().unwrap();\n//         let zero_slice = [0u8; SEED_SIZE];\n//         assert_ne!(kp.get_privkey(), zero_slice);\n//     }\n//\n//     // this obviously isn't a cryptanalysis, but hey, at least make sure the random doesn't generate all zeros\n//     fn test_ecdh() {\n//         let kp = KeyPair::new_from_slice(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\").unwrap();\n//\n//         let zero_slice = [10u8; UNCOMPRESSED_PUBLIC_KEY_SIZE];\n//\n//         let dhkey = kp.derive_key(\u0026zero_slice).unwrap();\n//\n//         assert_eq!(dhkey, b\"SOME EXPECTED KEY\");\n//     }\n// }\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":36},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","sha.rs"],"content":"use ring::digest;\n\npub const HASH_SIZE: usize = 32;\n\npub fn sha_256(data: \u0026[u8]) -\u003e [u8; HASH_SIZE] {\n    let hash = digest::digest(\u0026digest::SHA256, data);\n\n    let mut result = [0u8; HASH_SIZE];\n    result.copy_from_slice(hash.as_ref());\n\n    result\n}\n\n// #[cfg(feature = \"test\")]\n// pub mod tests {\n//     use super::{\n//         Keychain, CONSENSUS_SEED_SEALING_PATH, KEY_MANAGER, REGISTRATION_KEY_SEALING_PATH,\n//     };\n//     use crate::crypto::{Kdf, KeyPair, Seed};\n//     use crate::crypto::CryptoError;\n//\n//     // todo: fix test vectors to actually work\n//     fn test_derive_key() {\n//         let seed = Seed::new_from_slice(\u0026[10u8; 32]);\n//\n//         let kdf1 = seed.derive_key_from_this(\u00261.to_be_bytes());\n//         let kdf2 = seed.derive_key_from_this(\u00262.to_be_bytes());\n//\n//         assert_eq!(kdf1, b\"SOME VALUE\");\n//         assert_eq!(kdf2, b\"SOME VALUE\");\n//     }\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","storage.rs"],"content":"use crate::crypto::ed25519::Ed25519PrivateKey;\nuse crate::crypto::traits::SealedKey;\nuse crate::crypto::{AESKey, KeyPair, Seed, SECRET_KEY_SIZE};\nuse enclave_ffi_types::EnclaveError;\nuse log::*;\nuse std::io::{Read, Write};\nuse std::sgxfs::SgxFile;\n\nimpl SealedKey for AESKey {\n    fn seal(\u0026self, filepath: \u0026str) -\u003e Result\u003c(), EnclaveError\u003e {\n        seal(self.get(), filepath)\n    }\n\n    fn unseal(filepath: \u0026str) -\u003e Result\u003cSelf, EnclaveError\u003e {\n        let buf = open(filepath)?;\n        Ok(Self::from(buf))\n    }\n}\n\nimpl SealedKey for Seed {\n    fn seal(\u0026self, filepath: \u0026str) -\u003e Result\u003c(), EnclaveError\u003e {\n        seal(\u0026self.as_slice(), filepath)\n    }\n\n    fn unseal(filepath: \u0026str) -\u003e Result\u003cSelf, EnclaveError\u003e {\n        let buf = open(filepath)?;\n        Ok(Self::from(buf))\n    }\n}\n\nimpl SealedKey for KeyPair {\n    fn seal(\u0026self, filepath: \u0026str) -\u003e Result\u003c(), EnclaveError\u003e {\n        // Files are automatically closed when they go out of scope.\n        seal(\u0026self.get_privkey(), filepath)\n    }\n\n    fn unseal(filepath: \u0026str) -\u003e Result\u003cSelf, EnclaveError\u003e {\n        let buf = open(filepath)?;\n        Ok(KeyPair::from(buf))\n    }\n}\n\nfn seal(data: \u0026[u8; 32], filepath: \u0026str) -\u003e Result\u003c(), EnclaveError\u003e {\n    let mut file = SgxFile::create(filepath).map_err(|_err| EnclaveError::FailedUnseal)?;\n\n    file.write_all(data)\n        .map_err(|_err| EnclaveError::FailedUnseal)\n}\n\nfn open(filepath: \u0026str) -\u003e Result\u003cEd25519PrivateKey, EnclaveError\u003e {\n    let mut file = SgxFile::open(filepath).map_err(|_err| EnclaveError::FailedUnseal)?;\n\n    let mut buf = Ed25519PrivateKey::default();\n    let n = file\n        .read(buf.as_mut())\n        .map_err(|_err| EnclaveError::FailedUnseal)?;\n\n    if n \u003c SECRET_KEY_SIZE {\n        error!(\n            \"[Enclave] Dramatic read from {} ended prematurely (n = {} \u003c SECRET_KEY_SIZE = {})\",\n            filepath, n, SECRET_KEY_SIZE\n        );\n        return Err(EnclaveError::FailedUnseal);\n    }\n    Ok(buf)\n}\n\n#[cfg(feature = \"test\")]\npub mod tests {\n\n    use super::{open, seal};\n    use log::*;\n\n    // todo: fix test vectors to actually work\n    pub fn test_seal() {\n        let key = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n\n        if let Err(e) = seal(key, \"file\") {\n            error!(\"Failed to seal data: {:?}\", e)\n        };\n    }\n\n    // // todo: fix test vectors to actually work\n    // pub fn test_open() {\n    //     let key = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    //\n    //     if let Err(e) = seal(key, \"file\") {\n    //         error!(\"Failed to seal data: {:?}\", e)\n    //         // todo: fail\n    //     };\n    //\n    //     let data = open(\"file\").expect(\u0026format!(\"Failed to open data: {:?}\", e));\n    //\n    //     assert_eq!(data, key);\n    // }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":15},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","crypto","traits.rs"],"content":"use enclave_ffi_types::EnclaveError;\n\nuse crate::cosmwasm::types::CanonicalAddr;\nuse crate::crypto::CryptoError;\n\npub const HMAC_SIGNATURE_SIZE: usize = 32;\npub const EC_256_PRIVATE_KEY_SIZE: usize = 32;\n\npub trait Encryptable {\n    fn encrypt(\u0026self, plaintext: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e;\n    fn decrypt(\u0026self, ciphertext: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e;\n}\n\npub trait SIVEncryptable {\n    fn encrypt_siv(\u0026self, plaintext: \u0026[u8], ad: Option\u003c\u0026[\u0026[u8]]\u003e) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e;\n    fn decrypt_siv(\u0026self, plaintext: \u0026[u8], ad: Option\u003c\u0026[\u0026[u8]]\u003e) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e;\n}\n\npub trait SealedKey\nwhere\n    Self: std::marker::Sized,\n{\n    fn seal(\u0026self, filepath: \u0026str) -\u003e Result\u003c(), EnclaveError\u003e;\n    fn unseal(filepath: \u0026str) -\u003e Result\u003cSelf, EnclaveError\u003e;\n}\n\npub trait Rng {\n    fn rand_slice(buf: \u0026mut [u8]) -\u003e Result\u003c(), CryptoError\u003e;\n}\n\npub trait Kdf\u003cT\u003e {\n    fn derive_key_from_this(\u0026self, data: \u0026[u8]) -\u003e T;\n}\n\npub trait Hmac {\n    fn sign_sha_256(\u0026self, to_sign: \u0026[u8]) -\u003e [u8; HMAC_SIGNATURE_SIZE];\n}\n\npub trait AlignedMemory {}\n\npub trait ExportECKey {\n    fn key_ref(\u0026self) -\u003e \u0026[u8; EC_256_PRIVATE_KEY_SIZE];\n}\n\n// https://github.com/tendermint/tendermint/blob/v0.33.3/crypto/crypto.go#L22\npub trait PubKey: PartialEq {\n    fn get_address(\u0026self) -\u003e CanonicalAddr;\n    fn bytes(\u0026self) -\u003e Vec\u003cu8\u003e;\n    fn verify_bytes(\u0026self, bytes: \u0026[u8], sig: \u0026[u8]) -\u003e Result\u003c(), CryptoError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","exports.rs"],"content":"use lazy_static::lazy_static;\nuse log::*;\nuse std::ffi::c_void;\n\nuse enclave_ffi_types::{\n    Ctx, EnclaveBuffer, EnclaveError, HandleResult, HealthCheckResult, InitResult, QueryResult,\n};\nuse std::panic;\nuse std::sync::SgxMutex;\n\nuse crate::results::{\n    result_handle_success_to_handleresult, result_init_success_to_initresult,\n    result_query_success_to_queryresult,\n};\nuse crate::{\n    oom_handler, recursion_depth,\n    utils::{validate_const_ptr, validate_mut_ptr},\n};\n\nlazy_static! {\n    static ref ECALL_ALLOCATE_STACK: SgxMutex\u003cVec\u003cEnclaveBuffer\u003e\u003e = SgxMutex::new(Vec::new());\n}\n\n/// Allocate a buffer in the enclave and return a pointer to it. This is useful for ocalls that\n/// want to return a response of unknown length to the enclave. Instead of pre-allocating it on the\n/// ecall side, the ocall can call this ecall and return the EnclaveBuffer to the ecall that called\n/// it.\n///\n/// host -\u003e ecall_x -\u003e ocall_x -\u003e ecall_allocate\n/// # Safety\n/// Always use protection\n#[no_mangle]\npub unsafe extern \"C\" fn ecall_allocate(buffer: *const u8, length: usize) -\u003e EnclaveBuffer {\n    if let Err(_err) = oom_handler::register_oom_handler() {\n        error!(\"Could not register OOM handler!\");\n        return EnclaveBuffer::default();\n    }\n\n    if let Err(_e) = validate_const_ptr(buffer, length as usize) {\n        error!(\"Tried to access data outside enclave memory space!\");\n        return EnclaveBuffer::default();\n    }\n\n    let slice = std::slice::from_raw_parts(buffer, length);\n    let result = panic::catch_unwind(|| {\n        let vector_copy = slice.to_vec();\n        let boxed_vector = Box::new(vector_copy);\n        let heap_pointer = Box::into_raw(boxed_vector);\n        let enclave_buffer = EnclaveBuffer {\n            ptr: heap_pointer as *mut c_void,\n        };\n        ECALL_ALLOCATE_STACK\n            .lock()\n            .unwrap()\n            .push(enclave_buffer.unsafe_clone());\n        enclave_buffer\n    });\n\n    if let Err(_err) = oom_handler::restore_safety_buffer() {\n        error!(\"Could not restore OOM safety buffer!\");\n        return EnclaveBuffer::default();\n    }\n\n    result.unwrap_or_else(|err| {\n        // We can get here only by failing to allocate memory,\n        // so there's no real need here to test if oom happened\n        error!(\"Enclave ran out of memory: {:?}\", err);\n        oom_handler::get_then_clear_oom_happened();\n        EnclaveBuffer::default()\n    })\n}\n\n#[derive(Debug, PartialEq)]\npub struct BufferRecoveryError;\n\n/// Take a pointer as returned by `ecall_allocate` and recover the Vec\u003cu8\u003e inside of it.\n/// # Safety\n///  This is a text\npub unsafe fn recover_buffer(ptr: EnclaveBuffer) -\u003e Result\u003cOption\u003cVec\u003cu8\u003e\u003e, BufferRecoveryError\u003e {\n    if ptr.ptr.is_null() {\n        return Ok(None);\n    }\n\n    let mut alloc_stack = ECALL_ALLOCATE_STACK.lock().unwrap();\n\n    // search the stack from the end for this pointer\n    let maybe_index = alloc_stack\n        .iter()\n        .rev()\n        .position(|buffer| buffer.ptr as usize == ptr.ptr as usize);\n    if let Some(index_from_the_end) = maybe_index {\n        // This index is probably at the end of the stack, but we give it a little more flexibility\n        // in case access patterns change in the future\n        let index = alloc_stack.len() - index_from_the_end - 1;\n        alloc_stack.swap_remove(index);\n    } else {\n        return Err(BufferRecoveryError);\n    }\n    let boxed_vector = Box::from_raw(ptr.ptr as *mut Vec\u003cu8\u003e);\n    Ok(Some(*boxed_vector))\n}\n\n/// # Safety\n/// Always use protection\n#[no_mangle]\npub unsafe extern \"C\" fn ecall_init(\n    context: Ctx,\n    gas_limit: u64,\n    used_gas: *mut u64,\n    contract: *const u8,\n    contract_len: usize,\n    env: *const u8,\n    env_len: usize,\n    msg: *const u8,\n    msg_len: usize,\n    sig_info: *const u8,\n    sig_info_len: usize,\n) -\u003e InitResult {\n    let _recursion_guard = match recursion_depth::guard() {\n        Ok(rg) =\u003e rg,\n        Err(err) =\u003e {\n            // https://github.com/enigmampc/SecretNetwork/pull/517#discussion_r481924571\n            // I believe that this error condition is currently unreachable.\n            // I think we can safely remove it completely right now, and have\n            // recursion_depth::increment() simply increment the counter with no further checks,\n            // but i wanted to stay on the safe side here, in case something changes in the\n            // future, and we can easily spot that we forgot to add a limit somewhere.\n            error!(\"recursion limit exceeded, can not perform init!\");\n            return InitResult::Failure { err };\n        }\n    };\n    if let Err(err) = oom_handler::register_oom_handler() {\n        error!(\"Could not register OOM handler!\");\n        return InitResult::Failure { err };\n    }\n    if let Err(_e) = validate_mut_ptr(used_gas as _, std::mem::size_of::\u003cu64\u003e()) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_init_success_to_initresult(Err(EnclaveError::FailedFunctionCall));\n    }\n    if let Err(_e) = validate_const_ptr(env, env_len as usize) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_init_success_to_initresult(Err(EnclaveError::FailedFunctionCall));\n    }\n    if let Err(_e) = validate_const_ptr(msg, msg_len as usize) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_init_success_to_initresult(Err(EnclaveError::FailedFunctionCall));\n    }\n    if let Err(_e) = validate_const_ptr(contract, contract_len as usize) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_init_success_to_initresult(Err(EnclaveError::FailedFunctionCall));\n    }\n    if let Err(_e) = validate_const_ptr(sig_info, sig_info_len as usize) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_init_success_to_initresult(Err(EnclaveError::FailedFunctionCall));\n    }\n\n    let contract = std::slice::from_raw_parts(contract, contract_len);\n    let env = std::slice::from_raw_parts(env, env_len);\n    let msg = std::slice::from_raw_parts(msg, msg_len);\n    let sig_info = std::slice::from_raw_parts(sig_info, sig_info_len);\n    let result = panic::catch_unwind(|| {\n        let mut local_used_gas = *used_gas;\n        let result = crate::wasm::init(\n            context,\n            gas_limit,\n            \u0026mut local_used_gas,\n            contract,\n            env,\n            msg,\n            sig_info,\n        );\n        *used_gas = local_used_gas;\n        result_init_success_to_initresult(result)\n    });\n\n    if let Err(err) = oom_handler::restore_safety_buffer() {\n        error!(\"Could not restore OOM safety buffer!\");\n        return InitResult::Failure { err };\n    }\n\n    if let Ok(res) = result {\n        res\n    } else {\n        *used_gas = gas_limit / 2;\n\n        if oom_handler::get_then_clear_oom_happened() {\n            error!(\"Call ecall_init failed because the enclave ran out of memory!\");\n            InitResult::Failure {\n                err: EnclaveError::OutOfMemory,\n            }\n        } else {\n            error!(\"Call ecall_init panicked unexpectedly!\");\n            InitResult::Failure {\n                err: EnclaveError::Panic,\n            }\n        }\n    }\n}\n\n/// # Safety\n/// Always use protection\n#[no_mangle]\npub unsafe extern \"C\" fn ecall_handle(\n    context: Ctx,\n    gas_limit: u64,\n    used_gas: *mut u64,\n    contract: *const u8,\n    contract_len: usize,\n    env: *const u8,\n    env_len: usize,\n    msg: *const u8,\n    msg_len: usize,\n    sig_info: *const u8,\n    sig_info_len: usize,\n) -\u003e HandleResult {\n    let _recursion_guard = match recursion_depth::guard() {\n        Ok(rg) =\u003e rg,\n        Err(err) =\u003e {\n            // https://github.com/enigmampc/SecretNetwork/pull/517#discussion_r481924571\n            // I believe that this error condition is currently unreachable.\n            // I think we can safely remove it completely right now, and have\n            // recursion_depth::increment() simply increment the counter with no further checks,\n            // but i wanted to stay on the safe side here, in case something changes in the\n            // future, and we can easily spot that we forgot to add a limit somewhere.\n            error!(\"recursion limit exceeded, can not perform handle!\");\n            return HandleResult::Failure { err };\n        }\n    };\n    if let Err(err) = oom_handler::register_oom_handler() {\n        error!(\"Could not register OOM handler!\");\n        return HandleResult::Failure { err };\n    }\n    if let Err(_e) = validate_mut_ptr(used_gas as _, std::mem::size_of::\u003cu64\u003e()) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_handle_success_to_handleresult(Err(EnclaveError::FailedFunctionCall));\n    }\n    if let Err(_e) = validate_const_ptr(env, env_len as usize) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_handle_success_to_handleresult(Err(EnclaveError::FailedFunctionCall));\n    }\n    if let Err(_e) = validate_const_ptr(msg, msg_len as usize) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_handle_success_to_handleresult(Err(EnclaveError::FailedFunctionCall));\n    }\n    if let Err(_e) = validate_const_ptr(contract, contract_len as usize) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_handle_success_to_handleresult(Err(EnclaveError::FailedFunctionCall));\n    }\n    if let Err(_e) = validate_const_ptr(sig_info, sig_info_len as usize) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_handle_success_to_handleresult(Err(EnclaveError::FailedFunctionCall));\n    }\n\n    let contract = std::slice::from_raw_parts(contract, contract_len);\n    let env = std::slice::from_raw_parts(env, env_len);\n    let msg = std::slice::from_raw_parts(msg, msg_len);\n    let sig_info = std::slice::from_raw_parts(sig_info, sig_info_len);\n    let result = panic::catch_unwind(|| {\n        let mut local_used_gas = *used_gas;\n        let result = crate::wasm::handle(\n            context,\n            gas_limit,\n            \u0026mut local_used_gas,\n            contract,\n            env,\n            msg,\n            sig_info,\n        );\n        *used_gas = local_used_gas;\n        result_handle_success_to_handleresult(result)\n    });\n\n    if let Err(err) = oom_handler::restore_safety_buffer() {\n        error!(\"Could not restore OOM safety buffer!\");\n        return HandleResult::Failure { err };\n    }\n\n    if let Ok(res) = result {\n        res\n    } else {\n        *used_gas = gas_limit / 2;\n\n        if oom_handler::get_then_clear_oom_happened() {\n            error!(\"Call ecall_handle failed because the enclave ran out of memory!\");\n            HandleResult::Failure {\n                err: EnclaveError::OutOfMemory,\n            }\n        } else {\n            error!(\"Call ecall_handle panicked unexpectedly!\");\n            HandleResult::Failure {\n                err: EnclaveError::Panic,\n            }\n        }\n    }\n}\n\n/// # Safety\n/// Always use protection\n#[no_mangle]\npub unsafe extern \"C\" fn ecall_query(\n    context: Ctx,\n    gas_limit: u64,\n    used_gas: *mut u64,\n    contract: *const u8,\n    contract_len: usize,\n    msg: *const u8,\n    msg_len: usize,\n) -\u003e QueryResult {\n    let _recursion_guard = match recursion_depth::guard() {\n        Ok(rg) =\u003e rg,\n        Err(err) =\u003e {\n            // https://github.com/enigmampc/SecretNetwork/pull/517#discussion_r481924571\n            // I believe that this error condition is currently unreachable.\n            // I think we can safely remove it completely right now, and have\n            // recursion_depth::increment() simply increment the counter with no further checks,\n            // but i wanted to stay on the safe side here, in case something changes in the\n            // future, and we can easily spot that we forgot to add a limit somewhere.\n            error!(\"recursion limit exceeded, can not perform query!\");\n            return QueryResult::Failure { err };\n        }\n    };\n    if let Err(err) = oom_handler::register_oom_handler() {\n        error!(\"Could not register OOM handler!\");\n        return QueryResult::Failure { err };\n    }\n    if let Err(_e) = validate_mut_ptr(used_gas as _, std::mem::size_of::\u003cu64\u003e()) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_query_success_to_queryresult(Err(EnclaveError::FailedFunctionCall));\n    }\n    if let Err(_e) = validate_const_ptr(msg, msg_len as usize) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_query_success_to_queryresult(Err(EnclaveError::FailedFunctionCall));\n    }\n    if let Err(_e) = validate_const_ptr(contract, contract_len as usize) {\n        error!(\"Tried to access data outside enclave memory!\");\n        return result_query_success_to_queryresult(Err(EnclaveError::FailedFunctionCall));\n    }\n\n    let contract = std::slice::from_raw_parts(contract, contract_len);\n    let msg = std::slice::from_raw_parts(msg, msg_len);\n    let result = panic::catch_unwind(|| {\n        let mut local_used_gas = *used_gas;\n        let result = crate::wasm::query(context, gas_limit, \u0026mut local_used_gas, contract, msg);\n        *used_gas = local_used_gas;\n        result_query_success_to_queryresult(result)\n    });\n\n    if let Err(err) = oom_handler::restore_safety_buffer() {\n        error!(\"Could not restore OOM safety buffer!\");\n        return QueryResult::Failure { err };\n    }\n\n    if let Ok(res) = result {\n        res\n    } else {\n        *used_gas = gas_limit / 2;\n\n        if oom_handler::get_then_clear_oom_happened() {\n            error!(\"Call ecall_query failed because the enclave ran out of memory!\");\n            QueryResult::Failure {\n                err: EnclaveError::OutOfMemory,\n            }\n        } else {\n            error!(\"Call ecall_query panicked unexpectedly!\");\n            QueryResult::Failure {\n                err: EnclaveError::Panic,\n            }\n        }\n    }\n}\n\n/// # Safety\n/// Always use protection\n#[no_mangle]\npub unsafe extern \"C\" fn ecall_health_check() -\u003e HealthCheckResult {\n    HealthCheckResult::Success\n}\n\n#[cfg(feature = \"test\")]\npub mod tests {\n    use super::*;\n    use crate::count_failures;\n\n    pub fn run_tests() {\n        println!();\n        let mut failures = 0;\n\n        count_failures!(failures, {\n            test_recover_enclave_buffer_valid();\n            test_recover_enclave_buffer_invalid();\n            test_recover_enclave_buffer_invalid_but_similar();\n            test_recover_enclave_buffer_invalid_null();\n            test_recover_enclave_buffer_in_recursion_valid();\n            test_recover_enclave_buffer_in_recursion_invalid();\n            test_recover_enclave_buffer_multiple_out_of_order_valid();\n            test_recover_enclave_buffer_multiple_out_of_order_invalid();\n        });\n\n        if failures != 0 {\n            println!(\"{}: {} tests failed\", file!(), failures);\n            panic!()\n        }\n    }\n\n    fn test_recover_enclave_buffer_valid() {\n        let message = b\"some example text\";\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0);\n        let enclave_buffer = unsafe { ecall_allocate(message.as_ptr(), message.len()) };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 1);\n        let recovered = unsafe { recover_buffer(enclave_buffer) };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0);\n        assert_eq!(recovered.unwrap().unwrap(), message);\n    }\n\n    fn test_recover_enclave_buffer_invalid() {\n        let enclave_buffer = EnclaveBuffer {\n            ptr: 0x12345678_usize as _,\n        };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0);\n        let recovered = unsafe { recover_buffer(enclave_buffer) };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0);\n        assert_eq!(recovered.unwrap_err(), BufferRecoveryError);\n    }\n\n    fn test_recover_enclave_buffer_invalid_but_similar() {\n        let message = Box::new(Vec::\u003cu8\u003e::from(\u0026b\"some example text\"[..]));\n        let enclave_buffer = EnclaveBuffer {\n            ptr: message.as_ptr() as _,\n        };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0);\n        let recovered = unsafe { recover_buffer(enclave_buffer) };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0);\n        assert_eq!(recovered.unwrap_err(), BufferRecoveryError);\n    }\n\n    fn test_recover_enclave_buffer_invalid_null() {\n        let enclave_buffer = EnclaveBuffer {\n            ptr: std::ptr::null_mut(),\n        };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0);\n        let recovered = unsafe { recover_buffer(enclave_buffer) };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0);\n        assert_eq!(recovered.unwrap(), None);\n    }\n\n    fn test_recover_enclave_buffer_in_recursion_valid() {\n        let recursion_depth = 10;\n        let messages: Vec\u003cString\u003e = (0..recursion_depth)\n            .map(|num| format!(\"message-{}\", num))\n            .collect();\n\n        // simulate building up the stack recursively\n        let enclave_buffers: Vec\u003cEnclaveBuffer\u003e = messages\n            .iter()\n            .enumerate()\n            .map(|(index, message)| {\n                assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), index);\n                unsafe { ecall_allocate(message.as_ptr(), message.len()) }\n            })\n            .collect();\n\n        // simulate clearing the stack recursively\n        for (index, (message, enclave_buffer)) in messages\n            .into_iter()\n            .zip(enclave_buffers.into_iter())\n            .enumerate()\n            .rev()\n        {\n            assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), index + 1);\n            let recovered = unsafe { recover_buffer(enclave_buffer) };\n            assert_eq!(recovered.unwrap().unwrap(), message.as_bytes())\n        }\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0)\n    }\n\n    // This test is very similar to the test above, except it tries to give incorrect\n    // inputs in the deepest part of the recursion\n    fn test_recover_enclave_buffer_in_recursion_invalid() {\n        let recursion_depth = 10;\n        let messages: Vec\u003cString\u003e = (0..recursion_depth)\n            .map(|num| format!(\"message-{}\", num))\n            .collect();\n\n        // simulate building up the stack recursively\n        let enclave_buffers: Vec\u003cEnclaveBuffer\u003e = messages\n            .iter()\n            .enumerate()\n            .map(|(index, message)| {\n                assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), index);\n                unsafe { ecall_allocate(message.as_ptr(), message.len()) }\n            })\n            .collect();\n\n        let message = Box::new(Vec::\u003cu8\u003e::from(\u0026b\"some example text\"[..]));\n        let enclave_buffer = EnclaveBuffer {\n            ptr: message.as_ptr() as _,\n        };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), recursion_depth);\n        let recovered = unsafe { recover_buffer(enclave_buffer) };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), recursion_depth);\n        assert_eq!(recovered.unwrap_err(), BufferRecoveryError);\n\n        // simulate clearing the stack recursively\n        for (index, (message, enclave_buffer)) in messages\n            .into_iter()\n            .zip(enclave_buffers.into_iter())\n            .enumerate()\n            .rev()\n        {\n            assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), index + 1);\n            let recovered = unsafe { recover_buffer(enclave_buffer) };\n            assert_eq!(recovered.unwrap().unwrap(), message.as_bytes())\n        }\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0)\n    }\n\n    // These tests are vry similar to the recursion tests,\n    // except that they don't release the buffers in a FIFO order.\n    // In this case, I just release them in a FILO order, which should be worst-case.\n\n    fn test_recover_enclave_buffer_multiple_out_of_order_valid() {\n        let recursion_depth = 10;\n        let messages: Vec\u003cString\u003e = (0..recursion_depth)\n            .map(|num| format!(\"message-{}\", num))\n            .collect();\n\n        // simulate building up the stack recursively\n        let enclave_buffers: Vec\u003cEnclaveBuffer\u003e = messages\n            .iter()\n            .enumerate()\n            .map(|(index, message)| {\n                assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), index);\n                unsafe { ecall_allocate(message.as_ptr(), message.len()) }\n            })\n            .collect();\n\n        // simulate clearing the stack recursively\n        // `.rev().enumerate().rev()` means that we'll be iterating over the lists in order, with reversed indexes.\n        for (index, (message, enclave_buffer)) in messages\n            .into_iter()\n            .zip(enclave_buffers.into_iter())\n            .rev()\n            .enumerate()\n            .rev()\n        {\n            assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), index + 1);\n            let recovered = unsafe { recover_buffer(enclave_buffer) };\n            assert_eq!(recovered.unwrap().unwrap(), message.as_bytes())\n        }\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0)\n    }\n\n    fn test_recover_enclave_buffer_multiple_out_of_order_invalid() {\n        let recursion_depth = 10;\n        let messages: Vec\u003cString\u003e = (0..recursion_depth)\n            .map(|num| format!(\"message-{}\", num))\n            .collect();\n\n        // simulate building up the stack recursively\n        let enclave_buffers: Vec\u003cEnclaveBuffer\u003e = messages\n            .iter()\n            .enumerate()\n            .map(|(index, message)| {\n                assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), index);\n                unsafe { ecall_allocate(message.as_ptr(), message.len()) }\n            })\n            .collect();\n\n        let message = Box::new(Vec::\u003cu8\u003e::from(\u0026b\"some example text\"[..]));\n        let enclave_buffer = EnclaveBuffer {\n            ptr: message.as_ptr() as _,\n        };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), recursion_depth);\n        let recovered = unsafe { recover_buffer(enclave_buffer) };\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), recursion_depth);\n        assert_eq!(recovered.unwrap_err(), BufferRecoveryError);\n\n        // simulate clearing the stack recursively\n        // `.rev().enumerate().rev()` means that we'll be iterating over the lists in order, with reversed indexes.\n        for (index, (message, enclave_buffer)) in messages\n            .into_iter()\n            .zip(enclave_buffers.into_iter())\n            .rev()\n            .enumerate()\n            .rev()\n        {\n            assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), index + 1);\n            let recovered = unsafe { recover_buffer(enclave_buffer) };\n            assert_eq!(recovered.unwrap().unwrap(), message.as_bytes())\n        }\n        assert_eq!(ECALL_ALLOCATE_STACK.lock().unwrap().len(), 0)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","imports.rs"],"content":"//! This file should be autogenerated based on the headers created from the .edl file.\n\nuse enclave_ffi_types::{Ctx, EnclaveBuffer, OcallReturn, UntrustedVmError, UserSpaceBuffer};\nuse sgx_types::*;\n\nextern \"C\" {\n    pub fn ocall_allocate(\n        retval: *mut UserSpaceBuffer,\n        buffer: *const u8,\n        length: usize,\n    ) -\u003e sgx_status_t;\n\n    pub fn ocall_read_db(\n        retval: *mut OcallReturn,\n        context: Ctx,\n        vm_error: *mut UntrustedVmError,\n        gas_used: *mut u64,\n        value: *mut EnclaveBuffer,\n        key: *const u8,\n        key_len: usize,\n    ) -\u003e sgx_status_t;\n\n    pub fn ocall_query_chain(\n        retval: *mut OcallReturn,\n        context: Ctx,\n        vm_error: *mut UntrustedVmError,\n        gas_used: *mut u64,\n        gas_limit: u64,\n        value: *mut EnclaveBuffer,\n        query: *const u8,\n        query_len: usize,\n    ) -\u003e sgx_status_t;\n\n    pub fn ocall_remove_db(\n        retval: *mut OcallReturn,\n        context: Ctx,\n        vm_error: *mut UntrustedVmError,\n        gas_used: *mut u64,\n        key: *const u8,\n        key_len: usize,\n    ) -\u003e sgx_status_t;\n\n    pub fn ocall_write_db(\n        retval: *mut OcallReturn,\n        context: Ctx,\n        vm_error: *mut UntrustedVmError,\n        gas_used: *mut u64,\n        key: *const u8,\n        key_len: usize,\n        value: *const u8,\n        value_len: usize,\n    ) -\u003e sgx_status_t;\n}\n\nextern \"C\" {\n    pub fn ocall_sgx_init_quote(\n        ret_val: *mut sgx_status_t,\n        ret_ti: *mut sgx_target_info_t,\n        ret_gid: *mut sgx_epid_group_id_t,\n    ) -\u003e sgx_status_t;\n    pub fn ocall_get_ias_socket(ret_val: *mut sgx_status_t, ret_fd: *mut i32) -\u003e sgx_status_t;\n    pub fn ocall_get_quote(\n        ret_val: *mut sgx_status_t,\n        p_sigrl: *const u8,\n        sigrl_len: u32,\n        p_report: *const sgx_report_t,\n        quote_type: sgx_quote_sign_type_t,\n        p_spid: *const sgx_spid_t,\n        p_nonce: *const sgx_quote_nonce_t,\n        p_qe_report: *mut sgx_report_t,\n        p_quote: *mut u8,\n        maxlen: u32,\n        p_quote_len: *mut u32,\n    ) -\u003e sgx_status_t;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","lib.rs"],"content":"#![feature(try_reserve)]\n// similar trick to get the IDE to use sgx_tstd even when it doesn't know we're targeting SGX\n#[cfg(not(target_env = \"sgx\"))]\nextern crate sgx_tstd as std;\n// This annotation is here to trick the IDE into ignoring the extern crate, and instead pull in sgx_types from our\n// Cargo.toml. By importing sgx_types using `extern crate` but without letting it resolve in Cargo.toml when compiling\n// to SGX, we make the compiler pull it in from the target root, which contains the sgx_types listed in Xargo.toml.\n// This in turn silences errors about using the same types from two versions of the same crate.\n// (go ahead, try to remove this block and change the Cargo.toml import to a normal one)\n#[cfg(target_env = \"sgx\")]\nextern crate sgx_types;\n\nuse ctor::*;\nuse log::LevelFilter;\n\nuse crate::logger::*;\n\nmod macros;\n\npub mod exports;\npub mod imports;\npub mod logger;\nmod oom_handler;\nmod recursion_depth;\npub mod registration;\nuse std::env;\n\nmod consts;\nmod cosmwasm;\nmod crypto;\nmod results;\nmod storage;\nmod utils;\nmod wasm;\n\nmod tests;\n\nstatic LOGGER: SimpleLogger = SimpleLogger;\n\n#[cfg(all(feature = \"production\", feature = \"SGX_MODE_HW\"))]\n#[ctor]\nfn init_logger() {\n    log::set_logger(\u0026LOGGER).unwrap(); // It's ok to panic at this stage. This shouldn't happen though\n    set_log_level_or_default(LevelFilter::Error, LevelFilter::Warn);\n}\n\n#[cfg(all(not(feature = \"production\"), not(feature = \"test\")))]\n#[ctor]\nfn init_logger() {\n    log::set_logger(\u0026LOGGER).unwrap(); // It's ok to panic at this stage. This shouldn't happen though\n    set_log_level_or_default(LevelFilter::Trace, LevelFilter::Trace);\n}\n\nfn log_level_from_str(env_log_level: \u0026str) -\u003e Option\u003cLevelFilter\u003e {\n    match env_log_level {\n        \"OFF\" =\u003e Some(LevelFilter::Off),\n        \"ERROR\" =\u003e Some(LevelFilter::Error),\n        \"WARN\" =\u003e Some(LevelFilter::Warn),\n        \"INFO\" =\u003e Some(LevelFilter::Info),\n        \"DEBUG\" =\u003e Some(LevelFilter::Debug),\n        \"TRACE\" =\u003e Some(LevelFilter::Trace),\n        _ =\u003e None,\n    }\n}\n\nfn set_log_level_or_default(default: LevelFilter, max_level: LevelFilter) {\n    if default \u003e max_level {\n        panic!(\n            \"Logging configuration is broken, stopping to prevent secret leaking. default: {:?}, max level: {:?}\",\n            default, max_level\n        );\n    }\n\n    let mut log_level = default;\n\n    if let Some(env_log_level) =\n        log_level_from_str(\u0026env::var(consts::LOG_LEVEL_ENV_VAR).unwrap_or_default())\n    {\n        // We want to make sure log level is not higher than WARN in production to prevent accidental secret leakage\n        if env_log_level \u003c= max_level {\n            log_level = env_log_level;\n        }\n    }\n\n    log::set_max_level(log_level);\n}\n\n#[cfg(feature = \"test\")]\npub mod logging_tests {\n    use crate::{count_failures, set_log_level_or_default};\n    use ctor::*;\n    use lazy_static::lazy_static;\n    use log::*;\n    use log::{Metadata, Record};\n    use std::sync::SgxMutex;\n    use std::{env, panic};\n\n    lazy_static! {\n        static ref LOG_BUF: SgxMutex\u003cVec\u003cString\u003e\u003e = SgxMutex::new(Vec::new());\n    }\n    pub struct TestLogger;\n    impl log::Log for TestLogger {\n        fn enabled(\u0026self, _metadata: \u0026Metadata) -\u003e bool {\n            true\n        }\n        fn log(\u0026self, record: \u0026Record) {\n            LOG_BUF.lock().unwrap().push(format!(\n                \"{}  [{}] {}\",\n                record.level(),\n                record.target(),\n                record.args()\n            ));\n        }\n        fn flush(\u0026self) {}\n    }\n\n    #[ctor]\n    fn init_logger_test() {\n        log::set_logger(\u0026TestLogger).unwrap();\n    }\n\n    pub fn run_tests() {\n        println!();\n        let mut failures = 0;\n\n        count_failures!(failures, {\n            test_log_level();\n            test_log_default_greater_than_max();\n        });\n\n        if failures != 0 {\n            panic!(\"{}: {} tests failed\", file!(), failures);\n        }\n    }\n\n    fn test_log_level() {\n        env::set_var(\"LOG_LEVEL\", \"WARN\");\n        set_log_level_or_default(LevelFilter::Error, LevelFilter::Info);\n        assert_eq!(log::max_level(), LevelFilter::Warn);\n        info!(\"Should not process\");\n        assert!(LOG_BUF.lock().unwrap().is_empty());\n\n        env::set_var(\"LOG_LEVEL\", \"TRACE\");\n        set_log_level_or_default(LevelFilter::Error, LevelFilter::Info);\n        assert_eq!(log::max_level(), LevelFilter::Error);\n        debug!(\"Should not process\");\n        assert!(LOG_BUF.lock().unwrap().is_empty());\n\n        env::set_var(\"LOG_LEVEL\", \"WARN\");\n        set_log_level_or_default(LevelFilter::Warn, LevelFilter::Warn);\n        assert_eq!(log::max_level(), LevelFilter::Warn);\n        trace!(\"Should not process\");\n        assert!(LOG_BUF.lock().unwrap().is_empty());\n\n        warn!(\"This should process\");\n        assert_eq!(LOG_BUF.lock().unwrap().len(), 1);\n    }\n\n    fn test_log_default_greater_than_max() {\n        let result = panic::catch_unwind(|| {\n            set_log_level_or_default(LevelFilter::Trace, LevelFilter::Error);\n        });\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","logger.rs"],"content":"use log::{Metadata, Record};\n\npub struct SimpleLogger;\n\nimpl log::Log for SimpleLogger {\n    fn enabled(\u0026self, _metadata: \u0026Metadata) -\u003e bool {\n        // Not really needed since we set logging level at lib.rs in the init function\n        true\n    }\n\n    fn log(\u0026self, record: \u0026Record) {\n        println!(\n            \"{}  [{}] {}\",\n            record.level(),\n            record.target(),\n            record.args()\n        );\n    }\n\n    fn flush(\u0026self) {}\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","macros.rs"],"content":"/// This macro coerces all `?` marks in its scope to convert to the requested error type, and returns a Result\n/// of that error type.\n///\n/// This macro takes two arguments: an error type (`E`), and and expression or code block.\n/// It then wraps the code block in a closure that returns `Result\u003cT, E\u003e` such that T is the type of the\n/// expression or last expression in the code block.\n///\n/// This is useful when you have a scope in a bigger function in which `?`'s should convert to a type that is different\n/// from the error type of the containing function.\n///\n/// # Example\n///\n/// ```rust\n/// struct Error1;\n/// struct Error2;\n/// struct Error3;\n///\n/// impl From\u003cError1\u003e for Error2 {\n///     fn from (_: Error1) -\u003e Error2 {\n///         $T2\n///     }\n/// }\n///\n/// impl From\u003cError2\u003e for Error3 {\n///     fn from (_: Error2) -\u003e Error3 {\n///         $T2\n///     }\n/// }\n///\n/// fn err1() -\u003e Result\u003c(), Error1\u003e { Err(Error1) }\n/// fn err2() -\u003e Result\u003c(), Error2\u003e { Err(Error2) }\n/// fn err3() -\u003e Result\u003c(), Error3\u003e { Err(Error3) }\n///\n/// fn example() -\u003e Result\u003c(), Error3\u003e {\n///     err3()?; // just works\n///     err2()?; // from!(Error2, Error3);\n///     // uses both conversions\n///     coalesce!(Error2, {\n///         err1()?;\n///         err2()?;\n///         Ok(())\n///     })?;\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\nmacro_rules! coalesce {\n    ($error_type: ty, $body: expr) =\u003e {{\n        #[allow(unused_mut)]\n        let mut wrapper = || -\u003e std::result::Result\u003c_, $error_type\u003e { $body };\n        wrapper()\n    }};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","oom_handler.rs"],"content":"use core::sync::atomic::{AtomicBool, Ordering};\nuse enclave_ffi_types::EnclaveError;\nuse lazy_static::lazy_static;\n\n#[cfg(not(feature = \"production\"))]\nuse std::backtrace::{self, PrintFormat};\n\nuse std::sync::SgxMutex;\n/// SafetyBuffer is meant to occupy space on the heap, so when a memory\n/// allocation fails we will free this buffer to allow safe panic unwinding\n/// This is needed because while unwinding from panic some destructors try\n/// to allocate more memory which causes a double fault. This way we can\n/// make sure the unwind process has enough free memory to work properly.\nstruct SafetyBuffer {\n    chunks: usize,\n    min_chunks: usize,\n    buffer: Vec\u003cVec\u003cu8\u003e\u003e,\n}\n\nimpl SafetyBuffer {\n    /// Allocate `chunks` KiB on the heap\n    pub fn new(chunks: usize, min_chunks: usize) -\u003e Self {\n        SafetyBuffer {\n            chunks,\n            min_chunks,\n            buffer: SafetyBuffer::build_buffer(chunks, min_chunks).unwrap(),\n        }\n    }\n\n    /// Free the buffer to allow panic to safely unwind\n    pub fn clear(\u0026mut self) {\n        let mut temp = Vec::new();\n        std::mem::swap(\u0026mut self.buffer, \u0026mut temp);\n        drop(temp)\n    }\n\n    fn build_buffer(chunks: usize, min_chunks: usize) -\u003e Result\u003cVec\u003cVec\u003cu8\u003e\u003e, EnclaveError\u003e {\n        let mut buffer: Vec\u003cVec\u003cu8\u003e\u003e = Vec::with_capacity(chunks);\n        SafetyBuffer::top_up_buffer(\u0026mut buffer, chunks, min_chunks)?;\n        Ok(buffer)\n    }\n\n    fn top_up_buffer(\n        buffer: \u0026mut Vec\u003cVec\u003cu8\u003e\u003e,\n        chunks: usize,\n        min_chunks: usize,\n    ) -\u003e Result\u003c(), EnclaveError\u003e {\n        for i in buffer.len()..chunks {\n            let mut kb: Vec\u003cu8\u003e = Vec::new();\n            match kb.try_reserve_exact(1024) {\n                Ok(_) =\u003e { /* continue */ }\n                Err(_err) =\u003e {\n                    if i \u003e min_chunks {\n                        break;\n                    } else {\n                        return Err(EnclaveError::MemorySafetyAllocationError);\n                    }\n                }\n            };\n            buffer.push(kb)\n        }\n        Ok(())\n    }\n\n    // Reallocate the buffer, use this after a successful unwind\n    pub fn restore(\u0026mut self) -\u003e Result\u003c(), EnclaveError\u003e {\n        if self.buffer.capacity() \u003c self.chunks {\n            SafetyBuffer::top_up_buffer(\u0026mut self.buffer, self.chunks, self.min_chunks)?;\n        }\n        Ok(())\n    }\n}\n\nlazy_static! {\n    /// SAFETY_BUFFER is a 4 MiB of SafetyBuffer. This is twice the bare minimum to unwind after\n    /// a best-case OOM event. thanks to the recursion limit on queries, together with other memory\n    /// limits, we don't expect to hit OOM, and this mechanism remains in place just in case.\n    /// 2 MiB is the minimum allowed buffer. If we don't succeed to allocate 2 MiB, we throw a panic,\n    /// if we do succeed to allocate 2 MiB but less than 4 MiB than we move on and will try to allocate\n    /// the rest on the next entry to the enclave.\n    static ref SAFETY_BUFFER: SgxMutex\u003cSafetyBuffer\u003e = SgxMutex::new(SafetyBuffer::new(4 * 1024, 2 * 1024));\n}\n\nstatic OOM_HAPPENED: AtomicBool = AtomicBool::new(false);\n\n#[cfg(not(feature = \"production\"))]\nfn enable_backtraces() {\n    let _ = backtrace::enable_backtrace(\"librust_cosmwasm_enclave.signed.so\", PrintFormat::Full);\n}\n\n#[cfg(feature = \"production\")]\nfn enable_backtraces() {}\n\npub fn register_oom_handler() -\u003e Result\u003c(), EnclaveError\u003e {\n    enable_backtraces();\n\n    {\n        SAFETY_BUFFER.lock().unwrap().restore()?;\n    }\n\n    get_then_clear_oom_happened();\n\n    std::alloc::set_alloc_error_hook(|layout| {\n        OOM_HAPPENED.store(true, Ordering::SeqCst);\n\n        {\n            SAFETY_BUFFER.lock().unwrap().clear();\n        }\n\n        panic!(\n            \"SGX: Memory allocation of {} bytes failed. Trying to recover...\\n\",\n            layout.size()\n        );\n    });\n\n    Ok(())\n}\n\npub fn get_then_clear_oom_happened() -\u003e bool {\n    OOM_HAPPENED.swap(false, Ordering::SeqCst)\n}\n\npub fn restore_safety_buffer() -\u003e Result\u003c(), EnclaveError\u003e {\n    SAFETY_BUFFER.lock().unwrap().restore()\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","recursion_depth.rs"],"content":"use std::sync::SgxMutex;\n\nuse lazy_static::lazy_static;\n\nuse enclave_ffi_types::EnclaveError;\n\nconst RECURSION_LIMIT: u8 = 5;\n\nlazy_static! {\n    /// This counter tracks the recursion depth of queries,\n    /// and effectively the amount of loaded instances of WASMI.\n    ///\n    /// It is incremented before each computation begins and is decremented after each computation ends.\n    static ref RECURSION_DEPTH: SgxMutex\u003cu8\u003e = SgxMutex::new(0);\n}\n\nfn increment() -\u003e Result\u003c(), EnclaveError\u003e {\n    let mut depth = RECURSION_DEPTH.lock().unwrap();\n    if *depth == RECURSION_LIMIT {\n        return Err(EnclaveError::ExceededRecursionLimit);\n    }\n    *depth = depth.saturating_add(1);\n    Ok(())\n}\n\nfn decrement() {\n    let mut depth = RECURSION_DEPTH.lock().unwrap();\n    *depth = depth.saturating_sub(1);\n}\n\n/// Returns whether or not this is the last possible level of recursion\npub fn limit_reached() -\u003e bool {\n    *RECURSION_DEPTH.lock().unwrap() == RECURSION_LIMIT\n}\n\npub struct RecursionGuard {\n    _private: (), // prevent direct instantiation outside this module\n}\n\nimpl RecursionGuard {\n    pub fn new() -\u003e Result\u003cSelf, EnclaveError\u003e {\n        increment()?;\n        Ok(Self { _private: () })\n    }\n}\n\nimpl Drop for RecursionGuard {\n    fn drop(\u0026mut self) {\n        decrement();\n    }\n}\n\npub fn guard() -\u003e Result\u003cRecursionGuard, EnclaveError\u003e {\n    RecursionGuard::new()\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","registration","attestation.rs"],"content":"#![cfg_attr(not(feature = \"SGX_MODE_HW\"), allow(unused))]\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse itertools::Itertools;\nuse log::*;\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse sgx_rand::{os, Rng};\nuse sgx_tcrypto::{rsgx_sha256_slice, SgxEccHandle};\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse sgx_tse::{rsgx_create_report, rsgx_verify_report};\n\n#[cfg(not(feature = \"SGX_MODE_HW\"))]\nuse sgx_types::{sgx_create_report, SgxResult};\n\nuse sgx_types::{\n    c_int, sgx_quote_sign_type_t, sgx_report_data_t, sgx_report_t, sgx_spid_t, sgx_status_t,\n    sgx_target_info_t,\n};\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse sgx_types::{sgx_epid_group_id_t, sgx_quote_nonce_t};\n\nuse std::io::Read;\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse std::io::Write;\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse std::net::TcpStream;\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse std::ptr;\nuse std::str;\nuse std::string::String;\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse std::sync::Arc;\nuse std::vec::Vec;\n\nuse crate::crypto::KeyPair;\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse crate::imports::{ocall_get_ias_socket, ocall_get_quote, ocall_sgx_init_quote};\nuse crate::registration::report::EndorsedAttestationReport;\n\nuse super::hex;\nuse crate::consts::{SigningMethod, SIGNING_METHOD};\n\npub const DEV_HOSTNAME: \u0026str = \"api.trustedservices.intel.com\";\n\n#[cfg(feature = \"production\")]\npub const SIGRL_SUFFIX: \u0026str = \"/sgx/attestation/v4/sigrl/\";\n#[cfg(feature = \"production\")]\npub const REPORT_SUFFIX: \u0026str = \"/sgx/attestation/v4/report\";\n\n#[cfg(not(feature = \"production\"))]\npub const SIGRL_SUFFIX: \u0026str = \"/sgx/dev/attestation/v4/sigrl/\";\n#[cfg(not(feature = \"production\"))]\npub const REPORT_SUFFIX: \u0026str = \"/sgx/dev/attestation/v4/report\";\n\n// extra_data size that will store the public key of the attesting node\nconst REPORT_DATA_SIZE: usize = 32;\n\n#[cfg(not(feature = \"SGX_MODE_HW\"))]\npub fn create_attestation_certificate(\n    kp: \u0026KeyPair,\n    sign_type: sgx_quote_sign_type_t,\n    _spid: \u0026[u8],\n    _api_key: \u0026[u8],\n) -\u003e Result\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e), sgx_status_t\u003e {\n    // init sgx ecc\n    let ecc_handle = SgxEccHandle::new();\n    let _result = ecc_handle.open();\n\n    // convert keypair private to sgx ecc private\n    let (prv_k, pub_k) = ecc_handle.create_key_pair().unwrap();\n\n    // this is the ed25519 public key we want to encode\n    let encoded_pubkey = base64::encode(\u0026kp.get_pubkey());\n\n    let (key_der, cert_der) =\n        super::cert::gen_ecc_cert(encoded_pubkey, \u0026prv_k, \u0026pub_k, \u0026ecc_handle)?;\n    let _result = ecc_handle.close();\n\n    Ok((key_der, cert_der))\n}\n\n#[cfg(not(feature = \"SGX_MODE_HW\"))]\npub fn create_report_with_data(\n    target_info: \u0026sgx_target_info_t,\n    out_report: \u0026mut sgx_report_t,\n    extra_data: \u0026[u8],\n) -\u003e sgx_status_t {\n    let mut report_data: sgx_report_data_t = sgx_report_data_t::default();\n    // secret data to be attached with the report.\n    // if extra_data.len() \u003e REPORT_DATA_SIZE {\n    //     return sgx_status_t::SGX_ERROR_INVALID_PARAMETER;\n    // }\n    // report_data.d[..extra_data.len()].copy_from_slice(extra_data);\n    let mut report = sgx_report_t::default();\n    let ret = unsafe {\n        sgx_create_report(\n            target_info as *const sgx_target_info_t,\n            \u0026report_data as *const sgx_report_data_t,\n            \u0026mut report as *mut sgx_report_t,\n        )\n    };\n    let result = match ret {\n        sgx_status_t::SGX_SUCCESS =\u003e Ok(report),\n        _ =\u003e Err(ret),\n    };\n    match result {\n        Ok(r) =\u003e {\n            *out_report = r;\n            sgx_status_t::SGX_SUCCESS\n        }\n        Err(err) =\u003e {\n            // println!(\"[-] Enclave: error creating report\");\n            err\n        }\n    }\n}\n\n// todo: add public/private key handling pub_k: \u0026sgx_ec256_public_t,\n#[cfg(feature = \"SGX_MODE_HW\")]\npub fn create_attestation_certificate(\n    kp: \u0026KeyPair,\n    sign_type: sgx_quote_sign_type_t,\n    spid: \u0026[u8],\n    api_key: \u0026[u8],\n) -\u003e Result\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e), sgx_status_t\u003e {\n    // extract private key from KeyPair\n    let ecc_handle = SgxEccHandle::new();\n    let _result = ecc_handle.open();\n\n    // use ephemeral key\n    let (prv_k, pub_k) = ecc_handle.create_key_pair().unwrap();\n\n    // call create_report using the secp256k1 public key, and __not__ the P256 one\n    let signed_report = match create_attestation_report(\u0026kp.get_pubkey(), sign_type, spid, api_key)\n    {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            error!(\"Error creating attestation report\");\n            return Err(e);\n        }\n    };\n\n    let payload: String = serde_json::to_string(\u0026signed_report).map_err(|_| {\n        error!(\"Error serializing report. May be malformed, or badly encoded\");\n        sgx_status_t::SGX_ERROR_UNEXPECTED\n    })?;\n    let (key_der, cert_der) = super::cert::gen_ecc_cert(payload, \u0026prv_k, \u0026pub_k, \u0026ecc_handle)?;\n    let _result = ecc_handle.close();\n\n    Ok((key_der, cert_der))\n}\n\n#[cfg(feature = \"SGX_MODE_HW\")]\npub fn get_mr_enclave() -\u003e Result\u003c[u8; 32], sgx_status_t\u003e {\n    let mut ti: sgx_target_info_t = sgx_target_info_t::default();\n    let mut eg: sgx_epid_group_id_t = sgx_epid_group_id_t::default();\n    let mut rt: sgx_status_t = sgx_status_t::SGX_ERROR_UNEXPECTED;\n\n    let res = unsafe {\n        ocall_sgx_init_quote(\n            \u0026mut rt as *mut sgx_status_t,\n            \u0026mut ti as *mut sgx_target_info_t,\n            \u0026mut eg as *mut sgx_epid_group_id_t,\n        )\n    };\n\n    if res != sgx_status_t::SGX_SUCCESS {\n        return Err(res);\n    }\n    if rt != sgx_status_t::SGX_SUCCESS {\n        return Err(rt);\n    }\n\n    // placeholder report\n    let report_data: sgx_report_data_t = sgx_report_data_t::default();\n\n    let rep = match rsgx_create_report(\u0026ti, \u0026report_data) {\n        Ok(r) =\u003e {\n            trace!(\"This enclave MR_ENCLAVE is: {:?}\", r.body.mr_enclave.m);\n            r.body.mr_enclave.m\n        }\n        Err(_e) =\u003e {\n            error!(\"Failed to get local MR_ENCLAVE. Corrupted enclave or other unknown error\");\n            return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);\n        }\n    };\n\n    Ok(rep)\n}\n\n//input: pub_k: \u0026sgx_ec256_public_t, todo: make this the pubkey of the node\n#[cfg(feature = \"SGX_MODE_HW\")]\n#[allow(const_err)]\npub fn create_attestation_report(\n    pub_k: \u0026[u8; 32],\n    sign_type: sgx_quote_sign_type_t,\n    spid_file: \u0026[u8],\n    api_key_file: \u0026[u8],\n) -\u003e Result\u003cEndorsedAttestationReport, sgx_status_t\u003e {\n    // Workflow:\n    // (1) ocall to get the target_info structure (ti) and epid group id (eg)\n    // (1.5) get sigrl\n    // (2) call sgx_create_report with ti+data, produce an sgx_report_t\n    // (3) ocall to sgx_get_quote to generate (*mut sgx-quote_t, uint32_t)\n\n    // (1) get ti + eg\n    let mut ti: sgx_target_info_t = sgx_target_info_t::default();\n    let mut eg: sgx_epid_group_id_t = sgx_epid_group_id_t::default();\n    let mut rt: sgx_status_t = sgx_status_t::SGX_ERROR_UNEXPECTED;\n\n    let res = unsafe {\n        ocall_sgx_init_quote(\n            \u0026mut rt as *mut sgx_status_t,\n            \u0026mut ti as *mut sgx_target_info_t,\n            \u0026mut eg as *mut sgx_epid_group_id_t,\n        )\n    };\n\n    trace!(\"EPID group = {:?}\", eg);\n\n    if res != sgx_status_t::SGX_SUCCESS {\n        return Err(res);\n    }\n\n    if rt != sgx_status_t::SGX_SUCCESS {\n        return Err(rt);\n    }\n\n    let eg_num = as_u32_le(eg);\n\n    // (1.5) get sigrl\n    let mut ias_sock: i32 = 0;\n\n    let res =\n        unsafe { ocall_get_ias_socket(\u0026mut rt as *mut sgx_status_t, \u0026mut ias_sock as *mut i32) };\n\n    if res != sgx_status_t::SGX_SUCCESS {\n        return Err(res);\n    }\n\n    if rt != sgx_status_t::SGX_SUCCESS {\n        return Err(rt);\n    }\n\n    trace!(\"Got ias_sock successfully = {}\", ias_sock);\n\n    // Now sigrl_vec is the revocation list, a vec\u003cu8\u003e\n    let sigrl_vec: Vec\u003cu8\u003e = get_sigrl_from_intel(ias_sock, eg_num, api_key_file);\n\n    // (2) Generate the report\n    // Fill ecc256 public key into report_data\n    let mut report_data: sgx_report_data_t = sgx_report_data_t::default();\n\n    report_data.d[..32].copy_from_slice(pub_k);\n\n    /* This is used to match the encoding of the public key here with the ecc key, but honestly\n    the certificate uses curve P256, so that will cause issues anyway -- I'm leaving the code here\n    as a reference in case we want to take another look at this at some point */\n\n    // let mut pub_k_gx = pub_k.gx.clone();\n    // pub_k_gx.reverse();\n    // let mut pub_k_gy = pub_k.gy.clone();\n    // pub_k_gy.reverse();\n    // report_data.d[..32].clone_from_slice(\u0026pub_k_gx);\n    // report_data.d[32..].clone_from_slice(\u0026pub_k_gy);\n\n    let rep = match rsgx_create_report(\u0026ti, \u0026report_data) {\n        Ok(r) =\u003e {\n            match SIGNING_METHOD {\n                SigningMethod::MRENCLAVE =\u003e {\n                    trace!(\n                        \"Report creation =\u003e success. Using MR_SIGNER: {:?}\",\n                        r.body.mr_signer.m\n                    );\n                }\n                SigningMethod::MRSIGNER =\u003e {\n                    trace!(\n                        \"Report creation =\u003e success. Got MR_ENCLAVE {:?}\",\n                        r.body.mr_signer.m\n                    );\n                }\n                SigningMethod::NONE =\u003e {\n                    trace!(\"Report creation =\u003e success. Not using any verification\");\n                }\n            }\n            r\n        }\n        Err(e) =\u003e {\n            error!(\"Report creation =\u003e failed {:?}\", e);\n            return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);\n        }\n    };\n\n    let mut quote_nonce = sgx_quote_nonce_t { rand: [0; 16] };\n    let mut os_rng = os::SgxRng::new().unwrap();\n    os_rng.fill_bytes(\u0026mut quote_nonce.rand);\n    trace!(\"Nonce generated successfully\");\n    let mut qe_report = sgx_report_t::default();\n    const RET_QUOTE_BUF_LEN: u32 = 2048;\n    let mut return_quote_buf: [u8; RET_QUOTE_BUF_LEN as usize] = [0; RET_QUOTE_BUF_LEN as usize];\n    let mut quote_len: u32 = 0;\n\n    // (3) Generate the quote\n    // Args:\n    //       1. sigrl: ptr + len\n    //       2. report: ptr 432bytes\n    //       3. linkable: u32, unlinkable=0, linkable=1\n    //       4. spid: sgx_spid_t ptr 16bytes\n    //       5. sgx_quote_nonce_t ptr 16bytes\n    //       6. p_sig_rl + sigrl size ( same to sigrl)\n    //       7. [out]p_qe_report need further check\n    //       8. [out]p_quote\n    //       9. quote_size\n    let (p_sigrl, sigrl_len) = if sigrl_vec.is_empty() {\n        (ptr::null(), 0)\n    } else {\n        (sigrl_vec.as_ptr(), sigrl_vec.len() as u32)\n    };\n    let p_report = (\u0026rep) as *const sgx_report_t;\n    let quote_type = sign_type;\n\n    let spid: sgx_spid_t = hex::decode_spid(\u0026String::from_utf8_lossy(spid_file));\n\n    let p_spid = \u0026spid as *const sgx_spid_t;\n    let p_nonce = \u0026quote_nonce as *const sgx_quote_nonce_t;\n    let p_qe_report = \u0026mut qe_report as *mut sgx_report_t;\n    let p_quote = return_quote_buf.as_mut_ptr();\n    let maxlen = RET_QUOTE_BUF_LEN;\n    let p_quote_len = \u0026mut quote_len as *mut u32;\n\n    let result = unsafe {\n        ocall_get_quote(\n            \u0026mut rt as *mut sgx_status_t,\n            p_sigrl,\n            sigrl_len,\n            p_report,\n            quote_type,\n            p_spid,\n            p_nonce,\n            p_qe_report,\n            p_quote,\n            maxlen,\n            p_quote_len,\n        )\n    };\n\n    if result != sgx_status_t::SGX_SUCCESS {\n        warn!(\"ocall_get_quote returned {}\", result);\n        return Err(result);\n    }\n\n    if rt != sgx_status_t::SGX_SUCCESS {\n        warn!(\"ocall_get_quote returned {}\", rt);\n        return Err(rt);\n    }\n\n    // Added 09-28-2018\n    // Perform a check on qe_report to verify if the qe_report is valid\n    match rsgx_verify_report(\u0026qe_report) {\n        Ok(()) =\u003e trace!(\"rsgx_verify_report passed!\"),\n        Err(x) =\u003e {\n            warn!(\"rsgx_verify_report failed with {:?}\", x);\n            return Err(x);\n        }\n    }\n\n    // Check if the qe_report is produced on the same platform\n    if ti.mr_enclave.m != qe_report.body.mr_enclave.m\n        || ti.attributes.flags != qe_report.body.attributes.flags\n        || ti.attributes.xfrm != qe_report.body.attributes.xfrm\n    {\n        error!(\"qe_report does not match current target_info!\");\n        return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);\n    }\n\n    trace!(\"QE report check passed\");\n\n    // Debug\n    // for i in 0..quote_len {\n    //     print!(\"{:02X}\", unsafe {*p_quote.offset(i as isize)});\n    // }\n    // println!(\"\");\n\n    // Check qe_report to defend against replay attack\n    // The purpose of p_qe_report is for the ISV enclave to confirm the QUOTE\n    // it received is not modified by the untrusted SW stack, and not a replay.\n    // The implementation in QE is to generate a REPORT targeting the ISV\n    // enclave (target info from p_report) , with the lower 32Bytes in\n    // report.data = SHA256(p_nonce||p_quote). The ISV enclave can verify the\n    // p_qe_report and report.data to confirm the QUOTE has not be modified and\n    // is not a replay. It is optional.\n\n    let mut rhs_vec: Vec\u003cu8\u003e = quote_nonce.rand.to_vec();\n    rhs_vec.extend(\u0026return_quote_buf[..quote_len as usize]);\n    let rhs_hash = rsgx_sha256_slice(\u0026rhs_vec[..]).unwrap();\n    let lhs_hash = \u0026qe_report.body.report_data.d[..REPORT_DATA_SIZE];\n\n    trace!(\"Report rhs hash = {:02X}\", rhs_hash.iter().format(\"\"));\n    trace!(\"Report lhs hash = {:02X}\", lhs_hash.iter().format(\"\"));\n\n    if rhs_hash != lhs_hash {\n        error!(\"Quote is tampered!\");\n        return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);\n    }\n\n    let quote_vec: Vec\u003cu8\u003e = return_quote_buf[..quote_len as usize].to_vec();\n    let res =\n        unsafe { ocall_get_ias_socket(\u0026mut rt as *mut sgx_status_t, \u0026mut ias_sock as *mut i32) };\n\n    if res != sgx_status_t::SGX_SUCCESS {\n        return Err(res);\n    }\n\n    if rt != sgx_status_t::SGX_SUCCESS {\n        return Err(rt);\n    }\n\n    let (attn_report, signature, signing_cert) =\n        get_report_from_intel(ias_sock, quote_vec, api_key_file);\n    Ok(EndorsedAttestationReport {\n        report: attn_report.into_bytes(),\n        signature,\n        signing_cert,\n    })\n}\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nfn parse_response_attn_report(resp: \u0026[u8]) -\u003e (String, Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\n    trace!(\"parse_response_attn_report\");\n    let mut headers = [httparse::EMPTY_HEADER; 16];\n    let mut respp = httparse::Response::new(\u0026mut headers);\n    let result = respp.parse(resp);\n    trace!(\"parse result {:?}\", result);\n\n    let msg: \u0026'static str;\n\n    match respp.code {\n        Some(200) =\u003e msg = \"OK Operation Successful\",\n        Some(401) =\u003e msg = \"Unauthorized Failed to authenticate or authorize request.\",\n        Some(404) =\u003e msg = \"Not Found GID does not refer to a valid EPID group ID.\",\n        Some(500) =\u003e msg = \"Internal error occurred\",\n        Some(503) =\u003e {\n            msg = \"Service is currently not able to process the request (due to\n            a temporary overloading or maintenance). This is a\n            temporary state – the same request can be repeated after\n            some time. \"\n        }\n        _ =\u003e {\n            warn!(\"DBG:{}\", respp.code.unwrap());\n            msg = \"Unknown error occured\"\n        }\n    }\n\n    info!(\"{}\", msg);\n    let mut len_num: u32 = 0;\n\n    let mut sig = String::new();\n    let mut cert = String::new();\n    let mut attn_report = String::new();\n\n    for i in 0..respp.headers.len() {\n        let h = respp.headers[i];\n        //println!(\"{} : {}\", h.name, str::from_utf8(h.value).unwrap());\n        match h.name {\n            \"Content-Length\" =\u003e {\n                let len_str = String::from_utf8(h.value.to_vec()).unwrap();\n                len_num = len_str.parse::\u003cu32\u003e().unwrap();\n                trace!(\"content length = {}\", len_num);\n            }\n            \"X-IASReport-Signature\" =\u003e sig = str::from_utf8(h.value).unwrap().to_string(),\n            \"X-IASReport-Signing-Certificate\" =\u003e {\n                cert = str::from_utf8(h.value).unwrap().to_string()\n            }\n            _ =\u003e (),\n        }\n    }\n\n    // Remove %0A from cert, and only obtain the signing cert\n    cert = cert.replace(\"%0A\", \"\");\n    cert = hex::percent_decode(cert);\n\n    let v: Vec\u003c\u0026str\u003e = cert.split(\"-----\").collect();\n    let sig_cert = v[2].to_string();\n\n    if len_num != 0 {\n        let header_len = result.unwrap().unwrap();\n        let resp_body = \u0026resp[header_len..];\n        attn_report = str::from_utf8(resp_body).unwrap().to_string();\n        info!(\"Attestation report: {}\", attn_report);\n    }\n\n    let sig_bytes = base64::decode(\u0026sig).unwrap();\n    let sig_cert_bytes = base64::decode(\u0026sig_cert).unwrap();\n    // len_num == 0\n    (attn_report, sig_bytes, sig_cert_bytes)\n}\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nfn parse_response_sigrl(resp: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n    trace!(\"parse_response_sigrl\");\n    let mut headers = [httparse::EMPTY_HEADER; 16];\n    let mut respp = httparse::Response::new(\u0026mut headers);\n    let result = respp.parse(resp);\n    trace!(\"parse result {:?}\", result);\n    trace!(\"parse response{:?}\", respp);\n\n    let msg: \u0026'static str;\n\n    match respp.code {\n        Some(200) =\u003e msg = \"OK Operation Successful\",\n        Some(401) =\u003e msg = \"Unauthorized Failed to authenticate or authorize request.\",\n        Some(404) =\u003e msg = \"Not Found GID does not refer to a valid EPID group ID.\",\n        Some(500) =\u003e msg = \"Internal error occurred\",\n        Some(503) =\u003e {\n            msg = \"Service is currently not able to process the request (due to\n            a temporary overloading or maintenance). This is a\n            temporary state – the same request can be repeated after\n            some time. \"\n        }\n        _ =\u003e msg = \"Unknown error occured\",\n    }\n\n    info!(\"{}\", msg);\n    let mut len_num: u32 = 0;\n\n    for i in 0..respp.headers.len() {\n        let h = respp.headers[i];\n        if h.name == \"content-length\" {\n            let len_str = String::from_utf8(h.value.to_vec()).unwrap();\n            len_num = len_str.parse::\u003cu32\u003e().unwrap();\n            trace!(\"content length = {}\", len_num);\n        }\n    }\n\n    if len_num != 0 {\n        let header_len = result.unwrap().unwrap();\n        let resp_body = \u0026resp[header_len..];\n        trace!(\"Base64-encoded SigRL: {:?}\", resp_body);\n\n        return base64::decode(str::from_utf8(resp_body).unwrap()).unwrap();\n    }\n\n    // len_num == 0\n    Vec::new()\n}\n\n#[cfg(feature = \"SGX_MODE_HW\")]\npub fn make_ias_client_config() -\u003e rustls::ClientConfig {\n    let mut config = rustls::ClientConfig::new();\n\n    config\n        .root_store\n        .add_server_trust_anchors(\u0026webpki_roots::TLS_SERVER_ROOTS);\n\n    config\n}\n\n#[cfg(feature = \"SGX_MODE_HW\")]\npub fn get_sigrl_from_intel(fd: c_int, gid: u32, api_key_file: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n    trace!(\"get_sigrl_from_intel fd = {:?}\", fd);\n    let config = make_ias_client_config();\n    let ias_key = String::from_utf8_lossy(api_key_file).trim_end().to_owned();\n\n    let req = format!(\"GET {}{:08x} HTTP/1.1\\r\\nHOST: {}\\r\\nOcp-Apim-Subscription-Key: {}\\r\\nConnection: Close\\r\\n\\r\\n\",\n                      SIGRL_SUFFIX,\n                      gid,\n                      DEV_HOSTNAME,\n                      ias_key);\n\n    trace!(\"get_sigrl_from_intel: {}\", req);\n\n    let dns_name = webpki::DNSNameRef::try_from_ascii_str(DEV_HOSTNAME).unwrap();\n    let mut sess = rustls::ClientSession::new(\u0026Arc::new(config), dns_name);\n    let mut sock = TcpStream::new(fd).unwrap();\n    let mut tls = rustls::Stream::new(\u0026mut sess, \u0026mut sock);\n\n    let _result = tls.write(req.as_bytes());\n    let mut plaintext = Vec::new();\n\n    info!(\"write complete\");\n\n    match tls.read_to_end(\u0026mut plaintext) {\n        Ok(_) =\u003e (),\n        Err(e) =\u003e {\n            warn!(\"get_sigrl_from_intel tls.read_to_end: {:?}\", e);\n            panic!(\"Communication error with IAS\");\n        }\n    }\n    info!(\"read_to_end complete\");\n    let resp_string = String::from_utf8(plaintext.clone()).unwrap();\n\n    trace!(\"{}\", resp_string);\n\n    // resp_string\n\n    parse_response_sigrl(\u0026plaintext)\n}\n\n// TODO: support pse\n#[cfg(feature = \"SGX_MODE_HW\")]\npub fn get_report_from_intel(\n    fd: c_int,\n    quote: Vec\u003cu8\u003e,\n    api_key_file: \u0026[u8],\n) -\u003e (String, Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\n    trace!(\"get_report_from_intel fd = {:?}\", fd);\n    let config = make_ias_client_config();\n    let encoded_quote = base64::encode(\u0026quote[..]);\n    let encoded_json = format!(\"{{\\\"isvEnclaveQuote\\\":\\\"{}\\\"}}\\r\\n\", encoded_quote);\n    let ias_key = String::from_utf8_lossy(api_key_file).trim_end().to_owned();\n\n    let req = format!(\"POST {} HTTP/1.1\\r\\nHOST: {}\\r\\nOcp-Apim-Subscription-Key:{}\\r\\nContent-Length:{}\\r\\nContent-Type: application/json\\r\\nConnection: close\\r\\n\\r\\n{}\",\n                      REPORT_SUFFIX,\n                      DEV_HOSTNAME,\n                      ias_key,\n                      encoded_json.len(),\n                      encoded_json);\n\n    trace!(\"{}\", req);\n    let dns_name = webpki::DNSNameRef::try_from_ascii_str(DEV_HOSTNAME).unwrap();\n    let mut sess = rustls::ClientSession::new(\u0026Arc::new(config), dns_name);\n    let mut sock = TcpStream::new(fd).unwrap();\n    let mut tls = rustls::Stream::new(\u0026mut sess, \u0026mut sock);\n\n    let _result = tls.write(req.as_bytes());\n    let mut plaintext = Vec::new();\n\n    info!(\"write complete\");\n\n    tls.read_to_end(\u0026mut plaintext).unwrap();\n    info!(\"read_to_end complete\");\n    let resp_string = String::from_utf8(plaintext.clone()).unwrap();\n\n    trace!(\"resp_string = {}\", resp_string);\n\n    let (attn_report, sig, cert) = parse_response_attn_report(\u0026plaintext);\n\n    (attn_report, sig, cert)\n}\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nfn as_u32_le(array: [u8; 4]) -\u003e u32 {\n    (array[0] as u32)\n        + ((array[1] as u32) \u003c\u003c 8)\n        + ((array[2] as u32) \u003c\u003c 16)\n        + ((array[3] as u32) \u003c\u003c 24)\n}\n\n// commented out because it only contains one test\n// #[cfg(feature = \"test\")]\n// pub mod tests {\n//     use crate::crypto::KeyPair;\n//     use crate::registration::cert::verify_ra_cert;\n//\n//     use super::create_attestation_certificate;\n//     use super::sgx_quote_sign_type_t;\n//\n//     // todo: replace public key with real value\n//     pub fn test_create_attestation_certificate() {\n//         let kp = KeyPair::new_from_slice(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\").unwrap();\n//\n//         let cert =\n//             create_attestation_certificate(\u0026kp, sgx_quote_sign_type_t::SGX_UNLINKABLE_SIGNATURE)\n//                 .unwrap();\n//\n//         let result = verify_ra_cert(cert[1]).unwrap();\n//\n//         assert_eq!(result, kp.get_pubkey())\n//     }\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","registration","cert.rs"],"content":"#![cfg_attr(not(feature = \"SGX_MODE_HW\"), allow(unused))]\n\nuse bit_vec::BitVec;\nuse chrono::Utc as TzUtc;\nuse chrono::{Duration, TimeZone};\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse log::*;\nuse num_bigint::BigUint;\nuse sgx_tcrypto::SgxEccHandle;\nuse sgx_types::{\n    sgx_ec256_private_t, sgx_ec256_public_t, sgx_platform_info_t, sgx_status_t,\n    sgx_update_info_bit_t, SgxResult,\n};\nuse std::io::BufReader;\nuse std::str;\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse std::untrusted::time::SystemTimeEx;\nuse yasna::models::ObjectIdentifier;\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse super::attestation::get_mr_enclave;\n\nuse crate::consts::CERTEXPIRYDAYS;\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse crate::consts::{SigningMethod, MRSIGNER, SIGNING_METHOD};\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse super::report::{AttestationReport, SgxQuoteStatus};\nuse crate::registration::report::AdvisoryIDs;\nuse enclave_ffi_types::NodeAuthResult;\n\nextern \"C\" {\n    pub fn ocall_get_update_info(\n        ret_val: *mut sgx_status_t,\n        platformBlob: *const sgx_platform_info_t,\n        enclaveTrusted: i32,\n        update_info: *mut sgx_update_info_bit_t,\n    ) -\u003e sgx_status_t;\n}\n\npub const IAS_REPORT_CA: \u0026[u8] = include_bytes!(\"../../Intel_SGX_Attestation_RootCA.pem\");\n\nconst ISSUER: \u0026str = \"SecretTEE\";\nconst SUBJECT: \u0026str = \"Secret Network Node Certificate\";\n\npub enum Error {\n    GenericError,\n}\n\npub fn gen_ecc_cert(\n    payload: String,\n    prv_k: \u0026sgx_ec256_private_t,\n    pub_k: \u0026sgx_ec256_public_t,\n    ecc_handle: \u0026SgxEccHandle,\n) -\u003e SgxResult\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e)\u003e {\n    // Generate public key bytes since both DER will use it\n    let mut pub_key_bytes: Vec\u003cu8\u003e = vec![4];\n    let mut pk_gx = pub_k.gx;\n    pk_gx.reverse();\n    let mut pk_gy = pub_k.gy;\n    pk_gy.reverse();\n    pub_key_bytes.extend_from_slice(\u0026pk_gx);\n    pub_key_bytes.extend_from_slice(\u0026pk_gy);\n\n    // Generate Certificate DER\n    let cert_der = yasna::construct_der(|writer| {\n        writer.write_sequence(|writer| {\n            writer.next().write_sequence(|writer| {\n                // Certificate Version\n                writer\n                    .next()\n                    .write_tagged(yasna::Tag::context(0), |writer| {\n                        writer.write_i8(2);\n                    });\n                // Certificate Serial Number (unused but required)\n                writer.next().write_u8(1);\n                // Signature Algorithm: ecdsa-with-SHA256\n                writer.next().write_sequence(|writer| {\n                    writer\n                        .next()\n                        .write_oid(\u0026ObjectIdentifier::from_slice(\u0026[1, 2, 840, 10045, 4, 3, 2]));\n                });\n                // Issuer: CN=MesaTEE (unused but required)\n                writer.next().write_sequence(|writer| {\n                    writer.next().write_set(|writer| {\n                        writer.next().write_sequence(|writer| {\n                            writer\n                                .next()\n                                .write_oid(\u0026ObjectIdentifier::from_slice(\u0026[2, 5, 4, 3]));\n                            writer.next().write_utf8_string(\u0026ISSUER);\n                        });\n                    });\n                });\n                // Validity: Issuing/Expiring Time (unused but required)\n                let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n                let issue_ts = TzUtc.timestamp(now.as_secs() as i64, 0);\n                let expire = now + Duration::days(CERTEXPIRYDAYS).to_std().unwrap();\n                let expire_ts = TzUtc.timestamp(expire.as_secs() as i64, 0);\n                writer.next().write_sequence(|writer| {\n                    writer\n                        .next()\n                        .write_utctime(\u0026yasna::models::UTCTime::from_datetime(\u0026issue_ts));\n                    writer\n                        .next()\n                        .write_utctime(\u0026yasna::models::UTCTime::from_datetime(\u0026expire_ts));\n                });\n                // Subject: CN=MesaTEE (unused but required)\n                writer.next().write_sequence(|writer| {\n                    writer.next().write_set(|writer| {\n                        writer.next().write_sequence(|writer| {\n                            writer\n                                .next()\n                                .write_oid(\u0026ObjectIdentifier::from_slice(\u0026[2, 5, 4, 3]));\n                            writer.next().write_utf8_string(\u0026SUBJECT);\n                        });\n                    });\n                });\n                writer.next().write_sequence(|writer| {\n                    // Public Key Algorithm\n                    writer.next().write_sequence(|writer| {\n                        // id-ecPublicKey\n                        writer\n                            .next()\n                            .write_oid(\u0026ObjectIdentifier::from_slice(\u0026[1, 2, 840, 10045, 2, 1]));\n                        // prime256v1\n                        writer\n                            .next()\n                            .write_oid(\u0026ObjectIdentifier::from_slice(\u0026[1, 2, 840, 10045, 3, 1, 7]));\n                    });\n                    // Public Key\n                    writer\n                        .next()\n                        .write_bitvec(\u0026BitVec::from_bytes(\u0026pub_key_bytes));\n                });\n                // Certificate V3 Extension\n                writer\n                    .next()\n                    .write_tagged(yasna::Tag::context(3), |writer| {\n                        writer.write_sequence(|writer| {\n                            writer.next().write_sequence(|writer| {\n                                writer.next().write_oid(\u0026ObjectIdentifier::from_slice(\u0026[\n                                    2, 16, 840, 1, 113_730, 1, 13,\n                                ]));\n                                writer.next().write_bytes(\u0026payload.into_bytes());\n                            });\n                        });\n                    });\n            });\n            // Signature Algorithm: ecdsa-with-SHA256\n            writer.next().write_sequence(|writer| {\n                writer\n                    .next()\n                    .write_oid(\u0026ObjectIdentifier::from_slice(\u0026[1, 2, 840, 10045, 4, 3, 2]));\n            });\n            // Signature\n            let sig = {\n                let tbs = \u0026writer.buf[4..];\n                ecc_handle.ecdsa_sign_slice(tbs, \u0026prv_k).unwrap()\n            };\n            let sig_der = yasna::construct_der(|writer| {\n                writer.write_sequence(|writer| {\n                    let mut sig_x = sig.x;\n                    sig_x.reverse();\n                    let mut sig_y = sig.y;\n                    sig_y.reverse();\n                    writer.next().write_biguint(\u0026BigUint::from_slice(\u0026sig_x));\n                    writer.next().write_biguint(\u0026BigUint::from_slice(\u0026sig_y));\n                });\n            });\n            writer.next().write_bitvec(\u0026BitVec::from_bytes(\u0026sig_der));\n        });\n    });\n\n    // Generate Private Key DER\n    let key_der = yasna::construct_der(|writer| {\n        writer.write_sequence(|writer| {\n            writer.next().write_u8(0);\n            writer.next().write_sequence(|writer| {\n                writer\n                    .next()\n                    .write_oid(\u0026ObjectIdentifier::from_slice(\u0026[1, 2, 840, 10045, 2, 1]));\n                writer\n                    .next()\n                    .write_oid(\u0026ObjectIdentifier::from_slice(\u0026[1, 2, 840, 10045, 3, 1, 7]));\n            });\n            let inner_key_der = yasna::construct_der(|writer| {\n                writer.write_sequence(|writer| {\n                    writer.next().write_u8(1);\n                    let mut prv_k_r = prv_k.r;\n                    prv_k_r.reverse();\n                    writer.next().write_bytes(\u0026prv_k_r);\n                    writer\n                        .next()\n                        .write_tagged(yasna::Tag::context(1), |writer| {\n                            writer.write_bitvec(\u0026BitVec::from_bytes(\u0026pub_key_bytes));\n                        });\n                });\n            });\n            writer.next().write_bytes(\u0026inner_key_der);\n        });\n    });\n\n    Ok((key_der, cert_der))\n}\n\nfn extract_asn1_value(cert: \u0026[u8], oid: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    let mut offset = match cert.windows(oid.len()).position(|window| window == oid) {\n        Some(size) =\u003e size,\n        None =\u003e {\n            return Err(Error::GenericError);\n        }\n    };\n\n    offset += 12; // 11 + TAG (0x04)\n\n    if offset + 2 \u003e= cert.len() {\n        return Err(Error::GenericError);\n    }\n\n    // Obtain Netscape Comment length\n    let mut len = cert[offset] as usize;\n    if len \u003e 0x80 {\n        len = (cert[offset + 1] as usize) * 0x100 + (cert[offset + 2] as usize);\n        offset += 2;\n    }\n\n    // Obtain Netscape Comment\n    offset += 1;\n\n    if offset + len \u003e= cert.len() {\n        return Err(Error::GenericError);\n    }\n\n    let payload = cert[offset..offset + len].to_vec();\n\n    Ok(payload)\n}\n\npub fn get_netscape_comment(cert_der: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    // Search for Netscape Comment OID\n    let ns_cmt_oid = \u0026[\n        0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x42, 0x01, 0x0D,\n    ];\n    extract_asn1_value(cert_der, ns_cmt_oid)\n}\n\n#[allow(dead_code)]\npub fn get_cert_pubkey(cert_der: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    // Search for Public Key prime256v1 OID\n    let prime256v1_oid = \u0026[0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07];\n    extract_asn1_value(cert_der, prime256v1_oid)\n}\n\npub fn get_ias_auth_config() -\u003e (Vec\u003cu8\u003e, rustls::RootCertStore) {\n    // Verify if the signing cert is issued by Intel CA\n    let mut ias_ca_stripped = IAS_REPORT_CA.to_vec();\n    ias_ca_stripped.retain(|\u0026x| x != 0x0d \u0026\u0026 x != 0x0a);\n    let head_len = \"-----BEGIN CERTIFICATE-----\".len();\n    let tail_len = \"-----END CERTIFICATE-----\".len();\n    let full_len = ias_ca_stripped.len();\n    let ias_ca_core: \u0026[u8] = \u0026ias_ca_stripped[head_len..full_len - tail_len];\n    let ias_cert_dec = base64::decode_config(ias_ca_core, base64::STANDARD).unwrap();\n\n    let mut ca_reader = BufReader::new(\u0026IAS_REPORT_CA[..]);\n\n    let mut root_store = rustls::RootCertStore::empty();\n    root_store\n        .add_pem_file(\u0026mut ca_reader)\n        .expect(\"Failed to add CA\");\n\n    (ias_cert_dec, root_store)\n}\n\n#[cfg(not(feature = \"SGX_MODE_HW\"))]\npub fn verify_ra_cert(cert_der: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, NodeAuthResult\u003e {\n    let payload = get_netscape_comment(cert_der).map_err(|_err| NodeAuthResult::InvalidCert)?;\n\n    let pk = base64::decode(\u0026payload).map_err(|_err| NodeAuthResult::InvalidCert)?;\n\n    Ok(pk)\n}\n\n/// # Verifies remote attestation cert\n///\n/// Logic:\n/// 1. Extract public key\n/// 2. Extract netscape comment - where the attestation report is located\n/// 3. Parse the report itself (verify it is signed by intel)\n/// 4. Extract public key from report body\n/// 5. Verify enclave signature (mr enclave/signer)\n///\n#[cfg(feature = \"SGX_MODE_HW\")]\npub fn verify_ra_cert(cert_der: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, NodeAuthResult\u003e {\n    // Before we reach here, Webpki already verifed the cert is properly signed\n\n    let report = AttestationReport::from_cert(cert_der).map_err(|_| NodeAuthResult::InvalidCert)?;\n\n    // 2. Verify quote status (mandatory field)\n\n    verify_quote_status(\u0026report.sgx_quote_status, \u0026report.advisroy_ids)?;\n\n    // verify certificate\n    match SIGNING_METHOD {\n        SigningMethod::MRENCLAVE =\u003e {\n            let this_mr_enclave = match get_mr_enclave() {\n                Ok(r) =\u003e r,\n                Err(_) =\u003e {\n                    error!(\"This should never happen. If you see this, your node isn't working anymore\");\n                    return Err(NodeAuthResult::Panic);\n                }\n            };\n\n            if report.sgx_quote_body.isv_enclave_report.mr_enclave != this_mr_enclave {\n                error!(\"Got a different mr_enclave than expected. Invalid certificate\");\n                warn!(\n                    \"received: {:?} \\n expected: {:?}\",\n                    report.sgx_quote_body.isv_enclave_report.mr_enclave, this_mr_enclave\n                );\n                return Err(NodeAuthResult::MrEnclaveMismatch);\n            }\n        }\n        SigningMethod::MRSIGNER =\u003e {\n            if report.sgx_quote_body.isv_enclave_report.mr_signer != MRSIGNER {\n                error!(\"Got a different mrsigner than expected. Invalid certificate\");\n                warn!(\n                    \"received: {:?} \\n expected: {:?}\",\n                    report.sgx_quote_body.isv_enclave_report.mr_signer, MRSIGNER\n                );\n                return Err(NodeAuthResult::MrSignerMismatch);\n            }\n        }\n        SigningMethod::NONE =\u003e {}\n    }\n\n    let report_public_key = report.sgx_quote_body.isv_enclave_report.report_data[0..32].to_vec();\n    Ok(report_public_key)\n}\n\n#[cfg(all(feature = \"SGX_MODE_HW\", feature = \"production\"))]\npub fn verify_quote_status(\n    quote_status: \u0026SgxQuoteStatus,\n    advisories: \u0026AdvisoryIDs,\n) -\u003e Result\u003c(), NodeAuthResult\u003e {\n    match quote_status {\n        SgxQuoteStatus::OK =\u003e Ok(()),\n        SgxQuoteStatus::SwHardeningNeeded =\u003e Ok(()),\n        SgxQuoteStatus::ConfigurationAndSwHardeningNeeded =\u003e {\n            let vulnerable = advisories.vulnerable();\n            if vulnerable.is_empty() {\n                Ok(())\n            } else {\n                error!(\"Platform is updated but requires further BIOS configuration\");\n                error!(\n                    \"The following vulnerabilities must be mitigated: {:?}\",\n                    vulnerable\n                );\n                Err(NodeAuthResult::from(quote_status))\n            }\n        }\n        _ =\u003e {\n            error!(\n                \"Invalid attestation quote status - cannot verify remote node: {:?}\",\n                quote_status\n            );\n            Err(NodeAuthResult::from(quote_status))\n        }\n    }\n}\n\n#[cfg(all(feature = \"SGX_MODE_HW\", not(feature = \"production\")))]\npub fn verify_quote_status(\n    quote_status: \u0026SgxQuoteStatus,\n    advisories: \u0026AdvisoryIDs,\n) -\u003e Result\u003c(), NodeAuthResult\u003e {\n    match quote_status {\n        SgxQuoteStatus::OK =\u003e Ok(()),\n        SgxQuoteStatus::SwHardeningNeeded =\u003e Ok(()),\n        SgxQuoteStatus::GroupOutOfDate =\u003e {\n            warn!(\"TCB level of SGX platform service is outdated. You should check for firmware updates\");\n            warn!(\n                \"The following vulnerabilities must be mitigated: {:?}\",\n                advisories.vulnerable()\n            );\n            Ok(())\n        }\n        SgxQuoteStatus::ConfigurationAndSwHardeningNeeded =\u003e {\n            let vulnerable = advisories.vulnerable();\n            if vulnerable.is_empty() {\n                Ok(())\n            } else {\n                error!(\"Platform is updated but requires further BIOS configuration\");\n                error!(\n                    \"The following vulnerabilities must be mitigated: {:?}\",\n                    vulnerable\n                );\n                Err(NodeAuthResult::from(quote_status))\n            }\n        }\n        _ =\u003e {\n            error!(\n                \"Invalid attestation quote status - cannot verify remote node: {:?}\",\n                quote_status\n            );\n            Err(NodeAuthResult::from(quote_status))\n        }\n    }\n}\n\n#[cfg(feature = \"test\")]\npub mod tests {\n    use crate::crypto::KeyPair;\n\n    use super::verify_ra_cert;\n    use crate::registration::report::AttestationReport;\n    use enclave_ffi_types::NodeAuthResult;\n    use std::io::Read;\n    use std::untrusted::fs::File;\n\n    fn tls_ra_cert_der_out_of_date() -\u003e Vec\u003cu8\u003e {\n        let mut cert = vec![];\n        let mut f = File::open(\n            \"../wasmi-runtime/src/registration/fixtures/attestation_cert_out_of_date.der\",\n        )\n        .unwrap();\n        f.read_to_end(\u0026mut cert).unwrap();\n\n        cert\n    }\n\n    fn tls_ra_cert_der_sw_config_needed() -\u003e Vec\u003cu8\u003e {\n        let mut cert = vec![];\n        let mut f = File::open(\n            \"../wasmi-runtime/src/registration/fixtures/attestation_cert_sw_config_needed.der\",\n        )\n        .unwrap();\n        f.read_to_end(\u0026mut cert).unwrap();\n\n        cert\n    }\n\n    #[cfg(feature = \"SGX_MODE_HW\")]\n    fn tls_ra_cert_der_valid() -\u003e Vec\u003cu8\u003e {\n        let mut cert = vec![];\n        let mut f = File::open(\"../wasmi-runtime/src/registration/fixtures/attestation_cert_hw_v2\")\n            .unwrap();\n        f.read_to_end(\u0026mut cert).unwrap();\n\n        cert\n    }\n\n    #[cfg(not(feature = \"SGX_MODE_HW\"))]\n    fn tls_ra_cert_der_valid() -\u003e Vec\u003cu8\u003e {\n        let mut cert = vec![];\n        let mut f =\n            File::open(\"../wasmi-runtime/src/registration/fixtures/attestation_cert_sw\").unwrap();\n        f.read_to_end(\u0026mut cert).unwrap();\n\n        cert\n    }\n\n    #[cfg(not(feature = \"SGX_MODE_HW\"))]\n    pub fn test_certificate_invalid_configuration_needed() {}\n\n    #[cfg(feature = \"SGX_MODE_HW\")]\n    pub fn test_certificate_invalid_configuration_needed() {\n        let tls_ra_cert = tls_ra_cert_der_sw_config_needed();\n        let report = AttestationReport::from_cert(\u0026tls_ra_cert);\n        assert!(report.is_ok());\n\n        let result =\n            verify_ra_cert(\u0026tls_ra_cert).expect_err(\"Certificate should not pass validation\");\n\n        assert_eq!(result, NodeAuthResult::SwHardeningAndConfigurationNeeded)\n    }\n\n    #[cfg(not(feature = \"SGX_MODE_HW\"))]\n    pub fn test_certificate_invalid_group_out_of_date() {}\n\n    #[cfg(feature = \"SGX_MODE_HW\")]\n    pub fn test_certificate_invalid_group_out_of_date() {\n        let tls_ra_cert = tls_ra_cert_der_out_of_date();\n        let report = AttestationReport::from_cert(\u0026tls_ra_cert);\n        assert!(report.is_ok());\n\n        let result =\n            verify_ra_cert(\u0026tls_ra_cert).expect_err(\"Certificate should not pass validation\");\n\n        assert_eq!(result, NodeAuthResult::GroupOutOfDate)\n    }\n\n    pub fn test_certificate_valid() {\n        let tls_ra_cert = tls_ra_cert_der_valid();\n        let result = verify_ra_cert(\u0026tls_ra_cert).unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","registration","hex.rs"],"content":"#![cfg_attr(not(feature = \"SGX_MODE_HW\"), allow(unused))]\n\nuse log::*;\nuse sgx_types::sgx_spid_t;\nuse std::char;\n\nfn decode_hex_digit(digit: char) -\u003e u8 {\n    match digit {\n        '0'..='9' =\u003e digit as u8 - b'0',\n        'a'..='f' =\u003e digit as u8 - b'a' + 10,\n        'A'..='F' =\u003e digit as u8 - b'A' + 10,\n        _ =\u003e panic!(),\n    }\n}\n\npub fn decode_spid(hex: \u0026str) -\u003e sgx_spid_t {\n    let mut spid = sgx_spid_t::default();\n    let hex = hex.trim();\n\n    if hex.len() \u003c 16 * 2 {\n        warn!(\"Input spid file len ({}) is incorrect!\", hex.len());\n        return spid;\n    }\n\n    let decoded_vec = decode_hex(hex);\n\n    spid.id.copy_from_slice(\u0026decoded_vec[..16]);\n\n    spid\n}\n\npub fn decode_hex(hex: \u0026str) -\u003e Vec\u003cu8\u003e {\n    let mut r: Vec\u003cu8\u003e = Vec::new();\n    let mut chars = hex.chars().enumerate();\n    loop {\n        let (pos, first) = match chars.next() {\n            None =\u003e break,\n            Some(elt) =\u003e elt,\n        };\n        if first == ' ' {\n            continue;\n        }\n        let (_, second) = match chars.next() {\n            None =\u003e panic!(\"pos = {}d\", pos),\n            Some(elt) =\u003e elt,\n        };\n        r.push((decode_hex_digit(first) \u003c\u003c 4) | decode_hex_digit(second));\n    }\n    r\n}\n\n#[allow(unused)]\nfn encode_hex_digit(digit: u8) -\u003e char {\n    match char::from_digit(digit as u32, 16) {\n        Some(c) =\u003e c,\n        _ =\u003e panic!(),\n    }\n}\n\n#[allow(unused)]\nfn encode_hex_byte(byte: u8) -\u003e [char; 2] {\n    [encode_hex_digit(byte \u003e\u003e 4), encode_hex_digit(byte \u0026 0x0Fu8)]\n}\n\n#[allow(unused)]\npub fn encode_hex(bytes: \u0026[u8]) -\u003e String {\n    let strs: Vec\u003cString\u003e = bytes\n        .iter()\n        .map(|byte| encode_hex_byte(*byte).iter().copied().collect())\n        .collect();\n    strs.join(\" \")\n}\n\n// taken from https://github.com/apache/incubator-teaclave-sgx-sdk/blob/master/samplecode/mutual-ra/enclave/src/cert.rs\n// isn't actually hex, but I'm sticking it here anyway\npub fn percent_decode(orig: String) -\u003e String {\n    let v: Vec\u003c\u0026str\u003e = orig.split('%').collect();\n    let mut ret = String::new();\n    ret.push_str(v[0]);\n    if v.len() \u003e 1 {\n        for s in v[1..].iter() {\n            ret.push(u8::from_str_radix(\u0026s[0..2], 16).unwrap() as char);\n            ret.push_str(\u0026s[2..]);\n        }\n    }\n    ret\n}\n\n#[cfg(test)]\nmod test {\n\n    use super::decode_hex;\n    use super::encode_hex;\n\n    #[test]\n    fn test_decode_hex() {\n        assert_eq!(decode_hex(\"\"), [].to_vec());\n        assert_eq!(decode_hex(\"00\"), [0x00u8].to_vec());\n        assert_eq!(decode_hex(\"ff\"), [0xffu8].to_vec());\n        assert_eq!(decode_hex(\"AB\"), [0xabu8].to_vec());\n        assert_eq!(decode_hex(\"fa 19\"), [0xfau8, 0x19].to_vec());\n    }\n\n    #[test]\n    fn test_encode_hex() {\n        assert_eq!(\"\".to_string(), encode_hex(\u0026[]));\n        assert_eq!(\"00\".to_string(), encode_hex(\u0026[0x00]));\n        assert_eq!(\"ab\".to_string(), encode_hex(\u0026[0xab]));\n        assert_eq!(\n            \"01 a2 1a fe\".to_string(),\n            encode_hex(\u0026[0x01, 0xa2, 0x1a, 0xfe])\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","registration","mod.rs"],"content":"pub use attestation::create_attestation_certificate;\npub use offchain::{ecall_get_attestation_report, ecall_init_bootstrap, ecall_init_node};\npub use onchain::ecall_authenticate_new_node;\n\nmod attestation;\nmod cert;\nmod hex;\nmod offchain;\nmod onchain;\nmod report;\n\nmod seed_exchange;\n\n#[cfg(feature = \"test\")]\npub mod tests {\n    use super::*;\n    use crate::count_failures;\n\n    pub fn run_tests() {\n        println!();\n        let mut failures = 0;\n\n        count_failures!(failures, {\n            report::tests::test_sgx_quote_parse_from();\n            report::tests::test_attestation_report_from_cert();\n            report::tests::test_attestation_report_from_cert_api_version_not_compatible();\n            cert::tests::test_certificate_valid();\n            cert::tests::test_certificate_invalid_configuration_needed();\n        });\n\n        if failures != 0 {\n            panic!(\"{}: {} tests failed\", file!(), failures);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","registration","offchain.rs"],"content":"//!\n/// These functions run off chain, and so are not limited by deterministic limitations. Feel free\n/// to go crazy with random generation entropy, time requirements, or whatever else\n///\nuse log::*;\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse sgx_types::{sgx_platform_info_t, sgx_update_info_bit_t};\nuse sgx_types::{sgx_quote_sign_type_t, sgx_status_t};\nuse std::slice;\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse enclave_ffi_types::NodeAuthResult;\n\nuse crate::consts::{\n    ATTESTATION_CERTIFICATE_SAVE_PATH, ENCRYPTED_SEED_SIZE, IO_CERTIFICATE_SAVE_PATH,\n    SEED_EXCH_CERTIFICATE_SAVE_PATH,\n};\nuse crate::crypto::{Keychain, KEY_MANAGER, PUBLIC_KEY_SIZE};\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse crate::registration::report::AttestationReport;\nuse crate::storage::write_to_untrusted;\nuse crate::utils::{attest_from_key, validate_const_ptr, validate_mut_ptr, validate_mut_slice};\n\nuse super::attestation::create_attestation_certificate;\nuse super::cert::verify_ra_cert;\n#[cfg(feature = \"SGX_MODE_HW\")]\nuse super::cert::{ocall_get_update_info, verify_quote_status};\nuse super::seed_exchange::decrypt_seed;\n\n///\n/// `ecall_init_bootstrap`\n///\n/// Function to handle the initialization of the bootstrap node. Generates the master private/public\n/// key (seed + pk_io/sk_io). This happens once at the initialization of a chain. Returns the master\n/// public key (pk_io), which is saved on-chain, and used to propagate the seed to registering nodes\n///\n/// # Safety\n///  Something should go here\n///\n#[no_mangle]\npub unsafe extern \"C\" fn ecall_init_bootstrap(\n    public_key: \u0026mut [u8; PUBLIC_KEY_SIZE],\n    spid: *const u8,\n    spid_len: u32,\n    api_key: *const u8,\n    api_key_len: u32,\n) -\u003e sgx_status_t {\n    if let Err(_e) = validate_mut_ptr(public_key.as_mut_ptr(), public_key.len()) {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n\n    if let Err(_e) = validate_const_ptr(spid, spid_len as usize) {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n    let spid_slice = slice::from_raw_parts(spid, spid_len as usize);\n\n    if let Err(_e) = validate_const_ptr(api_key, api_key_len as usize) {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n    let api_key_slice = slice::from_raw_parts(api_key, api_key_len as usize);\n\n    let mut key_manager = Keychain::new();\n\n    if let Err(_e) = key_manager.create_consensus_seed() {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n\n    if let Err(_e) = key_manager.generate_consensus_master_keys() {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n\n    if let Err(_e) = key_manager.create_registration_key() {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n\n    let kp = key_manager.seed_exchange_key().unwrap();\n    if let Err(status) = attest_from_key(\n        \u0026kp,\n        SEED_EXCH_CERTIFICATE_SAVE_PATH,\n        spid_slice,\n        api_key_slice,\n    ) {\n        return status;\n    }\n\n    let kp = key_manager.get_consensus_io_exchange_keypair().unwrap();\n    if let Err(status) = attest_from_key(\u0026kp, IO_CERTIFICATE_SAVE_PATH, spid_slice, api_key_slice) {\n        return status;\n    }\n\n    public_key.copy_from_slice(\u0026key_manager.seed_exchange_key().unwrap().get_pubkey());\n    trace!(\n        \"ecall_init_bootstrap consensus_seed_exchange_keypair public key: {:?}\",\n        \u0026public_key.to_vec()\n    );\n\n    sgx_status_t::SGX_SUCCESS\n}\n\n///\n///  `ecall_init_node`\n///\n/// This function is called during initialization of __non__ bootstrap nodes.\n///\n/// It receives the master public key (pk_io) and uses it, and its node key (generated in [ecall_key_gen])\n/// to decrypt the seed.\n///\n/// The seed was encrypted using Diffie-Hellman in the function [ecall_get_encrypted_seed]\n///\n/// This function happens off-chain, so if we panic for some reason it _can_ be acceptable,\n///  though probably not recommended\n///\n/// # Safety\n///  Something should go here\n///\n#[no_mangle]\npub unsafe extern \"C\" fn ecall_init_node(\n    master_cert: *const u8,\n    master_cert_len: u32,\n    encrypted_seed: *const u8,\n    encrypted_seed_len: u32,\n) -\u003e sgx_status_t {\n    if let Err(_e) = validate_const_ptr(master_cert, master_cert_len as usize) {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n\n    if let Err(_e) = validate_const_ptr(encrypted_seed, encrypted_seed_len as usize) {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n\n    let cert_slice = slice::from_raw_parts(master_cert, master_cert_len as usize);\n\n    if (encrypted_seed_len as usize) != ENCRYPTED_SEED_SIZE {\n        warn!(\n            \"Got encrypted seed with the wrong size: {:?}\",\n            encrypted_seed_len\n        );\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n\n    let encrypted_seed_slice = slice::from_raw_parts(encrypted_seed, encrypted_seed_len as usize);\n\n    let mut encrypted_seed = [0u8; ENCRYPTED_SEED_SIZE];\n    encrypted_seed.copy_from_slice(\u0026encrypted_seed_slice);\n\n    // public keys in certificates don't have 0x04, so we'll copy it here\n    let mut target_public_key: [u8; PUBLIC_KEY_SIZE] = [0u8; PUBLIC_KEY_SIZE];\n\n    // validate certificate w/ attestation report\n    let pk = match verify_ra_cert(cert_slice) {\n        Err(e) =\u003e {\n            error!(\"Error in validating certificate: {:?}\", e);\n            return sgx_status_t::SGX_ERROR_UNEXPECTED;\n        }\n        Ok(res) =\u003e res,\n    };\n\n    // just make sure the of the public key isn't messed up\n    if pk.len() != PUBLIC_KEY_SIZE {\n        error!(\n            \"Got public key from certificate with the wrong size: {:?}\",\n            pk.len()\n        );\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n    target_public_key.copy_from_slice(\u0026pk);\n\n    let mut key_manager = Keychain::new();\n    let seed = match decrypt_seed(\u0026key_manager, target_public_key, encrypted_seed) {\n        Ok(result) =\u003e result,\n        Err(status) =\u003e return status,\n    };\n\n    if let Err(_e) = key_manager.set_consensus_seed(seed) {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n\n    if let Err(_e) = key_manager.generate_consensus_master_keys() {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n\n    sgx_status_t::SGX_SUCCESS\n}\n\n#[no_mangle]\n/**\n * `ecall_get_attestation_report`\n *\n * Creates the attestation report to be used to authenticate with the blockchain. The output of this\n * function is an X.509 certificate signed by the enclave, which contains the report signed by Intel.\n *\n * Verifying functions will verify the public key bytes sent in the extra data of the __report__ (which\n * may or may not match the public key of the __certificate__ -- depending on implementation choices)\n *\n * This x509 certificate can be used in the future for mutual-RA cross-enclave TLS channels, or for\n * other creative usages.\n * # Safety\n * Something should go here\n */\npub unsafe extern \"C\" fn ecall_get_attestation_report(\n    spid: *const u8,\n    spid_len: u32,\n    api_key: *const u8,\n    api_key_len: u32,\n) -\u003e sgx_status_t {\n    if let Err(_e) = validate_const_ptr(spid, spid_len as usize) {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n    let spid_slice = slice::from_raw_parts(spid, spid_len as usize);\n\n    if let Err(_e) = validate_const_ptr(api_key, api_key_len as usize) {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n    let api_key_slice = slice::from_raw_parts(api_key, api_key_len as usize);\n\n    let kp = KEY_MANAGER.get_registration_key().unwrap();\n    trace!(\n        \"ecall_get_attestation_report key pk: {:?}\",\n        \u0026kp.get_pubkey().to_vec()\n    );\n    let (_private_key_der, cert) = match create_attestation_certificate(\n        \u0026kp,\n        sgx_quote_sign_type_t::SGX_UNLINKABLE_SIGNATURE,\n        spid_slice,\n        api_key_slice,\n    ) {\n        Err(e) =\u003e {\n            warn!(\"Error in create_attestation_certificate: {:?}\", e);\n            return e;\n        }\n        Ok(res) =\u003e res,\n    };\n\n    if let Err(status) = write_to_untrusted(cert.as_slice(), ATTESTATION_CERTIFICATE_SAVE_PATH) {\n        return status;\n    }\n\n    print_local_report_info(cert.as_slice());\n\n    sgx_status_t::SGX_SUCCESS\n}\n\n///\n/// This function generates the registration_key, which is used in the attestation and registration\n/// process\n///\n#[no_mangle]\npub unsafe extern \"C\" fn ecall_key_gen(\n    public_key: \u0026mut [u8; PUBLIC_KEY_SIZE],\n) -\u003e sgx_types::sgx_status_t {\n    if let Err(_e) = validate_mut_slice(public_key) {\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    }\n\n    let mut key_manager = Keychain::new();\n    if let Err(_e) = key_manager.create_registration_key() {\n        error!(\"Failed to create registration key\");\n        return sgx_status_t::SGX_ERROR_UNEXPECTED;\n    };\n\n    let pubkey = key_manager.get_registration_key().unwrap().get_pubkey();\n    public_key.clone_from_slice(\u0026pubkey);\n    trace!(\"ecall_key_gen key pk: {:?}\", public_key.to_vec());\n    sgx_status_t::SGX_SUCCESS\n}\n\n#[cfg(not(feature = \"SGX_MODE_HW\"))]\nfn print_local_report_info(_cert: \u0026[u8]) {}\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nfn print_local_report_info(cert: \u0026[u8]) {\n    let report = match AttestationReport::from_cert(cert) {\n        Ok(r) =\u003e r,\n        Err(_) =\u003e {\n            error!(\"Error parsing report\");\n            return;\n        }\n    };\n\n    let node_auth_result = NodeAuthResult::from(\u0026report.sgx_quote_status);\n    // print\n    match verify_quote_status(\u0026report.sgx_quote_status, \u0026report.advisroy_ids) {\n        Err(status) =\u003e match status {\n            NodeAuthResult::SwHardeningAndConfigurationNeeded =\u003e {\n                println!(\"Platform status is SW_HARDENING_AND_CONFIGURATION_NEEDED. This means is updated but requires further BIOS configuration\");\n            }\n            NodeAuthResult::GroupOutOfDate =\u003e {\n                println!(\"Platform status is GROUP_OUT_OF_DATE. This means that one of the system components is missing a security update\");\n            }\n            _ =\u003e {\n                println!(\"Platform status is {}\", status);\n            }\n        },\n        _ =\u003e println!(\"Platform Okay!\"),\n    }\n\n    // print platform blob info\n    match node_auth_result {\n        NodeAuthResult::GroupOutOfDate | NodeAuthResult::SwHardeningAndConfigurationNeeded =\u003e unsafe {\n            print_platform_info(\u0026report)\n        },\n        _ =\u003e {}\n    }\n}\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nunsafe fn print_platform_info(report: \u0026AttestationReport) {\n    if let Some(platform_info) = \u0026report.platform_info_blob {\n        let mut update_info = sgx_update_info_bit_t::default();\n        let mut rt = sgx_status_t::default();\n        let res = ocall_get_update_info(\n            \u0026mut rt as *mut sgx_status_t,\n            platform_info[4..].as_ptr() as *const sgx_platform_info_t,\n            1,\n            \u0026mut update_info,\n        );\n\n        if res != sgx_status_t::SGX_SUCCESS {\n            println!(\"res={:?}\", res);\n            return;\n        }\n\n        if rt != sgx_status_t::SGX_SUCCESS {\n            if update_info.ucodeUpdate != 0 {\n                println!(\"Processor Firmware Update (ucodeUpdate). A security upgrade for your computing\\n\\\n                            device is required for this application to continue to provide you with a high degree of\\n\\\n                            security. Please contact your device manufacturer’s support website for a BIOS update\\n\\\n                            for this system\");\n            }\n\n            if update_info.csmeFwUpdate != 0 {\n                println!(\"Intel Manageability Engine Update (csmeFwUpdate). A security upgrade for your\\n\\\n                            computing device is required for this application to continue to provide you with a high\\n\\\n                            degree of security. Please contact your device manufacturer’s support website for a\\n\\\n                            BIOS and/or Intel® Manageability Engine update for this system\");\n            }\n\n            if update_info.pswUpdate != 0 {\n                println!(\"Intel SGX Platform Software Update (pswUpdate). A security upgrade for your\\n\\\n                              computing device is required for this application to continue to provide you with a high\\n\\\n                              degree of security. Please visit this application’s support website for an Intel SGX\\n\\\n                              Platform SW update\");\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","registration","onchain.rs"],"content":"///\n/// These functions run on-chain and must be deterministic across all nodes\n///\nuse log::*;\nuse std::panic;\n\nuse enclave_ffi_types::NodeAuthResult;\n\nuse crate::consts::ENCRYPTED_SEED_SIZE;\nuse crate::crypto::PUBLIC_KEY_SIZE;\nuse crate::{\n    oom_handler::{self, get_then_clear_oom_happened},\n    utils::{validate_const_ptr, validate_mut_ptr},\n};\n\nuse super::cert::verify_ra_cert;\nuse super::seed_exchange::encrypt_seed;\n\n///\n/// `ecall_authenticate_new_node`\n///\n/// This call is used to help new nodes register in the network. The function will authenticate the\n/// new node, based on a received certificate. If the node is authenticated successfully, the seed\n/// will be encrypted and shared with the registering node.\n///\n/// The seed is encrypted with a key derived from the secret master key of the chain, and the public\n/// key of the requesting chain\n///\n/// This function happens on-chain, so any panic here might cause the chain to go boom\n///\n/// # Safety\n/// Safety first\n#[no_mangle]\npub unsafe extern \"C\" fn ecall_authenticate_new_node(\n    cert: *const u8,\n    cert_len: u32,\n    seed: \u0026mut [u8; ENCRYPTED_SEED_SIZE],\n) -\u003e NodeAuthResult {\n    if let Err(_err) = oom_handler::register_oom_handler() {\n        error!(\"Could not register OOM handler!\");\n        return NodeAuthResult::MemorySafetyAllocationError;\n    }\n\n    if let Err(_e) = validate_mut_ptr(seed.as_mut_ptr(), seed.len()) {\n        return NodeAuthResult::InvalidInput;\n    }\n    if let Err(_e) = validate_const_ptr(cert, cert_len as usize) {\n        return NodeAuthResult::InvalidInput;\n    }\n    let cert_slice = std::slice::from_raw_parts(cert, cert_len as usize);\n\n    let result = panic::catch_unwind(|| -\u003e Result\u003cVec\u003cu8\u003e, NodeAuthResult\u003e {\n        // verify certificate, and return the public key in the extra data of the report\n        let pk = verify_ra_cert(cert_slice)?;\n\n        // just make sure the length isn't wrong for some reason (certificate may be malformed)\n        if pk.len() != PUBLIC_KEY_SIZE {\n            warn!(\n                \"Got public key from certificate with the wrong size: {:?}\",\n                pk.len()\n            );\n            return Err(NodeAuthResult::MalformedPublicKey);\n        }\n\n        let mut target_public_key: [u8; 32] = [0u8; 32];\n        target_public_key.copy_from_slice(\u0026pk);\n        trace!(\n            \"ecall_get_encrypted_seed target_public_key key pk: {:?}\",\n            \u0026target_public_key.to_vec()\n        );\n\n        let res: Vec\u003cu8\u003e =\n            encrypt_seed(target_public_key).map_err(|_| NodeAuthResult::SeedEncryptionFailed)?;\n\n        Ok(res)\n    });\n\n    if let Err(_err) = oom_handler::restore_safety_buffer() {\n        error!(\"Could not restore OOM safety buffer!\");\n        return NodeAuthResult::MemorySafetyAllocationError;\n    }\n\n    if let Ok(res) = result {\n        match res {\n            Ok(res) =\u003e {\n                seed.copy_from_slice(\u0026res);\n                NodeAuthResult::Success\n            }\n            Err(e) =\u003e e,\n        }\n    } else {\n        // There's no real need here to test if oom happened\n        get_then_clear_oom_happened();\n        warn!(\"Enclave call ecall_authenticate_new_node panic!\");\n        NodeAuthResult::Panic\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","registration","report.rs"],"content":"// Apache Teaclave (incubating)\n// Copyright 2019-2020 The Apache Software Foundation\n//\n// This product includes software developed at\n// The Apache Software Foundation (http://www.apache.org/).\n//! Types that contain information about attestation report.\n//! The implementation is based on Attestation Service API version 4.\n//! https://api.trustedservices.intel.com/documents/sgx-attestation-api-spec.pdf\nuse lazy_static::lazy_static;\nuse log::*;\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\nuse serde_json::Value;\nuse std::array::TryFromSliceError;\nuse std::collections::HashMap;\nuse std::convert::TryFrom;\nuse std::time::SystemTime;\nuse std::untrusted::time::SystemTimeEx;\nuse uuid::Uuid;\n\nuse super::cert::{get_ias_auth_config, get_netscape_comment};\nuse enclave_ffi_types::NodeAuthResult;\n\n#[derive(Debug)]\npub enum Error {\n    ReportParseError,\n    ReportValidationError,\n}\n\nimpl From\u003cstd::array::TryFromSliceError\u003e for Error {\n    fn from(_: TryFromSliceError) -\u003e Self {\n        Error::ReportParseError\n    }\n}\n\nimpl From\u003cserde_json::error::Error\u003e for Error {\n    fn from(_: serde_json::error::Error) -\u003e Self {\n        Error::ReportParseError\n    }\n}\n\n/// AttestationReport can be endorsed by either the Intel Attestation Service\n/// using EPID or Data Center Attestation\n/// Service (platform dependent) using ECDSA.\n#[derive(Default, Serialize, Deserialize)]\npub struct EndorsedAttestationReport {\n    /// Attestation report generated by the hardware\n    #[serde(serialize_with = \"as_base64\", deserialize_with = \"from_base64\")]\n    pub report: Vec\u003cu8\u003e,\n    /// Singature of the report\n    #[serde(serialize_with = \"as_base64\", deserialize_with = \"from_base64\")]\n    pub signature: Vec\u003cu8\u003e,\n    /// Certificate matching the signing key of the signature\n    #[serde(serialize_with = \"as_base64\", deserialize_with = \"from_base64\")]\n    pub signing_cert: Vec\u003cu8\u003e,\n}\n\nfn as_base64\u003cS\u003e(key: \u0026[u8], serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n{\n    serializer.serialize_str(\u0026base64::encode(\u0026key[..]))\n}\n\nfn from_base64\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003cVec\u003cu8\u003e, D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    struct Base64Visitor;\n\n    impl\u003c'de\u003e serde::de::Visitor\u003c'de\u003e for Base64Visitor {\n        type Value = Vec\u003cu8\u003e;\n\n        fn expecting(\u0026self, formatter: \u0026mut ::std::fmt::Formatter) -\u003e std::fmt::Result {\n            write!(formatter, \"base64 ASCII text\")\n        }\n\n        fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: serde::de::Error,\n        {\n            base64::decode(v).map_err(E::custom)\n        }\n    }\n    deserializer.deserialize_str(Base64Visitor)\n}\n\ntype SignatureAlgorithms = \u0026'static [\u0026'static webpki::SignatureAlgorithm];\nstatic SUPPORTED_SIG_ALGS: SignatureAlgorithms = \u0026[\n    \u0026webpki::ECDSA_P256_SHA256,\n    \u0026webpki::ECDSA_P256_SHA384,\n    \u0026webpki::ECDSA_P384_SHA256,\n    \u0026webpki::ECDSA_P384_SHA384,\n    \u0026webpki::RSA_PSS_2048_8192_SHA256_LEGACY_KEY,\n    \u0026webpki::RSA_PSS_2048_8192_SHA384_LEGACY_KEY,\n    \u0026webpki::RSA_PSS_2048_8192_SHA512_LEGACY_KEY,\n    \u0026webpki::RSA_PKCS1_2048_8192_SHA256,\n    \u0026webpki::RSA_PKCS1_2048_8192_SHA384,\n    \u0026webpki::RSA_PKCS1_2048_8192_SHA512,\n    \u0026webpki::RSA_PKCS1_3072_8192_SHA384,\n];\n\n/// A report generated by an enclave that contains measurement, identity and\n/// other data related to enclave.\n///\n/// # Note\n///\n/// Do not confuse `SgxEnclaveReport` with `AttestationReport`.\n/// `SgxEnclaveReport` is generated by SGX hardware and endorsed by Quoting\n/// Enclave through local attestation. The endorsed `SgxEnclaveReport` is an\n/// `SgxQuote`. The quote is then sent to some attestation service (IAS or\n/// DCAP-based AS). The endorsed `SgxQuote` is an attestation report signed by\n/// attestation service's private key, a.k.a., `EndorsedAttestationReport`.\npub struct SgxEnclaveReport {\n    /// Security version number of host system's CPU\n    pub cpu_svn: [u8; 16],\n    /// Misc select bits for the target enclave. Reserved for future function\n    /// extension.\n    pub misc_select: u32,\n    /// Attributes of the enclave, for example, whether the enclave is running\n    /// in debug mode.\n    pub attributes: [u8; 16],\n    /// Measurement value of the enclave. See\n    /// [`EnclaveMeasurement`](../types/struct.EnclaveMeasurement.html)\n    pub mr_enclave: [u8; 32],\n    /// Measurement value of the public key that verified the enclave. See\n    /// [`EnclaveMeasurement`](../types/struct.EnclaveMeasurement.html)\n    pub mr_signer: [u8; 32],\n    /// Product ID of the enclave\n    pub isv_prod_id: u16,\n    /// Security version number of the enclave\n    pub isv_svn: u16,\n    /// Set of data used for communication between enclave and target enclave\n    pub report_data: [u8; 64],\n}\n\nimpl std::fmt::Debug for SgxEnclaveReport {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        writeln!(f, \"cpu_svn: {:?}\", self.cpu_svn)?;\n        writeln!(f, \"misc_select: {:?}\", self.misc_select)?;\n        writeln!(f, \"attributes: {:?}\", self.attributes)?;\n        writeln!(f, \"mr_enclave: {:?}\", self.mr_enclave)?;\n        writeln!(f, \"mr_signer: {:?}\", self.mr_signer)?;\n        writeln!(f, \"isv_prod_id: {}\", self.isv_prod_id)?;\n        writeln!(f, \"isv_svn: {}\", self.isv_svn)?;\n        writeln!(f, \"report_data: {:?}\", \u0026self.report_data.to_vec())\n    }\n}\n\nimpl SgxEnclaveReport {\n    /// Parse bytes of report into `SgxEnclaveReport`.\n    pub fn parse_from\u003c'a\u003e(bytes: \u0026'a [u8]) -\u003e Result\u003cSelf, Error\u003e {\n        let mut pos: usize = 0;\n        let mut take = |n: usize| -\u003e Result\u003c\u0026'a [u8], Error\u003e {\n            if n \u003e 0 \u0026\u0026 bytes.len() \u003e= pos + n {\n                let ret = \u0026bytes[pos..pos + n];\n                pos += n;\n                Ok(ret)\n            } else {\n                error!(\"Enclave report parsing error - bad report size\");\n                Err(Error::ReportParseError)\n            }\n        };\n\n        // Start parsing report by bytes following specifications. Don't\n        // transmute directly, since there may cause endianness issue.\n        // off 48, size 16\n        let cpu_svn = \u003c[u8; 16]\u003e::try_from(take(16)?)?;\n\n        // off 64, size 4\n        let misc_select = u32::from_le_bytes(\u003c[u8; 4]\u003e::try_from(take(4)?)?);\n\n        // off 68, size 28\n        let _reserved = take(28)?;\n\n        // off 96, size 16\n        let attributes = \u003c[u8; 16]\u003e::try_from(take(16)?)?;\n\n        // off 112, size 32\n        let mr_enclave = \u003c[u8; 32]\u003e::try_from(take(32)?)?;\n\n        // off 144, size 32\n        let _reserved = take(32)?;\n\n        // off 176, size 32\n        let mr_signer = \u003c[u8; 32]\u003e::try_from(take(32)?)?;\n\n        // off 208, size 96\n        let _reserved = take(96)?;\n\n        // off 304, size 2\n        let isv_prod_id = u16::from_le_bytes(\u003c[u8; 2]\u003e::try_from(take(2)?)?);\n\n        // off 306, size 2\n        let isv_svn = u16::from_le_bytes(\u003c[u8; 2]\u003e::try_from(take(2)?)?);\n\n        // off 308, size 60\n        let _reserved = take(60)?;\n\n        // off 368, size 64\n        let mut report_data = [0u8; 64];\n        let _report_data = take(64)?;\n        let mut _it = _report_data.iter();\n        for i in report_data.iter_mut() {\n            *i = *_it.next().ok_or(Error::ReportParseError)?;\n        }\n\n        if pos != bytes.len() {\n            warn!(\"Enclave report parsing error.\");\n            return Err(Error::ReportParseError);\n        };\n\n        Ok(SgxEnclaveReport {\n            cpu_svn,\n            misc_select,\n            attributes,\n            mr_enclave,\n            mr_signer,\n            isv_prod_id,\n            isv_svn,\n            report_data,\n        })\n    }\n}\n\n/// SGX Quote structure version\n#[derive(Debug, PartialEq)]\n#[allow(dead_code)]\npub enum SgxQuoteVersion {\n    /// EPID quote version\n    V1(SgxEpidQuoteSigType),\n    /// EPID quote version\n    V2(SgxEpidQuoteSigType),\n    /// ECDSA quote version\n    V3(SgxEcdsaQuoteAkType),\n}\n\n/// Intel EPID attestation signature type\n#[derive(Debug, PartialEq)]\n#[allow(dead_code)]\npub enum SgxEpidQuoteSigType {\n    Unlinkable,\n    Linkable,\n}\n\n/// ECDSA attestation key type\n#[derive(Debug, PartialEq)]\npub enum SgxEcdsaQuoteAkType {\n    /// ECDSA-256-with-P-256 curve\n    P256_256,\n    /// ECDSA-384-with-P-384 curve\n    P384_384,\n}\n\n/// SGX Quote status\n#[derive(PartialEq, Debug)]\npub enum SgxQuoteStatus {\n    /// EPID signature of the ISV enclave QUOTE was verified correctly and the\n    /// TCB level of the SGX platform is up-to-date.\n    OK,\n    /// EPID signature of the ISV enclave QUOTE was invalid. The content of the\n    /// QUOTE is not trustworthy.\n    ///\n    /// For DCAP, the signature over the application report is invalid.\n    SignatureInvalid,\n    /// The EPID group has been revoked. When this value is returned, the\n    /// revocation Reason field of the Attestation Verification Report will\n    /// contain revocation reason code for this EPID group as reported in the\n    /// EPID Group CRL. The content of the QUOTE is not trustworthy.\n    GroupRevoked,\n    /// The EPID private key used to sign the QUOTE has been revoked by\n    /// signature. The content of the QUOTE is not trustworthy.\n    SignatureRevoked,\n    /// The EPID private key used to sign the QUOTE has been directly revoked\n    /// (not by signature). The content of the QUOTE is not trustworthy.\n    ///\n    /// For DCAP, the attestation key or platform has been revoked.\n    KeyRevoked,\n    /// SigRL version in ISV enclave QUOTE does not match the most recent\n    /// version of the SigRL. In rare situations, after SP retrieved the SigRL\n    /// from IAS and provided it to the platform, a newer version of the SigRL\n    /// is madeavailable. As a result, the Attestation Verification Report will\n    /// indicate SIGRL_VERSION_MISMATCH. SP can retrieve the most recent version\n    /// of SigRL from the IAS and request the platform to perform remote\n    /// attestation again with the most recent version of SigRL. If the platform\n    /// keeps failing to provide a valid QUOTE matching with the most recent\n    /// version of the SigRL, the content of the QUOTE is not trustworthy.\n    SigrlVersionMismatch,\n    /// The EPID signature of the ISV enclave QUOTE has been verified correctly,\n    /// but the TCB level of SGX platform is outdated (for further details see\n    /// Advisory IDs). The platform has not been identified as compromised and\n    /// thus it is not revoked. It is up to the Service Provider to decide\n    /// whether or not to trust the content of the QUOTE, andwhether or not to\n    /// trust the platform performing the attestation to protect specific\n    /// sensitive information.\n    GroupOutOfDate,\n    /// The EPID signature of the ISV enclave QUOTE has been verified correctly,\n    /// but additional configuration of SGX platform may be needed(for further\n    /// details see Advisory IDs). The platform has not been identified as\n    /// compromised and thus it is not revoked. It is up to the Service Provider\n    /// to decide whether or not to trust the content of the QUOTE, and whether\n    /// or not to trust the platform performing the attestation to protect\n    /// specific sensitive information.\n    ///\n    /// For DCAP, The Quote verification passed and the platform is patched to\n    /// the latest TCB level but additional configuration of the SGX\n    /// platform may be needed.\n    ConfigurationNeeded,\n    /// The EPID signature of the ISV enclave QUOTE has been verified correctly\n    /// but due to certain issues affecting the platform, additional SW\n    /// Hardening in the attesting SGX enclaves may be needed.The relying party\n    /// should evaluate the potential risk of an attack leveraging the relevant\n    /// issues on the attesting enclave, and whether the attesting enclave\n    /// employs adequate software hardening to mitigate the risk.\n    SwHardeningNeeded,\n    /// The EPID signature of the ISV enclave QUOTE has been verified correctly\n    /// but additional configuration for the platform and SW Hardening in the\n    /// attesting SGX enclaves may be needed. The platform has not been\n    /// identified as compromised and thus it is not revoked. It is up to the\n    /// Service Provider to decide whether or not to trust the content of the\n    /// QUOTE. The relying party should also evaluate the potential risk of an\n    /// attack leveraging the relevant issues on the attestation enclave, and\n    /// whether the attesting enclave employs adequate software hardening to\n    /// mitigate the risk.\n    ConfigurationAndSwHardeningNeeded,\n    /// DCAP specific quote status. The Quote is good but TCB level of the\n    /// platform is out of date. The platform needs patching to be at the latest\n    /// TCB level.\n    OutOfDate,\n    /// DCAP specific quote status. The Quote is good but the TCB level of the\n    /// platform is out of date and additional configuration of the SGX Platform\n    /// at its current patching level may be needed. The platform needs patching\n    /// to be at the latest TCB level.\n    OutOfDateConfigurationNeeded,\n    /// Other unknown bad status.\n    UnknownBadStatus,\n}\n\nimpl From\u003c\u0026SgxQuoteStatus\u003e for NodeAuthResult {\n    fn from(status: \u0026SgxQuoteStatus) -\u003e Self {\n        match status {\n            SgxQuoteStatus::ConfigurationAndSwHardeningNeeded =\u003e {\n                NodeAuthResult::SwHardeningAndConfigurationNeeded\n            }\n            SgxQuoteStatus::ConfigurationNeeded =\u003e NodeAuthResult::ConfigurationNeeded,\n            SgxQuoteStatus::GroupOutOfDate =\u003e NodeAuthResult::GroupOutOfDate,\n            SgxQuoteStatus::KeyRevoked =\u003e NodeAuthResult::KeyRevoked,\n            SgxQuoteStatus::SigrlVersionMismatch =\u003e NodeAuthResult::SigrlVersionMismatch,\n            SgxQuoteStatus::SignatureRevoked =\u003e NodeAuthResult::SignatureRevoked,\n            SgxQuoteStatus::GroupRevoked =\u003e NodeAuthResult::GroupRevoked,\n            _ =\u003e NodeAuthResult::BadQuoteStatus,\n        }\n    }\n}\n\nimpl From\u003c\u0026str\u003e for SgxQuoteStatus {\n    /// Convert from str status from the report to enum.\n    fn from(status: \u0026str) -\u003e Self {\n        match status {\n            \"OK\" =\u003e SgxQuoteStatus::OK,\n            \"SIGNATURE_INVALID\" =\u003e SgxQuoteStatus::SignatureInvalid,\n            \"GROUP_REVOKED\" =\u003e SgxQuoteStatus::GroupRevoked,\n            \"SIGNATURE_REVOKED\" =\u003e SgxQuoteStatus::SignatureRevoked,\n            \"KEY_REVOKED\" =\u003e SgxQuoteStatus::KeyRevoked,\n            \"SIGRL_VERSION_MISMATCH\" =\u003e SgxQuoteStatus::SigrlVersionMismatch,\n            \"GROUP_OUT_OF_DATE\" =\u003e SgxQuoteStatus::GroupOutOfDate,\n            \"OUT_OF_DATE\" =\u003e SgxQuoteStatus::OutOfDate,\n            \"OUT_OF_DATE_CONFIGURATION_NEEDED\" =\u003e SgxQuoteStatus::OutOfDateConfigurationNeeded,\n            \"CONFIGURATION_NEEDED\" =\u003e SgxQuoteStatus::ConfigurationNeeded,\n            \"SW_HARDENING_NEEDED\" =\u003e SgxQuoteStatus::SwHardeningNeeded,\n            \"CONFIGURATION_AND_SW_HARDENING_NEEDED\" =\u003e {\n                SgxQuoteStatus::ConfigurationAndSwHardeningNeeded\n            }\n            _ =\u003e SgxQuoteStatus::UnknownBadStatus,\n        }\n    }\n}\n\n/// An application that hosts an enclave can ask the enclave to produce a report\n/// (`SgxEnclaveReport`) and then pass this report to a platform service\n/// (Quoting Enclave) to produce a type of credential that reflects the enclave\n/// and platform state. The quote can be passed to entities off the platform,\n/// and verified using Intel EPID signature verification techniques.\npub struct SgxQuote {\n    /// Version of the quote structure\n    pub version: SgxQuoteVersion,\n    /// ID of the Intel EPID group of the platform belongs to\n    pub gid: u32,\n    /// Security version number of Quoting Enclave\n    pub isv_svn_qe: u16,\n    /// Security version number of PCE\n    pub isv_svn_pce: u16,\n    /// Vendor ID of Quoting Enclave\n    pub qe_vendor_id: Uuid,\n    /// User data\n    pub user_data: [u8; 20],\n    /// Report generated by the enclave\n    pub isv_enclave_report: SgxEnclaveReport,\n}\n\nimpl std::fmt::Debug for SgxQuote {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        writeln!(f, \"version: {:?}\", self.version)?;\n        writeln!(f, \"gid: {}\", self.gid)?;\n        writeln!(f, \"isv_svn_qe: {}\", self.isv_svn_qe)?;\n        writeln!(f, \"isv_svn_pce: {}\", self.isv_svn_pce)?;\n        writeln!(f, \"qe_vendor_id: {}\", self.qe_vendor_id)?;\n        writeln!(f, \"user_data: {:?}\", \u0026self.user_data)?;\n        writeln!(f, \"isv_enclave_report: \\n{:?}\", self.isv_enclave_report)\n    }\n}\n\nimpl SgxQuote {\n    /// Parse from bytes to `SgxQuote`.\n    // just unused in SW mode\n    #[allow(dead_code)]\n    fn parse_from\u003c'a\u003e(bytes: \u0026'a [u8]) -\u003e Result\u003cSelf, Error\u003e {\n        let mut pos: usize = 0;\n        let mut take = |n: usize| -\u003e Result\u003c\u0026'a [u8], Error\u003e {\n            if n \u003e 0 \u0026\u0026 bytes.len() \u003e= pos + n {\n                let ret = \u0026bytes[pos..pos + n];\n                pos += n;\n                Ok(ret)\n            } else {\n                warn!(\"Quote parsing error.\");\n                Err(Error::ReportParseError)\n            }\n        };\n\n        // Parse by bytes according to specifications.\n        // off 0, size 2 + 2\n        let version = match u16::from_le_bytes(\u003c[u8; 2]\u003e::try_from(take(2)?)?) {\n            1 =\u003e {\n                let signature_type = match u16::from_le_bytes(\u003c[u8; 2]\u003e::try_from(\n                    take(2).map_err(|_| Error::ReportParseError)?,\n                )?) {\n                    0 =\u003e SgxEpidQuoteSigType::Unlinkable,\n                    1 =\u003e SgxEpidQuoteSigType::Linkable,\n                    _ =\u003e {\n                        warn!(\"Invalid v1 quote signature type\");\n                        return Err(Error::ReportParseError);\n                    }\n                };\n                SgxQuoteVersion::V1(signature_type)\n            }\n            2 =\u003e {\n                let signature_type = match u16::from_le_bytes(\u003c[u8; 2]\u003e::try_from(\n                    take(2).map_err(|_| Error::ReportParseError)?,\n                )?) {\n                    0 =\u003e SgxEpidQuoteSigType::Unlinkable,\n                    1 =\u003e SgxEpidQuoteSigType::Linkable,\n                    _ =\u003e {\n                        warn!(\"Invalid v2 quote signature type\");\n                        return Err(Error::ReportParseError);\n                    }\n                };\n                SgxQuoteVersion::V2(signature_type)\n            }\n            3 =\u003e {\n                let attestation_key_type = match u16::from_le_bytes(\u003c[u8; 2]\u003e::try_from(\n                    take(2).map_err(|_| Error::ReportParseError)?,\n                )?) {\n                    2 =\u003e SgxEcdsaQuoteAkType::P256_256,\n                    3 =\u003e SgxEcdsaQuoteAkType::P384_384,\n                    _ =\u003e {\n                        warn!(\"Quote parsing error - ecdsa quote type invalid\");\n                        return Err(Error::ReportParseError);\n                    }\n                };\n                SgxQuoteVersion::V3(attestation_key_type)\n            }\n            _ =\u003e {\n                warn!(\"Quote parsing error - Unknown quote version\");\n                return Err(Error::ReportParseError);\n            }\n        };\n\n        // off 4, size 4\n        let gid = u32::from_le_bytes(\u003c[u8; 4]\u003e::try_from(take(4).map_err(|_| {\n            warn!(\"Failed to parse quote gid\");\n            Error::ReportParseError\n        })?)?);\n\n        // off 8, size 2\n        let isv_svn_qe = u16::from_le_bytes(\u003c[u8; 2]\u003e::try_from(take(2).map_err(|_| {\n            warn!(\"Failed to parse quote isv svn qe\");\n            Error::ReportParseError\n        })?)?);\n\n        // off 10, size 2\n        let isv_svn_pce = u16::from_le_bytes(\u003c[u8; 2]\u003e::try_from(take(2).map_err(|_| {\n            warn!(\"Failed to parse quote isv svn\");\n            Error::ReportParseError\n        })?)?);\n\n        // off 12, size 16\n        let qe_vendor_id_raw =\n            \u003c[u8; 16]\u003e::try_from(take(16).map_err(|_| Error::ReportParseError)?)?;\n        let qe_vendor_id = Uuid::from_slice(\u0026qe_vendor_id_raw).map_err(|_| {\n            warn!(\"Failed to parse quote vendor id\");\n            Error::ReportParseError\n        })?;\n\n        // off 28, size 20\n        let user_data = \u003c[u8; 20]\u003e::try_from(take(20).map_err(|_| {\n            warn!(\"Failed to parse quote user data\");\n            Error::ReportParseError\n        })?)?;\n\n        // off 48, size 384\n        let isv_enclave_report = SgxEnclaveReport::parse_from(take(384).map_err(|_| {\n            warn!(\"Failed to parse enclave report\");\n            Error::ReportParseError\n        })?)?;\n\n        if pos != bytes.len() {\n            warn!(\"Quote parsing error - Quote size different from expected\");\n            return Err(Error::ReportParseError);\n        };\n\n        Ok(Self {\n            version,\n            gid,\n            isv_svn_qe,\n            isv_svn_pce,\n            qe_vendor_id,\n            user_data,\n            isv_enclave_report,\n        })\n    }\n}\n\n#[cfg(all(feature = \"SGX_MODE_HW\", not(feature = \"production\")))]\nconst WHITELISTED_ADVISORIES: \u0026[\u0026str] = \u0026[\"INTEL-SA-00334\", \"INTEL-SA-00219\"];\n\n#[cfg(all(feature = \"SGX_MODE_HW\", feature = \"production\"))]\nconst WHITELISTED_ADVISORIES: \u0026[\u0026str] = \u0026[\"INTEL-SA-00334\", \"INTEL-SA-00219\"];\n\nlazy_static! {\n    static ref ADVISORY_DESC: HashMap\u003c\u0026'static str, \u0026'static str\u003e = [\n        (\n            \"INTEL-SA-00161\",\n            \"You must disable hyperthreading in the BIOS\"\n        ),\n        (\n            \"INTEL-SA-00289\",\n            \"You must disable overclocking/undervolting in the BIOS\"\n        ),\n    ]\n    .iter()\n    .copied()\n    .collect();\n}\n\n#[derive(Debug)]\npub struct AdvisoryIDs(pub Vec\u003cString\u003e);\n\n#[cfg(feature = \"SGX_MODE_HW\")]\nimpl AdvisoryIDs {\n    pub(crate) fn vulnerable(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut vulnerable: Vec\u003cString\u003e = vec![];\n        for i in self.0.iter() {\n            if !WHITELISTED_ADVISORIES.contains(\u0026i.as_str()) {\n                vulnerable.push(i.clone());\n                if let Some(v) = ADVISORY_DESC.get(\u0026i.as_str()) {\n                    vulnerable.push((*v).to_string())\n                }\n            }\n        }\n        vulnerable\n    }\n}\n\n/// A report that can be signed by Intel EPID (which generates\n/// `EndorsedAttestationReport`) and then sent off of the platform to be\n/// verified by remote client.\n#[derive(Debug)]\npub struct AttestationReport {\n    /// The freshness of the report, i.e., elapsed time after acquiring the\n    /// report in seconds.\n    // pub freshness: Duration,\n    /// Quote status\n    pub sgx_quote_status: SgxQuoteStatus,\n    /// Content of the quote\n    pub sgx_quote_body: SgxQuote,\n    pub platform_info_blob: Option\u003cVec\u003cu8\u003e\u003e,\n    pub advisroy_ids: AdvisoryIDs,\n}\n\nimpl AttestationReport {\n    /// Construct a AttestationReport from a X509 certificate and verify\n    /// attestation report with the report_ca_cert which is from the attestation\n    /// service provider.\n    // just unused in SW mode\n    #[allow(dead_code)]\n    pub fn from_cert(cert: \u0026[u8]) -\u003e Result\u003cSelf, Error\u003e {\n        // Before we reach here, Webpki already verifed the cert is properly signed.\n\n        let payload = get_netscape_comment(cert).map_err(|_err| Error::ReportParseError)?;\n\n        // Convert to endorsed report\n        let report: EndorsedAttestationReport = serde_json::from_slice(\u0026payload)?;\n\n        // Verify report's signature\n        let signing_cert = webpki::EndEntityCert::from(\u0026report.signing_cert)\n            .map_err(|_| Error::ReportParseError)?;\n\n        let (cert, root_store) = get_ias_auth_config();\n\n        let trust_anchors: Vec\u003cwebpki::TrustAnchor\u003e = root_store\n            .roots\n            .iter()\n            .map(|cert| cert.to_trust_anchor())\n            .collect();\n\n        let mut chain: Vec\u003c\u0026[u8]\u003e = Vec::new();\n        chain.push(\u0026cert);\n\n        let now_func = match webpki::Time::try_from(SystemTime::now()) {\n            Ok(val) =\u003e val,\n            Err(_e) =\u003e {\n                error!(\"Failed to get local time\");\n                return Err(Error::ReportParseError);\n            }\n        };\n\n        // todo: figure out what to do when the certificate expires\n        match signing_cert.verify_is_valid_tls_server_cert(\n            SUPPORTED_SIG_ALGS,\n            \u0026webpki::TLSServerTrustAnchors(\u0026trust_anchors),\n            \u0026chain,\n            now_func,\n        ) {\n            Ok(_) =\u003e info!(\"Certificate verified successfully\"),\n            Err(e) =\u003e {\n                warn!(\"Certificate verification error {:?}\", e);\n                return Err(Error::ReportValidationError);\n            }\n        }\n\n        // Verify the signature against the signing cert\n        match signing_cert.verify_signature(\n            \u0026webpki::RSA_PKCS1_2048_8192_SHA256,\n            \u0026report.report,\n            \u0026report.signature,\n        ) {\n            Ok(_) =\u003e info!(\"Signature verified successfully\"),\n            Err(e) =\u003e {\n                warn!(\"Signature verification error {:?}\", e);\n                return Err(Error::ReportParseError);\n            }\n        }\n\n        // Verify and extract information from attestation report\n        let attn_report: Value = serde_json::from_slice(\u0026report.report)?;\n        trace!(\"attn_report: {}\", attn_report);\n\n        // Verify API version is supported\n        let version = attn_report[\"version\"]\n            .as_u64()\n            .ok_or(Error::ReportParseError)?;\n\n        if version != 4 {\n            warn!(\"API version incompatible\");\n            return Err(Error::ReportParseError);\n        };\n\n        let mut platform_info_blob = None;\n        if let Some(blob) = attn_report[\"platformInfoBlob\"].as_str() {\n            let as_binary = hex::decode(blob).map_err(|_| {\n                warn!(\"Error parsing platform info\");\n                Error::ReportParseError\n            })?;\n            platform_info_blob = Some(as_binary)\n        }\n\n        // Get quote status\n        let sgx_quote_status = {\n            let status_string = attn_report[\"isvEnclaveQuoteStatus\"]\n                .as_str()\n                .ok_or_else(|| {\n                    warn!(\"Error parsing enclave quote status\");\n                    Error::ReportParseError\n                })?;\n            SgxQuoteStatus::from(status_string)\n        };\n\n        // Get quote body\n        let sgx_quote_body = {\n            let quote_encoded = attn_report[\"isvEnclaveQuoteBody\"].as_str().ok_or_else(|| {\n                warn!(\"Error unpacking enclave quote body\");\n                Error::ReportParseError\n            })?;\n            let quote_raw = base64::decode(\u0026quote_encoded.as_bytes()).map_err(|_| {\n                warn!(\"Error decoding encoded quote body\");\n                Error::ReportParseError\n            })?;\n            SgxQuote::parse_from(quote_raw.as_slice())?\n        };\n\n        // Get advisories\n        let advisories: Vec\u003cString\u003e = serde_json::from_value(attn_report[\"advisoryIDs\"].clone())\n            .map_err(|_| {\n                warn!(\"Failed to decode advisories\");\n                Error::ReportParseError\n            })?;\n\n        // We don't actually validate the public key, since we use ephemeral certificates,\n        // and all we really care about that the report is valid and the key that is saved in the\n        // report_data field\n\n        Ok(Self {\n            sgx_quote_status,\n            sgx_quote_body,\n            platform_info_blob,\n            advisroy_ids: AdvisoryIDs(advisories),\n        })\n    }\n}\n\n#[cfg(feature = \"test\")]\npub mod tests {\n    use serde_json::json;\n    use std::io::Read;\n    use std::untrusted::fs::File;\n\n    use super::*;\n\n    fn tls_ra_cert_der_v3() -\u003e Vec\u003cu8\u003e {\n        let mut cert = vec![];\n        let mut f =\n            File::open(\"../wasmi-runtime/src/registration/fixtures/tls_ra_cert_v3.der\").unwrap();\n        f.read_to_end(\u0026mut cert).unwrap();\n\n        cert\n    }\n\n    fn tls_ra_cert_der_v4() -\u003e Vec\u003cu8\u003e {\n        let mut cert = vec![];\n        let mut f = File::open(\n            \"../wasmi-runtime/src/registration/fixtures/attestation_cert_out_of_date.der\",\n        )\n        .unwrap();\n        f.read_to_end(\u0026mut cert).unwrap();\n\n        cert\n    }\n\n    fn tls_ra_cert_der_out_of_date() -\u003e Vec\u003cu8\u003e {\n        let mut cert = vec![];\n        let mut f = File::open(\n            \"../wasmi-runtime/src/registration/fixtures/attestation_cert_sw_config_needed.der\",\n        )\n        .unwrap();\n        f.read_to_end(\u0026mut cert).unwrap();\n\n        cert\n    }\n\n    fn ias_root_ca_cert_der() -\u003e Vec\u003cu8\u003e {\n        let mut cert = vec![];\n        let mut f =\n            File::open(\"../wasmi-runtime/src/registration/fixtures/ias_root_ca_cert.der\").unwrap();\n        f.read_to_end(\u0026mut cert).unwrap();\n\n        cert\n    }\n\n    fn attesation_report() -\u003e Value {\n        let report = json!({\n            \"version\": 3,\n            \"timestamp\": \"2020-02-11T22:25:59.682915\",\n            \"platformInfoBlob\": \"1502006504000900000D0D02040180030000000000000000000\\\n                                 A00000B000000020000000000000B2FE0AE0F7FD4D552BF7EF4\\\n                                 C938D44E349F1BD0E76F041362DC52B43B7B25994978D792137\\\n                                 90362F6DAE91797ACF5BD5072E45F9A60795D1FFB10140421D8\\\n                                 691FFD\",\n            \"isvEnclaveQuoteStatus\": \"GROUP_OUT_OF_DATE\",\n            \"isvEnclaveQuoteBody\": \"AgABAC8LAAAKAAkAAAAAAK1zRQOIpndiP4IhlnW2AkwAAAAA\\\n                                    AAAAAAAAAAAAAAAABQ4CBf+AAAAAAAAAAAAAAAAAAAAAAAAA\\\n                                    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAHAAAA\\\n                                    AAAAADMKqRCjd2eA4gAmrj2sB68OWpMfhPH4MH27hZAvWGlT\\\n                                    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACD1xnn\\\n                                    ferKFHD2uvYqTXdDA8iZ22kCD5xw7h38CMfOngAAAAAAAAAA\\\n                                    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\n                                    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\n                                    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\n                                    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\n                                    AAAAAAAAAADYIY9k0MVmCdIDUuFLf/2bGIHAfPjO9nvC7fgz\\\n                                    rQedeA3WW4dFeI6oe+RCLdV3XYD1n6lEZjITOzPPLWDxulGz\",\n            \"id\": \"53530608302195762335736519878284384788\",\n            \"epidPseudonym\": \"NRksaQej8R/SyyHpZXzQGNBXqfrzPy5KCxcmJrEjupXrq3xrm2y2+J\\\n                              p0IBVtcW15MCekYs9K3UH82fPyj6F5ciJoMsgEMEIvRR+csX9uyd54\\\n                              p+m+/RVyuGYhWbhUcpJigdI5Q3x04GG/A7EP10j/zypwqhYLQh0qN1\\\n                              ykYt1N1P0=\"\n        });\n\n        report\n    }\n\n    pub fn test_sgx_quote_parse_from() {\n        let attn_report = attesation_report();\n        let sgx_quote_body_encoded = attn_report[\"isvEnclaveQuoteBody\"].as_str().unwrap();\n        let quote_raw = base64::decode(\u0026sgx_quote_body_encoded.as_bytes()).unwrap();\n        let sgx_quote = SgxQuote::parse_from(quote_raw.as_slice()).unwrap();\n\n        assert_eq!(\n            sgx_quote.version,\n            SgxQuoteVersion::V2(SgxEpidQuoteSigType::Linkable)\n        );\n        assert_eq!(sgx_quote.gid, 2863);\n        assert_eq!(sgx_quote.isv_svn_qe, 10);\n        assert_eq!(sgx_quote.isv_svn_pce, 9);\n        assert_eq!(\n            sgx_quote.qe_vendor_id,\n            Uuid::parse_str(\"00000000-ad73-4503-88a6-77623f822196\").unwrap()\n        );\n        assert_eq!(\n            sgx_quote.user_data,\n            [117, 182, 2, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        );\n\n        let isv_enclave_report = sgx_quote.isv_enclave_report;\n        assert_eq!(\n            isv_enclave_report.cpu_svn,\n            [5, 14, 2, 5, 255, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        );\n        assert_eq!(isv_enclave_report.misc_select, 0);\n        assert_eq!(\n            isv_enclave_report.attributes,\n            [7, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0]\n        );\n        assert_eq!(\n            isv_enclave_report.mr_enclave,\n            [\n                51, 10, 169, 16, 163, 119, 103, 128, 226, 0, 38, 174, 61, 172, 7, 175, 14, 90, 147,\n                31, 132, 241, 248, 48, 125, 187, 133, 144, 47, 88, 105, 83\n            ]\n        );\n        assert_eq!(\n            isv_enclave_report.mr_signer,\n            [\n                131, 215, 25, 231, 125, 234, 202, 20, 112, 246, 186, 246, 42, 77, 119, 67, 3, 200,\n                153, 219, 105, 2, 15, 156, 112, 238, 29, 252, 8, 199, 206, 158\n            ]\n        );\n        assert_eq!(isv_enclave_report.isv_prod_id, 0);\n        assert_eq!(isv_enclave_report.isv_svn, 0);\n        assert_eq!(\n            isv_enclave_report.report_data.to_vec(),\n            [\n                216, 33, 143, 100, 208, 197, 102, 9, 210, 3, 82, 225, 75, 127, 253, 155, 24, 129,\n                192, 124, 248, 206, 246, 123, 194, 237, 248, 51, 173, 7, 157, 120, 13, 214, 91,\n                135, 69, 120, 142, 168, 123, 228, 66, 45, 213, 119, 93, 128, 245, 159, 169, 68,\n                102, 50, 19, 59, 51, 207, 45, 96, 241, 186, 81, 179\n            ]\n            .to_vec()\n        );\n    }\n\n    pub fn test_attestation_report_from_cert() {\n        let tls_ra_cert = tls_ra_cert_der_v4();\n        let report = AttestationReport::from_cert(\u0026tls_ra_cert);\n        assert!(report.is_ok());\n\n        let report = report.unwrap();\n        assert_eq!(report.sgx_quote_status, SgxQuoteStatus::GroupOutOfDate);\n    }\n\n    pub fn test_attestation_report_from_cert_invalid() {\n        let tls_ra_cert = tls_ra_cert_der_v4();\n        let report = AttestationReport::from_cert(\u0026tls_ra_cert);\n        assert!(report.is_ok());\n\n        let report = report.unwrap();\n        assert_eq!(\n            report.sgx_quote_status,\n            SgxQuoteStatus::ConfigurationAndSwHardeningNeeded\n        );\n    }\n\n    pub fn test_attestation_report_from_cert_api_version_not_compatible() {\n        let tls_ra_cert = tls_ra_cert_der_v3();\n        let report = AttestationReport::from_cert(\u0026tls_ra_cert);\n        assert!(report.is_err());\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":236},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","registration","seed_exchange.rs"],"content":"use log::*;\nuse sgx_types::{sgx_status_t, SgxResult};\n\nuse crate::consts::ENCRYPTED_SEED_SIZE;\nuse crate::crypto::{\n    AESKey, Keychain, SIVEncryptable, Seed, KEY_MANAGER, PUBLIC_KEY_SIZE, SEED_KEY_SIZE,\n};\n\npub fn encrypt_seed(new_node_pk: [u8; PUBLIC_KEY_SIZE]) -\u003e SgxResult\u003cVec\u003cu8\u003e\u003e {\n    let shared_enc_key = KEY_MANAGER\n        .seed_exchange_key()\n        .unwrap()\n        .diffie_hellman(\u0026new_node_pk);\n\n    let mut authenticated_data: Vec\u003c\u0026[u8]\u003e = Vec::default();\n    authenticated_data.push(\u0026new_node_pk);\n    // encrypt the seed using the symmetric key derived in the previous stage\n    let res = match AESKey::new_from_slice(\u0026shared_enc_key).encrypt_siv(\n        KEY_MANAGER.get_consensus_seed().unwrap().as_slice() as \u0026[u8],\n        Some(\u0026authenticated_data),\n    ) {\n        Ok(r) =\u003e {\n            if r.len() != ENCRYPTED_SEED_SIZE {\n                error!(\n                    \"Seed encryption failed. Got seed of unexpected length: {:?}\",\n                    r.len()\n                );\n                return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);\n            }\n            r\n        }\n        Err(_e) =\u003e return Err(sgx_status_t::SGX_ERROR_UNEXPECTED),\n    };\n\n    Ok(res)\n}\n\n///\n/// master_pk: [seed_exch_publickey] - Public key that is written on-chain at genesis\n///\npub fn decrypt_seed(\n    key_manager: \u0026Keychain,\n    master_pk: [u8; PUBLIC_KEY_SIZE],\n    encrypted_seed: [u8; ENCRYPTED_SEED_SIZE],\n) -\u003e SgxResult\u003cSeed\u003e {\n    // create shared encryption key using ECDH\n    let shared_enc_key = key_manager\n        .get_registration_key()\n        .unwrap()\n        .diffie_hellman(\u0026master_pk);\n\n    let mut seed = Seed::default();\n\n    // Create AD of encryption\n    let my_public_key = key_manager.get_registration_key().unwrap().get_pubkey();\n    let mut authenticated_data: Vec\u003c\u0026[u8]\u003e = Vec::default();\n    authenticated_data.push(\u0026my_public_key);\n\n    // decrypt\n    seed.as_mut()\n        .copy_from_slice(\u0026match AESKey::new_from_slice(\u0026shared_enc_key)\n            .decrypt_siv(\u0026encrypted_seed, Some(\u0026authenticated_data))\n        {\n            Ok(r) =\u003e {\n                if r.len() != SEED_KEY_SIZE {\n                    error!(\n                        \"Init failed! Decrypted seed has invalid length - {:?}\",\n                        r.len()\n                    );\n                    return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);\n                }\n                r\n            }\n            Err(_e) =\u003e return Err(sgx_status_t::SGX_ERROR_UNEXPECTED),\n        });\n    Ok(seed)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","results.rs"],"content":"use enclave_ffi_types::{\n    EnclaveError, HandleResult, InitResult, QueryResult, UntrustedVmError, UserSpaceBuffer,\n};\nuse sgx_types::sgx_status_t;\n\nuse crate::imports::ocall_allocate;\n\n/// This struct is returned from module initialization.\npub struct InitSuccess {\n    /// The output of the calculation\n    pub output: Vec\u003cu8\u003e,\n    /// The contract_key of this contract.\n    pub contract_key: [u8; 64],\n}\n\npub fn result_init_success_to_initresult(result: Result\u003cInitSuccess, EnclaveError\u003e) -\u003e InitResult {\n    match result {\n        Ok(InitSuccess {\n            output,\n            contract_key,\n        }) =\u003e {\n            let user_buffer = unsafe {\n                let mut user_buffer = std::mem::MaybeUninit::\u003cUserSpaceBuffer\u003e::uninit();\n                match ocall_allocate(user_buffer.as_mut_ptr(), output.as_ptr(), output.len()) {\n                    sgx_status_t::SGX_SUCCESS =\u003e { /* continue */ }\n                    _ =\u003e {\n                        return InitResult::Failure {\n                            err: EnclaveError::FailedOcall {\n                                vm_error: UntrustedVmError::default(),\n                            },\n                        }\n                    }\n                }\n                user_buffer.assume_init()\n            };\n            InitResult::Success {\n                output: user_buffer,\n                contract_key,\n            }\n        }\n        Err(err) =\u003e InitResult::Failure { err },\n    }\n}\n\n/// This struct is returned from a handle method.\npub struct HandleSuccess {\n    /// The output of the calculation\n    pub output: Vec\u003cu8\u003e,\n}\n\npub fn result_handle_success_to_handleresult(\n    result: Result\u003cHandleSuccess, EnclaveError\u003e,\n) -\u003e HandleResult {\n    match result {\n        Ok(HandleSuccess { output }) =\u003e {\n            let user_buffer = unsafe {\n                let mut user_buffer = std::mem::MaybeUninit::\u003cUserSpaceBuffer\u003e::uninit();\n                match ocall_allocate(user_buffer.as_mut_ptr(), output.as_ptr(), output.len()) {\n                    sgx_status_t::SGX_SUCCESS =\u003e { /* continue */ }\n                    _ =\u003e {\n                        return HandleResult::Failure {\n                            err: EnclaveError::FailedOcall {\n                                vm_error: UntrustedVmError::default(),\n                            },\n                        }\n                    }\n                }\n                user_buffer.assume_init()\n            };\n            HandleResult::Success {\n                output: user_buffer,\n            }\n        }\n        Err(err) =\u003e HandleResult::Failure { err },\n    }\n}\n\n/// This struct is returned from a query method.\npub struct QuerySuccess {\n    /// The output of the calculation\n    pub output: Vec\u003cu8\u003e,\n}\n\npub fn result_query_success_to_queryresult(\n    result: Result\u003cQuerySuccess, EnclaveError\u003e,\n) -\u003e QueryResult {\n    match result {\n        Ok(QuerySuccess { output }) =\u003e {\n            let user_buffer = unsafe {\n                let mut user_buffer = std::mem::MaybeUninit::\u003cUserSpaceBuffer\u003e::uninit();\n                match ocall_allocate(user_buffer.as_mut_ptr(), output.as_ptr(), output.len()) {\n                    sgx_status_t::SGX_SUCCESS =\u003e { /* continue */ }\n                    _ =\u003e {\n                        return QueryResult::Failure {\n                            err: EnclaveError::FailedOcall {\n                                vm_error: UntrustedVmError::default(),\n                            },\n                        }\n                    }\n                }\n                user_buffer.assume_init()\n            };\n            QueryResult::Success {\n                output: user_buffer,\n            }\n        }\n        Err(err) =\u003e QueryResult::Failure { err },\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","storage.rs"],"content":"use crate::utils::UnwrapOrSgxErrorUnexpected;\n\nuse sgx_types::*;\nuse std::io::Write;\nuse std::untrusted::fs::File;\n\npub fn write_to_untrusted(bytes: \u0026[u8], filepath: \u0026str) -\u003e SgxResult\u003c()\u003e {\n    let mut f = File::create(filepath)\n        .sgx_error_with_log(\u0026format!(\"Creating file '{}' failed\", filepath))?;\n    f.write_all(bytes)\n        .sgx_error_with_log(\"[Enclave] Writing File failed!\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","tests.rs"],"content":"#[cfg(not(feature = \"test\"))]\n#[no_mangle]\npub extern \"C\" fn ecall_run_tests() -\u003e u32 {\n    println!(\"This enclave was not built for running tests.\");\n    0\n}\n\n#[cfg(feature = \"test\")]\nmod test {\n    /// Catch failures like the standard test runner, and print similar information per test.\n    /// Tests can only fail by panicking, not by returning a `Result` type.\n    #[macro_export]\n    macro_rules! count_failures {\n        ( $counter: ident, { $($test: expr;)* } ) =\u003e {\n            $(\n                print!(\"test {} ... \", std::stringify!($test));\n                match std::panic::catch_unwind(|| $test) {\n                    Ok(_) =\u003e println!(\"ok\"),\n                    Err(_) =\u003e {\n                        $counter += 1;\n                        println!(\"FAILED\");\n                    }\n                }\n            )*\n        }\n    }\n\n    #[no_mangle]\n    pub extern \"C\" fn ecall_run_tests() -\u003e u32 {\n        println!(\"Running tests!\");\n\n        let mut failures = 0;\n\n        count_failures!(failures, {\n            // This line is commented out because it was creating a file without removing it, which was annoying.\n            // crate::registration::tests::run_tests();\n            crate::crypto::tests::run_tests();\n            crate::wasm::tests::run_tests();\n            crate::registration::tests::run_tests();\n            crate::logging_tests::run_tests();\n\n            // example failing tests:\n            // panic!(\"AAAAA\");\n            // panic!(\"BBBBB\");\n        });\n\n        failures\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","utils.rs"],"content":"use log::*;\n\nuse sgx_trts::trts::{\n    rsgx_lfence, rsgx_raw_is_outside_enclave, rsgx_sfence, rsgx_slice_is_outside_enclave,\n};\nuse sgx_types::*;\n\nuse crate::crypto::KeyPair;\nuse crate::registration::create_attestation_certificate;\nuse crate::storage::write_to_untrusted;\n\npub trait UnwrapOrSgxErrorUnexpected {\n    type ReturnType;\n    fn sgx_error(self) -\u003e Result\u003cSelf::ReturnType, sgx_status_t\u003e;\n    fn sgx_error_with_log(self, err_mgs: \u0026str) -\u003e Result\u003cSelf::ReturnType, sgx_status_t\u003e;\n}\n\nimpl\u003cT, S\u003e UnwrapOrSgxErrorUnexpected for Result\u003cT, S\u003e {\n    type ReturnType = T;\n    fn sgx_error(self) -\u003e Result\u003cSelf::ReturnType, sgx_status_t\u003e {\n        match self {\n            Ok(r) =\u003e Ok(r),\n            Err(_) =\u003e Err(sgx_status_t::SGX_ERROR_UNEXPECTED),\n        }\n    }\n\n    fn sgx_error_with_log(self, log_msg: \u0026str) -\u003e Result\u003cSelf::ReturnType, sgx_status_t\u003e {\n        match self {\n            Ok(r) =\u003e Ok(r),\n            Err(_) =\u003e {\n                error!(\"{}\", log_msg);\n                Err(sgx_status_t::SGX_ERROR_UNEXPECTED)\n            }\n        }\n    }\n}\n\npub fn validate_mut_ptr(ptr: *mut u8, ptr_len: usize) -\u003e SgxResult\u003c()\u003e {\n    if rsgx_raw_is_outside_enclave(ptr, ptr_len) {\n        warn!(\"Tried to access memory outside enclave -- rsgx_slice_is_outside_enclave\");\n        return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);\n    }\n    rsgx_sfence();\n    Ok(())\n}\n\npub fn validate_const_ptr(ptr: *const u8, ptr_len: usize) -\u003e SgxResult\u003c()\u003e {\n    if ptr.is_null() || ptr_len == 0 {\n        warn!(\"Tried to access an empty pointer - ptr.is_null()\");\n        return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);\n    }\n    rsgx_lfence();\n    Ok(())\n}\n\npub fn validate_mut_slice(mut_slice: \u0026mut [u8]) -\u003e SgxResult\u003c()\u003e {\n    if rsgx_slice_is_outside_enclave(mut_slice) {\n        warn!(\"Tried to access memory outside enclave -- rsgx_slice_is_outside_enclave\");\n        return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);\n    }\n    rsgx_sfence();\n    Ok(())\n}\n\npub fn attest_from_key(\n    kp: \u0026KeyPair,\n    save_path: \u0026str,\n    spid: \u0026[u8],\n    api_key: \u0026[u8],\n) -\u003e SgxResult\u003c()\u003e {\n    let (_, cert) = match create_attestation_certificate(\n        \u0026kp,\n        sgx_quote_sign_type_t::SGX_UNLINKABLE_SIGNATURE,\n        spid,\n        api_key,\n    ) {\n        Err(e) =\u003e {\n            error!(\"Error in create_attestation_certificate: {:?}\", e);\n            return Err(e);\n        }\n        Ok(res) =\u003e res,\n    };\n\n    if let Err(status) = write_to_untrusted(cert.as_slice(), save_path) {\n        return Err(status);\n    }\n\n    Ok(())\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","contract_operations.rs"],"content":"use log::*;\nuse parity_wasm::elements;\nuse parity_wasm::elements::Module;\nuse wasmi::ModuleInstance;\n\nuse enclave_ffi_types::{Ctx, EnclaveError};\n\nuse crate::cosmwasm::types::{CanonicalAddr, Env, SigInfo};\nuse crate::crypto::Ed25519PublicKey;\nuse crate::results::{HandleSuccess, InitSuccess, QuerySuccess};\nuse crate::wasm::types::{IoNonce, SecretMessage};\n\nuse super::contract_validation::{\n    calc_contract_hash, extract_contract_key, generate_encryption_key, validate_contract_key,\n    validate_msg, verify_params, ContractKey, CONTRACT_KEY_LENGTH,\n};\nuse super::gas::{gas_rules, WasmCosts};\nuse super::io::encrypt_output;\nuse super::{\n    memory::validate_memory,\n    runtime::{create_builder, ContractInstance, ContractOperation, Engine, WasmiImportResolver},\n};\n\nuse crate::coalesce;\nuse crate::cosmwasm::encoding::Binary;\n\n/*\nEach contract is compiled with these functions already implemented in wasm:\nfn cosmwasm_api_0_6() -\u003e i32;  // Seems unused, but we should support it anyways\nfn allocate(size: usize) -\u003e *mut c_void;\nfn deallocate(pointer: *mut c_void);\nfn init(env_ptr: *mut c_void, msg_ptr: *mut c_void) -\u003e *mut c_void\nfn handle(env_ptr: *mut c_void, msg_ptr: *mut c_void) -\u003e *mut c_void\nfn query(msg_ptr: *mut c_void) -\u003e *mut c_void\n\nRe `init`, `handle` and `query`: We need to pass `env` \u0026 `msg`\ndown to the wasm implementations, but because they are buffers\nwe need to allocate memory regions inside the VM's instance and copy\n`env` \u0026 `msg` into those memory regions inside the VM's instance.\n*/\n\npub fn init(\n    context: Ctx,       // need to pass this to read_db \u0026 write_db\n    gas_limit: u64,     // gas limit for this execution\n    used_gas: \u0026mut u64, // out-parameter for gas used in execution\n    contract: \u0026[u8],    // contract wasm bytes\n    env: \u0026[u8],         // blockchain state\n    msg: \u0026[u8],         // probably function call and args\n    sig_info: \u0026[u8],    // info about signature verification\n) -\u003e Result\u003cInitSuccess, EnclaveError\u003e {\n    let mut parsed_env: Env = serde_json::from_slice(env).map_err(|err| {\n        warn!(\n            \"got an error while trying to deserialize env input bytes into json {:?}: {}\",\n            String::from_utf8_lossy(\u0026env),\n            err\n        );\n        EnclaveError::FailedToDeserialize\n    })?;\n\n    let canonical_contract_address = CanonicalAddr::from_human(\u0026parsed_env.contract.address).map_err(|err| {\n        warn!(\n            \"got an error while trying to deserialize parsed_env.contract.address from bech32 string to bytes {:?}: {}\",\n            parsed_env.contract.address, err\n        );\n        EnclaveError::FailedToDeserialize\n    })?;\n    let contract_key =\n        generate_encryption_key(\u0026parsed_env, contract, \u0026(canonical_contract_address.0).0)?;\n    trace!(\"Init: Contract Key: {:?}\", contract_key.to_vec().as_slice());\n\n    let parsed_sig_info: SigInfo = serde_json::from_slice(sig_info).map_err(|err| {\n        warn!(\n            \"got an error while trying to deserialize env input bytes into json {:?}: {}\",\n            String::from_utf8_lossy(\u0026sig_info),\n            err\n        );\n        EnclaveError::FailedToDeserialize\n    })?;\n\n    let secret_msg = SecretMessage::from_slice(msg)?;\n    trace!(\n        \"Init input before decryption: {:?}\",\n        String::from_utf8_lossy(\u0026msg)\n    );\n\n    verify_params(\u0026parsed_sig_info, \u0026parsed_env, \u0026secret_msg)?;\n\n    let decrypted_msg = secret_msg.decrypt()?;\n\n    let validated_msg = validate_msg(\u0026decrypted_msg, contract)?;\n\n    trace!(\n        \"Init input after decryption: {:?}\",\n        String::from_utf8_lossy(\u0026validated_msg)\n    );\n\n    let mut engine = start_engine(\n        context,\n        gas_limit,\n        contract,\n        \u0026contract_key,\n        ContractOperation::Init,\n        secret_msg.nonce,\n        secret_msg.user_public_key,\n    )?;\n\n    parsed_env.contract_code_hash = hex::encode(calc_contract_hash(contract));\n\n    let new_env = serde_json::to_vec(\u0026parsed_env).map_err(|err| {\n        warn!(\n            \"got an error while trying to serialize parsed_env into bytes {:?}: {}\",\n            parsed_env, err\n        );\n        EnclaveError::FailedToSerialize\n    })?;\n\n    let env_ptr = engine.write_to_memory(\u0026new_env)?;\n    let msg_ptr = engine.write_to_memory(\u0026validated_msg)?;\n\n    // This wrapper is used to coalesce all errors in this block to one object\n    // so we can `.map_err()` in one place for all of them\n    let output = coalesce!(EnclaveError, {\n        let vec_ptr = engine.init(env_ptr, msg_ptr)?;\n        let output = engine.extract_vector(vec_ptr)?;\n        // TODO: copy cosmwasm's structures to enclave\n        // TODO: ref: https://github.com/CosmWasm/cosmwasm/blob/b971c037a773bf6a5f5d08a88485113d9b9e8e7b/packages/std/src/init_handle.rs#L129\n        // TODO: ref: https://github.com/CosmWasm/cosmwasm/blob/b971c037a773bf6a5f5d08a88485113d9b9e8e7b/packages/std/src/query.rs#L13\n        let output = encrypt_output(\n            output,\n            secret_msg.nonce,\n            secret_msg.user_public_key,\n            \u0026canonical_contract_address,\n        )?;\n\n        Ok(output)\n    })\n    .map_err(|err| {\n        *used_gas = engine.gas_used();\n        err\n    })?;\n\n    *used_gas = engine.gas_used();\n    // todo: can move the key to somewhere in the output message if we want\n\n    Ok(InitSuccess {\n        output,\n        contract_key,\n    })\n}\n\npub fn handle(\n    context: Ctx,\n    gas_limit: u64,\n    used_gas: \u0026mut u64,\n    contract: \u0026[u8],\n    env: \u0026[u8],\n    msg: \u0026[u8],\n    sig_info: \u0026[u8],\n) -\u003e Result\u003cHandleSuccess, EnclaveError\u003e {\n    let mut parsed_env: Env = serde_json::from_slice(env).map_err(|err| {\n        warn!(\n            \"got an error while trying to deserialize env input bytes into json {:?}: {}\",\n            env, err\n        );\n        EnclaveError::FailedToDeserialize\n    })?;\n\n    trace!(\"handle parsed_env: {:?}\", parsed_env);\n\n    let parsed_sig_info: SigInfo = serde_json::from_slice(sig_info).map_err(|err| {\n        warn!(\n            \"got an error while trying to deserialize env input bytes into json {:?}: {}\",\n            String::from_utf8_lossy(\u0026sig_info),\n            err\n        );\n        EnclaveError::FailedToDeserialize\n    })?;\n\n    let secret_msg = SecretMessage::from_slice(msg)?;\n\n    // Verify env parameters against the signed tx\n    verify_params(\u0026parsed_sig_info, \u0026parsed_env, \u0026secret_msg)?;\n\n    let contract_key = extract_contract_key(\u0026parsed_env)?;\n\n    let secret_msg = SecretMessage::from_slice(msg)?;\n    let decrypted_msg = secret_msg.decrypt()?;\n\n    let validated_msg = validate_msg(\u0026decrypted_msg, contract)?;\n\n    trace!(\n        \"Handle input afer decryption: {:?}\",\n        String::from_utf8_lossy(\u0026validated_msg)\n    );\n\n    let canonical_contract_address = CanonicalAddr::from_human(\u0026parsed_env.contract.address).map_err(|err| {\n        warn!(\n            \"got an error while trying to deserialize parsed_env.contract.address from bech32 string to bytes {:?}: {}\",\n            parsed_env.contract.address, err\n        );\n        EnclaveError::FailedToDeserialize\n    })?;\n\n    if !validate_contract_key(\u0026contract_key, \u0026(canonical_contract_address.0).0, contract) {\n        warn!(\"got an error while trying to deserialize output bytes\");\n        return Err(EnclaveError::FailedContractAuthentication);\n    }\n\n    trace!(\"Successfully authenticated the contract!\");\n\n    trace!(\n        \"Handle: Contract Key: {:?}\",\n        contract_key.to_vec().as_slice()\n    );\n\n    let mut engine = start_engine(\n        context,\n        gas_limit,\n        contract,\n        \u0026contract_key,\n        ContractOperation::Handle,\n        secret_msg.nonce,\n        secret_msg.user_public_key,\n    )?;\n\n    parsed_env.contract_code_hash = hex::encode(calc_contract_hash(contract));\n\n    let new_env = serde_json::to_vec(\u0026parsed_env).map_err(|err| {\n        warn!(\n            \"got an error while trying to serialize parsed_env into bytes {:?}: {}\",\n            parsed_env, err\n        );\n        EnclaveError::FailedToSerialize\n    })?;\n\n    let env_ptr = engine.write_to_memory(\u0026new_env)?;\n    let msg_ptr = engine.write_to_memory(\u0026validated_msg)?;\n\n    // This wrapper is used to coalesce all errors in this block to one object\n    // so we can `.map_err()` in one place for all of them\n    let output = coalesce!(EnclaveError, {\n        let vec_ptr = engine.handle(env_ptr, msg_ptr)?;\n\n        let output = engine.extract_vector(vec_ptr)?;\n\n        debug!(\n            \"(2) nonce just before encrypt_output: nonce = {:?} pubkey = {:?}\",\n            secret_msg.nonce, secret_msg.user_public_key\n        );\n        let output = encrypt_output(\n            output,\n            secret_msg.nonce,\n            secret_msg.user_public_key,\n            \u0026canonical_contract_address,\n        )?;\n        Ok(output)\n    })\n    .map_err(|err| {\n        *used_gas = engine.gas_used();\n        err\n    })?;\n\n    *used_gas = engine.gas_used();\n    Ok(HandleSuccess { output })\n}\n\npub fn query(\n    context: Ctx,\n    gas_limit: u64,\n    used_gas: \u0026mut u64,\n    contract: \u0026[u8],\n    msg: \u0026[u8],\n) -\u003e Result\u003cQuerySuccess, EnclaveError\u003e {\n    if msg.len() \u003c CONTRACT_KEY_LENGTH {\n        warn!(\"Input query is shorter than the minimum expected. Msg is malformed\");\n        return Err(EnclaveError::FailedFunctionCall);\n    }\n\n    let (key, msg) = msg.split_at(CONTRACT_KEY_LENGTH);\n\n    let mut contract_key = [0; CONTRACT_KEY_LENGTH];\n    contract_key.copy_from_slice(key);\n\n    trace!(\n        \"Query: Contract Key: {:?}\",\n        contract_key.to_vec().as_slice()\n    );\n\n    let secret_msg = SecretMessage::from_slice(msg)?;\n    let decrypted_msg = secret_msg.decrypt()?;\n    trace!(\n        \"Query input afer decryption: {:?}\",\n        String::from_utf8_lossy(\u0026decrypted_msg)\n    );\n    let validated_msg = validate_msg(\u0026decrypted_msg, contract)?;\n\n    let mut engine = start_engine(\n        context,\n        gas_limit,\n        contract,\n        \u0026contract_key,\n        ContractOperation::Query,\n        secret_msg.nonce,\n        secret_msg.user_public_key,\n    )?;\n\n    let msg_ptr = engine.write_to_memory(\u0026validated_msg)?;\n\n    // This wrapper is used to coalesce all errors in this block to one object\n    // so we can `.map_err()` in one place for all of them\n    let output = coalesce!(EnclaveError, {\n        let vec_ptr = engine.query(msg_ptr)?;\n\n        let output = engine.extract_vector(vec_ptr)?;\n\n        let output = encrypt_output(\n            output,\n            secret_msg.nonce,\n            secret_msg.user_public_key,\n            \u0026CanonicalAddr(Binary(Vec::new())), // Not used for queries\n        )?;\n        Ok(output)\n    })\n    .map_err(|err| {\n        *used_gas = engine.gas_used();\n        err\n    })?;\n\n    *used_gas = engine.gas_used();\n    Ok(QuerySuccess { output })\n}\n\nfn start_engine(\n    context: Ctx,\n    gas_limit: u64,\n    contract: \u0026[u8],\n    contract_key: \u0026ContractKey,\n    operation: ContractOperation,\n    nonce: IoNonce,\n    user_public_key: Ed25519PublicKey,\n) -\u003e Result\u003cEngine, EnclaveError\u003e {\n    info!(\"Deserializing Wasm contract\");\n\n    // Create a parity-wasm module first, so we can inject gas metering to it\n    // (you need a parity-wasm module to use the pwasm-utils crate)\n    let mut p_modlue: Module =\n        elements::deserialize_buffer(contract).map_err(|_| EnclaveError::InvalidWasm)?;\n\n    info!(\"Deserialized Wasm contract\");\n\n    info!(\"Validating WASM memory demands\");\n\n    validate_memory(\u0026mut p_modlue)?;\n\n    info!(\"Validated WASM memory demands\");\n\n    // Set the gas costs for wasm op-codes (there is an inline stack_height limit in WasmCosts)\n    let wasm_costs = WasmCosts::default();\n\n    // Inject gas metering to pwasm module\n    let contract_module = pwasm_utils::inject_gas_counter(p_modlue, \u0026gas_rules(\u0026wasm_costs))\n        .map_err(|_| EnclaveError::FailedGasMeteringInjection)?;\n\n    info!(\"Trying to create Wasmi module from parity...\");\n\n    // Create a wasmi module from the parity module\n    let module = wasmi::Module::from_parity_wasm_module(contract_module)\n        .map_err(|_err| EnclaveError::InvalidWasm)?;\n\n    info!(\"Created Wasmi module from parity. Now checking for floating points...\");\n\n    module\n        .deny_floating_point()\n        .map_err(|_err| EnclaveError::WasmModuleWithFP)?;\n\n    // Create new imports resolver.\n    // These are the signatures of rust functions available to invoke from wasm code.\n    let resolver = WasmiImportResolver {};\n    let imports_builder = create_builder(\u0026resolver);\n\n    // Instantiate a module with our imports and assert that there is no `start` function.\n    let module_instance = ModuleInstance::new(\u0026module, \u0026imports_builder).map_err(|err| {\n        warn!(\"Error in instantiation: {:?}\", err);\n        EnclaveError::InvalidWasm\n    })?;\n    if module_instance.has_start() {\n        return Err(EnclaveError::WasmModuleWithStart);\n    }\n    let module = module_instance.not_started_instance().clone();\n\n    let contract_instance = ContractInstance::new(\n        context,\n        module.clone(),\n        gas_limit,\n        wasm_costs,\n        *contract_key,\n        operation,\n        nonce,\n        user_public_key,\n    );\n\n    Ok(Engine::new(contract_instance, module))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","contract_validation.rs"],"content":"use log::*;\n\nuse crate::cosmwasm::encoding::Binary;\nuse crate::cosmwasm::types::{\n    CanonicalAddr, CosmosSignature, Env, SigInfo, SignDoc, SignDocWasmMsg,\n};\nuse crate::crypto::traits::PubKey;\nuse crate::crypto::{sha_256, AESKey, Hmac, Kdf, HASH_SIZE, KEY_MANAGER};\nuse crate::wasm::io;\nuse crate::wasm::types::SecretMessage;\nuse enclave_ffi_types::EnclaveError;\n\npub type ContractKey = [u8; CONTRACT_KEY_LENGTH];\n\npub const CONTRACT_KEY_LENGTH: usize = HASH_SIZE + HASH_SIZE;\n\nconst HEX_ENCODED_HASH_SIZE: usize = HASH_SIZE * 2;\n\npub fn generate_encryption_key(\n    env: \u0026Env,\n    contract: \u0026[u8],\n    contract_address: \u0026[u8],\n) -\u003e Result\u003c[u8; CONTRACT_KEY_LENGTH], EnclaveError\u003e {\n    let consensus_state_ikm = KEY_MANAGER.get_consensus_state_ikm().unwrap();\n\n    let contract_hash = calc_contract_hash(contract);\n\n    let (_, sender_address_u5) = bech32::decode(env.message.sender.as_str()).map_err(|err| {\n        warn!(\n            \"got an error while trying to deserialize env.message.sender from bech32 string to bytes {:?}: {}\",\n            env.message.sender, err\n        );\n        EnclaveError::FailedToDeserialize\n    })?;\n    let snder_address: Vec\u003cu8\u003e = sender_address_u5.iter().map(|x| x.to_u8()).collect();\n\n    let sender_id = generate_sender_id(\u0026snder_address, env.block.height as u64);\n\n    let mut encryption_key = [0u8; 64];\n\n    let authenticated_contract_id = generate_contract_id(\n        \u0026consensus_state_ikm,\n        \u0026sender_id,\n        \u0026contract_hash,\n        contract_address,\n    );\n\n    encryption_key[0..32].copy_from_slice(\u0026sender_id);\n    encryption_key[32..].copy_from_slice(\u0026authenticated_contract_id);\n\n    Ok(encryption_key)\n}\n\npub fn extract_contract_key(env: \u0026Env) -\u003e Result\u003c[u8; CONTRACT_KEY_LENGTH], EnclaveError\u003e {\n    if env.contract_key.is_none() {\n        warn!(\"Contract execute with empty contract key\");\n        return Err(EnclaveError::FailedContractAuthentication);\n    }\n\n    let contract_key =\n        base64::decode(env.contract_key.as_ref().unwrap().as_bytes()).map_err(|err| {\n            warn!(\n                \"got an error while trying to deserialize output bytes into json {:?}: {}\",\n                env, err\n            );\n            EnclaveError::FailedContractAuthentication\n        })?;\n\n    if contract_key.len() != CONTRACT_KEY_LENGTH {\n        warn!(\"Contract execute with empty contract key\");\n        return Err(EnclaveError::FailedContractAuthentication);\n    }\n\n    let mut key_as_bytes = [0u8; CONTRACT_KEY_LENGTH];\n\n    key_as_bytes.copy_from_slice(\u0026contract_key);\n\n    Ok(key_as_bytes)\n}\n\npub fn generate_sender_id(msg_sender: \u0026[u8], block_height: u64) -\u003e [u8; HASH_SIZE] {\n    let mut input_data = msg_sender.to_vec();\n    input_data.extend_from_slice(\u0026block_height.to_be_bytes());\n    sha_256(\u0026input_data)\n}\n\npub fn generate_contract_id(\n    consensus_state_ikm: \u0026AESKey,\n    sender_id: \u0026[u8; HASH_SIZE],\n    code_hash: \u0026[u8; HASH_SIZE],\n    contract_address: \u0026[u8],\n) -\u003e [u8; HASH_SIZE] {\n    let authentication_key = consensus_state_ikm.derive_key_from_this(sender_id.as_ref());\n\n    let mut input_data = sender_id.to_vec();\n    input_data.extend_from_slice(code_hash);\n    input_data.extend_from_slice(contract_address);\n    authentication_key.sign_sha_256(\u0026input_data)\n}\n\npub fn calc_contract_hash(contract_bytes: \u0026[u8]) -\u003e [u8; HASH_SIZE] {\n    sha_256(\u0026contract_bytes)\n}\n\npub fn validate_contract_key(\n    contract_key: \u0026[u8; CONTRACT_KEY_LENGTH],\n    contract_address: \u0026[u8],\n    contract_code: \u0026[u8],\n) -\u003e bool {\n    // parse contract key -\u003e \u003c signer_id || authentication_code \u003e\n    let mut signer_id: [u8; HASH_SIZE] = [0u8; HASH_SIZE];\n    signer_id.copy_from_slice(\u0026contract_key[0..HASH_SIZE]);\n\n    let mut expected_authentication_id: [u8; HASH_SIZE] = [0u8; HASH_SIZE];\n    expected_authentication_id.copy_from_slice(\u0026contract_key[HASH_SIZE..]);\n\n    // calculate contract hash\n    let contract_hash = calc_contract_hash(contract_code);\n\n    // get the enclave key\n    let enclave_key = KEY_MANAGER\n        .get_consensus_state_ikm()\n        .map_err(|_err| {\n            warn!(\"Error extracting consensus_state_key\");\n            false\n        })\n        .unwrap();\n\n    // calculate the authentication_id\n    let calculated_authentication_id =\n        generate_contract_id(\u0026enclave_key, \u0026signer_id, \u0026contract_hash, contract_address);\n\n    calculated_authentication_id == expected_authentication_id\n}\n\npub fn validate_msg(msg: \u0026[u8], contract_code: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, EnclaveError\u003e {\n    if msg.len() \u003c HEX_ENCODED_HASH_SIZE {\n        warn!(\"Malformed message - expected contract code hash to be prepended to the msg\");\n        return Err(EnclaveError::ValidationFailure);\n    }\n\n    let calc_contract_hash = calc_contract_hash(contract_code);\n\n    let mut received_contract_hash: [u8; HEX_ENCODED_HASH_SIZE] = [0u8; HEX_ENCODED_HASH_SIZE];\n    received_contract_hash.copy_from_slice(\u0026msg[0..HEX_ENCODED_HASH_SIZE]);\n\n    let decoded_hash: Vec\u003cu8\u003e = hex::decode(\u0026received_contract_hash[..]).map_err(|_| {\n        warn!(\"Got message with malformed contract hash\");\n        EnclaveError::ValidationFailure\n    })?;\n\n    if decoded_hash != calc_contract_hash {\n        warn!(\"Message contains mismatched contract hash\");\n        return Err(EnclaveError::ValidationFailure);\n    }\n\n    Ok(msg[HEX_ENCODED_HASH_SIZE..].to_vec())\n}\n\npub fn verify_params(\n    sig_info: \u0026SigInfo,\n    env: \u0026Env,\n    msg: \u0026SecretMessage,\n) -\u003e Result\u003c(), EnclaveError\u003e {\n    info!(\"Verifying message signatures..\");\n\n    // If there's no callback signature - it's not a callback and there has to be a tx signer + signature\n    if let Some(callback_sig) = \u0026sig_info.callback_sig {\n        if verify_callback_sig(\n            callback_sig.as_slice(),\n            \u0026CanonicalAddr::from_human(\u0026env.message.sender)\n                .or(Err(EnclaveError::FailedToSerialize))?,\n            msg,\n        ) {\n            info!(\"Message verified! msg.sender is the calling contract\");\n            return Ok(());\n        }\n\n        warn!(\"Callback signature verification failed\");\n    } else {\n        trace!(\n            \"Sign bytes are: {:?}\",\n            String::from_utf8_lossy(sig_info.sign_bytes.as_slice())\n        );\n\n        let sign_doc: SignDoc =\n            serde_json::from_slice(sig_info.sign_bytes.as_slice()).map_err(|err| {\n                warn!(\n                    \"got an error while trying to deserialize sign doc bytes into json {:?}: {}\",\n                    sig_info.sign_bytes.as_slice(),\n                    err\n                );\n                EnclaveError::FailedToDeserialize\n            })?;\n\n        trace!(\"sign doc: {:?}\", sign_doc);\n\n        // This verifies that signatures and sign bytes are self consistent\n        sig_info\n            .signature\n            .get_public_key()\n            .verify_bytes(\n                \u0026sig_info.sign_bytes.as_slice(),\n                \u0026sig_info.signature.get_signature().as_slice(),\n            )\n            .map_err(|err| {\n                warn!(\"Signature verification failed: {:?}\", err);\n                EnclaveError::FailedTxVerification\n            })?;\n\n        if verify_signature_params(\u0026sign_doc, sig_info, env, msg) {\n            info!(\"Parameters verified successfully\");\n            return Ok(());\n        }\n\n        warn!(\"Parameter verification failed\");\n    }\n\n    Err(EnclaveError::FailedTxVerification)\n}\n\nfn verify_callback_sig(\n    callback_signature: \u0026[u8],\n    sender: \u0026CanonicalAddr,\n    msg: \u0026SecretMessage,\n) -\u003e bool {\n    if callback_signature.is_empty() {\n        return false;\n    }\n\n    let callback_sig = io::create_callback_signature(sender, msg);\n\n    if !callback_signature.eq(callback_sig.as_slice()) {\n        trace!(\n            \"Contract signature does not match with the one sent: {:?}\",\n            callback_signature\n        );\n        return false;\n    }\n\n    true\n}\n\nfn verify_sender(signature: \u0026CosmosSignature, msg_sender: \u0026CanonicalAddr) -\u003e bool {\n    let sender_pubkey = signature.get_public_key();\n    let address = sender_pubkey.get_address();\n\n    if address.eq(\u0026msg_sender) {\n        return true;\n    }\n\n    false\n}\n\nfn get_verified_msg\u003c'a\u003e(\n    sign_doc: \u0026'a SignDoc,\n    sent_msg: \u0026'a SecretMessage,\n) -\u003e Option\u003c\u0026'a SignDocWasmMsg\u003e {\n    sign_doc.msgs.iter().find(|\u0026m| match m {\n        SignDocWasmMsg::Execute { msg, .. } | SignDocWasmMsg::Instantiate { init_msg: msg, .. } =\u003e {\n            let binary_msg_result = Binary::from_base64(msg);\n            if let Ok(binary_msg) = binary_msg_result {\n                return Binary(sent_msg.to_vec()) == binary_msg;\n            }\n\n            false\n        }\n    })\n}\n\nfn verify_contract(msg: \u0026SignDocWasmMsg, env: \u0026Env) -\u003e bool {\n    // Contract address is relevant only to execute, since during sending an instantiate message the contract address is not yet known\n    if let SignDocWasmMsg::Execute { contract, .. } = msg {\n        info!(\"Verifying contract address..\");\n        if env.contract.address != *contract {\n            trace!(\n                \"Contract address sent to enclave {:?} is not the same as the signed one {:?}\",\n                env.contract.address,\n                *contract\n            );\n            return false;\n        }\n    }\n\n    true\n}\n\nfn verify_funds(msg: \u0026SignDocWasmMsg, env: \u0026Env) -\u003e bool {\n    match msg {\n        SignDocWasmMsg::Execute { sent_funds, .. }\n        | SignDocWasmMsg::Instantiate {\n            init_funds: sent_funds,\n            ..\n        } =\u003e \u0026env.message.sent_funds == sent_funds,\n    }\n}\n\nfn verify_signature_params(\n    sign_doc: \u0026SignDoc,\n    sig_info: \u0026SigInfo,\n    env: \u0026Env,\n    sent_msg: \u0026SecretMessage,\n) -\u003e bool {\n    info!(\"Verifying sender..\");\n\n    let msg_sender = if let Ok(msg_sender) = CanonicalAddr::from_human(\u0026env.message.sender) {\n        msg_sender\n    } else {\n        return false;\n    };\n\n    if !verify_sender(\u0026sig_info.signature, \u0026msg_sender) {\n        warn!(\"Sender verification failed!\");\n        trace!(\n            \"Message sender {:?} does not match with the message signer {:?}\",\n            \u0026env.message.sender,\n            \u0026sig_info.signature.get_public_key().get_address()\n        );\n        return false;\n    }\n\n    info!(\"Verifying message..\");\n    // If msg is not found (is None) then it means message verification failed,\n    // since it didn't find a matching signed message\n    let msg = get_verified_msg(sign_doc, sent_msg);\n    if msg.is_none() {\n        warn!(\"Message verification failed!\");\n        trace!(\n            \"Message sent to contract {:?} is not equal to any signed messages {:?}\",\n            sent_msg.to_vec(),\n            sign_doc.msgs\n        );\n        return false;\n    }\n    let msg = msg.unwrap();\n\n    if !verify_contract(msg, env) {\n        warn!(\"Contract address verification failed!\");\n        return false;\n    }\n\n    info!(\"Verifying funds..\");\n    if !verify_funds(msg, env) {\n        warn!(\"Funds verification failed!\");\n        return false;\n    }\n\n    true\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","db.rs"],"content":"use super::contract_validation::ContractKey;\nuse super::errors::WasmEngineError;\nuse crate::crypto::{sha_256, AESKey, Kdf, SIVEncryptable, KEY_MANAGER};\nuse crate::{exports, imports};\n\nuse enclave_ffi_types::{Ctx, EnclaveBuffer, OcallReturn, UntrustedVmError};\n\nuse log::*;\nuse sgx_types::sgx_status_t;\n\npub fn write_encrypted_key(\n    key: \u0026[u8],\n    value: \u0026[u8],\n    context: \u0026Ctx,\n    contract_key: \u0026ContractKey,\n) -\u003e Result\u003cu64, WasmEngineError\u003e {\n    // Get the state key from the key manager\n\n    let scrambled_field_name = field_name_digest(key, contract_key);\n\n    info!(\n        \"Writing to scrambled field name: {:?}\",\n        scrambled_field_name\n    );\n\n    let (ad, ad_used_gas) = derive_ad_for_field(\u0026scrambled_field_name, \u0026context)?;\n\n    let encrypted_value = encrypt_key(\u0026scrambled_field_name, value, contract_key, \u0026ad)?;\n\n    let mut db_data: Vec\u003cu8\u003e = ad.to_vec();\n    db_data.extend_from_slice(encrypted_value.as_slice());\n\n    // Write the new data as concat(ad, encrypted_val)\n    let write_used_gas = write_db(context, \u0026scrambled_field_name, \u0026db_data).map_err(|err| {\n        warn!(\n            \"write_db() go an error from ocall_write_db, stopping wasm: {:?}\",\n            err\n        );\n        err\n    })?;\n\n    Ok(ad_used_gas + write_used_gas)\n}\n\npub fn read_encrypted_key(\n    key: \u0026[u8],\n    context: \u0026Ctx,\n    contract_key: \u0026ContractKey,\n) -\u003e Result\u003c(Option\u003cVec\u003cu8\u003e\u003e, u64), WasmEngineError\u003e {\n    let scrambled_field_name = field_name_digest(key, contract_key);\n\n    info!(\n        \"Reading from scrambled field name: {:?}\",\n        scrambled_field_name\n    );\n\n    // Call read_db (this bubbles up to Tendermint via ocalls and FFI to Go code)\n    // This returns the value from Tendermint\n    match read_db(context, \u0026scrambled_field_name) {\n        Ok((value, gas_used)) =\u003e match value {\n            Some(value) =\u003e match decrypt_key(\u0026scrambled_field_name, \u0026value, contract_key) {\n                Ok(decrypted) =\u003e Ok((Some(decrypted), gas_used)),\n                // This error case is why we have all the matches here.\n                // If we successfully collected a value, but failed to decrypt it, then we propagate that error.\n                Err(err) =\u003e Err(err),\n            },\n            None =\u003e Ok((None, gas_used)),\n        },\n        Err(err) =\u003e Err(err),\n    }\n}\n\npub fn remove_encrypted_key(\n    key: \u0026[u8],\n    context: \u0026Ctx,\n    contract_key: \u0026ContractKey,\n) -\u003e Result\u003cu64, WasmEngineError\u003e {\n    let scrambled_field_name = field_name_digest(key, contract_key);\n\n    info!(\"Removing scrambled field name: {:?}\", scrambled_field_name);\n\n    // Call remove_db (this bubbles up to Tendermint via ocalls and FFI to Go code)\n    // fn remove_db(context: Ctx, key: \u0026[u8]) {\n    let gas_used = remove_db(context, \u0026scrambled_field_name).map_err(|err| {\n        warn!(\n            \"remove_db() got an error from ocall_remove_db, stopping wasm: {:?}\",\n            err\n        );\n        err\n    })?;\n    Ok(gas_used)\n}\n\npub fn field_name_digest(field_name: \u0026[u8], contract_key: \u0026ContractKey) -\u003e [u8; 32] {\n    let mut data = field_name.to_vec();\n    data.extend_from_slice(contract_key);\n\n    sha_256(\u0026data)\n}\n\n/// Safe wrapper around reads from the contract storage\nfn read_db(context: \u0026Ctx, key: \u0026[u8]) -\u003e Result\u003c(Option\u003cVec\u003cu8\u003e\u003e, u64), WasmEngineError\u003e {\n    let mut ocall_return = OcallReturn::Success;\n    let mut enclave_buffer = std::mem::MaybeUninit::\u003cEnclaveBuffer\u003e::uninit();\n    let mut vm_err = UntrustedVmError::default();\n    let mut gas_used = 0_u64;\n    let value = unsafe {\n        let status = imports::ocall_read_db(\n            (\u0026mut ocall_return) as *mut _,\n            context.unsafe_clone(),\n            (\u0026mut vm_err) as *mut _,\n            (\u0026mut gas_used) as *mut _,\n            enclave_buffer.as_mut_ptr(),\n            key.as_ptr(),\n            key.len(),\n        );\n        match status {\n            sgx_status_t::SGX_SUCCESS =\u003e { /* continue */ }\n            error_status =\u003e {\n                warn!(\n                    \"read_db() got an error from ocall_read_db, stopping wasm: {:?}\",\n                    error_status\n                );\n                return Err(WasmEngineError::FailedOcall(vm_err));\n            }\n        }\n\n        match ocall_return {\n            OcallReturn::Success =\u003e {\n                let enclave_buffer = enclave_buffer.assume_init();\n                exports::recover_buffer(enclave_buffer)?\n            }\n            OcallReturn::Failure =\u003e {\n                return Err(WasmEngineError::FailedOcall(vm_err));\n            }\n            OcallReturn::Panic =\u003e return Err(WasmEngineError::Panic),\n        }\n    };\n\n    Ok((value, gas_used))\n}\n\n/// Safe wrapper around reads from the contract storage\nfn remove_db(context: \u0026Ctx, key: \u0026[u8]) -\u003e Result\u003cu64, WasmEngineError\u003e {\n    let mut ocall_return = OcallReturn::Success;\n    let mut vm_err = UntrustedVmError::default();\n    let mut gas_used = 0_u64;\n    match unsafe {\n        imports::ocall_remove_db(\n            (\u0026mut ocall_return) as *mut _,\n            context.unsafe_clone(),\n            (\u0026mut vm_err) as *mut _,\n            (\u0026mut gas_used) as *mut _,\n            key.as_ptr(),\n            key.len(),\n        )\n    } {\n        sgx_status_t::SGX_SUCCESS =\u003e { /* continue */ }\n        _error_status =\u003e return Err(WasmEngineError::FailedOcall(vm_err)),\n    }\n\n    match ocall_return {\n        OcallReturn::Success =\u003e Ok(gas_used),\n        OcallReturn::Failure =\u003e Err(WasmEngineError::FailedOcall(vm_err)),\n        OcallReturn::Panic =\u003e Err(WasmEngineError::Panic),\n    }\n}\n\n/// Safe wrapper around writes to the contract storage\nfn write_db(context: \u0026Ctx, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003cu64, WasmEngineError\u003e {\n    let mut ocall_return = OcallReturn::Success;\n    let mut vm_err = UntrustedVmError::default();\n    let mut gas_used = 0_u64;\n    match unsafe {\n        imports::ocall_write_db(\n            (\u0026mut ocall_return) as *mut _,\n            context.unsafe_clone(),\n            (\u0026mut vm_err) as *mut _,\n            (\u0026mut gas_used) as *mut _,\n            key.as_ptr(),\n            key.len(),\n            value.as_ptr(),\n            value.len(),\n        )\n    } {\n        sgx_status_t::SGX_SUCCESS =\u003e { /* continue */ }\n        _err_status =\u003e return Err(WasmEngineError::FailedOcall(vm_err)),\n    }\n\n    match ocall_return {\n        OcallReturn::Success =\u003e Ok(gas_used),\n        OcallReturn::Failure =\u003e Err(WasmEngineError::FailedOcall(vm_err)),\n        OcallReturn::Panic =\u003e Err(WasmEngineError::Panic),\n    }\n}\n\nfn derive_ad_for_field(\n    field_name: \u0026[u8],\n    context: \u0026Ctx,\n) -\u003e Result\u003c([u8; 32], u64), WasmEngineError\u003e {\n    let (old_value, gas_used) = read_db(context, field_name)?;\n    let ad = sha_256(\n        old_value\n            .as_ref()\n            // Extract previous_ad to calculate the new ad (first 32 bytes)\n            .map(|old_value| old_value.split_at(32).0)\n            // No data exist yet for this state_key_name, so creating a new `ad`\n            .unwrap_or(field_name),\n    );\n    Ok((ad, gas_used))\n}\n\nfn encrypt_key(\n    field_name: \u0026[u8],\n    value: \u0026[u8],\n    contract_key: \u0026ContractKey,\n    ad: \u0026[u8],\n) -\u003e Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e {\n    let encryption_key = get_symmetrical_key(field_name, contract_key);\n\n    encryption_key\n        .encrypt_siv(\u0026value, Some(\u0026[ad]))\n        .map_err(|err| {\n            warn!(\n                \"write_db() got an error while trying to encrypt the value {:?}, stopping wasm: {:?}\",\n                String::from_utf8_lossy(\u0026value),\n                err\n            );\n            WasmEngineError::EncryptionError\n    })\n}\n\nfn decrypt_key(\n    field_name: \u0026[u8],\n    value: \u0026[u8],\n    contract_key: \u0026ContractKey,\n) -\u003e Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e {\n    let decryption_key = get_symmetrical_key(field_name, contract_key);\n\n    // Slice ad from `value`\n    let (ad, encrypted_value) = value.split_at(32);\n\n    decryption_key.decrypt_siv(\u0026encrypted_value, Some(\u0026[ad])).map_err(|err| {\n        warn!(\n            \"read_db() got an error while trying to decrypt the value for key {:?}, stopping wasm: {:?}\",\n            String::from_utf8_lossy(\u0026field_name),\n            err\n        );\n        WasmEngineError::DecryptionError\n    })\n}\n\nfn get_symmetrical_key(field_name: \u0026[u8], contract_key: \u0026ContractKey) -\u003e AESKey {\n    let consensus_state_ikm = KEY_MANAGER.get_consensus_state_ikm().unwrap();\n\n    // Derive the key to the specific field name\n    let mut derivation_data = field_name.to_vec();\n    derivation_data.extend_from_slice(contract_key.to_vec().as_slice());\n    consensus_state_ikm.derive_key_from_this(\u0026derivation_data)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","errors.rs"],"content":"use derive_more::Display;\nuse enclave_ffi_types::{EnclaveError, UntrustedVmError};\nuse log::*;\nuse wasmi::{Error as InterpreterError, HostError, TrapKind};\n\nuse crate::exports::BufferRecoveryError;\n\n#[derive(Debug, Display)]\n#[non_exhaustive]\npub enum WasmEngineError {\n    #[display(fmt = \"FailedOcall\")]\n    FailedOcall(UntrustedVmError),\n    HostMisbehavior,\n    OutOfGas,\n    Panic,\n\n    EncryptionError,\n    DecryptionError,\n    SerializationError,\n    DeserializationError,\n    // This is for unexpected error while processing base32 data.\n    Base32Error,\n\n    MemoryAllocationError,\n    MemoryReadError,\n    MemoryWriteError,\n    /// The contract attempted to write to storage during a query\n    UnauthorizedWrite,\n\n    NonExistentImportFunction,\n}\n\nimpl HostError for WasmEngineError {}\n\nimpl From\u003cWasmEngineError\u003e for EnclaveError {\n    fn from(engine_err: WasmEngineError) -\u003e Self {\n        use WasmEngineError::*;\n        match engine_err {\n            FailedOcall(vm_error) =\u003e EnclaveError::FailedOcall {\n                vm_error: UntrustedVmError { ptr: vm_error.ptr },\n            },\n            OutOfGas =\u003e EnclaveError::OutOfGas,\n            EncryptionError =\u003e EnclaveError::EncryptionError,\n            DecryptionError =\u003e EnclaveError::DecryptionError,\n            MemoryAllocationError =\u003e EnclaveError::MemoryAllocationError,\n            MemoryReadError =\u003e EnclaveError::MemoryReadError,\n            MemoryWriteError =\u003e EnclaveError::MemoryWriteError,\n            UnauthorizedWrite =\u003e EnclaveError::UnauthorizedWrite,\n            HostMisbehavior =\u003e EnclaveError::HostMisbehavior,\n            // Unexpected WasmEngineError variant\n            _other =\u003e EnclaveError::Unknown,\n        }\n    }\n}\n\nimpl From\u003cBufferRecoveryError\u003e for WasmEngineError {\n    fn from(_err: BufferRecoveryError) -\u003e Self {\n        WasmEngineError::HostMisbehavior\n    }\n}\n\n// This is implemented just to make a `Result::map` invocation below nicer.\n// All this does is unbox the `WasmEngineError` and call the `From` implementation above.\nimpl From\u003cBox\u003cWasmEngineError\u003e\u003e for EnclaveError {\n    fn from(engine_err: Box\u003cWasmEngineError\u003e) -\u003e Self {\n        Self::from(*engine_err)\n    }\n}\n\npub fn wasmi_error_to_enclave_error(wasmi_error: InterpreterError) -\u003e EnclaveError {\n    wasmi_error\n        .try_into_host_error()\n        .map(|host_error| {\n            host_error\n                .downcast::\u003cWasmEngineError\u003e()\n                .map_or(EnclaveError::Unknown, EnclaveError::from)\n        })\n        .unwrap_or_else(|wasmi_error| {\n            warn!(\"Got an error from wasmi: {:?}\", wasmi_error);\n            match wasmi_error {\n                InterpreterError::Trap(trap) =\u003e trap_kind_to_enclave_error(trap.into_kind()),\n                _ =\u003e EnclaveError::FailedFunctionCall,\n            }\n        })\n}\n\nfn trap_kind_to_enclave_error(kind: TrapKind) -\u003e EnclaveError {\n    match kind {\n        TrapKind::Unreachable =\u003e EnclaveError::ContractPanicUnreachable,\n        TrapKind::MemoryAccessOutOfBounds =\u003e EnclaveError::ContractPanicMemoryAccessOutOfBounds,\n        TrapKind::TableAccessOutOfBounds =\u003e EnclaveError::ContractPanicTableAccessOutOfBounds,\n        TrapKind::ElemUninitialized =\u003e EnclaveError::ContractPanicElemUninitialized,\n        TrapKind::DivisionByZero =\u003e EnclaveError::ContractPanicDivisionByZero,\n        TrapKind::InvalidConversionToInt =\u003e EnclaveError::ContractPanicInvalidConversionToInt,\n        TrapKind::StackOverflow =\u003e EnclaveError::ContractPanicStackOverflow,\n        TrapKind::UnexpectedSignature =\u003e EnclaveError::ContractPanicUnexpectedSignature,\n        // This is for cases that we don't care to represent, or were added in later versions of wasmi.\n        // Specifically `TrapKind::Host` should be handled in `wasmi_error_to_enclave_error` by calling\n        // `.as_host_error()` on the top-level error.\n        _ =\u003e EnclaveError::FailedFunctionCall,\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","gas.rs"],"content":"pub use pwasm_utils::{inject_gas_counter, rules};\n\n/// Wasm cost table\npub struct WasmCosts {\n    /// Default opcode cost\n    pub regular: u32,\n    /// Div operations multiplier.\n    pub div: u32,\n    /// Div operations multiplier.\n    pub mul: u32,\n    /// Memory (load/store) operations multiplier.\n    pub mem: u32,\n    /// General static query of U256 value from env-info\n    pub static_u256: u32,\n    /// General static query of Address value from env-info\n    pub static_address: u32,\n    /// Memory stipend. Amount of free memory (in 64kb pages) each contract can use for stack.\n    pub initial_mem: u32,\n    /// Grow memory cost, per page (64kb)\n    pub grow_mem: u32,\n    /// Memory copy cost, per byte\n    pub memcpy: u32,\n    /// Max stack height (native WebAssembly stack limiter)\n    pub max_stack_height: u32,\n    /// Cost of wasm opcode is calculated as TABLE_ENTRY_COST * `opcodes_mul` / `opcodes_div`\n    pub opcodes_mul: u32,\n    /// Cost of wasm opcode is calculated as TABLE_ENTRY_COST * `opcodes_mul` / `opcodes_div`\n    pub opcodes_div: u32,\n    /// Cost invoking humanize_address from WASM\n    pub external_humanize_address: u32,\n    /// Cost invoking canonicalize_address from WASM\n    pub external_canonicalize_address: u32,\n}\n\nimpl Default for WasmCosts {\n    fn default() -\u003e Self {\n        WasmCosts {\n            regular: 1,\n            div: 16,\n            mul: 4,\n            mem: 2,\n            static_u256: 64,\n            static_address: 40,\n            initial_mem: 8192,\n            grow_mem: 8192,\n            memcpy: 1,\n            max_stack_height: 64 * 1024, // Assaf: I don't think this goes anywhere\n            opcodes_mul: 3,\n            opcodes_div: 8,\n            external_humanize_address: 8192,\n            external_canonicalize_address: 8192,\n        }\n    }\n}\n\npub fn gas_rules(wasm_costs: \u0026WasmCosts) -\u003e rules::Set {\n    rules::Set::new(wasm_costs.regular, {\n        let mut vals = ::std::collections::BTreeMap::new();\n        vals.insert(\n            rules::InstructionType::Load,\n            rules::Metering::Fixed(wasm_costs.mem as u32),\n        );\n        vals.insert(\n            rules::InstructionType::Store,\n            rules::Metering::Fixed(wasm_costs.mem as u32),\n        );\n        vals.insert(\n            rules::InstructionType::Div,\n            rules::Metering::Fixed(wasm_costs.div as u32),\n        );\n        vals.insert(\n            rules::InstructionType::Mul,\n            rules::Metering::Fixed(wasm_costs.mul as u32),\n        );\n        vals.insert(\n            rules::InstructionType::CurrentMemory,\n            rules::Metering::Fixed(wasm_costs.initial_mem as u32),\n        );\n        vals\n    })\n    .with_grow_cost(wasm_costs.grow_mem)\n}\n\n#[derive(Debug, Clone)]\npub struct RuntimeWasmCosts {\n    pub write_value: u64,\n    pub write_additional_byte: u64,\n    pub deploy_byte: u64,\n    pub execution: u64,\n}\n\nimpl Default for RuntimeWasmCosts {\n    fn default() -\u003e Self {\n        RuntimeWasmCosts {\n            write_value: 10,\n            write_additional_byte: 1,\n            deploy_byte: 1,\n            execution: 10_000,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct RuntimeGas {\n    pub counter: u64,\n    pub limit: u64,\n    pub refund: u64,\n    pub costs: RuntimeWasmCosts,\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","io.rs"],"content":"/// This contains all the user-facing functions. In these functions we will be using\n/// the consensus_io_exchange_keypair and a user-generated key to create a symmetric key\n/// that is unique to the user and the enclave\n///\nuse super::types::{IoNonce, SecretMessage};\n\nuse crate::cosmwasm::encoding::Binary;\nuse crate::cosmwasm::types::{CanonicalAddr, CosmosMsg, WasmMsg, WasmOutput};\nuse crate::crypto::{AESKey, Ed25519PublicKey, Kdf, SIVEncryptable, KEY_MANAGER};\nuse enclave_ffi_types::EnclaveError;\nuse log::*;\nuse serde::Serialize;\nuse serde_json::json;\nuse sha2::Digest;\n\npub fn calc_encryption_key(nonce: \u0026IoNonce, user_public_key: \u0026Ed25519PublicKey) -\u003e AESKey {\n    let enclave_io_key = KEY_MANAGER.get_consensus_io_exchange_keypair().unwrap();\n\n    let tx_encryption_ikm = enclave_io_key.diffie_hellman(user_public_key);\n\n    let tx_encryption_key = AESKey::new_from_slice(\u0026tx_encryption_ikm).derive_key_from_this(nonce);\n\n    trace!(\"rust tx_encryption_key {:?}\", tx_encryption_key.get());\n\n    tx_encryption_key\n}\n\nfn encrypt_serializable\u003cT\u003e(key: \u0026AESKey, val: \u0026T) -\u003e Result\u003cString, EnclaveError\u003e\nwhere\n    T: ?Sized + Serialize,\n{\n    let serialized: String = serde_json::to_string(val).map_err(|err| {\n        debug!(\"got an error while trying to encrypt output error {}\", err);\n        EnclaveError::EncryptionError\n    })?;\n\n    // todo: think about if we should just move this function to handle only serde_json::Value::Strings\n    // instead of removing the extra quotes like this\n    let trimmed = serialized.trim_start_matches('\"').trim_end_matches('\"');\n\n    let encrypted_data = key.encrypt_siv(trimmed.as_bytes(), None).map_err(|err| {\n        debug!(\n            \"got an error while trying to encrypt output error {:?}: {}\",\n            err, err\n        );\n        EnclaveError::EncryptionError\n    })?;\n\n    Ok(b64_encode(encrypted_data.as_slice()))\n}\n\nfn b64_encode(data: \u0026[u8]) -\u003e String {\n    base64::encode(data)\n}\n\npub fn encrypt_output(\n    output: Vec\u003cu8\u003e,\n    nonce: IoNonce,\n    user_public_key: Ed25519PublicKey,\n    contract_addr: \u0026CanonicalAddr,\n) -\u003e Result\u003cVec\u003cu8\u003e, EnclaveError\u003e {\n    let key = calc_encryption_key(\u0026nonce, \u0026user_public_key);\n\n    trace!(\n        \"Output before encryption: {:?}\",\n        String::from_utf8_lossy(\u0026output)\n    );\n\n    let mut output: WasmOutput = serde_json::from_slice(\u0026output).map_err(|err| {\n        warn!(\"got an error while trying to deserialize output bytes into json\");\n        trace!(\"output: {:?} error: {:?}\", output, err);\n        EnclaveError::FailedToDeserialize\n    })?;\n\n    match \u0026mut output {\n        WasmOutput::ErrObject { err } =\u003e {\n            let encrypted_err = encrypt_serializable(\u0026key, err)?;\n\n            // Putting the error inside a 'generic_err' envelope, so we can encrypt the error itself\n            *err = json!({\"generic_err\":{\"msg\":encrypted_err}});\n        }\n\n        WasmOutput::OkString { ok } =\u003e {\n            *ok = encrypt_serializable(\u0026key, ok)?;\n        }\n\n        // Encrypt all Wasm messages (keeps Bank, Staking, etc.. as is)\n        WasmOutput::OkObject { ok } =\u003e {\n            for msg in \u0026mut ok.messages {\n                if let CosmosMsg::Wasm(wasm_msg) = msg {\n                    encrypt_wasm_msg(wasm_msg, nonce, user_public_key, contract_addr)?;\n                }\n            }\n\n            for log in \u0026mut ok.log {\n                log.key = encrypt_serializable(\u0026key, \u0026log.key)?;\n                log.value = encrypt_serializable(\u0026key, \u0026log.value)?;\n            }\n\n            if let Some(data) = \u0026mut ok.data {\n                *data = Binary::from_base64(\u0026encrypt_serializable(\u0026key, data)?)?;\n            }\n        }\n    };\n\n    trace!(\"WasmOutput: {:?}\", output);\n\n    let encrypted_output = serde_json::to_vec(\u0026output).map_err(|err| {\n        debug!(\n            \"got an error while trying to serialize output json into bytes {:?}: {}\",\n            output, err\n        );\n        EnclaveError::FailedToSerialize\n    })?;\n\n    Ok(encrypted_output)\n}\n\nfn encrypt_wasm_msg(\n    wasm_msg: \u0026mut WasmMsg,\n    nonce: IoNonce,\n    user_public_key: Ed25519PublicKey,\n    contract_addr: \u0026CanonicalAddr,\n) -\u003e Result\u003c(), EnclaveError\u003e {\n    match wasm_msg {\n        WasmMsg::Execute {\n            msg,\n            callback_code_hash,\n            callback_sig,\n            ..\n        }\n        | WasmMsg::Instantiate {\n            msg,\n            callback_code_hash,\n            callback_sig,\n            ..\n        } =\u003e {\n            let mut hash_appended_msg = callback_code_hash.as_bytes().to_vec();\n            hash_appended_msg.extend_from_slice(msg.as_slice());\n\n            let mut msg_to_pass = SecretMessage::from_base64(\n                Binary(hash_appended_msg).to_base64(),\n                nonce,\n                user_public_key,\n            )?;\n\n            msg_to_pass.encrypt_in_place()?;\n            *msg = Binary::from(msg_to_pass.to_vec().as_slice());\n\n            *callback_sig = Some(create_callback_signature(contract_addr, \u0026msg_to_pass));\n        }\n    }\n\n    Ok(())\n}\n\npub fn create_callback_signature(\n    contract_addr: \u0026CanonicalAddr,\n    msg_to_sign: \u0026SecretMessage,\n) -\u003e Vec\u003cu8\u003e {\n    // Hash(Enclave_secret | sender(current contract) | msg_to_pass)\n    let mut callback_sig_bytes = KEY_MANAGER\n        .get_consensus_callback_secret()\n        .unwrap()\n        .get()\n        .to_vec();\n\n    callback_sig_bytes.extend(contract_addr.as_slice());\n    callback_sig_bytes.extend(msg_to_sign.msg.as_slice());\n\n    sha2::Sha256::digest(callback_sig_bytes.as_slice()).to_vec()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","memory.rs"],"content":"use parity_wasm::elements::{MemoryType, Module};\n\nuse log::*;\n\nuse enclave_ffi_types::EnclaveError;\n\npub fn validate_memory(p_modlue: \u0026mut Module) -\u003e Result\u003c(), EnclaveError\u003e {\n    let memory_section = p_modlue\n        .memory_section_mut()\n        .ok_or(EnclaveError::CannotInitializeWasmMemory).map_err(|err| {\n            error!(\n                \"Error accessing memory section of WASM while trying to validate memory demands: {:?}\",\n                err\n            );\n            err\n        })?;\n\n    if memory_section.entries().len() != 1 {\n        error!(\n            \"WASM demands too many memory sections. Must be 1, demands {}\",\n            memory_section.entries().len()\n        );\n        return Err(EnclaveError::CannotInitializeWasmMemory);\n    }\n\n    let memory_entry = memory_section\n        .entries()\n        .first()\n        .ok_or(EnclaveError::CannotInitializeWasmMemory)\n        .map_err(|err| {\n            error!(\n                \"Error accessing memory entry of WASM while trying to validate memory demands: {:?}\",\n                err\n            );\n            err\n        })?;\n\n    let requested_initial_pages: u32 = memory_entry.limits().initial();\n    let maximum_allowed_pages: u32 = 192; // 12 MiB\n\n    if requested_initial_pages \u003e maximum_allowed_pages {\n        error!(\n            \"WASM Requested to initialize with {} pages, maximum allowed is {}\",\n            requested_initial_pages, maximum_allowed_pages\n        );\n        return Err(EnclaveError::CannotInitializeWasmMemory);\n    }\n\n    *memory_section.entries_mut() = vec![MemoryType::new(\n        requested_initial_pages,\n        Some(maximum_allowed_pages),\n    )];\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","mod.rs"],"content":"mod contract_operations;\nmod contract_validation;\nmod db;\nmod errors;\nmod gas;\nmod io;\nmod memory;\nmod query_chain;\nmod runtime;\nmod types;\n\npub use contract_operations::{handle, init, query};\n\n#[cfg(feature = \"test\")]\npub mod tests {\n    use super::*;\n    use crate::count_failures;\n\n    pub fn run_tests() {\n        println!();\n        let mut failures = 0;\n\n        count_failures!(failures, {\n            types::tests::test_new_from_slice();\n            // types::tests::test_msg_decrypt();\n        });\n\n        if failures != 0 {\n            panic!(\"{}: {} tests failed\", file!(), failures);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","query_chain.rs"],"content":"use super::errors::WasmEngineError;\nuse crate::crypto::Ed25519PublicKey;\nuse crate::recursion_depth;\nuse crate::wasm::types::{IoNonce, SecretMessage};\nuse crate::{exports, imports};\n\nuse crate::cosmwasm::{\n    encoding::Binary,\n    query::{QueryRequest, WasmQuery},\n    std_error::{StdError, StdResult},\n    system_error::{SystemError, SystemResult},\n};\n\nuse enclave_ffi_types::{Ctx, EnclaveBuffer, OcallReturn, UntrustedVmError};\nuse log::*;\nuse sgx_types::sgx_status_t;\n\npub fn encrypt_and_query_chain(\n    query: \u0026[u8],\n    context: \u0026Ctx,\n    nonce: IoNonce,\n    user_public_key: Ed25519PublicKey,\n    gas_used: \u0026mut u64,\n    gas_limit: u64,\n) -\u003e Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e {\n    if let Some(answer) = check_recursion_limit() {\n        return serialize_error_response(\u0026answer);\n    }\n\n    let mut query_struct: QueryRequest = match serde_json::from_slice(query) {\n        Ok(query_struct) =\u003e query_struct,\n        Err(err) =\u003e {\n            *gas_used = 500; // Should we charge gas for this to prevent spam?\n            return system_error_invalid_request(query, err);\n        }\n    };\n\n    let is_encrypted = encrypt_query_request(\u0026mut query_struct, nonce, user_public_key)?;\n\n    let encrypted_query = serde_json::to_vec(\u0026query_struct).map_err(|err| {\n        // this should never happen\n        debug!(\n            \"encrypt_and_query_chain() got an error while trying to serialize the query {:?} to pass to x/compute: {:?}\",\n            query_struct,\n            err\n        );\n        WasmEngineError::SerializationError\n    })?;\n\n    // Call query_chain (this bubbles up to x/compute via ocalls and FFI to Go code)\n    // This returns the answer from x/compute\n    let (result, query_used_gas) = query_chain(context, \u0026encrypted_query, gas_limit);\n    *gas_used = query_used_gas;\n    let encrypted_answer_as_vec = result?;\n\n    if !is_encrypted {\n        return Ok(encrypted_answer_as_vec);\n    }\n\n    // answer is QueryResult (Result\u003cResult\u003cBinary,StdError\u003e,SystemError\u003e) encoded by serde to bytes.\n    // we need to:\n    //  (1) deserialize it from bytes\n    //  (2) decrypt the Result/StdError\n    //  (3) turn in back to QueryResult as bytes\n    let parse_result = serde_json::from_slice(\u0026encrypted_answer_as_vec);\n    let encrypted_answer: SystemResult\u003cStdResult\u003cBinary\u003e\u003e = match parse_result {\n        Ok(encrypted_answer) =\u003e encrypted_answer,\n        Err(err) =\u003e {\n            return system_error_invalid_response(encrypted_answer_as_vec, err);\n        }\n    };\n\n    debug!(\n        \"encrypt_and_query_chain() got encrypted answer with gas {}: {:?}\",\n        gas_used, encrypted_answer\n    );\n\n    // decrypt query response\n    let answer: SystemResult\u003cStdResult\u003cBinary\u003e\u003e = match encrypted_answer {\n        Err(_) =\u003e encrypted_answer,\n        // normal response from contract\n        Ok(Ok(result)) =\u003e {\n            let decrypted = decrypt_query_response(query, result.0, nonce, user_public_key)?;\n            Ok(Ok(Binary(decrypted)))\n        }\n        // error response from contract, or critical error in called VM\n        Ok(Err(StdError::GenericErr { msg })) =\u003e {\n            if !msg.contains(\"query contract failed: encrypted: \") {\n                Ok(Err(StdError::GenericErr { msg }))\n            } else {\n                let msg_b64_encrypted = msg.replace(\"query contract failed: encrypted: \", \"\");\n                match base64::decode(\u0026msg_b64_encrypted) {\n                    Err(err) =\u003e {\n                        debug!(\n                            \"encrypt_and_query_chain() got an StdError as an answer {:?}, tried to decode \\\n                            the inner msg as bytes because it's encrypted, but got an error while trying to \\\n                            decode from base64: {}\",\n                            msg, err\n                        );\n                        return Err(WasmEngineError::DeserializationError);\n                    }\n                    Ok(error) =\u003e {\n                        let decrypted =\n                            decrypt_query_response_error(query, error, nonce, user_public_key)?;\n                        match serde_json::from_slice::\u003cStdError\u003e(\u0026decrypted) {\n                            Ok(answer) =\u003e Ok(Err(answer)),\n                            Err(err) =\u003e {\n                                debug!(\"encrypt_and_query_chain() got an error while trying to deserialize the inner error as StdError: {:?}\", err);\n                                return system_error_invalid_response(decrypted, err);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Ok(Err(std_error)) =\u003e {\n            // TODO when removing this you can replace this clause with: `other =\u003e other` instead of the `Ok(Err(...))`\n            debug!(\n                \"encrypt_and_query_chain() got an StdError as an answer, but it should be of type GenericErr and encrypted inside. Got instead: {:?}\",\n                std_error\n            );\n            Ok(Err(std_error))\n        }\n    };\n\n    trace!(\n        \"encrypt_and_query_chain() decrypted the answer to be: {:?}\",\n        answer\n    );\n\n    let answer_as_vec = serde_json::to_vec(\u0026answer).map_err(|err| {\n        debug!(\"encrypt_and_query_chain() got an error while trying to serialize the decrypted answer to bytes: {:?}\", err);\n        WasmEngineError::SerializationError\n    })?;\n\n    Ok(answer_as_vec)\n}\n\n/// Safe wrapper around quering other contracts and modules\nfn query_chain(\n    context: \u0026Ctx,\n    query: \u0026[u8],\n    gas_limit: u64,\n) -\u003e (Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e, u64) {\n    let mut ocall_return = OcallReturn::Success;\n    let mut enclave_buffer = std::mem::MaybeUninit::\u003cEnclaveBuffer\u003e::uninit();\n    let mut vm_err = UntrustedVmError::default();\n    let mut gas_used = 0_u64;\n    let value = unsafe {\n        let status = imports::ocall_query_chain(\n            \u0026mut ocall_return,\n            context.unsafe_clone(),\n            \u0026mut vm_err,\n            \u0026mut gas_used,\n            gas_limit,\n            enclave_buffer.as_mut_ptr(),\n            query.as_ptr(),\n            query.len(),\n        );\n\n        trace!(\"ocall_query_chain returned with gas {}\", gas_used);\n\n        match status {\n            sgx_status_t::SGX_SUCCESS =\u003e { /* continue */ }\n            error_status =\u003e {\n                warn!(\n                    \"query_chain() got an error from ocall_query_chain, stopping wasm: {:?}\",\n                    error_status\n                );\n                return (Err(WasmEngineError::FailedOcall(vm_err)), gas_used);\n            }\n        }\n\n        match ocall_return {\n            OcallReturn::Success =\u003e {\n                let enclave_buffer = enclave_buffer.assume_init();\n                match exports::recover_buffer(enclave_buffer) {\n                    Ok(buff) =\u003e buff.unwrap_or_default(),\n                    Err(err) =\u003e return (Err(err.into()), gas_used),\n                }\n            }\n            OcallReturn::Failure =\u003e return (Err(WasmEngineError::FailedOcall(vm_err)), gas_used),\n            OcallReturn::Panic =\u003e return (Err(WasmEngineError::Panic), gas_used),\n        }\n    };\n\n    (Ok(value), gas_used)\n}\n\n/// Check whether the query is allowed to run.\n///\n/// We make sure that a recursion limit is in place in order to\n/// mitigate cases where the enclave runs out of memory.\nfn check_recursion_limit() -\u003e Option\u003cSystemResult\u003cStdResult\u003cBinary\u003e\u003e\u003e {\n    if recursion_depth::limit_reached() {\n        debug!(\n            \"Recursion limit reached while performing nested queries. Returning error to contract.\"\n        );\n        Some(Err(SystemError::ExceededRecursionLimit {}))\n    } else {\n        None\n    }\n}\n\nfn system_error_invalid_request\u003cT\u003e(request: \u0026[u8], err: T) -\u003e Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e\nwhere\n    T: std::fmt::Debug + ToString,\n{\n    debug!(\n        \"encrypt_and_query_chain() cannot build struct from json {:?}: {:?}\",\n        String::from_utf8_lossy(request),\n        err\n    );\n    let answer: SystemResult\u003cStdResult\u003cBinary\u003e\u003e = Err(SystemError::InvalidRequest {\n        request: Binary(request.into()),\n        error: err.to_string(),\n    });\n\n    serialize_error_response(\u0026answer)\n}\n\nfn system_error_invalid_response\u003cT\u003e(response: Vec\u003cu8\u003e, err: T) -\u003e Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e\nwhere\n    T: std::fmt::Debug + ToString,\n{\n    let answer: SystemResult\u003cStdResult\u003cBinary\u003e\u003e = Err(SystemError::InvalidResponse {\n        response: Binary(response),\n        error: err.to_string(),\n    });\n\n    serialize_error_response(\u0026answer)\n}\n\nfn serialize_error_response(\n    answer: \u0026SystemResult\u003cStdResult\u003cBinary\u003e\u003e,\n) -\u003e Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e {\n    serde_json::to_vec(answer).map_err(|err| {\n        // this should never happen\n        debug!(\n            \"encrypt_and_query_chain() got an error while trying to serialize the error {:?} returned to WASM: {:?}\",\n            answer,\n            err\n        );\n\n        WasmEngineError::SerializationError\n    })\n}\n\nfn encrypt_query_request(\n    query_struct: \u0026mut QueryRequest,\n    nonce: IoNonce,\n    user_public_key: Ed25519PublicKey,\n) -\u003e Result\u003cbool, WasmEngineError\u003e {\n    let mut is_encrypted = false;\n\n    // encrypt message\n    if let QueryRequest::Wasm(WasmQuery::Smart {\n        msg,\n        callback_code_hash,\n        ..\n    }) = query_struct\n    {\n        is_encrypted = true;\n\n        let mut hash_appended_msg = callback_code_hash.clone().into_bytes();\n        hash_appended_msg.extend_from_slice(\u0026msg.0);\n\n        let mut encrypted_msg = SecretMessage {\n            msg: hash_appended_msg,\n            user_public_key,\n            nonce,\n        };\n        encrypted_msg.encrypt_in_place().map_err(|err| {\n            debug!(\n                \"encrypt_and_query_chain() got an error while trying to encrypt the request for query {:?}, stopping wasm: {:?}\",\n                String::from_utf8_lossy(\u0026msg.0),\n                err\n            );\n\n            WasmEngineError::EncryptionError\n        })?;\n\n        *msg = Binary(encrypted_msg.to_vec());\n    };\n\n    Ok(is_encrypted)\n}\n\nfn decrypt_query_response(\n    query: \u0026[u8],\n    response: Vec\u003cu8\u003e,\n    nonce: IoNonce,\n    user_public_key: Ed25519PublicKey,\n) -\u003e Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e {\n    // query response returns without nonce and user_public_key appended to it\n    // because the sender is supposed to have them already\n    let as_secret_msg = SecretMessage {\n        nonce,\n        user_public_key,\n        msg: response,\n    };\n\n    let b64_decrypted = as_secret_msg.decrypt().map_err(|err| {\n        debug!(\n            \"encrypt_and_query_chain() got an error while trying to decrypt the result for query {:?}, stopping wasm: {:?}\",\n            String::from_utf8_lossy(query),\n            err\n        );\n        WasmEngineError::DecryptionError\n    })?;\n\n    base64::decode(\u0026b64_decrypted).map_err(|err| {\n        debug!(\n            \"encrypt_and_query_chain() got an answer, managed to decrypt it, then tried to decode the output from base64 to bytes and failed: {:?}\",\n            err\n        );\n        WasmEngineError::DeserializationError\n    })\n}\n\nfn decrypt_query_response_error(\n    query: \u0026[u8],\n    error: Vec\u003cu8\u003e,\n    nonce: IoNonce,\n    user_public_key: Ed25519PublicKey,\n) -\u003e Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e {\n    let error_msg = SecretMessage {\n        nonce,\n        user_public_key,\n        msg: error,\n    };\n\n    error_msg.decrypt().map_err(|err| {\n        debug!(\n            \"encrypt_and_query_chain() got an error while trying to decrypt the inner error for query {:?}, stopping wasm: {:?}\",\n            String::from_utf8_lossy(\u0026query),\n            err\n        );\n        WasmEngineError::DecryptionError\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","runtime","contract.rs"],"content":"use bech32::{FromBase32, ToBase32};\nuse log::*;\nuse wasmi::{Error as InterpreterError, MemoryInstance, MemoryRef, ModuleRef, RuntimeValue, Trap};\n\nuse enclave_ffi_types::Ctx;\n\nuse crate::consts::BECH32_PREFIX_ACC_ADDR;\nuse crate::crypto::Ed25519PublicKey;\nuse crate::wasm::contract_validation::ContractKey;\nuse crate::wasm::db::{read_encrypted_key, remove_encrypted_key, write_encrypted_key};\nuse crate::wasm::errors::WasmEngineError;\nuse crate::wasm::runtime::traits::WasmiApi;\nuse crate::wasm::{gas::WasmCosts, query_chain::encrypt_and_query_chain, types::IoNonce};\n\npub enum ContractOperation {\n    Init,\n    Handle,\n    Query,\n    // Migrate. // not implemented\n}\n\n#[allow(unused)]\nimpl ContractOperation {\n    fn is_init(\u0026self) -\u003e bool {\n        matches!(self, ContractOperation::Init)\n    }\n\n    fn is_handle(\u0026self) -\u003e bool {\n        matches!(self, ContractOperation::Handle)\n    }\n\n    fn is_query(\u0026self) -\u003e bool {\n        matches!(self, ContractOperation::Query)\n    }\n}\n\n/// SecretContract maps function index to implementation\n/// When instantiating a module we give it the SecretNetworkImportResolver resolver\n/// When invoking a function inside the module we give it this runtime which is the actual functions implementation ()\npub struct ContractInstance {\n    pub context: Ctx,\n    pub memory: MemoryRef,\n    pub gas_limit: u64,\n    /// Gas used by wasmi\n    pub gas_used: u64,\n    /// Gas used by external services. This is tracked separately so we don't double-charge for external services later.\n    pub gas_used_externally: u64,\n    pub gas_costs: WasmCosts,\n    pub contract_key: ContractKey,\n    pub module: ModuleRef,\n    operation: ContractOperation,\n    pub user_nonce: IoNonce,\n    pub user_public_key: Ed25519PublicKey,\n}\n\nimpl ContractInstance {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        context: Ctx,\n        module: ModuleRef,\n        gas_limit: u64,\n        gas_costs: WasmCosts,\n        contract_key: ContractKey,\n        operation: ContractOperation,\n        user_nonce: IoNonce,\n        user_public_key: Ed25519PublicKey,\n    ) -\u003e Self {\n        let memory = (\u0026*module)\n            .export_by_name(\"memory\")\n            .expect(\"Module expected to have 'memory' export\")\n            .as_memory()\n            .cloned()\n            .expect(\"'memory' export should be of memory type\");\n\n        Self {\n            context,\n            memory,\n            gas_limit,\n            gas_used: 0,\n            gas_used_externally: 0,\n            gas_costs,\n            contract_key,\n            module,\n            operation,\n            user_nonce,\n            user_public_key,\n        }\n    }\n\n    fn get_memory(\u0026self) -\u003e \u0026MemoryInstance {\n        \u0026*self.memory\n    }\n\n    /// extract_vector extracts a vector from the wasm memory space\n    pub fn extract_vector(\u0026self, vec_ptr_ptr: u32) -\u003e Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e {\n        self.extract_vector_inner(vec_ptr_ptr).map_err(|err| {\n            debug!(\n                \"error while trying to read the buffer at {:?} : {:?}\",\n                vec_ptr_ptr, err\n            );\n            WasmEngineError::MemoryReadError\n        })\n    }\n\n    fn extract_vector_inner(\u0026self, vec_ptr_ptr: u32) -\u003e Result\u003cVec\u003cu8\u003e, InterpreterError\u003e {\n        let ptr: u32 = self.get_memory().get_value(vec_ptr_ptr)?;\n\n        if ptr == 0 {\n            return Err(InterpreterError::Memory(String::from(\n                \"Trying to read from null pointer in WASM memory\",\n            )));\n        }\n\n        let len: u32 = self.get_memory().get_value(vec_ptr_ptr + 8)?;\n\n        self.get_memory().get(ptr, len as usize)\n    }\n\n    pub fn allocate(\u0026mut self, len: u32) -\u003e Result\u003cu32, WasmEngineError\u003e {\n        self.allocate_inner(len).map_err(|err| {\n            debug!(\"Failed to allocate {} bytes in wasm: {}\", len, err);\n            WasmEngineError::MemoryAllocationError\n        })\n    }\n\n    fn allocate_inner(\u0026mut self, len: u32) -\u003e Result\u003cu32, InterpreterError\u003e {\n        match self.module.clone().invoke_export(\n            \"allocate\",\n            \u0026[RuntimeValue::I32(len as i32)],\n            self,\n        )? {\n            Some(RuntimeValue::I32(0)) =\u003e Err(InterpreterError::Memory(String::from(\n                \"Allocate returned null pointer from WASM\",\n            ))),\n            Some(RuntimeValue::I32(offset)) =\u003e Ok(offset as u32),\n            other =\u003e Err(InterpreterError::Value(format!(\n                \"allocate method returned value which wasn't u32: {:?}\",\n                other\n            ))),\n        }\n    }\n\n    pub fn write_to_allocated_memory(\n        \u0026mut self,\n        buffer: \u0026[u8],\n        ptr_to_region_in_wasm_vm: u32,\n    ) -\u003e Result\u003cu32, WasmEngineError\u003e {\n        self.write_to_allocated_memory_inner(buffer, ptr_to_region_in_wasm_vm)\n            .map_err(|err| {\n                debug!(\n                    \"error while trying to write the buffer {:?} to the destination buffer at {:?} : {:?}\",\n                    buffer, ptr_to_region_in_wasm_vm, err\n                );\n                WasmEngineError::MemoryWriteError\n            })\n    }\n\n    fn write_to_allocated_memory_inner(\n        \u0026mut self,\n        buffer: \u0026[u8],\n        ptr_to_region_in_wasm_vm: u32,\n    ) -\u003e Result\u003cu32, InterpreterError\u003e {\n        // WASM pointers are pointers to \"Region\"\n        // Region is a struct that looks like this:\n        // ptr_to_region -\u003e | 4byte = buffer_addr | 4bytes = buffer_cap | 4bytes = buffer_len |\n\n        // extract the buffer pointer from the region\n        let buffer_addr_in_wasm: u32 = self\n            .get_memory()\n            .get_value::\u003cu32\u003e(ptr_to_region_in_wasm_vm)?;\n\n        if buffer_addr_in_wasm == 0 {\n            return Err(InterpreterError::Memory(String::from(\n                \"Trying to write to null pointer in WASM memory\",\n            )));\n        }\n\n        let buffer_cap_in_wasm: u32 = self\n            .get_memory()\n            .get_value::\u003cu32\u003e(ptr_to_region_in_wasm_vm + 4)?;\n\n        if buffer_cap_in_wasm \u003c buffer.len() as u32 {\n            return Err(InterpreterError::Memory(format!(\n                \"Tried to write {} bytes but only got {} bytes in destination buffer\",\n                buffer.len(),\n                buffer_cap_in_wasm\n            )));\n        }\n\n        self.get_memory().set(buffer_addr_in_wasm, buffer)?;\n\n        self.get_memory()\n            .set_value::\u003cu32\u003e(ptr_to_region_in_wasm_vm + 8, buffer.len() as u32)?;\n\n        // return the WASM pointer\n        Ok(ptr_to_region_in_wasm_vm)\n    }\n\n    pub fn write_to_memory(\u0026mut self, buffer: \u0026[u8]) -\u003e Result\u003cu32, WasmEngineError\u003e {\n        // allocate return a pointer to a region\n        let ptr_to_region_in_wasm_vm = self.allocate(buffer.len() as u32)?;\n        self.write_to_allocated_memory(buffer, ptr_to_region_in_wasm_vm)\n    }\n\n    /// Track gas used inside wasmi\n    fn use_gas(\u0026mut self, gas_amount: u64) -\u003e Result\u003c(), WasmEngineError\u003e {\n        self.gas_used = self.gas_used.saturating_add(gas_amount);\n        self.check_gas_usage()\n    }\n\n    /// Track gas used by external services (e.g. storage)\n    fn use_gas_externally(\u0026mut self, gas_amount: u64) -\u003e Result\u003c(), WasmEngineError\u003e {\n        self.gas_used_externally = self.gas_used_externally.saturating_add(gas_amount);\n        self.check_gas_usage()\n    }\n\n    fn check_gas_usage(\u0026self) -\u003e Result\u003c(), WasmEngineError\u003e {\n        // Check if new amount is bigger than gas limit\n        // If is above the limit, halt execution\n        if self.is_gas_depleted() {\n            debug!(\n                \"Out of gas! Gas limit: {}, gas used: {}, gas used externally: {}\",\n                self.gas_limit, self.gas_used, self.gas_used_externally\n            );\n            Err(WasmEngineError::OutOfGas)\n        } else {\n            Ok(())\n        }\n    }\n\n    fn is_gas_depleted(\u0026self) -\u003e bool {\n        self.gas_limit \u003c self.gas_used.saturating_add(self.gas_used_externally)\n    }\n\n    fn gas_left(\u0026self) -\u003e u64 {\n        self.gas_limit\n            .saturating_sub(self.gas_used)\n            .saturating_sub(self.gas_used_externally)\n    }\n}\n\nimpl WasmiApi for ContractInstance {\n    /// Args:\n    /// 1. \"key\" to read from Tendermint (buffer of bytes)\n    /// key is a pointer to a region \"struct\" of \"pointer\" and \"length\"\n    /// A Region looks like { ptr: u32, len: u32 }\n    fn read_db_index(\u0026mut self, state_key_ptr_ptr: i32) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e {\n        let state_key_name = self\n            .extract_vector(state_key_ptr_ptr as u32)\n            .map_err(|err| {\n                debug!(\"read_db() error while trying to read state_key_name from wasm memory\");\n                err\n            })?;\n\n        trace!(\n            \"read_db() was called from WASM code with state_key_name: {:?}\",\n            String::from_utf8_lossy(\u0026state_key_name)\n        );\n\n        // Call read_db (this bubbles up to Tendermint via ocalls and FFI to Go code)\n        // This returns the value from Tendermint\n        let (value, gas_used) =\n            read_encrypted_key(\u0026state_key_name, \u0026self.context, \u0026self.contract_key)?;\n        self.use_gas_externally(gas_used)?;\n\n        let value = match value {\n            None =\u003e return Ok(Some(RuntimeValue::I32(0))),\n            Some(value) =\u003e value,\n        };\n\n        trace!(\n            \"read_db() got value with len {}: '{:?}'\",\n            value.len(),\n            value\n        );\n\n        let ptr_to_region_in_wasm_vm = self.write_to_memory(\u0026value).map_err(|err| {\n            debug!(\n                \"read_db() error while trying to allocate {} bytes for the value\",\n                value.len(),\n            );\n            err\n        })?;\n\n        // Return pointer to the allocated buffer with the value written to it\n        Ok(Some(RuntimeValue::I32(ptr_to_region_in_wasm_vm as i32)))\n    }\n\n    /// Args:\n    /// 1. \"key\" to delete from Tendermint (buffer of bytes)\n    /// key is a pointer to a region \"struct\" of \"pointer\" and \"length\"\n    /// A Region looks like { ptr: u32, len: u32 }\n    fn remove_db_index(\u0026mut self, state_key_ptr_ptr: i32) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e {\n        if self.operation.is_query() {\n            return Err(WasmEngineError::UnauthorizedWrite.into());\n        }\n\n        let state_key_name = self\n            .extract_vector(state_key_ptr_ptr as u32)\n            .map_err(|err| {\n                debug!(\"remove_db() error while trying to read state_key_name from wasm memory\");\n                err\n            })?;\n\n        trace!(\n            \"remove_db() was called from WASM code with state_key_name: {:?}\",\n            String::from_utf8_lossy(\u0026state_key_name)\n        );\n\n        // Call remove_db (this bubbles up to Tendermint via ocalls and FFI to Go code)\n        let gas_used = remove_encrypted_key(\u0026state_key_name, \u0026self.context, \u0026self.contract_key)?;\n        self.use_gas_externally(gas_used)?;\n\n        Ok(None)\n    }\n\n    /// Args:\n    /// 1. \"key\" to write to Tendermint (buffer of bytes)\n    /// 2. \"value\" to write to Tendermint (buffer of bytes)\n    /// Both of them are pointers to a region \"struct\" of \"pointer\" and \"length\"\n    /// Lets say Region looks like { ptr: u32, len: u32 }\n    fn write_db_index(\n        \u0026mut self,\n        state_key_ptr_ptr: i32,\n        value_ptr_ptr: i32,\n    ) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e {\n        if self.operation.is_query() {\n            return Err(WasmEngineError::UnauthorizedWrite.into());\n        }\n\n        let state_key_name = self\n            .extract_vector(state_key_ptr_ptr as u32)\n            .map_err(|err| {\n                debug!(\"write_db() error while trying to read state_key_name from wasm memory\");\n                err\n            })?;\n        let value = self.extract_vector(value_ptr_ptr as u32).map_err(|err| {\n            debug!(\"write_db() error while trying to read value from wasm memory\");\n            err\n        })?;\n\n        trace!(\n            \"write_db() was called from WASM code with state_key_name: {:?} value: {:?}\",\n            String::from_utf8_lossy(\u0026state_key_name),\n            String::from_utf8_lossy(\u0026value),\n        );\n\n        let used_gas =\n            write_encrypted_key(\u0026state_key_name, \u0026value, \u0026self.context, \u0026self.contract_key)\n                .map_err(|err| {\n                    debug!(\n                        \"write_db() error while trying to write the value to state: {:?}\",\n                        err\n                    );\n                    err\n                })?;\n        self.use_gas_externally(used_gas)?;\n\n        Ok(None)\n    }\n\n    /// Args:\n    /// 1. \"human\" to convert to canonical address (string)\n    /// 2. \"canonical\" a buffer to write the result into (buffer of bytes)\n    /// Both of them are pointers to a region \"struct\" of \"pointer\" and \"length\"\n    /// A Region looks like { ptr: u32, len: u32 }\n    fn canonicalize_address_index(\n        \u0026mut self,\n        human_ptr_ptr: i32,\n        canonical_ptr_ptr: i32,\n    ) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e {\n        self.use_gas_externally(self.gas_costs.external_canonicalize_address as u64)?;\n\n        let human = self.extract_vector(human_ptr_ptr as u32).map_err(|err| {\n            debug!(\n                \"canonicalize_address() error while trying to read human address from wasm memory\"\n            );\n            err\n        })?;\n\n        trace!(\n            \"canonicalize_address() was called from WASM code with {:?}\",\n            String::from_utf8_lossy(\u0026human)\n        );\n\n        // Turn Vec\u003cu8\u003e to str\n        let mut human_addr_str = match std::str::from_utf8(\u0026human) {\n            Err(err) =\u003e {\n                debug!(\n                    \"canonicalize_address() error while trying to parse human address from bytes to string: {:?}\",\n                    err\n                );\n                return Ok(Some(RuntimeValue::I32(\n                    self.write_to_memory(b\"input is not valid UTF-8\")? as i32,\n                )));\n            }\n            Ok(x) =\u003e x,\n        };\n\n        human_addr_str = human_addr_str.trim();\n        if human_addr_str.is_empty() {\n            return Ok(Some(RuntimeValue::I32(\n                self.write_to_memory(b\"input is empty\")? as i32,\n            )));\n        }\n\n        let (decoded_prefix, data) = match bech32::decode(\u0026human_addr_str) {\n            Err(err) =\u003e {\n                debug!(\n                    \"canonicalize_address() error while trying to decode human address {:?} as bech32: {:?}\",\n                    human_addr_str, err\n                );\n                return Ok(Some(RuntimeValue::I32(\n                    self.write_to_memory(err.to_string().as_bytes())? as i32,\n                )));\n            }\n            Ok(x) =\u003e x,\n        };\n\n        if decoded_prefix != BECH32_PREFIX_ACC_ADDR {\n            debug!(\n                \"canonicalize_address() wrong prefix {:?} (expected {:?}) while decoding human address {:?} as bech32\",\n                decoded_prefix,\n                BECH32_PREFIX_ACC_ADDR,\n                human_addr_str\n            );\n            return Ok(Some(RuntimeValue::I32(\n                self.write_to_memory(\n                    format!(\"wrong address prefix: {:?}\", decoded_prefix).as_bytes(),\n                )? as i32,\n            )));\n        }\n\n        let canonical = Vec::\u003cu8\u003e::from_base32(\u0026data).map_err(|err| {\n            // Assaf: From reading https://docs.rs/bech32/0.7.2/src/bech32/lib.rs.html#607\n            // and https://docs.rs/bech32/0.7.2/src/bech32/lib.rs.html#228 I don't think this can fail that way\n            debug!(\n                \"canonicalize_address() error while trying to decode bytes from base32 {:?}: {:?}\",\n                data, err\n            );\n            WasmEngineError::Base32Error\n        })?;\n\n        self.write_to_allocated_memory(\u0026canonical, canonical_ptr_ptr as u32)\n            .map_err(|err| {\n                debug!(\n                    \"canonicalize_address() error while trying to write the answer {:?} to the destination buffer\",\n                    canonical,\n                );\n                err\n            })?;\n\n        // return 0 == ok\n        Ok(Some(RuntimeValue::I32(0)))\n    }\n\n    /// Args:\n    /// 1. \"canonical\" to convert to human address (buffer of bytes)\n    /// 2. \"human\" a buffer to write the result (humanized string) into (buffer of bytes)\n    /// Both of them are pointers to a region \"struct\" of \"pointer\" and \"length\"\n    /// A Region looks like { ptr: u32, len: u32 }\n    fn humanize_address_index(\n        \u0026mut self,\n        canonical_ptr_ptr: i32,\n        human_ptr_ptr: i32,\n    ) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e {\n        self.use_gas_externally(self.gas_costs.external_humanize_address as u64)?;\n\n        let canonical = self\n            .extract_vector(canonical_ptr_ptr as u32)\n            .map_err(|err| {\n                debug!(\n                    \"humanize_address() error while trying to read canonical address from wasm memory\",\n                );\n                err\n            })?;\n\n        trace!(\n            \"humanize_address() was called from WASM code with {:?}\",\n            canonical\n        );\n\n        let human_addr_str = match bech32::encode(BECH32_PREFIX_ACC_ADDR, canonical.to_base32()) {\n            Err(err) =\u003e {\n                // Assaf: IMO This can never fail. From looking at bech32::encode, it only fails\n                // because input prefix issues. For us the prefix is always \"secert\" which is valid.\n                debug!(\"humanize_address() error while trying to encode canonical address {:?} to human: {:?}\",  canonical, err);\n                return Ok(Some(RuntimeValue::I32(\n                    self.write_to_memory(err.to_string().as_bytes())? as i32,\n                )));\n            }\n            Ok(x) =\u003e x,\n        };\n\n        let human_bytes = human_addr_str.into_bytes();\n\n        self.write_to_allocated_memory(\u0026human_bytes, human_ptr_ptr as u32)\n            .map_err(|err| {\n                debug!(\n                    \"humanize_address() error while trying to write the answer {:?} to the destination buffer\",\n                    human_bytes,\n                );\n                err\n            })?;\n\n        // return 0 == ok\n        Ok(Some(RuntimeValue::I32(0)))\n    }\n\n    // stub, for now\n    fn query_chain_index(\u0026mut self, query_ptr_ptr: i32) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e {\n        let query_buffer = self.extract_vector(query_ptr_ptr as u32).map_err(|err| {\n            debug!(\"query_chain() error while trying to read canonical address from wasm memory\",);\n            err\n        })?;\n\n        trace!(\n            \"query_chain() was called from WASM code with {:?}\",\n            String::from_utf8_lossy(\u0026query_buffer)\n        );\n\n        // Call query_chain (this bubbles up to x/compute via ocalls and FFI to Go code)\n        // Returns the value from x/compute\n        let mut gas_used: u64 = 0;\n        let answer = encrypt_and_query_chain(\n            \u0026query_buffer,\n            \u0026self.context,\n            self.user_nonce,\n            self.user_public_key,\n            \u0026mut gas_used,\n            self.gas_left(),\n        )?;\n\n        trace!(\n            \"query_chain() got answer from outside with gas {} and result {:?}\",\n            gas_used,\n            String::from_utf8_lossy(\u0026answer)\n        );\n\n        self.use_gas_externally(gas_used)?;\n\n        let ptr_to_region_in_wasm_vm = self.write_to_memory(\u0026answer).map_err(|err| {\n            debug!(\n                \"query_chain() error while trying to allocate and write the answer {:?} to the WASM VM\",\n                answer,\n            );\n            err\n        })?;\n\n        // Return pointer to the allocated buffer with the value written to it\n        Ok(Some(RuntimeValue::I32(ptr_to_region_in_wasm_vm as i32)))\n    }\n\n    fn gas_index(\u0026mut self, gas_amount: i32) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e {\n        self.use_gas(gas_amount as u64)?;\n        Ok(None)\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":239},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","runtime","engine.rs"],"content":"use log::*;\nuse wasmi::{ModuleRef, RuntimeValue};\n\nuse super::contract::ContractInstance;\nuse crate::wasm::errors::{wasmi_error_to_enclave_error, WasmEngineError};\n\nuse enclave_ffi_types::EnclaveError;\n\npub struct Engine {\n    contract_instance: ContractInstance,\n    module: ModuleRef,\n}\n\nimpl Engine {\n    pub fn new(contract_instance: ContractInstance, module: ModuleRef) -\u003e Self {\n        Self {\n            contract_instance,\n            module,\n        }\n    }\n\n    pub fn gas_used(\u0026self) -\u003e u64 {\n        self.contract_instance.gas_used\n    }\n\n    pub fn write_to_memory(\u0026mut self, buffer: \u0026[u8]) -\u003e Result\u003cu32, WasmEngineError\u003e {\n        self.contract_instance.write_to_memory(buffer)\n    }\n\n    pub fn extract_vector(\u0026self, vec_ptr_ptr: u32) -\u003e Result\u003cVec\u003cu8\u003e, WasmEngineError\u003e {\n        self.contract_instance.extract_vector(vec_ptr_ptr)\n    }\n\n    pub fn init(\u0026mut self, env_ptr: u32, msg_ptr: u32) -\u003e Result\u003cu32, EnclaveError\u003e {\n        info!(\"Invoking init() in wasm\");\n\n        match self\n            .module\n            .invoke_export(\n                \"init\",\n                \u0026[\n                    RuntimeValue::I32(env_ptr as i32),\n                    RuntimeValue::I32(msg_ptr as i32),\n                ],\n                \u0026mut self.contract_instance,\n            )\n            .map_err(wasmi_error_to_enclave_error)?\n        {\n            Some(RuntimeValue::I32(offset)) =\u003e Ok(offset as u32),\n            other =\u003e {\n                warn!(\"init method returned value which wasn't u32: {:?}\", other);\n                Err(EnclaveError::FailedFunctionCall)\n            }\n        }\n\n        // Itzik: leaving this here as an example in case we will want to do something like this in the future\n\n        // if result.is_ok() {\n        //     write_encrypted_key(\n        //         b\"key\",\n        //         contract_key,\n        //         \u0026self.contract_instance.context,\n        //         \u0026self.contract_instance.contract_key,\n        //     )\n        //     .map_err(|_| {\n        //         error!(\"Failed to write contract key to database\");\n        //         EnclaveError::InternalError\n        //     })?;\n        // }\n\n        //result\n    }\n\n    pub fn handle(\u0026mut self, env_ptr: u32, msg_ptr: u32) -\u003e Result\u003cu32, EnclaveError\u003e {\n        info!(\"Invoking handle() in wasm\");\n\n        // Itzik: leaving this here as an example in case we will want to do something like this in the future\n\n        // let stored_address = read_encrypted_key(\n        //     b\"key\",\n        //     \u0026self.contract_instance.context,\n        //     \u0026self.contract_instance.contract_key,\n        // )\n        // .map_err(|_| {\n        //     error!(\"WTF wrong contract key are you crazy???\");\n        //     EnclaveError::InternalError\n        // })?;\n        //\n        // match stored_address.0 {\n        //     Some(addr) =\u003e {\n        //         if addr != contract_key.to_vec() {\n        //             error!(\"WTF wrong contract key are you crazy???\");\n        //             return Err(EnclaveError::FailedUnseal);\n        //         }\n        //         Ok(())\n        //     }\n        //     None =\u003e {\n        //         error!(\"WTF no contract address found you must be trippin' dawg\");\n        //         Err(EnclaveError::InternalError)\n        //     }\n        // }?;\n\n        match self\n            .module\n            .invoke_export(\n                \"handle\",\n                \u0026[\n                    RuntimeValue::I32(env_ptr as i32),\n                    RuntimeValue::I32(msg_ptr as i32),\n                ],\n                \u0026mut self.contract_instance,\n            )\n            .map_err(wasmi_error_to_enclave_error)?\n        {\n            Some(RuntimeValue::I32(offset)) =\u003e Ok(offset as u32),\n            other =\u003e {\n                warn!(\"handle method returned value which wasn't u32: {:?}\", other);\n                Err(EnclaveError::FailedFunctionCall)\n            }\n        }\n    }\n\n    pub fn query(\u0026mut self, msg_ptr: u32) -\u003e Result\u003cu32, EnclaveError\u003e {\n        info!(\"Invoking query() in wasm\");\n\n        match self\n            .module\n            .invoke_export(\n                \"query\",\n                \u0026[RuntimeValue::I32(msg_ptr as i32)],\n                \u0026mut self.contract_instance,\n            )\n            .map_err(wasmi_error_to_enclave_error)?\n        {\n            Some(RuntimeValue::I32(offset)) =\u003e Ok(offset as u32),\n            other =\u003e {\n                warn!(\"query method returned value which wasn't u32: {:?}\", other);\n                Err(EnclaveError::FailedFunctionCall)\n            }\n        }\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":50},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","runtime","externals.rs"],"content":"use log::*;\nuse wasmi::{Externals, RuntimeArgs, RuntimeValue, Trap};\n\nuse crate::wasm::errors::WasmEngineError;\n\nuse super::contract::ContractInstance;\nuse super::traits::WasmiApi;\n\n#[derive(PartialEq, Eq)]\npub enum HostFunctions {\n    ReadDbIndex = 0,\n    WriteDbIndex = 1,\n    RemoveDbIndex = 2,\n    CanonicalizeAddressIndex = 3,\n    HumanizeAddressIndex = 4,\n    GasIndex = 5,\n    QueryChainIndex = 6,\n    Unknown,\n}\n\nimpl From\u003cusize\u003e for HostFunctions {\n    fn from(v: usize) -\u003e Self {\n        match v {\n            x if x == HostFunctions::ReadDbIndex as usize =\u003e HostFunctions::ReadDbIndex,\n            x if x == HostFunctions::WriteDbIndex as usize =\u003e HostFunctions::WriteDbIndex,\n            x if x == HostFunctions::RemoveDbIndex as usize =\u003e HostFunctions::RemoveDbIndex,\n            x if x == HostFunctions::CanonicalizeAddressIndex as usize =\u003e {\n                HostFunctions::CanonicalizeAddressIndex\n            }\n            x if x == HostFunctions::HumanizeAddressIndex as usize =\u003e {\n                HostFunctions::HumanizeAddressIndex\n            }\n            x if x == HostFunctions::GasIndex as usize =\u003e HostFunctions::GasIndex,\n            x if x == HostFunctions::QueryChainIndex as usize =\u003e HostFunctions::QueryChainIndex,\n            _ =\u003e HostFunctions::Unknown,\n        }\n    }\n}\n\nimpl Into\u003cusize\u003e for HostFunctions {\n    fn into(self) -\u003e usize {\n        self as usize\n    }\n}\n\n/// Wasmi Trait implementation\nimpl Externals for ContractInstance {\n    fn invoke_index(\n        \u0026mut self,\n        index: usize,\n        args: RuntimeArgs,\n    ) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e {\n        match HostFunctions::from(index) {\n            HostFunctions::ReadDbIndex =\u003e {\n                let key: i32 = args.nth_checked(0).map_err(|err| {\n                    warn!(\n                        \"read_db() error reading arguments, stopping wasm: {:?}\",\n                        err\n                    );\n                    err\n                })?;\n                self.read_db_index(key)\n            }\n            HostFunctions::RemoveDbIndex =\u003e {\n                let key: i32 = args.nth_checked(0).map_err(|err| {\n                    warn!(\n                        \"remove_db() error reading arguments, stopping wasm: {:?}\",\n                        err\n                    );\n                    err\n                })?;\n                self.remove_db_index(key)\n            }\n            HostFunctions::WriteDbIndex =\u003e {\n                let key: i32 = args.nth_checked(0).map_err(|err| {\n                    warn!(\n                        \"write_db() error reading arguments, stopping wasm: {:?}\",\n                        err\n                    );\n                    err\n                })?;\n                // Get pointer to the region of the value\n                let value: i32 = args.nth_checked(1)?;\n\n                self.write_db_index(key, value)\n            }\n            HostFunctions::CanonicalizeAddressIndex =\u003e {\n                let human: i32 = args.nth_checked(0).map_err(|err| {\n                    warn!(\n                        \"canonicalize_address() error reading arguments, stopping wasm: {:?}\",\n                        err\n                    );\n                    err\n                })?;\n\n                let canonical: i32 = args.nth_checked(1)?;\n\n                self.canonicalize_address_index(human, canonical)\n            }\n            // fn humanize_address(canonical: *const c_void, human: *mut c_void) -\u003e i32;\n            HostFunctions::HumanizeAddressIndex =\u003e {\n                let canonical: i32 = args.nth_checked(0).map_err(|err| {\n                    warn!(\n                        \"humanize_address() error reading first argument, stopping wasm: {:?}\",\n                        err\n                    );\n                    err\n                })?;\n\n                let human: i32 = args.nth_checked(1).map_err(|err| {\n                    warn!(\n                        \"humanize_address() error reading second argument, stopping wasm: {:?}\",\n                        err\n                    );\n                    err\n                })?;\n\n                self.humanize_address_index(canonical, human)\n            }\n            HostFunctions::QueryChainIndex =\u003e {\n                let query: i32 = args.nth_checked(0).map_err(|err| {\n                    warn!(\n                        \"query_chain() error reading argument, stopping wasm: {:?}\",\n                        err\n                    );\n                    err\n                })?;\n\n                self.query_chain_index(query)\n            }\n            HostFunctions::GasIndex =\u003e {\n                let gas_amount: i32 = args.nth_checked(0).map_err(|err| {\n                    warn!(\"gas() error reading arguments, stopping wasm: {:?}\", err);\n                    err\n                })?;\n                self.gas_index(gas_amount)\n            }\n            HostFunctions::Unknown =\u003e {\n                warn!(\"unknown function index\");\n                Err(WasmEngineError::NonExistentImportFunction.into())\n            }\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":73},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","runtime","import_resolver.rs"],"content":"use wasmi::{\n    Error as InterpreterError, FuncInstance, FuncRef, ImportsBuilder, ModuleImportResolver,\n    Signature, ValueType,\n};\n\nuse super::externals::HostFunctions;\n\npub fn create_builder(resolver: \u0026dyn ModuleImportResolver) -\u003e ImportsBuilder {\n    ImportsBuilder::new().with_resolver(\"env\", resolver)\n}\n\n/// EnigmaImportResolver maps function name to its function signature and also to function index in Runtime\n/// When instansiating a module we give it this resolver\n/// When invoking a function inside the module we can give it different runtimes (which we probably won't do)\n#[derive(Debug, Clone)]\npub struct WasmiImportResolver {}\n\n/// These functions should be available to invoke from wasm code\n/// These should pass the request up to go-cosmwasm:\n/// fn read_db(key: *const c_void, value: *mut c_void) -\u003e i32;\n/// fn write_db(key: *const c_void, value: *mut c_void);\n/// These should be implemented here: + TODO: Check Cosmwasm implementation for these:\n/// fn canonicalize_address(human: *const c_void, canonical: *mut c_void) -\u003e i32;\n/// fn humanize_address(canonical: *const c_void, human: *mut c_void) -\u003e i32;\nimpl ModuleImportResolver for WasmiImportResolver {\n    fn resolve_func(\n        \u0026self,\n        func_name: \u0026str,\n        _signature: \u0026Signature,\n    ) -\u003e Result\u003cFuncRef, InterpreterError\u003e {\n        let func_ref = match func_name {\n            // fn read_db(key: *const c_void, value: *mut c_void) -\u003e i32;\n            \"db_read\" =\u003e FuncInstance::alloc_host(\n                Signature::new(\u0026[ValueType::I32][..], Some(ValueType::I32)),\n                HostFunctions::ReadDbIndex.into(),\n            ),\n            // fn write_db(key: *const c_void, value: *mut c_void);\n            \"db_write\" =\u003e FuncInstance::alloc_host(\n                Signature::new(\u0026[ValueType::I32, ValueType::I32][..], None),\n                HostFunctions::WriteDbIndex.into(),\n            ),\n            // fn db_remove(key: *const c_void, value: *mut c_void) -\u003e i32;\n            \"db_remove\" =\u003e FuncInstance::alloc_host(\n                Signature::new(\u0026[ValueType::I32][..], None),\n                HostFunctions::RemoveDbIndex.into(),\n            ),\n            // fn canonicalize_address(human: *const c_void, canonical: *mut c_void) -\u003e i32;\n            \"canonicalize_address\" =\u003e FuncInstance::alloc_host(\n                Signature::new(\u0026[ValueType::I32, ValueType::I32][..], Some(ValueType::I32)),\n                HostFunctions::CanonicalizeAddressIndex.into(),\n            ),\n            // fn humanize_address(canonical: *const c_void, human: *mut c_void) -\u003e i32;\n            \"humanize_address\" =\u003e FuncInstance::alloc_host(\n                Signature::new(\u0026[ValueType::I32, ValueType::I32][..], Some(ValueType::I32)),\n                HostFunctions::HumanizeAddressIndex.into(),\n            ),\n            \"query_chain\" =\u003e FuncInstance::alloc_host(\n                Signature::new(\u0026[ValueType::I32][..], Some(ValueType::I32)),\n                HostFunctions::QueryChainIndex.into(),\n            ),\n            // fn gas(amount: i32);\n            \"gas\" =\u003e FuncInstance::alloc_host(\n                Signature::new(\u0026[ValueType::I32][..], None),\n                HostFunctions::GasIndex.into(),\n            ),\n            _ =\u003e {\n                return Err(InterpreterError::Function(format!(\n                    \"WASM VM doesn't export function with name {}\",\n                    func_name\n                )));\n            }\n        };\n        Ok(func_ref)\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","runtime","mod.rs"],"content":"mod contract;\nmod engine;\nmod externals;\nmod import_resolver;\npub mod traits;\n\npub use contract::{ContractInstance, ContractOperation};\npub use engine::Engine;\npub use import_resolver::{create_builder, WasmiImportResolver};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","runtime","traits.rs"],"content":"use wasmi::{RuntimeValue, Trap};\n\n/// These functions are imported to WASM code\npub trait WasmiApi {\n    fn read_db_index(\u0026mut self, state_key_ptr_ptr: i32) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e;\n\n    fn remove_db_index(\u0026mut self, state_key_ptr_ptr: i32) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e;\n\n    fn write_db_index(\n        \u0026mut self,\n        state_key_ptr_ptr: i32,\n        value_ptr_ptr: i32,\n    ) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e;\n\n    fn canonicalize_address_index(\n        \u0026mut self,\n        canonical_ptr_ptr: i32,\n        human_ptr_ptr: i32,\n    ) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e;\n\n    fn humanize_address_index(\n        \u0026mut self,\n        canonical_ptr_ptr: i32,\n        human_ptr_ptr: i32,\n    ) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e;\n\n    fn query_chain_index(\u0026mut self, query_ptr_ptr: i32) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e;\n\n    fn gas_index(\u0026mut self, gas_amount: i32) -\u003e Result\u003cOption\u003cRuntimeValue\u003e, Trap\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","src","wasm","types.rs"],"content":"// use crate::cosmwasm::types::CosmosMsg;\n\nuse crate::crypto::{AESKey, Ed25519PublicKey, SIVEncryptable};\nuse crate::wasm::io::calc_encryption_key;\nuse enclave_ffi_types::EnclaveError;\nuse log::*;\nuse serde::{Deserialize, Serialize};\n\npub type IoNonce = [u8; 32];\n\n#[derive(Serialize, Deserialize, PartialEq, Debug)]\npub struct SecretMessage {\n    pub nonce: IoNonce,\n    pub user_public_key: Ed25519PublicKey,\n    pub msg: Vec\u003cu8\u003e,\n}\n\nimpl SecretMessage {\n    pub fn encrypt_in_place(\u0026mut self) -\u003e Result\u003c(), EnclaveError\u003e {\n        self.msg = self\n            .encryption_key()\n            .encrypt_siv(self.msg.as_slice(), None)\n            .map_err(|err| {\n                error!(\"got an error while trying to encrypt the msg: {}\", err);\n                EnclaveError::EncryptionError\n            })?;\n\n        Ok(())\n    }\n\n    pub fn decrypt(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, EnclaveError\u003e {\n        let key = self.encryption_key();\n\n        // pass\n        let msg = key.decrypt_siv(self.msg.as_slice(), None).map_err(|err| {\n            error!(\"got an error while trying to decrypt the msg: {}\", err);\n            EnclaveError::DecryptionError\n        })?;\n\n        Ok(msg)\n    }\n\n    pub fn encryption_key(\u0026self) -\u003e AESKey {\n        calc_encryption_key(\u0026self.nonce, \u0026self.user_public_key)\n    }\n\n    pub fn from_base64(\n        msg_b64: String,\n        nonce: IoNonce,\n        user_public_key: Ed25519PublicKey,\n    ) -\u003e Result\u003cSelf, EnclaveError\u003e {\n        let msg = base64::decode(\u0026msg_b64.to_owned().into_bytes()).map_err(|err| {\n            error!(\n                \"got an error while trying to decode msg to next contract as base64 {:?}: {:?}\",\n                msg_b64, err\n            );\n            EnclaveError::FailedToDeserialize\n        })?;\n\n        Ok(SecretMessage {\n            msg,\n            nonce,\n            user_public_key,\n        })\n    }\n\n    pub fn from_slice(msg: \u0026[u8]) -\u003e Result\u003cSelf, EnclaveError\u003e {\n        // 32 bytes of nonce\n        // 32 bytes of 25519 compressed public key\n        // 16+ bytes of encrypted data\n\n        if msg.len() \u003c 82 {\n            error!(\n                \"Encrypted message length {:?} is too short. Cannot parse\",\n                msg.len()\n            );\n            return Err(EnclaveError::DecryptionError);\n        };\n\n        let mut nonce = [0u8; 32];\n        nonce.copy_from_slice(\u0026msg[0..32]);\n\n        let mut user_pubkey = [0u8; 32];\n        user_pubkey.copy_from_slice(\u0026msg[32..64]);\n\n        debug!(\n            \"SecretMessage::from_slice nonce = {:?} pubkey = {:?}\",\n            nonce, user_pubkey\n        );\n\n        Ok(SecretMessage {\n            nonce,\n            user_public_key: user_pubkey,\n            msg: msg[64..].to_vec(),\n        })\n    }\n\n    pub fn to_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n        let mut packed_msg: Vec\u003cu8\u003e = self.nonce.to_vec();\n        packed_msg.extend_from_slice(\u0026self.user_public_key);\n        packed_msg.extend_from_slice(self.msg.as_slice());\n        packed_msg\n    }\n}\n\n#[cfg(feature = \"test\")]\npub mod tests {\n\n    use super::*;\n    use crate::crypto::{AESKey, SIVEncryptable, Seed, KEY_MANAGER};\n\n    // todo: fix test vectors to actually work\n    pub fn test_new_from_slice() {\n        let nonce = [0u8; 32];\n        let user_public_key = [0u8; 32];\n        let msg = \"{\\\"ok\\\": \\\"{\\\"balance\\\": \\\"108\\\"}\\\"}\";\n\n        let mut slice = nonce.to_vec();\n        slice.extend_from_slice(\u0026user_public_key);\n        slice.extend_from_slice(msg.as_bytes());\n\n        let secret_msg = SecretMessage {\n            nonce,\n            user_public_key,\n            msg: msg.as_bytes().to_vec(),\n        };\n\n        let msg_from_slice = SecretMessage::from_slice(\u0026slice).unwrap();\n\n        assert_eq!(secret_msg, msg_from_slice);\n    }\n\n    // This is commented out because it's trying to modify KEY_MANAGER which is immutable.\n    // // todo: fix test vectors to actually work\n    // pub fn test_msg_decrypt() {\n    //     let seed = Seed::new().unwrap();\n    //\n    //     KEY_MANAGER\n    //         .set_consensus_seed(seed)\n    //         .expect(\"Failed to set seed\");\n    //\n    //     let nonce = [0u8; 32];\n    //     let user_public_key = [0u8; 32];\n    //\n    //     let msg = \"{\\\"ok\\\": \\\"{\\\"balance\\\": \\\"108\\\"}\\\"}\";\n    //     let key = calc_encryption_key(\u0026nonce, \u0026user_public_key);\n    //\n    //     let encrypted_msg = key.encrypt_siv(msg.as_bytes(), \u0026[\u0026[]]);\n    //\n    //     let secret_msg = SecretMessage {\n    //         nonce,\n    //         user_public_key,\n    //         msg: encrypted_msg,\n    //     };\n    //\n    //     let decrypted_msg = secret_msg.decrypt()?;\n    //\n    //     assert_eq!(decrypted_msg, msg)\n    // }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":46},{"path":["/","home","runner","work","sienna","sienna","platform","cosmwasm","packages","wasmi-runtime","xargo","sgx_tstd","build.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License..\n\nuse std::env;\n\nfn main() {\n    if cfg!(feature = \"backtrace\") {\n        println!(\"cargo:rustc-cfg=RUST_BACKTRACE=\\\"1\\\"\");\n        //println!(\"cargo:rustc-cfg=RUST_BACKTRACE=\\\"full\\\"\");\n    }\n\n    let sdk_dir = env::var(\"SGX_SDK\")\n        .unwrap_or_else(|_| \"/opt/intel/sgxsdk\".to_string());\n    let _is_sim = env::var(\"SGX_MODE\")\n        .unwrap_or_else(|_| \"HW\".to_string());\n\n    if cfg!(feature = \"thread\") {\n        println!(\"cargo:rustc-link-search=native={}/lib64\", sdk_dir);\n        println!(\"cargo:rustc-link-lib=static=sgx_pthread\");\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","build.rs"],"content":"use std::env;\n\nfn main() {\n    let is_sim = env::var(\"SGX_MODE\").unwrap_or_else(|_| \"HW\".to_string());\n    let sdk_dir = env::var(\"SGX_SDK\").unwrap_or_else(|_| \"/opt/intel/sgxsdk\".to_string());\n    let crate_dir = env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n\n    cbindgen::generate(crate_dir)\n        .expect(\"Unable to generate bindings\")\n        .write_to_file(\"./api/bindings.h\");\n\n    println!(\"cargo:rustc-link-search=native=./lib\");\n    println!(\"cargo:rustc-link-lib=static=Enclave_u\");\n\n    // println!(\"cargo:rustc-link-lib=dylib=sgx_uae_service\");\n\n    println!(\"cargo:rustc-link-search=native={}/lib64\", sdk_dir);\n    println!(\"cargo:rustc-link-lib=static=sgx_uprotected_fs\");\n    println!(\"cargo:rustc-link-lib=static=sgx_ukey_exchange\");\n\n    match is_sim.as_ref() {\n        \"SW\" =\u003e {\n            println!(\"cargo:rustc-link-lib=dylib=sgx_urts_sim\");\n            println!(\"cargo:rustc-link-lib=dylib=sgx_uae_service_sim\");\n        }\n        // Treat undefined as HW\n        _ =\u003e {\n            println!(\"cargo:rustc-link-lib=dylib=sgx_urts\");\n            println!(\"cargo:rustc-link-lib=dylib=sgx_uae_service\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","api.rs"],"content":"use cosmwasm_sgx_vm::{Api, FfiError, FfiResult, GasInfo};\nuse cosmwasm_std::{Binary, CanonicalAddr, HumanAddr};\n\nuse crate::error::GoResult;\nuse crate::memory::Buffer;\n\n// this represents something passed in from the caller side of FFI\n// in this case a struct with go function pointers\n#[repr(C)]\npub struct api_t {\n    _private: [u8; 0],\n}\n\n// These functions should return GoResult but because we don't trust them here, we treat the return value as i32\n// and then check it when converting to GoResult manually\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct GoApi_vtable {\n    pub humanize_address:\n        extern \"C\" fn(*const api_t, Buffer, *mut Buffer, *mut Buffer, *mut u64) -\u003e i32,\n    pub canonicalize_address:\n        extern \"C\" fn(*const api_t, Buffer, *mut Buffer, *mut Buffer, *mut u64) -\u003e i32,\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct GoApi {\n    pub state: *const api_t,\n    pub vtable: GoApi_vtable,\n}\n\n// We must declare that these are safe to Send, to use in wasm.\n// The known go caller passes in immutable function pointers, but this is indeed\n// unsafe for possible other callers.\n//\n// see: https://stackoverflow.com/questions/50258359/can-a-struct-containing-a-raw-pointer-implement-send-and-be-ffi-safe\nunsafe impl Send for GoApi {}\n\nimpl Api for GoApi {\n    fn canonical_address(\u0026self, human: \u0026HumanAddr) -\u003e FfiResult\u003cCanonicalAddr\u003e {\n        let human_bytes = human.as_str().as_bytes();\n        let human_bytes = Buffer::from_vec(human_bytes.to_vec());\n        let mut output = Buffer::default();\n        let mut err = Buffer::default();\n        let mut used_gas = 0_u64;\n        let go_result: GoResult = (self.vtable.canonicalize_address)(\n            self.state,\n            human_bytes,\n            \u0026mut output as *mut Buffer,\n            \u0026mut err as *mut Buffer,\n            \u0026mut used_gas as *mut u64,\n        )\n        .into();\n        let gas_info = GasInfo::with_cost(used_gas);\n        let _human = unsafe { human_bytes.consume() };\n\n        // return complete error message (reading from buffer for GoResult::Other)\n        let default = || format!(\"Failed to canonicalize the address: {}\", human);\n        unsafe {\n            if let Err(err) = go_result.into_ffi_result(err, default) {\n                return (Err(err), gas_info);\n            }\n        }\n\n        let canon = if output.ptr.is_null() {\n            Vec::new()\n        } else {\n            // We initialize `output` with a null pointer. if it is not null,\n            // that means it was initialized by the go code, with values generated by `memory::allocate_rust`\n            unsafe { output.consume() }\n        };\n        (Ok(CanonicalAddr(Binary(canon))), gas_info)\n    }\n\n    fn human_address(\u0026self, canonical: \u0026CanonicalAddr) -\u003e FfiResult\u003cHumanAddr\u003e {\n        let canonical_bytes = canonical.as_slice();\n        let canonical_buf = Buffer::from_vec(canonical_bytes.to_vec());\n        let mut output = Buffer::default();\n        let mut err = Buffer::default();\n        let mut used_gas = 0_u64;\n        let go_result: GoResult = (self.vtable.humanize_address)(\n            self.state,\n            canonical_buf,\n            \u0026mut output as *mut Buffer,\n            \u0026mut err as *mut Buffer,\n            \u0026mut used_gas as *mut u64,\n        )\n        .into();\n        let gas_info = GasInfo::with_cost(used_gas);\n        let _canonical = unsafe { canonical_buf.consume() };\n\n        // return complete error message (reading from buffer for GoResult::Other)\n        let default = || format!(\"Failed to humanize the address: {}\", canonical);\n        unsafe {\n            if let Err(err) = go_result.into_ffi_result(err, default) {\n                return (Err(err), gas_info);\n            }\n        }\n\n        let result = if output.ptr.is_null() {\n            Vec::new()\n        } else {\n            // We initialize `output` with a null pointer. if it is not null,\n            // that means it was initialized by the go code, with values generated by `memory::allocate_rust`\n            unsafe { output.consume() }\n        };\n        let human_result = String::from_utf8(result)\n            .map_err(FfiError::from)\n            .map(HumanAddr);\n        (human_result, gas_info)\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":43},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","db.rs"],"content":"use cosmwasm_sgx_vm::{FfiResult, GasInfo, Storage, StorageIterator};\n\nuse crate::error::GoResult;\nuse crate::gas_meter::gas_meter_t;\nuse crate::iterator::GoIter;\nuse crate::memory::Buffer;\n\n// this represents something passed in from the caller side of FFI\n#[repr(C)]\npub struct db_t {\n    _private: [u8; 0],\n}\n\n// These functions should return GoResult but because we don't trust them here, we treat the return value as i32\n// and then check it when converting to GoResult manually\n#[repr(C)]\npub struct DB_vtable {\n    pub read_db: extern \"C\" fn(\n        *mut db_t,\n        *mut gas_meter_t,\n        *mut u64,\n        Buffer,\n        *mut Buffer,\n        *mut Buffer,\n    ) -\u003e i32,\n    pub write_db:\n        extern \"C\" fn(*mut db_t, *mut gas_meter_t, *mut u64, Buffer, Buffer, *mut Buffer) -\u003e i32,\n    pub remove_db: extern \"C\" fn(*mut db_t, *mut gas_meter_t, *mut u64, Buffer, *mut Buffer) -\u003e i32,\n    // order -\u003e Ascending = 1, Descending = 2\n    // Note: we cannot set gas_meter on the returned GoIter due to cgo memory safety.\n    // Since we have the pointer in rust already, we must set that manually\n    pub scan_db: extern \"C\" fn(\n        *mut db_t,\n        *mut gas_meter_t,\n        *mut u64,\n        Buffer,\n        Buffer,\n        i32,\n        *mut GoIter,\n        *mut Buffer,\n    ) -\u003e i32,\n}\n\n#[repr(C)]\npub struct DB {\n    pub gas_meter: *mut gas_meter_t,\n    pub state: *mut db_t,\n    pub vtable: DB_vtable,\n}\n\nimpl Storage for DB {\n    fn get(\u0026self, key: \u0026[u8]) -\u003e FfiResult\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e {\n        let key_buf = Buffer::from_vec(key.to_vec());\n        let mut result_buf = Buffer::default();\n        let mut err = Buffer::default();\n        let mut used_gas = 0_u64;\n        let go_result: GoResult = (self.vtable.read_db)(\n            self.state,\n            self.gas_meter,\n            \u0026mut used_gas as *mut u64,\n            key_buf,\n            \u0026mut result_buf as *mut Buffer,\n            \u0026mut err as *mut Buffer,\n        )\n        .into();\n        let gas_info = GasInfo::with_externally_used(used_gas);\n        let _key = unsafe { key_buf.consume() };\n\n        // return complete error message (reading from buffer for GoResult::Other)\n        let default = || {\n            format!(\n                \"Failed to read a key in the db: {}\",\n                String::from_utf8_lossy(key)\n            )\n        };\n        unsafe {\n            if let Err(err) = go_result.into_ffi_result(err, default) {\n                return (Err(err), gas_info);\n            }\n        }\n\n        // We initialize `result_buf` with a null pointer. If it is not null, that means\n        // it was initialized by the go code, with values generated by `memory::allocate_rust`.\n        let value = if result_buf.ptr.is_null() {\n            None\n        } else {\n            Some(unsafe { result_buf.consume() })\n        };\n        (Ok(value), gas_info)\n    }\n\n    /// Allows iteration over a set of key/value pairs, either forwards or backwards.\n    ///\n    /// The bound `start` is inclusive and `end` is exclusive.\n    ///\n    /// If `start` is lexicographically greater than or equal to `end`, an empty range is described, mo matter of the order.\n    fn range\u003c'a\u003e(\n        \u0026'a self,\n        start: Option\u003c\u0026[u8]\u003e,\n        end: Option\u003c\u0026[u8]\u003e,\n        order: cosmwasm_std::Order,\n    ) -\u003e FfiResult\u003cBox\u003cdyn StorageIterator + 'a\u003e\u003e {\n        // returns nul pointer in Buffer in none, otherwise proper buffer\n        let start_buf = start\n            .map(|s| Buffer::from_vec(s.to_vec()))\n            .unwrap_or_default();\n        let end_buf = end\n            .map(|e| Buffer::from_vec(e.to_vec()))\n            .unwrap_or_default();\n        let mut err = Buffer::default();\n        let mut iter = GoIter::new(self.gas_meter);\n        let mut used_gas = 0_u64;\n        let go_result: GoResult = (self.vtable.scan_db)(\n            self.state,\n            self.gas_meter,\n            \u0026mut used_gas as *mut u64,\n            start_buf,\n            end_buf,\n            order.into(),\n            \u0026mut iter as *mut GoIter,\n            \u0026mut err as *mut Buffer,\n        )\n        .into();\n        let gas_info = GasInfo::with_externally_used(used_gas);\n        let _start = unsafe { start_buf.consume() };\n        let _end = unsafe { end_buf.consume() };\n\n        // return complete error message (reading from buffer for GoResult::Other)\n        let default = || {\n            format!(\n                \"Failed to read the next key between {:?} and {:?}\",\n                start.map(String::from_utf8_lossy),\n                end.map(String::from_utf8_lossy),\n            )\n        };\n        unsafe {\n            if let Err(err) = go_result.into_ffi_result(err, default) {\n                return (Err(err), gas_info);\n            }\n        }\n        (Ok(Box::new(iter)), gas_info)\n    }\n\n    fn set(\u0026mut self, key: \u0026[u8], value: \u0026[u8]) -\u003e FfiResult\u003c()\u003e {\n        let key_buf = Buffer::from_vec(key.to_vec());\n        let value_buf = Buffer::from_vec(value.to_vec());\n        let mut err = Buffer::default();\n        let mut used_gas = 0_u64;\n        let go_result: GoResult = (self.vtable.write_db)(\n            self.state,\n            self.gas_meter,\n            \u0026mut used_gas as *mut u64,\n            key_buf,\n            value_buf,\n            \u0026mut err as *mut Buffer,\n        )\n        .into();\n        let gas_info = GasInfo::with_externally_used(used_gas);\n        let _key = unsafe { key_buf.consume() };\n        let _value = unsafe { value_buf.consume() };\n        // return complete error message (reading from buffer for GoResult::Other)\n        let default = || {\n            format!(\n                \"Failed to set a key in the db: {}\",\n                String::from_utf8_lossy(key),\n            )\n        };\n        unsafe {\n            if let Err(err) = go_result.into_ffi_result(err, default) {\n                return (Err(err), gas_info);\n            }\n        }\n        (Ok(()), gas_info)\n    }\n\n    fn remove(\u0026mut self, key: \u0026[u8]) -\u003e FfiResult\u003c()\u003e {\n        let key_buf = Buffer::from_vec(key.to_vec());\n        let mut err = Buffer::default();\n        let mut used_gas = 0_u64;\n        let go_result: GoResult = (self.vtable.remove_db)(\n            self.state,\n            self.gas_meter,\n            \u0026mut used_gas as *mut u64,\n            key_buf,\n            \u0026mut err as *mut Buffer,\n        )\n        .into();\n        let gas_info = GasInfo::with_externally_used(used_gas);\n        let _key = unsafe { key_buf.consume() };\n        let default = || {\n            format!(\n                \"Failed to delete a key in the db: {}\",\n                String::from_utf8_lossy(key),\n            )\n        };\n        unsafe {\n            if let Err(err) = go_result.into_ffi_result(err, default) {\n                return (Err(err), gas_info);\n            }\n        }\n        (Ok(()), gas_info)\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":85},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","error","go.rs"],"content":"use cosmwasm_sgx_vm::FfiError;\nuse std::fmt;\n\nuse crate::Buffer;\n\n/// This enum gives names to the status codes returned from Go callbacks to Rust.\n///\n/// The go code will return one of these variants when returning.\n///\n/// cbindgen:prefix-with-name\n// NOTE TO DEVS: If you change the values assigned to the variants of this enum, You must also\n//               update the match statement in the From conversion below.\n//               Otherwise all hell may break loose.\n//               You have been warned.\n//\n#[repr(i32)] // This makes it so the enum looks like a simple i32 to Go\n#[derive(PartialEq)]\npub enum GoResult {\n    Ok = 0,\n    /// Go panicked for an unexpected reason.\n    Panic = 1,\n    /// Go received a bad argument from Rust\n    BadArgument = 2,\n    /// Ran out of gas while using the SDK (e.g. storage)\n    OutOfGas = 3,\n    /// An error happened during normal operation of a Go callback, which should abort the contract\n    Other = 4,\n    /// An error happened during normal operation of a Go callback, which should be fed back to the contract\n    User = 5,\n}\n\nimpl From\u003ci32\u003e for GoResult {\n    fn from(n: i32) -\u003e Self {\n        use GoResult::*;\n        // This conversion treats any number that is not otherwise an expected value as `GoError::Other`\n        match n {\n            0 =\u003e Ok,\n            1 =\u003e Panic,\n            2 =\u003e BadArgument,\n            3 =\u003e OutOfGas,\n            5 =\u003e User,\n            _ =\u003e Other,\n        }\n    }\n}\n\nimpl fmt::Display for GoResult {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            GoResult::Ok =\u003e write!(f, \"Ok\"),\n            GoResult::Panic =\u003e write!(f, \"Panic\"),\n            GoResult::BadArgument =\u003e write!(f, \"BadArgument\"),\n            GoResult::OutOfGas =\u003e write!(f, \"OutOfGas\"),\n            GoResult::Other =\u003e write!(f, \"Other Error\"),\n            GoResult::User =\u003e write!(f, \"User Error\"),\n        }\n    }\n}\n\nimpl GoResult {\n    /// This converts a GoResult to a `Result\u003c(), FfiError\u003e`, using a fallback error message for some cases.\n    /// If it is GoResult::User the error message will be returned to the contract.\n    /// Otherwise, the returned error will trigger a trap in the VM and abort contract execution immediately.\n    ///\n    /// Safety: this reads data from an externally provided buffer and assumes valid utf-8 encoding\n    /// Only call if you trust the code that provides `error_msg` to be correct.\n    pub unsafe fn into_ffi_result\u003cF\u003e(self, error_msg: Buffer, default: F) -\u003e Result\u003c(), FfiError\u003e\n    where\n        F: Fn() -\u003e String,\n    {\n        let read_error_msg = || {\n            // We initialize `error_msg` with a null pointer. if it is not null,\n            // that means it was initialized by the go code, with values generated by `memory::allocate_rust`\n            if error_msg.ptr.is_null() {\n                default()\n            } else {\n                String::from_utf8_lossy(\u0026error_msg.consume()).into()\n            }\n        };\n\n        match self {\n            GoResult::Ok =\u003e Ok(()),\n            GoResult::Panic =\u003e Err(FfiError::foreign_panic()),\n            GoResult::BadArgument =\u003e Err(FfiError::bad_argument()),\n            GoResult::OutOfGas =\u003e Err(FfiError::out_of_gas()),\n            GoResult::Other =\u003e Err(FfiError::unknown(read_error_msg())),\n            GoResult::User =\u003e Err(FfiError::user_err(read_error_msg())),\n        }\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","error","mod.rs"],"content":"mod go;\nmod rust;\n\npub use go::GoResult;\npub use rust::{clear_error, handle_c_error, set_error, Error};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","error","rust.rs"],"content":"use errno::{set_errno, Errno};\n\nuse cosmwasm_sgx_vm::VmError;\nuse snafu::Snafu;\n\nuse crate::memory::Buffer;\n\n#[derive(Debug, Snafu)]\npub enum Error {\n    #[snafu(display(\"Null/Empty argument: {}\", name))]\n    EmptyArg {\n        name: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: snafu::Backtrace,\n    },\n    /// Whenever UTF-8 bytes cannot be decoded into a unicode string, e.g. in String::from_utf8 or str::from_utf8.\n    #[snafu(display(\"Cannot decode UTF8 bytes into string: {}\", msg))]\n    InvalidUtf8 {\n        msg: String,\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Ran out of gas\"))]\n    OutOfGas {\n        #[cfg(feature = \"backtraces\")]\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Caught Panic\"))]\n    Panic {\n        #[cfg(feature = \"backtraces\")]\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"Execution error: {}\", msg))]\n    VmErr {\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: snafu::Backtrace,\n    },\n    #[snafu(display(\"{}\", msg))]\n    GoCwEnclaveError {\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: snafu::Backtrace,\n    },\n}\n\nimpl Error {\n    pub fn empty_arg\u003cT: Into\u003cString\u003e\u003e(name: T) -\u003e Self {\n        EmptyArg { name: name.into() }.build()\n    }\n\n    pub fn invalid_utf8\u003cS: ToString\u003e(msg: S) -\u003e Self {\n        InvalidUtf8 {\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n\n    pub fn panic() -\u003e Self {\n        Panic {}.build()\n    }\n\n    pub fn vm_err\u003cS: ToString\u003e(msg: S) -\u003e Self {\n        VmErr {\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n\n    pub fn enclave_err\u003cS: ToString\u003e(msg: S) -\u003e Self {\n        GoCwEnclaveError {\n            msg: msg.to_string(),\n        }\n        .build()\n    }\n\n    pub fn out_of_gas() -\u003e Self {\n        OutOfGas {}.build()\n    }\n}\n\nimpl From\u003cVmError\u003e for Error {\n    fn from(source: VmError) -\u003e Self {\n        match source {\n            VmError::GasDepletion =\u003e Error::out_of_gas(),\n            _ =\u003e Error::vm_err(source),\n        }\n    }\n}\n\nimpl From\u003cstd::str::Utf8Error\u003e for Error {\n    fn from(source: std::str::Utf8Error) -\u003e Self {\n        Error::invalid_utf8(source)\n    }\n}\n\nimpl From\u003cstd::string::FromUtf8Error\u003e for Error {\n    fn from(source: std::string::FromUtf8Error) -\u003e Self {\n        Error::invalid_utf8(source)\n    }\n}\n\n/// cbindgen:prefix-with-name\n#[repr(i32)]\nenum ErrnoValue {\n    Success = 0,\n    Other = 1,\n    OutOfGas = 2,\n}\n\npub fn clear_error() {\n    set_errno(Errno(ErrnoValue::Success as i32));\n}\n\npub fn set_error(err: Error, errout: Option\u003c\u0026mut Buffer\u003e) {\n    let msg = err.to_string();\n    if let Some(mb) = errout {\n        *mb = Buffer::from_vec(msg.into_bytes());\n    }\n    let errno = match err {\n        Error::OutOfGas { .. } =\u003e ErrnoValue::OutOfGas,\n        _ =\u003e ErrnoValue::Other,\n    } as i32;\n    set_errno(Errno(errno));\n}\n\n/// If `result` is Ok, this returns the binary representation of the Ok value and clears the error in `errout`.\n/// Otherwise it returns an empty vector and writes the error to `errout`.\npub fn handle_c_error\u003cT\u003e(result: Result\u003cT, Error\u003e, errout: Option\u003c\u0026mut Buffer\u003e) -\u003e Vec\u003cu8\u003e\nwhere\n    T: Into\u003cVec\u003cu8\u003e\u003e,\n{\n    match result {\n        Ok(value) =\u003e {\n            clear_error();\n            value.into()\n        }\n        Err(error) =\u003e {\n            set_error(error, errout);\n            Vec::new()\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_sgx_vm::FfiError;\n    use std::str;\n\n    #[test]\n    fn empty_arg_works() {\n        let error = Error::empty_arg(\"gas\");\n        match error {\n            Error::EmptyArg { name, .. } =\u003e {\n                assert_eq!(name, \"gas\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn invalid_utf8_works_for_strings() {\n        let error = Error::invalid_utf8(\"my text\");\n        match error {\n            Error::InvalidUtf8 { msg, .. } =\u003e {\n                assert_eq!(msg, \"my text\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn invalid_utf8_works_for_errors() {\n        let original = String::from_utf8(vec![0x80]).unwrap_err();\n        let error = Error::invalid_utf8(original);\n        match error {\n            Error::InvalidUtf8 { msg, .. } =\u003e {\n                assert_eq!(msg, \"invalid utf-8 sequence of 1 bytes from index 0\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn panic_works() {\n        let error = Error::panic();\n        match error {\n            Error::Panic { .. } =\u003e {}\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn vm_err_works_for_strings() {\n        let error = Error::vm_err(\"my text\");\n        match error {\n            Error::VmErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"my text\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn vm_err_works_for_errors() {\n        // No public interface exists to generate a VmError directly\n        let original: VmError = FfiError::out_of_gas().into();\n        let error = Error::vm_err(original);\n        match error {\n            Error::VmErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Ran out of gas during contract execution\");\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    // Tests of `impl From\u003cX\u003e for Error` converters\n\n    #[test]\n    fn from_std_str_utf8error_works() {\n        let error: Error = str::from_utf8(b\"Hello \\xF0\\x90\\x80World\")\n            .unwrap_err()\n            .into();\n        match error {\n            Error::InvalidUtf8 { msg, .. } =\u003e {\n                assert_eq!(msg, \"invalid utf-8 sequence of 3 bytes from index 6\")\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n\n    #[test]\n    fn from_std_string_fromutf8error_works() {\n        let error: Error = String::from_utf8(b\"Hello \\xF0\\x90\\x80World\".to_vec())\n            .unwrap_err()\n            .into();\n        match error {\n            Error::InvalidUtf8 { msg, .. } =\u003e {\n                assert_eq!(msg, \"invalid utf-8 sequence of 3 bytes from index 6\")\n            }\n            _ =\u003e panic!(\"expect different error\"),\n        }\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":18},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","gas_meter.rs"],"content":"/// An opaque type. `*gas_meter_t` represents a pointer to Go memory holding the gas meter.\n#[repr(C)]\npub struct gas_meter_t {\n    _private: [u8; 0],\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","iterator.rs"],"content":"use cosmwasm_sgx_vm::{FfiError, FfiResult, GasInfo, StorageIterator};\nuse cosmwasm_std::KV;\n\nuse crate::error::GoResult;\nuse crate::gas_meter::gas_meter_t;\nuse crate::memory::Buffer;\n\n// Iterator maintains integer references to some tables on the Go side\n#[repr(C)]\n#[derive(Default, Copy, Clone)]\npub struct iterator_t {\n    pub db_counter: u64,\n    pub iterator_index: u64,\n}\n\n// These functions should return GoResult but because we don't trust them here, we treat the return value as i32\n// and then check it when converting to GoResult manually\n#[repr(C)]\n#[derive(Default)]\npub struct Iterator_vtable {\n    pub next_db: Option\u003c\n        extern \"C\" fn(\n            iterator_t,\n            *mut gas_meter_t,\n            *mut u64,\n            *mut Buffer,\n            *mut Buffer,\n            *mut Buffer,\n        ) -\u003e i32,\n    \u003e,\n}\n\n#[repr(C)]\npub struct GoIter {\n    pub gas_meter: *mut gas_meter_t,\n    pub state: iterator_t,\n    pub vtable: Iterator_vtable,\n}\n\nimpl GoIter {\n    pub fn new(gas_meter: *mut gas_meter_t) -\u003e Self {\n        GoIter {\n            gas_meter,\n            state: iterator_t::default(),\n            vtable: Iterator_vtable::default(),\n        }\n    }\n}\n\nimpl StorageIterator for GoIter {\n    fn next(\u0026mut self) -\u003e FfiResult\u003cOption\u003cKV\u003e\u003e {\n        let next_db = match self.vtable.next_db {\n            Some(f) =\u003e f,\n            None =\u003e {\n                let result = Err(FfiError::unknown(\"iterator vtable not set\"));\n                return (result, GasInfo::free());\n            }\n        };\n\n        let mut key_buf = Buffer::default();\n        let mut value_buf = Buffer::default();\n        let mut err = Buffer::default();\n        let mut used_gas = 0_u64;\n        let go_result: GoResult = (next_db)(\n            self.state,\n            self.gas_meter,\n            \u0026mut used_gas as *mut u64,\n            \u0026mut key_buf as *mut Buffer,\n            \u0026mut value_buf as *mut Buffer,\n            \u0026mut err as *mut Buffer,\n        )\n        .into();\n        let gas_info = GasInfo::with_externally_used(used_gas);\n\n        // return complete error message (reading from buffer for GoResult::Other)\n        let default = || \"Failed to fetch next item from iterator\".to_string();\n        unsafe {\n            if let Err(err) = go_result.into_ffi_result(err, default) {\n                return (Err(err), gas_info);\n            }\n        }\n\n        let okey = unsafe { key_buf.read() };\n        let result = match okey {\n            Some(key) =\u003e {\n                let value = unsafe { value_buf.read() };\n                if let Some(value) = value {\n                    Ok(Some((key.into(), value.into())))\n                } else {\n                    Err(FfiError::unknown(\n                        \"Failed to read value while reading the next key in the db\",\n                    ))\n                }\n            }\n            None =\u003e Ok(None),\n        };\n        (result, gas_info)\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":33},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","lib.rs"],"content":"mod api;\nmod db;\nmod error;\nmod gas_meter;\nmod iterator;\nmod memory;\nmod querier;\nmod tests;\n\npub use api::GoApi;\npub use db::{db_t, DB};\npub use memory::{free_rust, Buffer};\npub use querier::GoQuerier;\n\nuse std::convert::TryInto;\nuse std::panic::{catch_unwind, AssertUnwindSafe};\nuse std::str::from_utf8;\n\nuse crate::error::{clear_error, handle_c_error, set_error, Error};\n\nuse cosmwasm_sgx_vm::untrusted_init_bootstrap;\nuse cosmwasm_sgx_vm::{\n    call_handle_raw, call_init_raw, call_migrate_raw, call_query_raw, features_from_csv, Checksum,\n    CosmCache, Extern,\n};\nuse cosmwasm_sgx_vm::{\n    create_attestation_report_u, untrusted_get_encrypted_seed, untrusted_health_check,\n    untrusted_init_node, untrusted_key_gen,\n};\n\nuse ctor::ctor;\nuse log::*;\n\n#[ctor]\nfn init_logger() {\n    simple_logger::init_with_level(log::Level::Info).unwrap();\n}\n\n#[repr(C)]\npub struct cache_t {}\n\nfn to_cache(ptr: *mut cache_t) -\u003e Option\u003c\u0026'static mut CosmCache\u003cDB, GoApi, GoQuerier\u003e\u003e {\n    if ptr.is_null() {\n        None\n    } else {\n        let c = unsafe { \u0026mut *(ptr as *mut CosmCache\u003cDB, GoApi, GoQuerier\u003e) };\n        Some(c)\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn get_health_check(err: Option\u003c\u0026mut Buffer\u003e) -\u003e Buffer {\n    match untrusted_health_check() {\n        Err(e) =\u003e {\n            set_error(Error::enclave_err(e.to_string()), err);\n            Buffer::default()\n        }\n        Ok(res) =\u003e {\n            clear_error();\n            Buffer::from_vec(format!(\"{}\", res).into_bytes())\n        }\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn get_encrypted_seed(cert: Buffer, err: Option\u003c\u0026mut Buffer\u003e) -\u003e Buffer {\n    trace!(\"Called get_encrypted_seed\");\n    let cert_slice = match unsafe { cert.read() } {\n        None =\u003e {\n            set_error(Error::empty_arg(\"attestation_cert\"), err);\n            return Buffer::default();\n        }\n        Some(r) =\u003e r,\n    };\n    trace!(\"Hello from right before untrusted_get_encrypted_seed\");\n    match untrusted_get_encrypted_seed(cert_slice) {\n        Err(e) =\u003e {\n            // An error happened in the SGX sdk.\n            set_error(Error::enclave_err(e.to_string()), err);\n            Buffer::default()\n        }\n        Ok(Err(e)) =\u003e {\n            // An error was returned from the enclave.\n            set_error(Error::enclave_err(e.to_string()), err);\n            Buffer::default()\n        }\n        Ok(Ok(seed)) =\u003e {\n            clear_error();\n            Buffer::from_vec(seed.to_vec())\n        }\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn init_bootstrap(\n    spid: Buffer,\n    api_key: Buffer,\n    err: Option\u003c\u0026mut Buffer\u003e,\n) -\u003e Buffer {\n    trace!(\"Hello from right before init_bootstrap\");\n\n    let spid_slice = match unsafe { spid.read() } {\n        None =\u003e {\n            set_error(Error::empty_arg(\"spid\"), err);\n            return Buffer::default();\n        }\n        Some(r) =\u003e r,\n    };\n\n    let api_key_slice = match unsafe { api_key.read() } {\n        None =\u003e {\n            set_error(Error::empty_arg(\"api_key\"), err);\n            return Buffer::default();\n        }\n        Some(r) =\u003e r,\n    };\n\n    match untrusted_init_bootstrap(spid_slice, api_key_slice) {\n        Err(e) =\u003e {\n            set_error(Error::enclave_err(e.to_string()), err);\n            Buffer::default()\n        }\n        Ok(r) =\u003e {\n            clear_error();\n            Buffer::from_vec(r.to_vec())\n        }\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn init_node(\n    master_cert: Buffer,\n    encrypted_seed: Buffer,\n    err: Option\u003c\u0026mut Buffer\u003e,\n) -\u003e bool {\n    let pk_slice = match unsafe { master_cert.read() } {\n        None =\u003e {\n            set_error(Error::empty_arg(\"master_cert\"), err);\n            return false;\n        }\n        Some(r) =\u003e r,\n    };\n    let encrypted_seed_slice = match unsafe { encrypted_seed.read() } {\n        None =\u003e {\n            set_error(Error::empty_arg(\"encrypted_seed\"), err);\n            return false;\n        }\n        Some(r) =\u003e r,\n    };\n\n    match untrusted_init_node(pk_slice, encrypted_seed_slice) {\n        Ok(_) =\u003e {\n            clear_error();\n            true\n        }\n        Err(e) =\u003e {\n            set_error(Error::enclave_err(e.to_string()), err);\n            false\n        }\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn create_attestation_report(\n    spid: Buffer,\n    api_key: Buffer,\n    err: Option\u003c\u0026mut Buffer\u003e,\n) -\u003e bool {\n    let spid_slice = match unsafe { spid.read() } {\n        None =\u003e {\n            set_error(Error::empty_arg(\"spid\"), err);\n            return false;\n        }\n        Some(r) =\u003e r,\n    };\n\n    let api_key_slice = match unsafe { api_key.read() } {\n        None =\u003e {\n            set_error(Error::empty_arg(\"api_key\"), err);\n            return false;\n        }\n        Some(r) =\u003e r,\n    };\n\n    if let Err(status) = create_attestation_report_u(spid_slice, api_key_slice) {\n        set_error(Error::enclave_err(status.to_string()), err);\n        return false;\n    }\n    clear_error();\n    true\n}\n\nfn to_extern(storage: DB, api: GoApi, querier: GoQuerier) -\u003e Extern\u003cDB, GoApi, GoQuerier\u003e {\n    Extern {\n        storage,\n        api,\n        querier,\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn init_cache(\n    data_dir: Buffer,\n    supported_features: Buffer,\n    // TODO: remove unused cache size\n    _cache_size: usize,\n    err: Option\u003c\u0026mut Buffer\u003e,\n) -\u003e *mut cache_t {\n    let r = catch_unwind(|| do_init_cache(data_dir, supported_features))\n        .unwrap_or_else(|_| Err(Error::panic()));\n    match r {\n        Ok(t) =\u003e {\n            clear_error();\n            t as *mut cache_t\n        }\n        Err(e) =\u003e {\n            set_error(e, err);\n            std::ptr::null_mut()\n        }\n    }\n}\n\n// store some common string for argument names\nstatic DATA_DIR_ARG: \u0026str = \"data_dir\";\nstatic FEATURES_ARG: \u0026str = \"supported_features\";\nstatic CACHE_ARG: \u0026str = \"cache\";\nstatic WASM_ARG: \u0026str = \"wasm\";\nstatic CODE_ID_ARG: \u0026str = \"code_id\";\nstatic MSG_ARG: \u0026str = \"msg\";\nstatic PARAMS_ARG: \u0026str = \"params\";\nstatic GAS_USED_ARG: \u0026str = \"gas_used\";\nstatic SIG_INFO_ARG: \u0026str = \"sig_info\";\n\nfn do_init_cache(\n    data_dir: Buffer,\n    supported_features: Buffer,\n) -\u003e Result\u003c*mut CosmCache\u003cDB, GoApi, GoQuerier\u003e, Error\u003e {\n    let dir = unsafe { data_dir.read() }.ok_or_else(|| Error::empty_arg(DATA_DIR_ARG))?;\n    let dir_str = from_utf8(dir)?;\n    // parse the supported features\n    let features_bin =\n        unsafe { supported_features.read() }.ok_or_else(|| Error::empty_arg(FEATURES_ARG))?;\n    let features_str = from_utf8(features_bin)?;\n    let features = features_from_csv(features_str);\n    let cache = unsafe { CosmCache::new(dir_str, features) }?;\n    let out = Box::new(cache);\n    Ok(Box::into_raw(out))\n}\n\n/// frees a cache reference\n///\n/// # Safety\n///\n/// This must be called exactly once for any `*cache_t` returned by `init_cache`\n/// and cannot be called on any other pointer.\n#[no_mangle]\npub extern \"C\" fn release_cache(cache: *mut cache_t) {\n    if !cache.is_null() {\n        // this will free cache when it goes out of scope\n        let _ = unsafe { Box::from_raw(cache as *mut CosmCache\u003cDB, GoApi, GoQuerier\u003e) };\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn create(cache: *mut cache_t, wasm: Buffer, err: Option\u003c\u0026mut Buffer\u003e) -\u003e Buffer {\n    let r = match to_cache(cache) {\n        Some(c) =\u003e catch_unwind(AssertUnwindSafe(move || do_create(c, wasm)))\n            .unwrap_or_else(|_| Err(Error::panic())),\n        None =\u003e Err(Error::empty_arg(CACHE_ARG)),\n    };\n    let data = handle_c_error(r, err);\n    Buffer::from_vec(data)\n}\n\nfn do_create(cache: \u0026mut CosmCache\u003cDB, GoApi, GoQuerier\u003e, wasm: Buffer) -\u003e Result\u003cChecksum, Error\u003e {\n    let wasm = unsafe { wasm.read() }.ok_or_else(|| Error::empty_arg(WASM_ARG))?;\n    let checksum = cache.save_wasm(wasm)?;\n    Ok(checksum)\n}\n\n#[no_mangle]\npub extern \"C\" fn get_code(cache: *mut cache_t, id: Buffer, err: Option\u003c\u0026mut Buffer\u003e) -\u003e Buffer {\n    let r = match to_cache(cache) {\n        Some(c) =\u003e catch_unwind(AssertUnwindSafe(move || do_get_code(c, id)))\n            .unwrap_or_else(|_| Err(Error::panic())),\n        None =\u003e Err(Error::empty_arg(CACHE_ARG)),\n    };\n    let data = handle_c_error(r, err);\n    Buffer::from_vec(data)\n}\n\nfn do_get_code(cache: \u0026mut CosmCache\u003cDB, GoApi, GoQuerier\u003e, id: Buffer) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    let id: Checksum = unsafe { id.read() }\n        .ok_or_else(|| Error::empty_arg(CACHE_ARG))?\n        .try_into()?;\n    let wasm = cache.load_wasm(\u0026id)?;\n    Ok(wasm)\n}\n\n#[no_mangle]\npub extern \"C\" fn instantiate(\n    cache: *mut cache_t,\n    contract_id: Buffer,\n    params: Buffer,\n    msg: Buffer,\n    db: DB,\n    api: GoApi,\n    querier: GoQuerier,\n    gas_limit: u64,\n    gas_used: Option\u003c\u0026mut u64\u003e,\n    err: Option\u003c\u0026mut Buffer\u003e,\n    sig_info: Buffer,\n) -\u003e Buffer {\n    let r = match to_cache(cache) {\n        Some(c) =\u003e catch_unwind(AssertUnwindSafe(move || {\n            do_init(\n                c,\n                contract_id,\n                params,\n                msg,\n                db,\n                api,\n                querier,\n                gas_limit,\n                gas_used,\n                sig_info,\n            )\n        }))\n        .unwrap_or_else(|_| Err(Error::panic())),\n        None =\u003e Err(Error::empty_arg(CACHE_ARG)),\n    };\n    let data = handle_c_error(r, err);\n    Buffer::from_vec(data)\n}\n\nfn do_init(\n    cache: \u0026mut CosmCache\u003cDB, GoApi, GoQuerier\u003e,\n    code_id: Buffer,\n    params: Buffer,\n    msg: Buffer,\n    db: DB,\n    api: GoApi,\n    querier: GoQuerier,\n    gas_limit: u64,\n    gas_used: Option\u003c\u0026mut u64\u003e,\n    sig_info: Buffer,\n) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    let gas_used = gas_used.ok_or_else(|| Error::empty_arg(GAS_USED_ARG))?;\n    let code_id: Checksum = unsafe { code_id.read() }\n        .ok_or_else(|| Error::empty_arg(CODE_ID_ARG))?\n        .try_into()?;\n    let params = unsafe { params.read() }.ok_or_else(|| Error::empty_arg(PARAMS_ARG))?;\n    let msg = unsafe { msg.read() }.ok_or_else(|| Error::empty_arg(MSG_ARG))?;\n    let sig_info = unsafe { sig_info.read() }.ok_or_else(|| Error::empty_arg(SIG_INFO_ARG))?;\n\n    let deps = to_extern(db, api, querier);\n    let mut instance = cache.get_instance(\u0026code_id, deps, gas_limit)?;\n    // We only check this result after reporting gas usage and returning the instance into the cache.\n    let res = call_init_raw(\u0026mut instance, params, msg, sig_info);\n    *gas_used = instance.create_gas_report().used_internally;\n    instance.recycle();\n    Ok(res?)\n}\n\n#[no_mangle]\npub extern \"C\" fn handle(\n    cache: *mut cache_t,\n    code_id: Buffer,\n    params: Buffer,\n    msg: Buffer,\n    db: DB,\n    api: GoApi,\n    querier: GoQuerier,\n    gas_limit: u64,\n    gas_used: Option\u003c\u0026mut u64\u003e,\n    err: Option\u003c\u0026mut Buffer\u003e,\n    sig_info: Buffer,\n) -\u003e Buffer {\n    let r = match to_cache(cache) {\n        Some(c) =\u003e catch_unwind(AssertUnwindSafe(move || {\n            do_handle(\n                c, code_id, params, msg, db, api, querier, gas_limit, gas_used, sig_info,\n            )\n        }))\n        .unwrap_or_else(|_| Err(Error::panic())),\n        None =\u003e Err(Error::empty_arg(CACHE_ARG)),\n    };\n    let data = handle_c_error(r, err);\n    Buffer::from_vec(data)\n}\n\nfn do_handle(\n    cache: \u0026mut CosmCache\u003cDB, GoApi, GoQuerier\u003e,\n    code_id: Buffer,\n    params: Buffer,\n    msg: Buffer,\n    db: DB,\n    api: GoApi,\n    querier: GoQuerier,\n    gas_limit: u64,\n    gas_used: Option\u003c\u0026mut u64\u003e,\n    sig_info: Buffer,\n) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    let gas_used = gas_used.ok_or_else(|| Error::empty_arg(GAS_USED_ARG))?;\n    let code_id: Checksum = unsafe { code_id.read() }\n        .ok_or_else(|| Error::empty_arg(CODE_ID_ARG))?\n        .try_into()?;\n    let params = unsafe { params.read() }.ok_or_else(|| Error::empty_arg(PARAMS_ARG))?;\n    let msg = unsafe { msg.read() }.ok_or_else(|| Error::empty_arg(MSG_ARG))?;\n    let sig_info = unsafe { sig_info.read() }.ok_or_else(|| Error::empty_arg(SIG_INFO_ARG))?;\n\n    let deps = to_extern(db, api, querier);\n    let mut instance = cache.get_instance(\u0026code_id, deps, gas_limit)?;\n    // We only check this result after reporting gas usage and returning the instance into the cache.\n    let res = call_handle_raw(\u0026mut instance, params, msg, sig_info);\n    *gas_used = instance.create_gas_report().used_internally;\n    instance.recycle();\n    Ok(res?)\n}\n\n#[no_mangle]\npub extern \"C\" fn migrate(\n    cache: *mut cache_t,\n    contract_id: Buffer,\n    params: Buffer,\n    msg: Buffer,\n    db: DB,\n    api: GoApi,\n    querier: GoQuerier,\n    gas_limit: u64,\n    gas_used: Option\u003c\u0026mut u64\u003e,\n    err: Option\u003c\u0026mut Buffer\u003e,\n) -\u003e Buffer {\n    let r = match to_cache(cache) {\n        Some(c) =\u003e catch_unwind(AssertUnwindSafe(move || {\n            do_migrate(\n                c,\n                contract_id,\n                params,\n                msg,\n                db,\n                api,\n                querier,\n                gas_limit,\n                gas_used,\n            )\n        }))\n        .unwrap_or_else(|_| Err(Error::panic())),\n        None =\u003e Err(Error::empty_arg(CACHE_ARG)),\n    };\n    let data = handle_c_error(r, err);\n    Buffer::from_vec(data)\n}\n\nfn do_migrate(\n    cache: \u0026mut CosmCache\u003cDB, GoApi, GoQuerier\u003e,\n    code_id: Buffer,\n    params: Buffer,\n    msg: Buffer,\n    db: DB,\n    api: GoApi,\n    querier: GoQuerier,\n    gas_limit: u64,\n    gas_used: Option\u003c\u0026mut u64\u003e,\n) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    let gas_used = gas_used.ok_or_else(|| Error::empty_arg(GAS_USED_ARG))?;\n    let code_id: Checksum = unsafe { code_id.read() }\n        .ok_or_else(|| Error::empty_arg(CODE_ID_ARG))?\n        .try_into()?;\n    let params = unsafe { params.read() }.ok_or_else(|| Error::empty_arg(PARAMS_ARG))?;\n    let msg = unsafe { msg.read() }.ok_or_else(|| Error::empty_arg(MSG_ARG))?;\n\n    let deps = to_extern(db, api, querier);\n    let mut instance = cache.get_instance(\u0026code_id, deps, gas_limit)?;\n    // We only check this result after reporting gas usage and returning the instance into the cache.\n    let res = call_migrate_raw(\u0026mut instance, params, msg);\n    *gas_used = instance.create_gas_report().used_internally;\n    instance.recycle();\n    Ok(res?)\n}\n\n#[no_mangle]\npub extern \"C\" fn query(\n    cache: *mut cache_t,\n    code_id: Buffer,\n    msg: Buffer,\n    db: DB,\n    api: GoApi,\n    querier: GoQuerier,\n    gas_limit: u64,\n    gas_used: Option\u003c\u0026mut u64\u003e,\n    err: Option\u003c\u0026mut Buffer\u003e,\n) -\u003e Buffer {\n    let r = match to_cache(cache) {\n        Some(c) =\u003e catch_unwind(AssertUnwindSafe(move || {\n            do_query(c, code_id, msg, db, api, querier, gas_limit, gas_used)\n        }))\n        .unwrap_or_else(|_| Err(Error::panic())),\n        None =\u003e Err(Error::empty_arg(CACHE_ARG)),\n    };\n    let data = handle_c_error(r, err);\n    Buffer::from_vec(data)\n}\n\nfn do_query(\n    cache: \u0026mut CosmCache\u003cDB, GoApi, GoQuerier\u003e,\n    code_id: Buffer,\n    msg: Buffer,\n    db: DB,\n    api: GoApi,\n    querier: GoQuerier,\n    gas_limit: u64,\n    gas_used: Option\u003c\u0026mut u64\u003e,\n) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    let gas_used = gas_used.ok_or_else(|| Error::empty_arg(GAS_USED_ARG))?;\n    let code_id: Checksum = unsafe { code_id.read() }\n        .ok_or_else(|| Error::empty_arg(CODE_ID_ARG))?\n        .try_into()?;\n    let msg = unsafe { msg.read() }.ok_or_else(|| Error::empty_arg(MSG_ARG))?;\n\n    let deps = to_extern(db, api, querier);\n    let mut instance = cache.get_instance(\u0026code_id, deps, gas_limit)?;\n    // We only check this result after reporting gas usage and returning the instance into the cache.\n    let res = call_query_raw(\u0026mut instance, msg);\n    *gas_used = instance.create_gas_report().used_internally;\n    instance.recycle();\n    Ok(res?)\n}\n\n#[no_mangle]\npub extern \"C\" fn key_gen(err: Option\u003c\u0026mut Buffer\u003e) -\u003e Buffer {\n    match untrusted_key_gen() {\n        Err(e) =\u003e {\n            set_error(Error::enclave_err(e.to_string()), err);\n            Buffer::default()\n        }\n        Ok(r) =\u003e {\n            clear_error();\n            Buffer::from_vec(r.to_vec())\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","memory.rs"],"content":"use std::mem;\nuse std::slice;\n\n#[no_mangle]\npub extern \"C\" fn allocate_rust(ptr: *const u8, length: usize) -\u003e Buffer {\n    // Go doesn't store empty buffers the same way Rust stores empty slices (with NonNull  pointers\n    // equal to the offset of the type, which would be equal to 1 in this case)\n    // so when it wants to represent an empty buffer, it passes a null pointer with 0 length here.\n    if length == 0 {\n        Buffer::from_vec(Vec::new())\n    } else {\n        Buffer::from_vec(Vec::from(unsafe { slice::from_raw_parts(ptr, length) }))\n    }\n}\n\n// this frees memory we released earlier\n#[no_mangle]\npub extern \"C\" fn free_rust(buf: Buffer) {\n    unsafe {\n        let _ = buf.consume();\n    }\n}\n\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct Buffer {\n    pub ptr: *mut u8,\n    pub len: usize,\n    pub cap: usize,\n}\n\nimpl Buffer {\n    /// `read` provides a reference to the included data to be parsed or copied elsewhere\n    ///\n    /// # Safety\n    ///\n    /// The caller must make sure that the `Buffer` points to valid and initialized memory\n    pub unsafe fn read(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e {\n        if self.ptr.is_null() {\n            None\n        } else {\n            Some(slice::from_raw_parts(self.ptr, self.len))\n        }\n    }\n\n    /// consume must only be used on memory previously released by from_vec\n    /// when the Vec is out of scope, it will deallocate the memory previously referenced by Buffer\n    ///\n    /// # Safety\n    ///\n    /// if not empty, `ptr` must be a valid memory reference, which was previously\n    /// created by `from_vec`. You may not consume a slice twice.\n    /// Otherwise you risk double free panics\n    pub unsafe fn consume(self) -\u003e Vec\u003cu8\u003e {\n        if self.ptr.is_null() {\n            vec![]\n        } else {\n            Vec::from_raw_parts(self.ptr, self.len, self.cap)\n        }\n    }\n\n    /// Creates a new zero length Buffer with the given capacity\n    pub fn with_capacity(capacity: usize) -\u003e Self {\n        Buffer::from_vec(Vec::\u003cu8\u003e::with_capacity(capacity))\n    }\n\n    // this releases our memory to the caller\n    pub fn from_vec(v: Vec\u003cu8\u003e) -\u003e Self {\n        let mut v = mem::ManuallyDrop::new(v);\n        Buffer {\n            ptr: v.as_mut_ptr(),\n            len: v.len(),\n            cap: v.capacity(),\n        }\n    }\n}\n\nimpl Default for Buffer {\n    fn default() -\u003e Self {\n        Buffer {\n            ptr: std::ptr::null_mut::\u003cu8\u003e(),\n            len: 0,\n            cap: 0,\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn read_works() {\n        let buffer1 = Buffer::from_vec(vec![0xAA]);\n        assert_eq!(unsafe { buffer1.read() }, Some(\u0026[0xAAu8] as \u0026[u8]));\n\n        let buffer2 = Buffer::from_vec(vec![0xAA, 0xBB, 0xCC]);\n        assert_eq!(\n            unsafe { buffer2.read() },\n            Some(\u0026[0xAAu8, 0xBBu8, 0xCCu8] as \u0026[u8])\n        );\n\n        let empty: \u0026[u8] = b\"\";\n\n        let buffer3 = Buffer::from_vec(Vec::new());\n        assert_eq!(unsafe { buffer3.read() }, Some(empty));\n\n        let buffer4 = Buffer::with_capacity(7);\n        assert_eq!(unsafe { buffer4.read() }, Some(empty));\n\n        // Cleanup\n        unsafe { buffer1.consume() };\n        unsafe { buffer2.consume() };\n        unsafe { buffer3.consume() };\n        unsafe { buffer4.consume() };\n    }\n\n    #[test]\n    fn with_capacity_works() {\n        let buffer = Buffer::with_capacity(7);\n        assert_eq!(buffer.ptr.is_null(), false);\n        assert_eq!(buffer.len, 0);\n        assert_eq!(buffer.cap, 7);\n\n        // Cleanup\n        unsafe { buffer.consume() };\n    }\n\n    #[test]\n    fn from_vec_and_consume_work() {\n        let mut original: Vec\u003cu8\u003e = vec![0x00, 0xaa, 0x76];\n        original.reserve_exact(2);\n        let original_ptr = original.as_ptr();\n\n        let buffer = Buffer::from_vec(original);\n        assert_eq!(buffer.ptr.is_null(), false);\n        assert_eq!(buffer.len, 3);\n        assert_eq!(buffer.cap, 5);\n\n        let restored = unsafe { buffer.consume() };\n        assert_eq!(restored.as_ptr(), original_ptr);\n        assert_eq!(restored.len(), 3);\n        assert_eq!(restored.capacity(), 5);\n        assert_eq!(\u0026restored, \u0026[0x00, 0xaa, 0x76]);\n    }\n\n    #[test]\n    fn from_vec_and_consume_work_for_zero_len() {\n        let mut original: Vec\u003cu8\u003e = vec![];\n        original.reserve_exact(2);\n        let original_ptr = original.as_ptr();\n\n        let buffer = Buffer::from_vec(original);\n        assert_eq!(buffer.ptr.is_null(), false);\n        assert_eq!(buffer.len, 0);\n        assert_eq!(buffer.cap, 2);\n\n        let restored = unsafe { buffer.consume() };\n        assert_eq!(restored.as_ptr(), original_ptr);\n        assert_eq!(restored.len(), 0);\n        assert_eq!(restored.capacity(), 2);\n    }\n\n    #[test]\n    fn from_vec_and_consume_work_for_zero_capacity() {\n        let original: Vec\u003cu8\u003e = vec![];\n        let original_ptr = original.as_ptr();\n\n        let buffer = Buffer::from_vec(original);\n        // Skip ptr test here. Since Vec does not allocate memory when capacity is 0, this could be anything\n        assert_eq!(buffer.len, 0);\n        assert_eq!(buffer.cap, 0);\n\n        let restored = unsafe { buffer.consume() };\n        assert_eq!(restored.as_ptr(), original_ptr);\n        assert_eq!(restored.len(), 0);\n        assert_eq!(restored.capacity(), 0);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","querier.rs"],"content":"use cosmwasm_sgx_vm::{FfiResult, GasInfo, Querier};\nuse cosmwasm_std::{Binary, StdResult, SystemError, SystemResult};\n\nuse crate::error::GoResult;\nuse crate::memory::Buffer;\n\n// this represents something passed in from the caller side of FFI\n#[repr(C)]\n#[derive(Clone)]\npub struct querier_t {\n    _private: [u8; 0],\n}\n\n#[repr(C)]\n#[derive(Clone)]\npub struct Querier_vtable {\n    // We return errors through the return buffer, but may return non-zero error codes on panic\n    pub query_external:\n        extern \"C\" fn(*const querier_t, u64, *mut u64, Buffer, *mut Buffer, *mut Buffer) -\u003e i32,\n}\n\n#[repr(C)]\n#[derive(Clone)]\npub struct GoQuerier {\n    pub state: *const querier_t,\n    pub vtable: Querier_vtable,\n}\n\n// TODO: check if we can do this safer...\nunsafe impl Send for GoQuerier {}\n\nimpl Querier for GoQuerier {\n    fn query_raw(\n        \u0026self,\n        request: \u0026[u8],\n        gas_limit: u64,\n    ) -\u003e FfiResult\u003cSystemResult\u003cStdResult\u003cBinary\u003e\u003e\u003e {\n        let request_buf = Buffer::from_vec(request.to_vec());\n        let mut result_buf = Buffer::default();\n        let mut err = Buffer::default();\n        let mut used_gas = 0_u64;\n        let go_result: GoResult = (self.vtable.query_external)(\n            self.state,\n            gas_limit,\n            \u0026mut used_gas as *mut u64,\n            request_buf,\n            \u0026mut result_buf as *mut Buffer,\n            \u0026mut err as *mut Buffer,\n        )\n        .into();\n        let gas_info = GasInfo::with_externally_used(used_gas);\n        let _request = unsafe { request_buf.consume() };\n\n        // return complete error message (reading from buffer for GoResult::Other)\n        let default = || {\n            format!(\n                \"Failed to query another contract with this request: {}\",\n                String::from_utf8_lossy(request)\n            )\n        };\n        unsafe {\n            if let Err(err) = go_result.into_ffi_result(err, default) {\n                return (Err(err), gas_info);\n            }\n        }\n\n        let bin_result = unsafe { result_buf.consume() };\n        let result = serde_json::from_slice(\u0026bin_result).or_else(|e| {\n            Ok(Err(SystemError::InvalidResponse {\n                error: format!(\"Parsing Go response: {}\", e),\n                response: bin_result.into(),\n            }))\n        });\n        (result, gas_info)\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","runner","work","sienna","sienna","platform","go-cosmwasm","src","tests.rs"],"content":"#![cfg(test)]\n\nuse serde::{Deserialize, Serialize};\nuse tempfile::TempDir;\n\nuse cosmwasm_std::{coins, HumanAddr};\nuse cosmwasm_vm::testing::{mock_dependencies, mock_env, mock_instance_with_gas_limit};\nuse cosmwasm_vm::{call_handle_raw, call_init_raw, features_from_csv, to_vec, CosmCache};\n\nstatic CONTRACT: \u0026[u8] = include_bytes!(\"../api/testdata/hackatom.wasm\");\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct InitMsg {\n    pub verifier: HumanAddr,\n    pub beneficiary: HumanAddr,\n}\n\nfn make_init_msg() -\u003e (InitMsg, HumanAddr) {\n    let verifier = HumanAddr::from(\"verifies\");\n    let beneficiary = HumanAddr::from(\"benefits\");\n    let creator = HumanAddr::from(\"creator\");\n    (\n        InitMsg {\n            verifier: verifier.clone(),\n            beneficiary: beneficiary.clone(),\n        },\n        creator,\n    )\n}\n\n#[test]\nfn handle_cpu_loop_with_cache() {\n    let deps = mock_dependencies(20, \u0026[]);\n    let gas_limit = 2_000_000u64;\n\n    let tmp_dir = TempDir::new().unwrap();\n    let features = features_from_csv(\"staking\");\n    let mut cache = unsafe { CosmCache::new(tmp_dir.path(), features) }.unwrap();\n\n    // store code\n    let code_id = cache.save_wasm(CONTRACT).unwrap();\n\n    // init\n    let (init_msg, creator) = make_init_msg();\n    let env = mock_env(creator, \u0026coins(1000, \"cosm\"));\n    let mut instance = cache.get_instance(\u0026code_id, deps, gas_limit).unwrap();\n    let raw_msg = to_vec(\u0026init_msg).unwrap();\n    let raw_env = to_vec(\u0026env).unwrap();\n    let res = call_init_raw(\u0026mut instance, \u0026raw_env, \u0026raw_msg);\n    let gas_used = gas_limit - instance.get_gas_left();\n    println!(\"Init used gas: {}\", gas_used);\n    res.unwrap();\n    let deps = instance.recycle().unwrap();\n\n    // handle\n    let mut instance = cache.get_instance(\u0026code_id, deps, gas_limit).unwrap();\n    let raw_msg = r#\"{\"cpu_loop\":{}}\"#;\n    let res = call_handle_raw(\u0026mut instance, \u0026raw_env, raw_msg.as_bytes());\n    let gas_used = gas_limit - instance.get_gas_left();\n    println!(\"Handle used gas: {}\", gas_used);\n    assert!(res.is_err());\n    assert_eq!(instance.get_gas_left(), 0);\n    instance.recycle();\n}\n\n#[test]\nfn handle_cpu_loop_no_cache() {\n    let gas_limit = 2_000_000u64;\n    let mut instance = mock_instance_with_gas_limit(CONTRACT, gas_limit);\n\n    // init\n    let (init_msg, creator) = make_init_msg();\n    let env = mock_env(creator, \u0026coins(1000, \"cosm\"));\n    let raw_msg = to_vec(\u0026init_msg).unwrap();\n    let raw_env = to_vec(\u0026env).unwrap();\n    let res = call_init_raw(\u0026mut instance, \u0026raw_env, \u0026raw_msg);\n    let gas_used = gas_limit - instance.get_gas_left();\n    println!(\"Init used gas: {}\", gas_used);\n    res.unwrap();\n\n    // handle\n    let raw_msg = r#\"{\"cpu_loop\":{}}\"#;\n    let res = call_handle_raw(\u0026mut instance, \u0026raw_env, raw_msg.as_bytes());\n    let gas_used = gas_limit - instance.get_gas_left();\n    println!(\"Handle used gas: {}\", gas_used);\n    assert!(res.is_err());\n    assert_eq!(instance.get_gas_left(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","third_party","build","src","lib.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","x","compute","internal","keeper","testdata","test-contract","src","contract.rs"],"content":"use cosmwasm_storage::PrefixedStorage;\n\nuse cosmwasm_std::{\n    log, to_binary, Api, BankMsg, Binary, Coin, CosmosMsg, Env, Extern, HandleResponse,\n    HandleResult, HumanAddr, InitResponse, InitResult, Querier, QueryRequest, QueryResult,\n    ReadonlyStorage, StdError, StdResult, Storage, Uint128, WasmMsg, WasmQuery,\n};\n\n/////////////////////////////// Messages ///////////////////////////////\n\nuse core::time;\nuse mem::MaybeUninit;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::{mem, thread};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum InitMsg {\n    Nop {},\n    Callback {\n        contract_addr: HumanAddr,\n        code_hash: String,\n    },\n    CallbackContractError {\n        contract_addr: HumanAddr,\n        code_hash: String,\n    },\n    ContractError {\n        error_type: String,\n    },\n    NoLogs {},\n    CallbackToInit {\n        code_id: u64,\n        code_hash: String,\n    },\n    CallbackBadParams {\n        contract_addr: HumanAddr,\n        code_hash: String,\n    },\n    Panic {},\n    SendExternalQueryDepthCounter {\n        to: HumanAddr,\n        depth: u8,\n        code_hash: String,\n    },\n    SendExternalQueryRecursionLimit {\n        to: HumanAddr,\n        depth: u8,\n        code_hash: String,\n    },\n    CallToInit {\n        code_id: u64,\n        code_hash: String,\n        label: String,\n        msg: String,\n    },\n    CallToExec {\n        addr: HumanAddr,\n        code_hash: String,\n        msg: String,\n    },\n    CallToQuery {\n        addr: HumanAddr,\n        code_hash: String,\n        msg: String,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum HandleMsg {\n    A {\n        contract_addr: HumanAddr,\n        code_hash: String,\n        x: u8,\n        y: u8,\n    },\n    B {\n        contract_addr: HumanAddr,\n        code_hash: String,\n        x: u8,\n        y: u8,\n    },\n    C {\n        x: u8,\n        y: u8,\n    },\n    UnicodeData {},\n    EmptyLogKeyValue {},\n    EmptyData {},\n    NoData {},\n    ContractError {\n        error_type: String,\n    },\n    NoLogs {},\n    CallbackToInit {\n        code_id: u64,\n        code_hash: String,\n    },\n    CallbackContractError {\n        contract_addr: HumanAddr,\n        code_hash: String,\n    },\n    CallbackBadParams {\n        contract_addr: HumanAddr,\n        code_hash: String,\n    },\n    SetState {\n        key: String,\n        value: String,\n    },\n    GetState {\n        key: String,\n    },\n    RemoveState {\n        key: String,\n    },\n    TestCanonicalizeAddressErrors {},\n    Panic {},\n    AllocateOnHeap {\n        bytes: u32,\n    },\n    PassNullPointerToImportsShouldThrow {\n        pass_type: String,\n    },\n    SendExternalQuery {\n        to: HumanAddr,\n        code_hash: String,\n    },\n    SendExternalQueryPanic {\n        to: HumanAddr,\n        code_hash: String,\n    },\n    SendExternalQueryError {\n        to: HumanAddr,\n        code_hash: String,\n    },\n    SendExternalQueryBadAbi {\n        to: HumanAddr,\n        code_hash: String,\n    },\n    SendExternalQueryBadAbiReceiver {\n        to: HumanAddr,\n        code_hash: String,\n    },\n    LogMsgSender {},\n    CallbackToLogMsgSender {\n        to: HumanAddr,\n        code_hash: String,\n    },\n    DepositToContract {},\n    SendFunds {\n        amount: u32,\n        denom: String,\n        to: HumanAddr,\n        from: HumanAddr,\n    },\n    SendFundsToInitCallback {\n        amount: u32,\n        denom: String,\n        code_id: u64,\n        code_hash: String,\n    },\n    SendFundsToExecCallback {\n        amount: u32,\n        denom: String,\n        to: HumanAddr,\n        code_hash: String,\n    },\n    Sleep {\n        ms: u64,\n    },\n    SendExternalQueryDepthCounter {\n        to: HumanAddr,\n        code_hash: String,\n        depth: u8,\n    },\n    SendExternalQueryRecursionLimit {\n        to: HumanAddr,\n        code_hash: String,\n        depth: u8,\n    },\n    WithFloats {\n        x: u8,\n        y: u8,\n    },\n    CallToInit {\n        code_id: u64,\n        code_hash: String,\n        label: String,\n        msg: String,\n    },\n    CallToExec {\n        addr: HumanAddr,\n        code_hash: String,\n        msg: String,\n    },\n    CallToQuery {\n        addr: HumanAddr,\n        code_hash: String,\n        msg: String,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    ContractError {\n        error_type: String,\n    },\n    Panic {},\n    ReceiveExternalQuery {\n        num: u8,\n    },\n    SendExternalQueryInfiniteLoop {\n        to: HumanAddr,\n        code_hash: String,\n    },\n    WriteToStorage {},\n    RemoveFromStorage {},\n    SendExternalQueryDepthCounter {\n        to: HumanAddr,\n        depth: u8,\n        code_hash: String,\n    },\n    SendExternalQueryRecursionLimit {\n        to: HumanAddr,\n        depth: u8,\n        code_hash: String,\n    },\n    CallToQuery {\n        addr: HumanAddr,\n        code_hash: String,\n        msg: String,\n    },\n}\n\n/////////////////////////////// Init ///////////////////////////////\n\npub fn init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: InitMsg,\n) -\u003e InitResult {\n    match msg {\n        InitMsg::Nop {} =\u003e Ok(InitResponse {\n            messages: vec![],\n            log: vec![log(\"init\", \"🌈\")],\n        }),\n        InitMsg::Callback {\n            contract_addr,\n            code_hash,\n        } =\u003e Ok(init_with_callback(deps, env, contract_addr, code_hash)),\n        InitMsg::ContractError { error_type } =\u003e Err(map_string_to_error(error_type)),\n        InitMsg::NoLogs {} =\u003e Ok(InitResponse::default()),\n        InitMsg::CallbackToInit { code_id, code_hash } =\u003e {\n            Ok(init_callback_to_init(deps, env, code_id, code_hash))\n        }\n        InitMsg::CallbackContractError {\n            contract_addr,\n            code_hash,\n        } =\u003e Ok(init_with_callback_contract_error(contract_addr, code_hash)),\n        InitMsg::CallbackBadParams {\n            contract_addr,\n            code_hash,\n        } =\u003e Ok(init_callback_bad_params(contract_addr, code_hash)),\n        InitMsg::Panic {} =\u003e panic!(\"panic in init\"),\n        InitMsg::SendExternalQueryDepthCounter {\n            to,\n            depth,\n            code_hash,\n        } =\u003e Ok(InitResponse {\n            messages: vec![],\n            log: vec![log(\n                format!(\n                    \"{}\",\n                    send_external_query_depth_counter(deps, to, depth, code_hash)\n                ),\n                \"\",\n            )],\n        }),\n        InitMsg::SendExternalQueryRecursionLimit {\n            to,\n            depth,\n            code_hash,\n        } =\u003e Ok(InitResponse {\n            messages: vec![],\n            log: vec![log(\n                \"message\",\n                send_external_query_recursion_limit(deps, to, depth, code_hash)?,\n            )],\n        }),\n        InitMsg::CallToInit {\n            code_id,\n            code_hash,\n            label,\n            msg,\n        } =\u003e Ok(InitResponse {\n            messages: vec![CosmosMsg::Wasm(WasmMsg::Instantiate {\n                code_id,\n                callback_code_hash: code_hash,\n                msg: Binary(msg.as_bytes().into()),\n                send: vec![],\n                label: label,\n            })],\n            log: vec![log(\"a\", \"a\")],\n        }),\n        InitMsg::CallToExec {\n            addr,\n            code_hash,\n            msg,\n        } =\u003e Ok(InitResponse {\n            messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: addr,\n                callback_code_hash: code_hash,\n                msg: Binary(msg.as_bytes().into()),\n                send: vec![],\n            })],\n            log: vec![log(\"b\", \"b\")],\n        }),\n        InitMsg::CallToQuery {\n            addr,\n            code_hash,\n            msg,\n        } =\u003e {\n            let answer: u32 = deps\n                .querier\n                .query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                    contract_addr: addr,\n                    callback_code_hash: code_hash,\n                    msg: Binary::from(msg.as_bytes().to_vec()),\n                }))\n                .map_err(|err| {\n                    StdError::generic_err(format!(\"Got an error from query: {:?}\", err))\n                })?;\n\n            Ok(InitResponse {\n                messages: vec![],\n                log: vec![log(\"c\", format!(\"{}\", answer))],\n            })\n        }\n    }\n}\n\nfn map_string_to_error(error_type: String) -\u003e StdError {\n    let as_str: \u0026str = \u0026error_type[..];\n    match as_str {\n        \"generic_err\" =\u003e StdError::generic_err(\"la la 🤯\"),\n        \"invalid_base64\" =\u003e StdError::invalid_base64(\"ra ra 🤯\"),\n        \"invalid_utf8\" =\u003e StdError::invalid_utf8(\"ka ka 🤯\"),\n        \"not_found\" =\u003e StdError::not_found(\"za za 🤯\"),\n        \"parse_err\" =\u003e StdError::parse_err(\"na na 🤯\", \"pa pa 🤯\"),\n        \"serialize_err\" =\u003e StdError::serialize_err(\"ba ba 🤯\", \"ga ga 🤯\"),\n        \"unauthorized\" =\u003e StdError::unauthorized(),\n        \"underflow\" =\u003e StdError::underflow(\"minuend 🤯\", \"subtrahend 🤯\"),\n        _ =\u003e StdError::generic_err(\"catch-all 🤯\"),\n    }\n}\n\nfn init_with_callback_contract_error(contract_addr: HumanAddr, code_hash: String) -\u003e InitResponse {\n    InitResponse {\n        messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_addr.clone(),\n            callback_code_hash: code_hash,\n            msg: Binary::from(r#\"{\"contract_error\":{\"error_type\":\"generic_err\"}}\"#.as_bytes()),\n            send: vec![],\n        })],\n        log: vec![log(\"init with a callback with contract error\", \"🤷‍♀️\")],\n    }\n}\n\nfn init_callback_bad_params(contract_addr: HumanAddr, code_hash: String) -\u003e InitResponse {\n    InitResponse {\n        messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_addr.clone(),\n            callback_code_hash: code_hash,\n            msg: Binary::from(r#\"{\"c\":{\"x\":\"banana\",\"y\":3}}\"#.as_bytes().to_vec()),\n            send: vec![],\n        })],\n        log: vec![],\n    }\n}\n\nfn init_with_callback\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    contract_addr: HumanAddr,\n    code_hash: String,\n) -\u003e InitResponse {\n    InitResponse {\n        messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            callback_code_hash: code_hash,\n            contract_addr: contract_addr.clone(),\n            msg: Binary::from(\"{\\\"c\\\":{\\\"x\\\":0,\\\"y\\\":13}}\".as_bytes().to_vec()),\n            send: vec![],\n        })],\n        log: vec![log(\"init with a callback\", \"🦄\")],\n    }\n}\n\npub fn init_callback_to_init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    code_id: u64,\n    code_hash: String,\n) -\u003e InitResponse {\n    InitResponse {\n        messages: vec![CosmosMsg::Wasm(WasmMsg::Instantiate {\n            code_id,\n            msg: Binary::from(\"{\\\"nop\\\":{}}\".as_bytes().to_vec()),\n            callback_code_hash: code_hash,\n            send: vec![],\n            label: String::from(\"fi\"),\n        })],\n        log: vec![log(\"instantiating a new contract from init!\", \"🐙\")],\n    }\n}\n\n/////////////////////////////// Handle ///////////////////////////////\n\npub fn handle\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    env: Env,\n    msg: HandleMsg,\n) -\u003e HandleResult {\n    match msg {\n        HandleMsg::A {\n            contract_addr,\n            code_hash,\n            x,\n            y,\n        } =\u003e Ok(a(deps, env, contract_addr, code_hash, x, y)),\n        HandleMsg::B {\n            contract_addr,\n            code_hash,\n            x,\n            y,\n        } =\u003e Ok(b(deps, env, contract_addr, code_hash, x, y)),\n        HandleMsg::C { x, y } =\u003e Ok(c(deps, env, x, y)),\n        HandleMsg::UnicodeData {} =\u003e Ok(unicode_data(deps, env)),\n        HandleMsg::EmptyLogKeyValue {} =\u003e Ok(empty_log_key_value(deps, env)),\n        HandleMsg::EmptyData {} =\u003e Ok(empty_data(deps, env)),\n        HandleMsg::NoData {} =\u003e Ok(no_data(deps, env)),\n        HandleMsg::ContractError { error_type } =\u003e Err(map_string_to_error(error_type)),\n        HandleMsg::NoLogs {} =\u003e Ok(HandleResponse::default()),\n        HandleMsg::CallbackToInit { code_id, code_hash } =\u003e {\n            Ok(exec_callback_to_init(deps, env, code_id, code_hash))\n        }\n        HandleMsg::CallbackBadParams {\n            contract_addr,\n            code_hash,\n        } =\u003e Ok(exec_callback_bad_params(contract_addr, code_hash)),\n        HandleMsg::CallbackContractError {\n            contract_addr,\n            code_hash,\n        } =\u003e Ok(exec_with_callback_contract_error(contract_addr, code_hash)),\n        HandleMsg::SetState { key, value } =\u003e Ok(set_state(deps, key, value)),\n        HandleMsg::GetState { key } =\u003e Ok(get_state(deps, key)),\n        HandleMsg::RemoveState { key } =\u003e Ok(remove_state(deps, key)),\n        HandleMsg::TestCanonicalizeAddressErrors {} =\u003e test_canonicalize_address_errors(deps),\n        HandleMsg::Panic {} =\u003e panic!(\"panic in exec\"),\n        HandleMsg::AllocateOnHeap { bytes } =\u003e Ok(allocate_on_heap(bytes as usize)),\n        HandleMsg::PassNullPointerToImportsShouldThrow { pass_type } =\u003e {\n            Ok(pass_null_pointer_to_imports_should_throw(deps, pass_type))\n        }\n        HandleMsg::SendExternalQuery { to, code_hash } =\u003e Ok(HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: Some(vec![send_external_query(deps, to, code_hash)].into()),\n        }),\n        HandleMsg::SendExternalQueryDepthCounter {\n            to,\n            code_hash,\n            depth,\n        } =\u003e Ok(HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: Some(\n                vec![send_external_query_depth_counter(\n                    deps, to, depth, code_hash,\n                )]\n                .into(),\n            ),\n        }),\n        HandleMsg::SendExternalQueryRecursionLimit {\n            to,\n            code_hash,\n            depth,\n        } =\u003e Ok(HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: Some(to_binary(\u0026send_external_query_recursion_limit(\n                deps, to, depth, code_hash,\n            )?)?),\n        }),\n        HandleMsg::SendExternalQueryPanic { to, code_hash } =\u003e {\n            send_external_query_panic(deps, to, code_hash)\n        }\n        HandleMsg::SendExternalQueryError { to, code_hash } =\u003e {\n            send_external_query_stderror(deps, to, code_hash)\n        }\n        HandleMsg::SendExternalQueryBadAbi { to, code_hash } =\u003e {\n            send_external_query_bad_abi(deps, to, code_hash)\n        }\n        HandleMsg::SendExternalQueryBadAbiReceiver { to, code_hash } =\u003e {\n            send_external_query_bad_abi_receiver(deps, to, code_hash)\n        }\n        HandleMsg::LogMsgSender {} =\u003e Ok(HandleResponse {\n            messages: vec![],\n            log: vec![log(\"msg.sender\", env.message.sender.to_string())],\n            data: None,\n        }),\n        HandleMsg::CallbackToLogMsgSender { to, code_hash } =\u003e Ok(HandleResponse {\n            messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: to.clone(),\n                callback_code_hash: code_hash,\n                msg: Binary::from(r#\"{\"log_msg_sender\":{}}\"#.as_bytes().to_vec()),\n                send: vec![],\n            })],\n            log: vec![log(\"hi\", \"hey\")],\n            data: None,\n        }),\n        HandleMsg::DepositToContract {} =\u003e Ok(HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: Some(to_binary(\u0026env.message.sent_funds).unwrap()),\n        }),\n        HandleMsg::SendFunds {\n            amount,\n            from,\n            to,\n            denom,\n        } =\u003e Ok(HandleResponse {\n            messages: vec![CosmosMsg::Bank(BankMsg::Send {\n                from_address: from,\n                to_address: to,\n                amount: vec![Coin {\n                    amount: Uint128(amount as u128),\n                    denom: denom,\n                }],\n            })],\n            log: vec![],\n            data: None,\n        }),\n        HandleMsg::SendFundsToInitCallback {\n            amount,\n            denom,\n            code_id,\n            code_hash,\n        } =\u003e Ok(HandleResponse {\n            messages: vec![CosmosMsg::Wasm(WasmMsg::Instantiate {\n                msg: Binary(\"{\\\"nop\\\":{}}\".as_bytes().to_vec()),\n                code_id: code_id,\n                callback_code_hash: code_hash,\n                label: String::from(\"yo\"),\n                send: vec![Coin {\n                    amount: Uint128(amount as u128),\n                    denom: denom,\n                }],\n            })],\n            log: vec![],\n            data: None,\n        }),\n        HandleMsg::SendFundsToExecCallback {\n            amount,\n            denom,\n            to,\n            code_hash,\n        } =\u003e Ok(HandleResponse {\n            messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n                msg: Binary(\"{\\\"no_data\\\":{}}\".as_bytes().to_vec()),\n                contract_addr: to,\n                callback_code_hash: code_hash,\n                send: vec![Coin {\n                    amount: Uint128(amount as u128),\n                    denom: denom,\n                }],\n            })],\n            log: vec![],\n            data: None,\n        }),\n        HandleMsg::Sleep { ms } =\u003e {\n            thread::sleep(time::Duration::from_millis(ms));\n\n            Ok(HandleResponse {\n                messages: vec![],\n                log: vec![],\n                data: None,\n            })\n        }\n        HandleMsg::WithFloats { x, y } =\u003e Ok(HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: Some(use_floats(x, y)),\n        }),\n        HandleMsg::CallToInit {\n            code_id,\n            code_hash,\n            label,\n            msg,\n        } =\u003e Ok(HandleResponse {\n            messages: vec![CosmosMsg::Wasm(WasmMsg::Instantiate {\n                code_id,\n                callback_code_hash: code_hash,\n                msg: Binary(msg.as_bytes().into()),\n                send: vec![],\n                label: label,\n            })],\n            log: vec![log(\"a\", \"a\")],\n            data: None,\n        }),\n        HandleMsg::CallToExec {\n            addr,\n            code_hash,\n            msg,\n        } =\u003e Ok(HandleResponse {\n            messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: addr,\n                callback_code_hash: code_hash,\n                msg: Binary(msg.as_bytes().into()),\n                send: vec![],\n            })],\n            log: vec![log(\"b\", \"b\")],\n            data: None,\n        }),\n        HandleMsg::CallToQuery {\n            addr,\n            code_hash,\n            msg,\n        } =\u003e {\n            let answer: u32 = deps\n                .querier\n                .query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                    contract_addr: addr,\n                    callback_code_hash: code_hash,\n                    msg: Binary::from(msg.as_bytes().to_vec()),\n                }))\n                .map_err(|err| {\n                    StdError::generic_err(format!(\"Got an error from query: {:?}\", err))\n                })?;\n\n            Ok(HandleResponse {\n                messages: vec![],\n                log: vec![log(\"c\", format!(\"{}\", answer))],\n                data: None,\n            })\n        }\n    }\n}\n\n#[cfg(feature = \"with_floats\")]\nfn use_floats(x: u8, y: u8) -\u003e Binary {\n    let res: f64 = (x as f64) / (y as f64);\n    to_binary(\u0026format!(\"{}\", res)).unwrap()\n}\n\n#[cfg(not(feature = \"with_floats\"))]\nfn use_floats(x: u8, y: u8) -\u003e Binary {\n    Binary(vec![x, y])\n}\n\nfn send_external_query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    contract_addr: HumanAddr,\n    code_hash: String,\n) -\u003e u8 {\n    let answer: u8 = deps\n        .querier\n        .query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr,\n            callback_code_hash: code_hash,\n            msg: Binary::from(r#\"{\"receive_external_query\":{\"num\":2}}\"#.as_bytes().to_vec()),\n        }))\n        .unwrap();\n    answer\n}\n\nfn send_external_query_depth_counter\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    contract_addr: HumanAddr,\n    depth: u8,\n    code_hash: String,\n) -\u003e u8 {\n    if depth == 0 {\n        return 0;\n    }\n\n    let answer: u8 = deps\n        .querier\n        .query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: contract_addr.clone(),\n            callback_code_hash: code_hash.clone(),\n            msg: Binary(\n                format!(\n                    r#\"{{\"send_external_query_depth_counter\":{{\"to\":\"{}\",\"code_hash\":\"{}\",\"depth\":{}}}}}\"#,\n                    contract_addr.clone().to_string(),\n                    code_hash.clone().to_string(),\n                    depth - 1\n                )\n                .into(),\n            ),\n        }))\n        .unwrap();\n\n    answer + 1\n}\n\nfn send_external_query_recursion_limit\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    contract_addr: HumanAddr,\n    depth: u8,\n    code_hash: String,\n) -\u003e StdResult\u003cString\u003e {\n    let result = deps\n        .querier\n        .query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: contract_addr.clone(),\n            callback_code_hash: code_hash.clone(),\n            msg: Binary(\n                format!(\n                    r#\"{{\"send_external_query_recursion_limit\":{{\"to\":\"{}\",\"code_hash\":\"{}\",\"depth\":{}}}}}\"#,\n                    contract_addr.clone().to_string(),\n                    code_hash.clone().to_string(),\n                    depth + 1\n                )\n                .into_bytes(),\n            ),\n        }));\n\n    // 5 is the current recursion limit.\n    if depth != 5 {\n        result\n    } else {\n        match result {\n            Err(StdError::GenericErr { msg, .. })\n                if msg == \"Querier system error: Query recursion limit exceeded\" =\u003e\n            {\n                Ok(String::from(\"Recursion limit was correctly enforced\"))\n            }\n            _ =\u003e Err(StdError::generic_err(\n                \"Recursion limit was bypassed! this is a bug!\",\n            )),\n        }\n    }\n}\n\nfn send_external_query_panic\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    contract_addr: HumanAddr,\n    code_hash: String,\n) -\u003e HandleResult {\n    let err = deps\n        .querier\n        .query::\u003cu8\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr,\n            msg: Binary::from(r#\"{\"panic\":{}}\"#.as_bytes().to_vec()),\n            callback_code_hash: code_hash,\n        }))\n        .unwrap_err();\n\n    Err(err)\n}\n\nfn send_external_query_stderror\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    contract_addr: HumanAddr,\n    code_hash: String,\n) -\u003e HandleResult {\n    let answer = deps\n        .querier\n        .query::\u003cBinary\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr,\n            msg: Binary::from(\n                r#\"{\"contract_error\":{\"error_type\":\"generic_err\"}}\"#\n                    .as_bytes()\n                    .to_vec(),\n            ),\n            callback_code_hash: code_hash,\n        }));\n\n    match answer {\n        Ok(wtf) =\u003e Ok(HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: Some(wtf),\n        }),\n        Err(e) =\u003e Err(e),\n    }\n}\n\nfn send_external_query_bad_abi\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    contract_addr: HumanAddr,\n    code_hash: String,\n) -\u003e HandleResult {\n    let answer = deps\n        .querier\n        .query::\u003cBinary\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr,\n            callback_code_hash: code_hash,\n            msg: Binary::from(\n                r#\"\"contract_error\":{\"error_type\":\"generic_err\"}}\"#.as_bytes().to_vec(),\n            ),\n        }));\n\n    match answer {\n        Ok(wtf) =\u003e Ok(HandleResponse {\n            messages: vec![],\n            log: vec![],\n            data: Some(wtf),\n        }),\n        Err(e) =\u003e Err(e),\n    }\n}\n\nfn send_external_query_bad_abi_receiver\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    contract_addr: HumanAddr,\n    code_hash: String,\n) -\u003e HandleResult {\n    let answer = deps\n        .querier\n        .query::\u003cString\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr,\n            msg: Binary::from(r#\"{\"receive_external_query\":{\"num\":25}}\"#.as_bytes().to_vec()),\n            callback_code_hash: code_hash,\n        }));\n\n    match answer {\n        Ok(wtf) =\u003e Ok(HandleResponse {\n            messages: vec![],\n            log: vec![log(\"wtf\", wtf)],\n            data: None,\n        }),\n        Err(e) =\u003e Err(e),\n    }\n}\n\nfn exec_callback_bad_params(contract_addr: HumanAddr, code_hash: String) -\u003e HandleResponse {\n    HandleResponse {\n        messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_addr.clone(),\n            callback_code_hash: code_hash,\n            msg: Binary::from(r#\"{\"c\":{\"x\":\"banana\",\"y\":3}}\"#.as_bytes().to_vec()),\n            send: vec![],\n        })],\n        log: vec![],\n        data: None,\n    }\n}\n\npub fn a\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    contract_addr: HumanAddr,\n    code_hash: String,\n    x: u8,\n    y: u8,\n) -\u003e HandleResponse {\n    HandleResponse {\n        messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_addr.clone(),\n            callback_code_hash: code_hash.clone(),\n            msg: Binary::from(format!(\n                \"{{\\\"b\\\":{{\\\"x\\\":{} ,\\\"y\\\": {},\\\"contract_addr\\\": \\\"{}\\\",\\\"code_hash\\\": \\\"{}\\\" }}}}\",\n                x,\n                y,\n                contract_addr.as_str(),\n                \u0026code_hash\n            )\n                .as_bytes()\n                .to_vec()),\n            send: vec![],\n        })],\n        log: vec![log(\"banana\", \"🍌\")],\n        data: Some(Binary(vec![x, y])),\n    }\n}\n\npub fn b\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    contract_addr: HumanAddr,\n    code_hash: String,\n    x: u8,\n    y: u8,\n) -\u003e HandleResponse {\n    HandleResponse {\n        messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_addr.clone(),\n            callback_code_hash: code_hash,\n            msg: Binary::from(\n                format!(\"{{\\\"c\\\":{{\\\"x\\\":{} ,\\\"y\\\": {} }}}}\", x + 1, y + 1)\n                    .as_bytes()\n                    .to_vec(),\n            ),\n            send: vec![],\n        })],\n        log: vec![log(\"kiwi\", \"🥝\")],\n        data: Some(Binary(vec![x + y])),\n    }\n}\n\npub fn c\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    x: u8,\n    y: u8,\n) -\u003e HandleResponse {\n    HandleResponse {\n        messages: vec![],\n        log: vec![log(\"watermelon\", \"🍉\")],\n        data: Some(Binary(vec![x + y])),\n    }\n}\n\npub fn empty_log_key_value\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n) -\u003e HandleResponse {\n    HandleResponse {\n        messages: vec![],\n        log: vec![log(\"my value is empty\", \"\"), log(\"\", \"my key is empty\")],\n        data: None,\n    }\n}\n\npub fn empty_data\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n) -\u003e HandleResponse {\n    HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(Binary(vec![])),\n    }\n}\n\npub fn unicode_data\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n) -\u003e HandleResponse {\n    HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: Some(Binary(\"🍆🥑🍄\".as_bytes().to_vec())),\n    }\n}\n\npub fn no_data\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n) -\u003e HandleResponse {\n    HandleResponse {\n        messages: vec![],\n        log: vec![],\n        data: None,\n    }\n}\n\npub fn exec_callback_to_init\u003cS: Storage, A: Api, Q: Querier\u003e(\n    _deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    _env: Env,\n    code_id: u64,\n    code_hash: String,\n) -\u003e HandleResponse {\n    HandleResponse {\n        messages: vec![CosmosMsg::Wasm(WasmMsg::Instantiate {\n            code_id,\n            msg: Binary::from(\"{\\\"nop\\\":{}}\".as_bytes().to_vec()),\n            callback_code_hash: code_hash,\n            send: vec![],\n            label: String::from(\"hi\"),\n        })],\n        log: vec![log(\"instantiating a new contract\", \"🪂\")],\n        data: None,\n    }\n}\n\nfn exec_with_callback_contract_error(\n    contract_addr: HumanAddr,\n    code_hash: String,\n) -\u003e HandleResponse {\n    HandleResponse {\n        messages: vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_addr.clone(),\n            callback_code_hash: code_hash,\n            msg: Binary::from(\n                r#\"{\"contract_error\":{\"error_type\":\"generic_err\"}}\"#\n                    .as_bytes()\n                    .to_vec(),\n            ),\n            send: vec![],\n        })],\n        log: vec![log(\"exec with a callback with contract error\", \"🤷‍♂️\")],\n        data: None,\n    }\n}\n\nfn allocate_on_heap(bytes: usize) -\u003e HandleResponse {\n    let mut values: Vec\u003cu8\u003e = vec![0; bytes];\n    values[bytes - 1] = 1;\n\n    HandleResponse {\n        data: Some(Binary(\"😅\".as_bytes().to_vec())),\n        log: vec![],\n        messages: vec![],\n    }\n}\n\nfn get_state\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    key: String,\n) -\u003e HandleResponse {\n    let store = PrefixedStorage::new(b\"my_prefix\", \u0026mut deps.storage);\n\n    match store.get(key.as_bytes()) {\n        Some(value) =\u003e HandleResponse {\n            data: Some(Binary(value)),\n            log: vec![],\n            messages: vec![],\n        },\n        None =\u003e HandleResponse::default(),\n    }\n}\n\nfn set_state\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    key: String,\n    value: String,\n) -\u003e HandleResponse {\n    let mut store = PrefixedStorage::new(b\"my_prefix\", \u0026mut deps.storage);\n    store.set(key.as_bytes(), value.as_bytes());\n    HandleResponse::default()\n}\n\nfn remove_state\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    key: String,\n) -\u003e HandleResponse {\n    let mut store = PrefixedStorage::new(b\"my_prefix\", \u0026mut deps.storage);\n    store.remove(key.as_bytes());\n    HandleResponse::default()\n}\n\n#[allow(invalid_value)]\n#[allow(unused_must_use)]\nfn pass_null_pointer_to_imports_should_throw\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n    pass_type: String,\n) -\u003e HandleResponse {\n    let null_ptr_slice: \u0026[u8] = unsafe { MaybeUninit::zeroed().assume_init() };\n\n    match \u0026pass_type[..] {\n        \"read_db_key\" =\u003e {\n            deps.storage.get(null_ptr_slice);\n        }\n        \"write_db_key\" =\u003e {\n            deps.storage.set(null_ptr_slice, b\"write value\");\n        }\n        \"write_db_value\" =\u003e {\n            deps.storage.set(b\"write key\", null_ptr_slice);\n        }\n        \"remove_db_key\" =\u003e {\n            deps.storage.remove(null_ptr_slice);\n        }\n        \"canonicalize_address_input\" =\u003e {\n            deps.api\n                .canonical_address(unsafe { MaybeUninit::zeroed().assume_init() });\n        }\n        \"canonicalize_address_output\" =\u003e { /* TODO */ }\n        \"humanize_address_input\" =\u003e {\n            deps.api\n                .human_address(unsafe { MaybeUninit::zeroed().assume_init() });\n        }\n        \"humanize_address_output\" =\u003e { /* TODO */ }\n        _ =\u003e {}\n    };\n\n    HandleResponse::default()\n}\n\nfn test_canonicalize_address_errors\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026mut Extern\u003cS, A, Q\u003e,\n) -\u003e HandleResult {\n    match deps.api.canonical_address(\u0026HumanAddr(String::from(\"\"))) {\n        Err(StdError::GenericErr { msg, backtrace: _ }) =\u003e {\n            if msg != String::from(\"canonicalize_address errored: input is empty\") {\n                return Err(StdError::generic_err(\n                    \"empty address should have failed with 'canonicalize_address errored: input is empty'\",\n                ));\n            }\n            // all is good, continue\n        }\n        _ =\u003e return Err(StdError::generic_err(\n            \"empty address should have failed with 'canonicalize_address errored: input is empty'\",\n        )),\n    }\n\n    match deps.api.canonical_address(\u0026HumanAddr(String::from(\"   \"))) {\n        Err(StdError::GenericErr { msg, backtrace: _ }) =\u003e {\n            if msg != String::from(\"canonicalize_address errored: input is empty\") {\n                return Err(StdError::generic_err(\n                    \"empty trimmed address should have failed with 'canonicalize_address errored: input is empty'\",\n                ));\n            }\n            // all is good, continue\n        }\n        _ =\u003e {\n            return Err(StdError::generic_err(\n                \"empty trimmed address should have failed with 'canonicalize_address errored: input is empty'\",\n            ))\n        }\n    }\n\n    match deps\n        .api\n        .canonical_address(\u0026HumanAddr(String::from(\"cosmos1h99hrcc54ms9lxxxx\")))\n    {\n        Err(StdError::GenericErr { msg, backtrace: _ }) =\u003e {\n            if msg != String::from(\"canonicalize_address errored: invalid checksum\") {\n                return Err(StdError::generic_err(\n                    \"bad bech32 should have failed with 'canonicalize_address errored: invalid checksum'\",\n                ));\n            }\n            // all is good, continue\n        }\n        _ =\u003e return Err(StdError::generic_err(\n            \"bad bech32 should have failed with 'canonicalize_address errored: invalid checksum'\",\n        )),\n    }\n\n    match deps.api.canonical_address(\u0026HumanAddr(String::from(\n        \"cosmos1h99hrcc54ms9luwpex9kw0rwdt7etvfdyxh6gu\",\n    ))) {\n        Err(StdError::GenericErr { msg, backtrace: _ }) =\u003e {\n            if msg != String::from(\"canonicalize_address errored: wrong address prefix: \\\"cosmos\\\"\")\n            {\n                return Err(StdError::generic_err(\n                    \"bad prefix should have failed with 'canonicalize_address errored: wrong address prefix: \\\"cosmos\\\"'\",\n                ));\n            }\n            // all is good, continue\n        }\n        _ =\u003e {\n            return Err(StdError::generic_err(\n                \"bad prefix should have failed with 'canonicalize_address errored: wrong address prefix: \\\"cosmos\\\"'\",\n            ))\n        }\n    }\n\n    Ok(HandleResponse {\n        data: Some(Binary(\"🤟\".as_bytes().to_vec())),\n        log: vec![],\n        messages: vec![],\n    })\n}\n\n/////////////////////////////// Query ///////////////////////////////\n\npub fn query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    _msg: QueryMsg,\n) -\u003e QueryResult {\n    match _msg {\n        QueryMsg::ContractError { error_type } =\u003e Err(map_string_to_error(error_type)),\n        QueryMsg::Panic {} =\u003e panic!(\"panic in query\"),\n        QueryMsg::ReceiveExternalQuery { num } =\u003e {\n            Ok(Binary(serde_json_wasm::to_vec(\u0026(num + 1)).unwrap()))\n        }\n        QueryMsg::SendExternalQueryInfiniteLoop { to, code_hash } =\u003e {\n            send_external_query_infinite_loop(deps, to, code_hash)\n        }\n        QueryMsg::WriteToStorage {} =\u003e write_to_storage_in_query(deps),\n        QueryMsg::RemoveFromStorage {} =\u003e remove_from_storage_in_query(deps),\n        QueryMsg::SendExternalQueryDepthCounter {\n            to,\n            depth,\n            code_hash,\n        } =\u003e Ok(to_binary(\u0026send_external_query_depth_counter(\n            deps, to, depth, code_hash,\n        ))\n        .unwrap()),\n        QueryMsg::SendExternalQueryRecursionLimit {\n            to,\n            depth,\n            code_hash,\n        } =\u003e to_binary(\u0026send_external_query_recursion_limit(\n            deps, to, depth, code_hash,\n        )?),\n        QueryMsg::CallToQuery {\n            addr,\n            code_hash,\n            msg,\n        } =\u003e {\n            let answer: u32 = deps\n                .querier\n                .query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                    contract_addr: addr,\n                    callback_code_hash: code_hash,\n                    msg: Binary::from(msg.as_bytes().to_vec()),\n                }))\n                .map_err(|err| {\n                    StdError::generic_err(format!(\"Got an error from query: {:?}\", err))\n                })?;\n            return Ok(to_binary(\u0026answer)?);\n        }\n    }\n}\n\nfn send_external_query_infinite_loop\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n    contract_addr: HumanAddr,\n    code_hash: String,\n) -\u003e QueryResult {\n    let answer = deps\n        .querier\n        .query::\u003cBinary\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: contract_addr.clone(),\n            callback_code_hash: code_hash.clone(),\n            msg: Binary::from(\n                format!(\n                    r#\"{{\"send_external_query_infinite_loop\":{{\"to\":\"{}\", \"code_hash\":\"{}\"}}}}\"#,\n                    contract_addr.clone().to_string(),\n                    \u0026code_hash\n                )\n                .as_bytes()\n                .to_vec(),\n            ),\n        }));\n\n    match answer {\n        Ok(wtf) =\u003e Ok(Binary(wtf.into())),\n        Err(e) =\u003e Err(e),\n    }\n}\n\nfn write_to_storage_in_query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e StdResult\u003cBinary\u003e {\n    let deps = unsafe { \u0026mut *(deps as *const _ as *mut Extern\u003cS, A, Q\u003e) };\n    deps.storage.set(b\"abcd\", b\"dcba\");\n\n    Ok(Binary(vec![]))\n}\n\nfn remove_from_storage_in_query\u003cS: Storage, A: Api, Q: Querier\u003e(\n    deps: \u0026Extern\u003cS, A, Q\u003e,\n) -\u003e StdResult\u003cBinary\u003e {\n    let deps = unsafe { \u0026mut *(deps as *const _ as *mut Extern\u003cS, A, Q\u003e) };\n    deps.storage.remove(b\"abcd\");\n\n    Ok(Binary(vec![]))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","sienna","sienna","platform","x","compute","internal","keeper","testdata","test-contract","src","lib.rs"],"content":"pub mod contract;\n\n#[cfg(target_arch = \"wasm32\")]\nmod wasm {\n    use super::contract;\n    use cosmwasm_std::{\n        do_handle, do_init, do_query, ExternalApi, ExternalQuerier, ExternalStorage,\n    };\n\n    #[no_mangle]\n    extern \"C\" fn init(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_init(\n            \u0026contract::init::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn handle(env_ptr: u32, msg_ptr: u32) -\u003e u32 {\n        do_handle(\n            \u0026contract::handle::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            env_ptr,\n            msg_ptr,\n        )\n    }\n\n    #[no_mangle]\n    extern \"C\" fn query(msg_ptr: u32) -\u003e u32 {\n        do_query(\n            \u0026contract::query::\u003cExternalStorage, ExternalApi, ExternalQuerier\u003e,\n            msg_ptr,\n        )\n    }\n\n    // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available\n    // automatically because we `use cosmwasm_std`.\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>