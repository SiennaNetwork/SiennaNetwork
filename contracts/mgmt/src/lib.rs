#[macro_use] extern crate fadroma;

// TODO(fadroma): we don't really need these to be public, but
// currently the submodules generated by the macro
// import these from their parent module (this one)
pub use secret_toolkit::snip20::handle::{mint_msg, transfer_msg, set_minters_msg};
pub use sienna_schedule::{Seconds, Schedule, Pool, Account, Vesting, Validation};
pub use linear_map::LinearMap;

/// How much each recipient has claimed so far
pub type History = LinearMap<HumanAddr, Uint128>;

/// The managed SNIP20 contract's code hash.
pub type CodeHash = String;

/// Pair of address and code hash
pub type ContractLink = (HumanAddr, CodeHash);

/// Whether the vesting process has begun and when.
pub type Launched = Option<Seconds>;

/// Default value for Secret Network block size
/// (according to Reuven on Discord; used for padding).
pub const BLOCK_SIZE: usize = 256;

/// Error messages
#[macro_export] macro_rules! MGMTError {
    (CORRUPTED)   => { "broken" };  // Contract has entered a state that violates core assumptions.
    (NOTHING)     => { "nothing" }; // Unknown claimant or nothing to claim right now.
    (UNDERWAY)    => { "already underway" }; // Already launched
    (PRELAUNCH)   => { "not launched yet" }; // Not launched yet
    (NOT_FOUND)   => { "not found" };        // Can't find account or pool by name
    (ADD_ACCOUNT) => { "unexpected error when adding account" } // Shouldn't happen
}

contract!(
    [State] {
        /// The instantiatior of the contract.
        admin:    Option<HumanAddr>,
        /// The SNIP20 token contract that will be managed by this instance.
        /// (see `secretcli query compute contract-hash --help` to get the hash).
        token:    ContractLink,
        /// When this contract is launched, this is set to the block time.
        launched: Launched,
        /// History of fulfilled claims.
        history:  History,
        /// Vesting configuration.
        schedule: Schedule
    }
    /// Initializing an instance of the contract:
    ///  - requires the address and code hash of
    ///    a contract that implements SNIP20
    ///  - makes the initializer the admin
    [Init] (deps, env, msg: {
        schedule: Schedule,
        token:    ContractLink
    }) {
        let admin    = Some(env.message.sender);
        let history  = History::new();
        let launched = None;
        State { admin, history, launched, schedule, token }
    }
    [Query] (_deps, state, msg) {
        /// Return error count and launch timestamp.
        Status () {
            Response::Status { launched: state.launched }
        }
        /// Return schedule
        Schedule () {
            Response::Schedule { schedule: state.schedule }
        }
        /// Return amount that can be claimed by the specified address at the specified time
        Progress (address: HumanAddr, time: Seconds) {
            if let Some(launched) = &state.launched {
                let elapsed = get_elapsed(time, *launched);
                let unlocked = state.schedule.unlocked(elapsed, &address).into();
                let claimed = match state.history.get(&address.clone()) {
                    Some(&claimed) => claimed,
                    None => Uint128::zero()
                };
                Response::Progress { time, launched: *launched, elapsed, unlocked, claimed }
            } else {
                Response::Error { msg: MGMTError!(PRELAUNCH).to_string() }
            }
        }
        /// Return the allocated portion size of an account
        /// (used by RPT to validate its configuration)
        Portion (pool_name: String, account_name: String) {
            for pool in state.schedule.pools.iter() {
                if pool.name == pool_name {
                    for account in pool.accounts.iter() {
                        if account.name == account_name {
                            let portion = Uint128::from(account.portion_size());
                            return Response::Portion { portion }
                        }
                    }
                    break
                }
            }
            Response::NotFound {}
        }
    }
    [Response] {
        Status   { launched: Launched }
        Schedule { schedule: Schedule }
        Portion  { portion: Uint128 }
        Progress { time: Seconds, launched: Seconds, elapsed: Seconds, unlocked: Uint128, claimed: Uint128 }
        Error    { msg: String }
        NotFound {}
    }
    [Handle] (deps, env, state, msg) {
        /// Load a new schedule (only before launching the contract)
        Configure (schedule: Schedule) {
            is_admin(&state, &env)?;
            is_not_launched(&state)?;
            schedule.validate()?;
            state.schedule = schedule;
            ok!(state)
        }
        /// Add a new account to a partially filled pool
        AddAccount (pool: String, account: Account) {
            is_admin(&state, &env)?;
            match state.schedule.add_account(pool, account) {
                Ok(()) => ok!(state),
                Err(e) => match e {
                    StdError::GenericErr { msg, .. } => err_msg(state, &msg),
                    _ => err_msg(state, MGMTError!(ADD_ACCOUNT))
                }
            }
        }
        /// The admin can make someone else the admin,
        /// but there can be only one admin at a given time (or none)
        SetOwner (new_admin: HumanAddr) {
            is_admin(&state, &env)?;
            state.admin = Some(new_admin);
            ok!(state)
        }
        /// DANGER: Set admin to None, making further changes impossible.
        Disown () {
            is_admin(&state, &env)?;
            state.admin = None;
            ok!(state)
        }
        /// An instance can be launched only once.
        /// Launching the instance mints the total tokens as specified by
        /// the schedule, and prevents any more tokens from ever being minted
        /// by the underlying contract.
        Launch () {
            is_admin(&state, &env)?;
            is_not_launched(&state)?;
            state.launched = Some(env.block.time);
            ok!(state, acquire(&state, &env)?, vec![
                LogAttribute { key: "launched".to_string(), value: env.block.time.to_string() }
            ])
        }
        /// After launch, recipients can call the Claim method to
        /// receive the gains that they have accumulated so far.
        Claim () {
            let launched = is_launched(&state)?;
            let elapsed = get_elapsed(env.block.time, launched);
            let address = env.message.sender;
            let (unlocked, claimable) = portion(&state, &address, elapsed);
            if claimable > 0 {
                state.history.insert(address.clone().into(), unlocked.into());
                ok!(state, vec![transfer(&state, &address, claimable.into())?])
            } else {
                err_msg(state, MGMTError!(NOTHING))
            }
        }
    }

);

fn is_admin (state: &State, env: &Env) -> StdResult<()> {
    if state.admin == Some(env.message.sender.clone()) { return Ok(()) }
    Err(StdError::Unauthorized { backtrace: None })
}

fn is_not_launched (state: &State) -> StdResult<()> {
    match state.launched {
        None => Ok(()),
        Some(_) => Err(StdError::GenericErr {
            msg: MGMTError!(UNDERWAY).to_string(),
            backtrace: None
        })
    }
}

fn is_launched (state: &State) -> StdResult<Seconds> {
    match state.launched {
        Some(launched) => Ok(launched),
        None => Err(StdError::GenericErr {
            msg: MGMTError!(PRELAUNCH).to_string(),
            backtrace: None
        })
    }
}

fn get_elapsed (t1: Seconds, t2: Seconds) -> Seconds {
    if t1 > t2 {
        t1 - t2
    } else {
        0
    };
}

fn portion (state: &State, address: &HumanAddr, elapsed: Seconds) -> (u128, u128) {
    let unlocked = state.schedule.unlocked(elapsed, &address);
    if unlocked > 0 {
        let claimed = match state.history.get(&address.clone().into()) {
            Some(claimed) => claimed.u128(),
            None => 0
        };
        if unlocked > claimed {
            return (unlocked, unlocked - claimed);
        }
    }
    return (unlocked, 0)
}

fn acquire (state: &State, env: &Env) -> StdResult<Vec<CosmosMsg>> {
    let (addr, hash) = state.token.clone();
    Ok(vec![
        mint_msg(
            env.contract.address.clone(), state.schedule.total,
            None, BLOCK_SIZE, hash.clone(), addr.clone()
        )?,
        set_minters_msg(
            vec![],
            None, BLOCK_SIZE, hash.clone(), addr.clone()
        )?,
    ])
}

fn transfer (state: &State, recipient: &HumanAddr, amount: Uint128) -> StdResult<CosmosMsg> {
    let (addr, hash) = state.token.clone();
    transfer_msg(recipient.clone(), amount, None, BLOCK_SIZE, hash, addr)
}
